/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  ql_misc.qpp

  Qore Programming Language

  Copyright 2003 - 2011 David Nichols

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <qore/Qore.h>
#include <qore/intern/ql_misc.h>
#include <qore/intern/QoreSignal.h>

#include <string.h>
#include <time.h>
#include <errno.h>

static const BuiltinFunction *get_builtin_func(const QoreStringNode *str, ExceptionSink *xsink) {
   const BuiltinFunction *f = BuiltinFunctionList::find(str->getBuffer());
   if (!f)
      xsink->raiseException("NO-FUNCTION", "cannot find any builtin function '%s()'", str->getBuffer());
   return f;
}

// signal constants - if they are not defined define them here
#ifndef SIGABRT
#define SIGABRT 0
#endif
#ifndef SIGALRM
#define SIGALRM 0
#endif
#ifndef SIGBUS
#define SIGBUS 0
#endif
#ifndef SIGCANCEL
#define SIGCANCEL 0
#endif
#ifndef SIGCHLD
#define SIGCHLD 0
#endif
#ifndef SIGCLD
#define SIGCLD 0
#endif
#ifndef SIGCONT
#define SIGCONT 0
#endif
#ifndef SIGEMT
#define SIGEMT 0
#endif
#ifndef SIGFPE
#define SIGFPE 0
#endif
#ifndef SIGFREEZE
#define SIGFREEZE 0
#endif
#ifndef SIGHUP
#define SIGHUP 0
#endif
#ifndef SIGILL
#define SIGILL 0
#endif
#ifndef SIGINFO
#define SIGINFO 0
#endif
#ifndef SIGINT
#define SIGINT 0
#endif
#ifndef SIGIO
#define SIGIO 0
#endif
#ifndef SIGIOT
#define SIGIOT 0
#endif
#ifndef SIGJVM1
#define SIGJVM1 0
#endif
#ifndef SIGJVM2
#define SIGJVM2 0
#endif
#ifndef SIGKILL
#define SIGKILL 0
#endif
#ifndef SIGLOST
#define SIGLOST 0
#endif
#ifndef SIGLWP
#define SIGLWP 0
#endif
#ifndef SIGPIPE
#define SIGPIPE 0
#endif
#ifndef SIGPOLL
#define SIGPOLL 0
#endif
#ifndef SIGPROF
#define SIGPROF 0
#endif
#ifndef SIGPWR
#define SIGPWR 0
#endif
#ifndef SIGQUIT
#define SIGQUIT 0
#endif
#ifndef SIGSEGV
#define SIGSEGV 0
#endif
#ifndef SIGSTKFLT
#define SIGSTKFLT 0
#endif
#ifndef SIGSTOP
#define SIGSTOP 0
#endif
#ifndef SIGSYS
#define SIGSYS 0
#endif
#ifndef SIGTERM
#define SIGTERM 0
#endif
#ifndef SIGTHAW
#define SIGTHAW 0
#endif
#ifndef SIGTRAP
#define SIGTRAP 0
#endif
#ifndef SIGTSTP
#define SIGTSTP 0
#endif
#ifndef SIGTTIN
#define SIGTTIN 0
#endif
#ifndef SIGTTOU
#define SIGTTOU 0
#endif
#ifndef SIGURG
#define SIGURG 0
#endif
#ifndef SIGUSR1
#define SIGUSR1 0
#endif
#ifndef SIGUSR2
#define SIGUSR2 0
#endif
#ifndef SIGVTALRM
#define SIGVTALRM 0
#endif
#ifndef SIGWAITING
#define SIGWAITING 0
#endif
#ifndef SIGWINCH
#define SIGWINCH 0
#endif
#ifndef SIGXCPU
#define SIGXCPU 0
#endif
#ifndef SIGXFSZ
#define SIGXFSZ 0
#endif
#ifndef SIGXRES
#define SIGXRES 0
#endif

/** @defgroup signal_constants Signal Constants
    Signal constants - if any of the constants in this section are not defined on the host; the constant's value will be 0
*/
//@{
//! SIGABRT
const SIGABRT = SIGABRT;
//! SIGALRM
const SIGALRM = SIGALRM;
//! SIGBUS
const SIGBUS = SIGBUS;
//! SIGCANCEL
const SIGCANCEL = SIGCANCEL;
//! SIGCHLD
const SIGCHLD = SIGCHLD;
//! SIGCLD
const SIGCLD = SIGCLD;
//! SIGCONT
const SIGCONT = SIGCONT;
//! SIGEMT
const SIGEMT = SIGEMT;
//! SIGFPE
const SIGFPE = SIGFPE;
//! SIGFREEZE
const SIGFREEZE = SIGFREEZE;
//! SIGHUP
const SIGHUP = SIGHUP;
//! SIGILL
const SIGILL = SIGILL;
//! SIGINFO
const SIGINFO = SIGINFO;
//! SIGINT
const SIGINT = SIGINT;
//! SIGIO
const SIGIO = SIGIO;
//! SIGIOT
const SIGIOT = SIGIOT;
//! SIGJVM1
const SIGJVM1 = SIGJVM1;
//! SIGJVM2
const SIGJVM2 = SIGJVM2;
//! SIGKILL
const SIGKILL = SIGKILL;
//! SIGLOST
const SIGLOST = SIGLOST;
//! SIGLWP
const SIGLWP = SIGLWP;
//! SIGPIPE
const SIGPIPE = SIGPIPE;
//! SIGPOLL
const SIGPOLL = SIGPOLL;
//! SIGPROF
const SIGPROF = SIGPROF;
//! SIGPWR
const SIGPWR = SIGPWR;
//! SIGQUIT
const SIGQUIT = SIGQUIT;
//! SIGSEGV
const SIGSEGV = SIGSEGV;
//! SIGSTKFLT
const SIGSTKFLT = SIGSTKFLT;
//! SIGSTOP
const SIGSTOP = SIGSTOP;
//! SIGSYS
const SIGSYS = SIGSYS;
//! SIGTERM
const SIGTERM = SIGTERM;
//! SIGTHAW
const SIGTHAW = SIGTHAW;
//! SIGTRAP
const SIGTRAP = SIGTRAP;
//! SIGTSTP
const SIGTSTP = SIGTSTP;
//! SIGTTIN
const SIGTTIN = SIGTTIN;
//! SIGTTOU
const SIGTTOU = SIGTTOU;
//! SIGURG
const SIGURG = SIGURG;
//! SIGUSR1
const SIGUSR1 = SIGUSR1;
//! SIGUSR2
const SIGUSR2 = SIGUSR2;
//! SIGVTALRM
const SIGVTALRM = SIGVTALRM;
//! SIGWAITING
const SIGWAITING = SIGWAITING;
//! SIGWINCH
const SIGWINCH = SIGWINCH;
//! SIGXCPU
const SIGXCPU = SIGXCPU;
//! SIGXFSZ
const SIGXFSZ = SIGXFSZ;
//! SIGXRES
const SIGXRES = SIGXRES;

//! maps signal names to signal values
const NameToSignal = (
   "SIGABRT": SIGABRT,
   "SIGALRM": SIGALRM,
   "SIGBUS": SIGBUS,
   "SIGCANCEL": SIGCANCEL,
   "SIGCHLD": SIGCHLD,
   "SIGCLD": SIGCLD,
   "SIGCONT": SIGCONT,
   "SIGEMT": SIGEMT,
   "SIGFPE": SIGFPE,
   "SIGFREEZE": SIGFREEZE,
   "SIGHUP": SIGHUP,
   "SIGILL": SIGILL,
   "SIGINFO": SIGINFO,
   "SIGINT": SIGINT,
   "SIGIO": SIGIO,
   "SIGIOT": SIGIOT,
   "SIGJVM1": SIGJVM1,
   "SIGJVM2": SIGJVM2,
   "SIGKILL": SIGKILL,
   "SIGLOST": SIGLOST,
   "SIGLWP": SIGLWP,
   "SIGPIPE": SIGPIPE,
   "SIGPOLL": SIGPOLL,
   "SIGPROF": SIGPROF,
   "SIGPWR": SIGPWR,
   "SIGQUIT": SIGQUIT,
   "SIGSEGV": SIGSEGV,
   "SIGSTKFLT": SIGSTKFLT,
   "SIGSTOP": SIGSTOP,
   "SIGSYS": SIGSYS,
   "SIGTERM": SIGTERM,
   "SIGTHAW": SIGTHAW,
   "SIGTRAP": SIGTRAP,
   "SIGTSTP": SIGTSTP,
   "SIGTTIN": SIGTTIN,
   "SIGTTOU": SIGTTOU,
   "SIGURG": SIGURG,
   "SIGUSR1": SIGUSR1,
   "SIGUSR2": SIGUSR2,
   "SIGVTALRM": SIGVTALRM,
   "SIGWAITING": SIGWAITING,
   "SIGWINCH": SIGWINCH,
   "SIGXCPU": SIGXCPU,
   "SIGXFSZ": SIGXFSZ,
   "SIGXRES": SIGXRES,
   );

//! maps signal numbers (as a string key) to the symbolic name for the signal
const SignalToName = (
   SIGABRT: "SIGABRT",
   SIGALRM: "SIGALRM",
   SIGBUS: "SIGBUS",
   SIGCANCEL: "SIGCANCEL",
   SIGCHLD: "SIGCHLD",
   SIGCONT: "SIGCONT",
   SIGEMT: "SIGEMT",
   SIGFPE: "SIGFPE",
   SIGFREEZE: "SIGFREEZE",
   SIGHUP: "SIGHUP",
   SIGILL: "SIGILL",
   SIGINFO: "SIGINFO",
   SIGINT: "SIGINT",
   SIGIO: "SIGIO",
   SIGIOT: "SIGIOT",
   SIGJVM1: "SIGJVM1",
   SIGJVM2: "SIGJVM2",
   SIGKILL: "SIGKILL",
   SIGLOST: "SIGLOST",
   SIGLWP: "SIGLWP",
   SIGPIPE: "SIGPIPE",
   SIGPOLL: "SIGPOLL",
   SIGPROF: "SIGPROF",
   SIGPWR: "SIGPWR",
   SIGQUIT: "SIGQUIT",
   SIGSEGV: "SIGSEGV",
   SIGSTKSZ: "SIGSTKSZ",
   SIGSTOP: "SIGSTOP",
   SIGSYS: "SIGSYS",
   SIGTERM: "SIGTERM",
   SIGTHAW: "SIGTHAW",
   SIGTRAP: "SIGTRAP",
   SIGTSTP: "SIGTSTP",
   SIGTTIN: "SIGTTIN",
   SIGTTOU: "SIGTTOU",
   SIGURG: "SIGURG",
   SIGUSR1: "SIGUSR1",
   SIGUSR2: "SIGUSR2",
   SIGVTALRM: "SIGVTALRM",
   SIGWAITING: "SIGWAITING",
   SIGWINCH: "SIGWINCH",
   SIGXCPU: "SIGXCPU",
   SIGXFSZ: "SIGXFSZ",
   SIGXRES: "SIGXRES",
   );
//@}

/** @defgroup signal_handling_functions Signal Handing Functions
    Signal handing functions
*/
//@{
//! Sets or replaces a signal handler according to the signal number and closure or call reference (function or object method reference) passed
/** @par Platform Availability
    @ref Qore::HAVE_SIGNAL_HANDLING

    @par Restrictions
    @ref Qore::PO_PROCESS_CONTROL

    By the time this function returns, changes to the signal handling thread have already been effected.

    When a signal is raised and the signal handler code is called, the signal number is passed as an integer argument to the signal handling code.

    @param signal The signal number to process, see @ref signal_constants for possible values
    @param f The code to execute when the signal is caught; this should accept an integer argument giving the signal number

    @par Example
    @code
set_signal_handler(SIGINT, \signal_handler());
    @endcode

    @see @ref signal_handling for more information
*/
nothing set_signal_handler(softint signal, code f) [dom=QDOM_PROCESS] {
#ifdef HAVE_SIGNAL_HANDLING
   if (!signal || signal > QORE_SIGNAL_MAX) {
      xsink->raiseException("SET-SIGNAL-HANDLER-ERROR", "%d is not a valid signal", signal);
      return 0;
   }

   QSM.setHandler(signal, f, xsink);
#else
   xsink->raiseException("MISSING-FEATURE-ERROR", "this platform does not support signal handling, therefore the set_signal_handler() and remove_signal_handler() functions are not available in Qore; for maximum portability, use the constant Option::HAVE_SIGNAL_HANDLING to check if this function is implemented before calling");
#endif
   return 0;
}

//! Removes a signal handler and returns the signal handling state to the default
/** 
    @par Platform Availability
    @ref Qore::HAVE_SIGNAL_HANDLING

    @par Restrictions
    @ref Qore::PO_PROCESS_CONTROL

    By the time this function returns, changes to the signal handling thread have already been effected.

    @param signal The signal number to process, see @ref signal_constants for possible values

    @par Example
    @code
remove_signal_handler(SIGINT);
    @endcode

    @see @ref signal_handling for more information
*/
nothing remove_signal_handler(softint signal) [dom=QDOM_PROCESS] {
#ifdef HAVE_SIGNAL_HANDLING
   if (!signal || signal > QORE_SIGNAL_MAX) {
      xsink->raiseException("REMOVE-SIGNAL-HANDLER-ERROR", "%d is not a valid signal", signal);
      return 0;
   }
   QSM.removeHandler(signal, xsink);
#else
   xsink->raiseException("MISSING-FEATURE-ERROR", "this platform does not support signal handling, therefore the set_signal_handler() and remove_signal_handler() functions are not available in Qore; for maximum portability, use the constant Option::HAVE_SIGNAL_HANDLING to check if this function is implemented before calling");
#endif
   return 0;
}
//@}

/** @defgroup misc_functions Miscellaneous Functions
    Miscellaneous functions
 */
//@{
//! Calls a function and returns the return value, passing the remaining arguments after the function name to the function
/** 
    @par Example
    @code
    @endcode
*/
any call_function(string name, ...) {
   ReferenceHolder<QoreListNode> vargs(xsink);
   // if there are arguments to pass, create argument list by copying current list
   if (num_args(args) > 1)
      vargs = args->copyListFrom(1);

   return getProgram()->callFunction(name->getBuffer(), *vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
any call_function(code f, ...) {
   ReferenceHolder<QoreListNode> vargs(xsink);
   // if there are arguments to pass, create argument list by copying current list
   if (num_args(args) > 1)
      vargs = args->copyListFrom(1);

   return f->exec(*vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
any call_function_args(string name, *softlist vargs) {
   return getProgram()->callFunction(name->getBuffer(), vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
any call_function_args(code f, *softlist vargs) {
   return f->exec(vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode

    @throw NO-FUNCTION cannot find the given builtin function
*/
any call_builtin_function(string name, ...) {
   const BuiltinFunction *f = get_builtin_func(name, xsink);
   if (!f)
      return 0;

   ReferenceHolder<QoreListNode> vargs(xsink);
   // if there are arguments to pass, create argument list by copying current list
   if (num_args(args) > 1)
      vargs = args->copyListFrom(1);

   return f->evalDynamic(*vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
any call_builtin_function_args(string name, *softlist vargs) {
   const BuiltinFunction *f = get_builtin_func(name, xsink);
   if (!f)
      return 0;

   return f->evalDynamic(vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
bool exists(...) {
   // to emulate the exists operator, we must return True if more than one argument is passed
   // as this will appear to be a list to the exists operator, which is different from NOTHING
   return (num_args(args) <= 1) ? !is_nothing(get_param(args, 0)) : true;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
bool existsFunction(string name) {
   const char *str = name->getBuffer();
   
   if (getProgram()->existsFunction(str))
      return true;

   return builtinFunctions.find(str);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
bool existsFunction(code[doc] c) [flags=QC_NOOP] {
   return true;
}

//! 
/** 
 */
nothing existsFunction() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*string functionType(string name) {
   const char *str = name->getBuffer();

   if (getProgram()->existsFunction(str))
      return new QoreStringNode("user");

   return builtinFunctions.find(str) ? new QoreStringNode("builtin") : 0;
}

//! 
/** 
 */
nothing functionType() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string html_encode(string str) {
   QoreStringNode *ns = new QoreStringNode(str->getEncoding());
   ns->concatAndHTMLEncode(str->getBuffer());
   return ns;
}

//! 
/** 
 */
nothing html_encode() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string html_decode(string str) {
   QoreStringNode *ns = new QoreStringNode(str->getEncoding());
   ns->concatAndHTMLDecode(str);
   return ns;
}

//! 
/** 
 */
nothing html_decode() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string get_default_encoding() {
   return new QoreStringNode(QCS_DEFAULT->getCode());
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
nothing parse(string code, string label) {
   getProgram()->parse(code, label, xsink);
}

//! 
/** 
 */
nothing parse() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string getClassName(object obj) {
   return new QoreStringNode(obj->getClass()->getName());
}

//! 
/** 
 */
nothing getClassName() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
hash parse_url(string url) {
   QoreURL qurl(url);
   if (!qurl.isValid()) {
      xsink->raiseException("PARSE-URL-ERROR", "URL '%s' cannot be parsed", url->getBuffer());
      return 0;
   }

   return qurl.getHash();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*hash parseURL(string url) {
   QoreURL qurl(url);
   return qurl.isValid() ? qurl.getHash() : 0;
}

//! 
/** 
 */
nothing parseURL() [flags=QC_RUNTIME_NOOP] {
}

//! Executes a process and returns a string of the output (stdout only)
/** @par Restrictions
    Not available with @ref Qore::PO_NO_EXTERNAL_PROCESS

    @param cmd The shell command to executed as a subprocess
    
    @return The stdout of the shell command that was executed

    @par Example
    @code
my string $files = $files = backquote("ls");
    @endcode

    @throw BACKQUOTE-ERROR An error occurred with the fork() or opening the stdout pipe
*/
string backquote(string cmd) [dom=QDOM_EXTERNAL_PROCESS] {
   return backquoteEval(cmd->getBuffer(), xsink);
}

//! 
/** 
 */
nothing backquote() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string makeBase64String(string str) {
   QoreStringNode *rv = new QoreStringNode;
   rv->concatBase64(str);
   return rv;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string makeBase64String(binary bin) {
   return new QoreStringNode(bin);
}

//! 
/** 
 */
nothing makeBase64String() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
binary parseBase64String(string str) {
   return str->parseBase64(xsink);
}

//! 
/** 
 */
nothing parseBase64String() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string parseBase64StringToString(string str) {
   return str->parseBase64ToString(xsink);
}

//! 
/** 
 */
nothing parseBase64StringToString() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
list getModuleList() {
   return MM.getModuleList();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
hash getModuleHash() {
   return MM.getModuleHash();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
list getFeatureList() {
   return getProgram()->getFeatureList();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
list hash_values(hash h) {
   QoreListNode *l = new QoreListNode;

   ConstHashIterator hi(h);
   while (hi.next())
      l->push(hi.getReferencedValue());

   return l;
}

//! 
/** 
 */
nothing hash_values() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
bool has_key(hash h, string key) {
   bool exists;
   h->getKeyValueExistence(key, exists, xsink);
   return exists;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
bool has_key(object obj, string key) {
   AutoVLock vl(xsink);
   AbstractQoreNode **ptr = obj->getExistingValuePtr(key, &vl, xsink);
   return (bool)ptr;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_byte(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= size || offset < 0)
      return 0;

   return new QoreBigIntNode(ptr[offset]);  
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_byte(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= size || offset < 0)
      return 0;

   return new QoreBigIntNode(ptr[offset]);  
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int getByte(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= size || offset < 0)
      return 0;

   return new QoreBigIntNode(ptr[offset]);  
}

//! 
/** 
 */
nothing getByte() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int getByte(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= size || offset < 0)
      return 0;

   return new QoreBigIntNode(ptr[offset]);  
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_16(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 1) || offset < 0)
      return 0;

   short val = ntohs(*((unsigned short *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_16(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 1) || offset < 0)
      return 0;

   short val = ntohs(*((unsigned short *)&ptr[offset]));

   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_32(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = ntohl(*((unsigned int *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_32(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = ntohl(*((unsigned int *)&ptr[offset]));

   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int getWord32(string str, softint offset = 0) [flags=QC_CONSTANT|QC_DEPRECATED] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = ntohl(*((unsigned int *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int getWord32(binary b, softint offset = 0) [flags=QC_CONSTANT|QC_DEPRECATED] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = ntohl(*((unsigned int *)&ptr[offset]));

   return new QoreBigIntNode(val);
}

//! 
/** 
 */
nothing getWord32() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_64(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 7) || offset < 0)
      return 0;

   int64 val = MSBi8(*((int64 *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_64(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 7) || offset < 0)
      return 0;

   int64 val = MSBi8(*((int64 *)&ptr[offset]));

   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_16_lsb(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 1) || offset < 0)
      return 0;

   short val = LSBi2(*((unsigned short *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_16_lsb(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 1) || offset < 0)
      return 0;

   short val = LSBi2(*((unsigned short *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_32_lsb(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = LSBi4(*((unsigned int *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_32_lsb(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = LSBi4(*((unsigned int *)&ptr[offset]));

   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_64_lsb(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 7) || offset < 0)
      return 0;

   int64 val = LSBi8(*((int64 *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_64_lsb(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 7) || offset < 0)
      return 0;

   int64 val = LSBi8(*((int64 *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
*/
string splice(string[doc] str) [flags=QC_NOOP] {
   return new QoreStringNode;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string splice(string str, softint start) {
   QoreStringNodeHolder pstr(str->copy());
   pstr->splice(start, xsink);
   return *xsink ? 0 : pstr.release();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string splice(string str, softint start, softint len, *string nstr) {
   QoreStringNodeHolder pstr(str->copy());
   pstr->splice(start, len, nstr, xsink);
   return *xsink ? 0 : pstr.release();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
list splice(list l, softint start) {
   ReferenceHolder<QoreListNode> lst(l->copy(), xsink);
   lst->splice(start, xsink);
   return *xsink ? 0 : lst.release();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
list splice(list l, softint start, softint len, *list nlist) {
   ReferenceHolder<QoreListNode> lst(l->copy(), xsink);
   lst->splice(start, len, nlist, xsink);
   return *xsink ? 0 : lst.release();
}

//! 
/** 
 */
nothing splice() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string makeHexString(string str) [flags=QC_CONSTANT] {
   QoreStringNode *rv = new QoreStringNode;
   rv->concatHex(str);
   return rv;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string makeHexString(binary bin) {
   QoreStringNode *str = new QoreStringNode;
   str->concatHex(bin);
   return str;
}

//! 
/** 
 */
nothing makeHexString() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
binary parseHexString(string hexstr) {
   return hexstr->parseHex(xsink);
}

//! 
/** 
 */
nothing parseHexString() [flags=QC_RUNTIME_NOOP] {
}

//! takes a string of hexadecimal digits (like \c "6d4f84e0"; with or without leading \c "x" or \c "0x") and returns the corresponding base-10 integer
/** 
    @par Example
    @code
    @endcode
*/
int hextoint(string str) {
   if (!str->strlen())
      return 0;

   int64 rc = 0;
   int64 pow = 0;
   const char *buf = str->getBuffer();
   qore_size_t len = str->size();
   if (*buf == '0' && *(buf + 1) == 'x') {
      buf += 2;
      len -= 2;
   }
   else if (*buf == 'x') {
      buf++;
      --len;
   }
   for (const char *p = buf + len - 1; p >= buf; p--) {
      int n = get_nibble(*p, xsink);
      if (xsink->isException())
	 return 0;
      if (!pow) {
	 rc = n;
	 pow = 16;
      }
      else {
	 rc += n * pow;
	 pow *= 16;
      }
   }
   return rc;
}

//! 
/** 
 */
nothing hextoint() [flags=QC_RUNTIME_NOOP] {
}

//! parses a string representing a number in a configurable base and returns the integer
/** 
    @par Example
    @code
    @endcode
    
    @throw STRTOINT-ERROR cannot parse string; unsupported base, etc
*/
int strtoint(string num, int base) {
   errno = 0;
   int64 rv = strtoll(num->getBuffer(), 0, base);
   if (errno == EINVAL || errno == ERANGE)
      xsink->raiseException("STRTOINT-ERROR", "could not parse '%s' to an integer", num->getBuffer());
   return rv;
}

//! 
/** 
 */
nothing strtoint() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
nothing load_module(string name) [flags=QC_CONSTANT] {
   MM.runTimeLoadModule(name->getBuffer(), xsink);
}

//! 
/** 
 */
nothing load_module() [flags=QC_RUNTIME_NOOP] {
}

//! returns a string with percent-encodings substituted for characters
/** 
    @par Example
    @code
    @endcode
*/
string decode_url(string url) [flags=QC_CONSTANT] {
   QoreStringNode *str = new QoreStringNode(url->getEncoding());
   
   if (!url->strlen())
      return str;

   const char *c = url->getBuffer();

   while (*c) {
      if (*c == '%' && isxdigit(*(c + 1)) && isxdigit(*(c + 2))) {
         char x[3] = { *(c + 1), *(c + 2), '\0' };
         char code = strtol(x, 0, 16);
         str->concat(code);
         c += 3;
         continue;
      }
      str->concat(*c);
      c++;
   }
   return str;
}

//! 
/** 
 */
nothing decode_url() [flags=QC_RUNTIME_NOOP] {
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*string get_script_path() {
   return getProgram()->getScriptPath();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*string get_script_dir() {
   return getProgram()->getScriptDir();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*string get_script_name() {
   return getProgram()->getScriptName();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
list get_qore_option_list() [flags=QC_CONSTANT] {
   static const char *tlist[] = { "OPTION", "ALGORITHM", "FUNCTION" };
   QoreListNode *l = new QoreListNode;

   for (unsigned j = 0; j < qore_option_list_size; ++j) {
      QoreHashNode *h = new QoreHashNode;
      h->setKeyValue("option", new QoreStringNode(qore_option_list[j].option), xsink);
      h->setKeyValue("constant", new QoreStringNode(qore_option_list[j].constant), xsink);
      h->setKeyValue("type", new QoreStringNode(tlist[qore_option_list[j].type]), xsink);
      h->setKeyValue("value", get_bool_node(qore_option_list[j].value), xsink);
      l->push(h);
   }
   return l;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
hash get_qore_library_info() [flags=QC_CONSTANT] {
   QoreHashNode *h = new QoreHashNode;

   h->setKeyValue("PlatformOS", new QoreStringNode(qore_target_os), xsink);
   h->setKeyValue("PlatformCPU", new QoreStringNode(qore_target_arch), xsink);
   h->setKeyValue("VersionString", new QoreStringNode(qore_version_string), xsink);   
   h->setKeyValue("VersionMajor", new QoreBigIntNode(qore_version_major), xsink);
   h->setKeyValue("VersionMinor", new QoreBigIntNode(qore_version_minor), xsink);
   h->setKeyValue("VersionSub", new QoreBigIntNode(qore_version_sub), xsink);
   h->setKeyValue("Build", new QoreStringNode(qore_build_number), xsink);
   h->setKeyValue("ModuleDir", new QoreStringNode(qore_module_dir), xsink);

   h->setKeyValue("BuildHost", new QoreStringNode(qore_build_host), xsink);
   h->setKeyValue("Compiler", new QoreStringNode(qore_cplusplus_compiler), xsink);
   h->setKeyValue("CFLAGS", new QoreStringNode(qore_cflags), xsink);
   h->setKeyValue("LDFLAGS", new QoreStringNode(qore_ldflags), xsink);

   return h;
}
//@}
