#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%enable-all-warnings
%require-types
%strict-args

%exec-class TableMapperTest

%requires ../../../../qlib/QUnit.qm
%requires ../../../../qlib/SqlUtil.qm
# load all possible SqlUtil driver-specific modules to ensure that our version is used when testing
%requires ../../../../qlib/OracleSqlUtil.qm
%requires ../../../../qlib/PgsqlSqlUtil.qm
%requires ../../../../qlib/MysqlSqlUtil.qm
%requires ../../../../qlib/FreetdsSqlUtil.qm
%requires ../../../../qlib/Schema.qm
%requires ../../../../qlib/Mapper.qm
%requires ../../../../qlib/TableMapper.qm

public class TableMapperTestSchema inherits AbstractSchema {
    public {
        const T_TableMapperTest = (
            "columns": (
                "id": c_number(C_NOT_NULL),
                "string": c_varchar(50, C_NULL),
                "dte": c_timestamp(C_NOT_NULL),
                "code1": c_varchar(50, C_NULL),
            ),
            );

        const Tables = (
            "table_mapper_test": T_TableMapperTest,
            );

        const Sequences = (
            "seq_table_mapper_test": {},
            );
    }

    constructor(AbstractDatasource ds, *string dts, *string its) : AbstractSchema(ds, dts, its) {
    }

    private *hash getTablesImpl() {
        return Tables;
    }

    private *hash getSequencesImpl() {
        return Sequences;
    }

    string getNameImpl() {
        return "TableMapperTestSchema";
    }

    string getVersionImpl() {
        return "1.0";
    }

    log(string fmt) {
        #vprintf(fmt + "\n", argv);
        delete argv;
    }

    logpf(string fmt) {
        #vprintf(fmt + "\n", argv);
        delete argv;
    }

    logProgress(string fmt) {
        #vprintf(fmt + "\n", argv);
        delete argv;
    }
}

public class TableMapperTest inherits QUnit::Test {
    private {
        AbstractSchema schema;
        AbstractTable table;

        const Map1 = (
            "id": ("sequence": "seq_table_mapper_test"),
            "string": True,
            "dte": ("code": date sub (nothing x, hash rec) { return now_us(); }),
            );

        const Map2 = (
            "id": ("sequence": "seq_table_mapper_test"),
            "string": ("code": string sub (any x, hash rec) { return rec.string ?? rec.str2; }),
            "dte": ("code": date sub (nothing x, hash rec) { return now_us(); }),
            );

        const ConstMap = (
            "id": ("constant": 1),
            "string": ("constant": "2"),
            "dte" : ("constant" : date("2017-05-03"),),
            );

        const Input1 = (("string": "string_1"),
                        ("string": "string_2"),
                        ("string": ""),
                       );
        const Input2 = (("string": "string_1", "str2" : "str2_1"),
                        ("string": "string_2", "str2" : "str2_2"),
                        ("string": NOTHING, "str2" : "str2_3"),
                       );
        const Input3 = ("string": ("string_1", "string_2", NOTHING), "str2": "str2");
        const Input4 = ("str2": "str2", "string": ("string_1", "string_2", NOTHING));
        const Output1 = (("string" : "string_1"),
                         ("string" : "string_2"),
                         ("string" : ""),
                        );

        const OutMap1 = (
            "seq": "id",
            "tstr": string sub (any ignored, hash rec) {
                return sprintf("%s-%s", rec.id, rec.string);
            },
            );

        const SelectHash = (
            "orderby": "id",
            );

        const OutputBulk1 = (
            ("id": 19, "code1": "code", "string": "string_1"),
            ("id": 20, "code1": "code", "string": "string_2"),
            ("id": 21, "code1": "code", "string": "str2"),
            );

        const OutputBulk2 = (
            ("id": 22, "code1": "code", "string": "string_1"),
            ("id": 23, "code1": "code", "string": "string_2"),
            ("id": 24, "code1": "code", "string": NOTHING),
            );

        const Output2 = (
            ("seq": 25, "tstr": "25-string_1"),
            ("seq": 26, "tstr": "26-string_2"),
            ("seq": 27, "tstr": "27-"),
            );

        const Output3 =
            (("string": "string_1"),
             ("string": "string_2"),
             ("string": "str2"),
            );

        const ConstOutput =
            (("id": 1, "string" : "2"),
             ("id": 1, "string" : "2"),
             ("id": 1, "string" : "2"),);
        const ConstOutputHash =
            ("id": 1,
             "string" : "2");

        const MyOpts = Opts + (
            "connstr": "c,conn=s",
            );

        const OptionColumn = 22;
    }

    constructor(any args, *hash mopts) : Test("TableMapperTest", "1.0", \args, mopts ?? MyOpts) {
        Datasource ds;
        try {
            ds = getDatasource();
            # create the test schema
            schema = new TableMapperTestSchema(ds);
            schema.align(False, m_options.verbose);
            # get table object
            table = (new Table(schema.getDatasource(), "table_mapper_test")).getTable();
        }
        catch (hash ex) {
            if (m_options.verbose)
                printf("%s: %s\n", ex.err, ex.desc);
        }
        # add test cases
        addTestCase("InboundTableMapper", \inboundTableMapperTest());
        addTestCase("OutputTableMapper", \outputTableMapperTest());

        set_return_value(main());
    }

    globalTearDown() {
        # drop the test schema
        if (schema)
            schema.drop(False, m_options.verbose);
    }

    private usageIntern() {
        TestReporter::usageIntern(OptionColumn);
        printOption("-c,--conn=ARG", "set DB connection argument (ex: \"driver:user/pass@db\")", OptionColumn);
    }

    inboundTableMapperTest() {
        if (!table)
            testSkip("no DB connection");

        list output1 = Output1;
        if (table.bindEmptyStringsAsNull())
            output1[2].string = NULL;
        list output2 = Output1;
        output2[2].string = "str2_3";

        # insertRow() test
        {
            on_exit table.rollback();

            InboundTableMapper mapper(table, Map1);
            checkMap((map mapper.insertRow($1), Input1), Input1, output1);
            checkMap(table.selectRows(("orderby": "id")), Input1, output1);
            assertEq(3, mapper.getCount());
        }

        # iterator() test
        {
            on_exit table.rollback();

            InboundTableMapper mapper(table, Map1);
            InboundTableMapperIterator i = mapper.iterator(Input1.iterator());
            map $1, i;
            checkMap(table.selectRows(("orderby": "id")), Input1, output1);
            assertEq(3, i.getCount());
            assertEq(3, mapper.getCount());
        }

        # queueData(hash) test
        {
            on_exit table.rollback();

            InboundTableMapper mapper(table, Map1);
            map mapper.queueData($1), Input1;
            checkMap((map $1, mapper.flush().contextIterator()), Input1, output1);
            checkMap(table.selectRows(("orderby": "id")), Input1, output1);
            assertEq(3, mapper.getCount());
        }

        # queueData(list of hashes) test with code referring to the input
        {
            # prepare data
            hash ih = map {$1: ()}, Input2[0].keyIterator();
            map (map ih{$1.key} += $1.value, $1.pairIterator()), Input2;

            on_exit table.rollback();

            InboundTableMapper mapper(table, Map2);
            mapper.queueData(ih);
            checkMap((map $1, mapper.flush().contextIterator()), Input2, output2);
            checkMap(table.selectRows(("orderby": "id")), Input2, output2);
            assertEq(3, mapper.getCount());
        }

        # issue #1754: queueData(hash of lists) test with code referring to the input
        {
            on_exit table.rollback();

            # prepare data for comparison
            list input3 = map $1, Input3.contextIterator();
            InboundTableMapper mapper(table, Map2);
            mapper.queueData(Input3);
            checkMap((map $1, mapper.flush().contextIterator()), input3, Output3);
            checkMap(table.selectRows(("orderby": "id")), input3, Output3);
            assertEq(3, mapper.getCount());
        }

        # queueData() test with all constants with bulk ops
        # NOTE: the outbound test depends on the data from this test, which is committed
        {
            on_exit table.rollback();
            InboundTableMapper mapper(table, ConstMap);
            *hash ret = mapper.queueData(Input3);
            if (!ret) { ret = mapper.flush(); }
            assertEq(3, mapper.getCount());
            assertEq(ConstOutputHash, ret);
        }

        # queueData() test with all constants with iterator
        # NOTE: the outbound test depends on the data from this test, which is committed
        {
            on_exit table.rollback();
            InboundTableMapper mapper(table, ConstMap);
            *hash ret = mapper.queueData(Input2.iterator());
            checkMap((map $1, mapper.flush().contextIterator()), Input2, ConstOutput);
            checkMap(table.selectRows(("orderby": "id")), Input2, ConstOutput);
            assertEq(3, mapper.getCount());
            assertEq(ret, ConstOutputHash);
        }

        # issue #1754: queueData(hash of lists) test with mixing list and non-list
        # with non-list in 1st place
        {
            on_exit table.rollback();

            # prepare data for comparison
            list input4 = map $1, Input4.contextIterator();
            InboundTableMapper mapper(table, Map2);
            mapper.queueData(Input4);
            checkMap((map $1, mapper.flush().contextIterator()), input4, Output3);
            checkMap(table.selectRows(("orderby": "id")), input4, Output3);
            assertEq(3, mapper.getCount());
        }

        # issue #1754: queueData(hash of lists) test with code, rowcode + a constant mapping
        {
            on_exit table.rollback();

            # prepare data for comparison
            list input3 = map $1, Input3.contextIterator();

            list rl = ();
            code rowcode = sub (hash h) { rl += h; };
            InboundTableMapper mapper(table, Map2 + ("code1": ("constant": "code")), ("rowcode": rowcode));
            mapper.queueData(Input3);
            checkMap((map $1, mapper.flush().contextIterator()), input3, Output3);
            checkMap(table.selectRows(("orderby": "id")), input3, Output3);
            assertEq(3, mapper.getCount());
            assertEq(Type::Date, rl[0].dte.type());
            map remove rl[$#].dte, rl;
            assertEq(OutputBulk1, rl);
        }

        # issue #1736: InboundTableMapper::queueData() error with hashes of lists
        # queueData(hash of lists) test
        {
            # prepare data
            hash ih = map {$1: ()}, Input1[0].keyIterator();
            map (map ih{$1.key} += $1.value, $1.pairIterator()), Input1;

            on_exit table.rollback();

            list rl = ();
            code rowcode = sub (hash h) { rl += h; };
            # test with constant mappings and with rowcode
            InboundTableMapper mapper(table, Map1 + ("code1": ("constant": "code")), ("rowcode": rowcode));
            mapper.queueData(ih);
            # issue #1738 test iterating mapper.flush() output including constant mappings with <hash>::contextIterator()
            checkMap((map $1, mapper.flush().contextIterator()), Input1, output1);
            checkMap(table.selectRows(("orderby": "id")), Input1, output1);
            assertEq(3, mapper.getCount());
            assertEq(Type::Date, rl[0].dte.type());
            map remove rl[$#].dte, rl;
            assertEq(OutputBulk2, rl);
        }

        # queueData(list) test
        # NOTE: the outbound test depends on the data from this test, which is committed
        {
            on_error table.rollback();
            on_success table.commit();

            InboundTableMapper mapper(table, Map1);
            mapper.queueData(Input1.iterator());
            checkMap((map $1, mapper.flush().contextIterator()), Input1, output1);
            checkMap(table.selectRows(("orderby": "id")), Input1, output1);
            assertEq(3, mapper.getCount());
        }
    }

    outputTableMapperTest() {
        if (!table)
            testSkip("no DB connection");

        SqlStatementOutboundMapper m(table, SelectHash, OutMap1);
        SqlStatementMapperIterator i = m.iterator();
        list l;
        while (list tl = i.mapBulk(2))
            l += tl;

        assertEq(Output2, l, "mapBulk");
        assertEq(3, i.getCount());
        assertEq(3, m.getCount());
    }

    checkMap(list l, list il, list ol) {
        foreach hash h in (l) {
            assertEq(Type::Int, h.id.type(), "id type for row " + $#);
            any hval = h.string === NULL ? NOTHING : h.string;
            any oval = ol[$#].string === NULL ? NOTHING : ol[$#].string;
            assertEq(oval, hval);
        }
    }

    Datasource getDatasource() {
        if (!m_options.connstr)
            m_options.connstr = ENV.QORE_DB_CONNSTR_ORACLE ?? ENV.QORE_DB_CONNSTR_PGSQL ?? ENV.QORE_DB_CONNSTR_MYSQL ?? ENV.QORE_DB_CONNSTR_FREETDS ?? ENV.QORE_DB_CONNSTR_SYBASE;
        Datasource ds(m_options.connstr);
        ds.open();
        return ds;
    }
}
