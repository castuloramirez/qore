#!/usr/bin/env qore
%new-style

%include ../../../../qlib/QUnit.qm

public class ResultsTest inherits QUnit::Test {
    throwsException(string type, string detail) {
        throw type, detail;
    }

    constructor() {
        testFunctions = (
            # Tests for TestResult* classes
            ("func": \testBoolResults(), "name": "Boolean results comparisons"),
            ("func": \testValueResults(), "name": "Value result type comparisons"),
            ("func": \testExceptionResults(), "name": "Exception results comparisons"),
            # Misc functionality
            ("func": \testAssertions(), "name": "Verify the testAssertion() method"),
            ("func": \testPrintouts(), "name": "Test various printouts"),
            # Comparison functions
            ("func": \testEquals(), "name": "Exercise the equals() comparator"),
            ("func": \testRegexp(), "name": "Exercise the regexpMatches() comparator"),
            ("func": \testIteration(), "name": "Exercise the equalsIterated() comparator")
        );
    }

    testBoolResults() {
        QUnit::TestResultSuccess s();
        QUnit::TestResultFailure f();

        # Success/Failure
        testAssertion(\s.equals(), (s,));
        testAssertion(\f.equals(), (f,));

        # Compare two different class instances (not using RESULT_(SUCCESS|FAILURE))
        testAssertion(\s.equals(), (new QUnit::TestResultSuccess(),));
        testAssertion(\f.equals(), (new QUnit::TestResultFailure(),));

        # Compare to predefined constants
        testAssertion(\s.equals(), (RESULT_SUCCESS,));
        testAssertion(\f.equals(), (RESULT_FAILURE,));

        # Negative comparisons
        testAssertion(\s.equals(), (f,), RESULT_FAILURE);
        testAssertion(\f.equals(), (s,), RESULT_FAILURE);
    }

    testValueResults() {
        QUnit::TestResultValue n(NOTHING);
        QUnit::TestResultValue i(30);
        QUnit::TestResultValue a((1, 2, 3, 4));
        QUnit::TestResultValue h((1: 2, 3: 4));

        # NOTHING does not equal anything but nothing
        testAssertion(\n.equals(), (new QUnit::TestResultValue(NOTHING)));
        testAssertion(\n.equals(), (i,), RESULT_FAILURE);
        testAssertion(\n.equals(), (a,), RESULT_FAILURE);

        # Integer equality
        testAssertion(\i.equals(), (new QUnit::TestResultValue(15+15),));
        testAssertion(\i.equals(), (new QUnit::TestResultValue(15+16),), RESULT_FAILURE);

        # List equality
        testAssertion(\a.equals(), (new QUnit::TestResultValue((1,2,3,4)),));
        # Lists are fixed order
        testAssertion(\a.equals(), (new QUnit::TestResultValue((2,1,3,4)),), RESULT_FAILURE);

        # Hash equality
        testAssertion(\h.equals(), (new QUnit::TestResultValue((1:2,3:4)),));
        # Hashes are unordered
        testAssertion(\h.equals(), (new QUnit::TestResultValue((3:4,1:2)),));
        testAssertion(\h.equals(), (new QUnit::TestResultValue((1:2)),), RESULT_FAILURE);
    }

    testExceptionResults() {
        # Base Exceptions
        testAssertion(\throwsException(), ("DUMMY-EXCEPTION", "dummy detail"), new QUnit::TestResultExceptionType("DUMMY-EXCEPTION"));
        testAssertion(\throwsException(), ("DUMMY-EXCEPTION", "dummy detail"), new QUnit::TestResultExceptionType("DUMMY-EXCEPTION", "umm"));
        testAssertion(\throwsException(), ("DUMMY-EXCEPTION", "dummy detail"), new QUnit::TestResultExceptionDetail("DUMMY-EXCEPTION", "dummy detail"));
        testAssertion(\throwsException(), ("DUMMY-EXCEPTION", "dummy detail"), new QUnit::TestResultExceptionRegexp("DUMMY-EXCEPTION", "[a-z]ummy.*"));

        # Reflectiveness of regexp matching ( a == b && b == a )
        QUnit::TestResultExceptionRegexp r("DUMMY-EXCEPTION", "[a-z]ummy.*");
        QUnit::TestResultExceptionDetail d("DUMMY-EXCEPTION", "dummy detail");
        testAssertion(\r.equals(), (d,));
        testAssertion(\d.equals(), (r,));
    }

    bool returnsTrue() {
        return True;
    }

    bool returnsFalse() {
        return False;
    }

    returnsNothing() {
        return;
    }

    list returnsList(list l) {
        return l;
    }

    testAssertions() {
        # Test basic properties
        testAssertion(\returnsTrue(), list());
        testAssertion(\returnsFalse(), list(), RESULT_FAILURE);
        testAssertion(\returnsNothing(), list(), new TestResultValue(NOTHING));

        # Check the return value of the assertion
        list lret = testAssertion(\returnsList(), (list(1,2,3),), new TestResultValue((1,2,3)));
        bool bret = testAssertion(\equals(), (lret, (1,2,3)));
        testAssertion(\returnsTrue(), (bret));
    }

    testPrintouts() {
        # TODO: Capturing output would be needed for this?
    }

    testEquals() {
        # True == True, succeeds
        testAssertion(\equals(), (True, True));
        # True == False, fails
        testAssertion(\equals(), (True, False), RESULT_FAILURE);
        # True != False, throws exception
        testAssertion(\testAssertion(), (\equals(), (True, False)), new QUnit::TestResultExceptionRegexp("TEST-EXCEPTION", "Expected.*Success.*\n.*Actual.*Failure"));
        # Comparing incompatible values, throws exception
        testAssertion(\testAssertion(), (\equals(), (True, 20)), new QUnit::TestResultExceptionRegexp("TEST-EXCEPTION", "Expected.*Success.*\n.*Actual.*Failure"));
    }

    testRegexp() {
        # Simple success/failure
        testAssertion(\regexpMatches(), ("abcd", "[a-d]{4}"));
        testAssertion(\regexpMatches(), ("abcdefgh", "zz"), RESULT_FAILURE);
        # Multiline regexps
        # newlines cannot be substituted by '.'
        testAssertion(\regexpMatches(), ("abcd\nefgh", "abcd.efgh"), RESULT_FAILURE);
        testAssertion(\regexpMatches(), ("abcd\nefgh\n", "a.*\ne.*h"));
        # Match many lines
        testAssertion(\regexpMatches(), ("a\nb\nc\nd\ne", "a(.*\n)*e"));
    }

    testIteration() {
        list left = (0, 1, 2, 3, 4);
        list right = (0, 1, 2, 3, 4);

        testAssertion(\equalsIterated(), (new ListIterator(left), new ListIterator(right)));

        # Left has more
        left += 5;
        testAssertion(\equalsIterated(), (new ListIterator(left), new ListIterator(right)), RESULT_FAILURE);
        # Right has more
        right += (5, 6);
        testAssertion(\equalsIterated(), (new ListIterator(left), new ListIterator(right)), RESULT_FAILURE);

        # Add a mismatch
        left += 7;
        testAssertion(\equalsIterated(), (new ListIterator(left), new ListIterator(right)), RESULT_FAILURE);
    }
}

return new ResultsTest().main();
