# -*- mode: qore; indent-tabs-mode: nil -*-
# @file PgsqlSqlUtil.qm Qore user module for working with PostgreSQL SQL data

/*  PgsqlSqlUtil.qm Copyright 2013 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.8 or better
%requires qore >= 0.8.8

# requires the SqlUtil module
%requires SqlUtil >= 1.0

# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings
%disable-warning non-existent-method-call

module PgsqlSqlUtil {
    version = "1.0";
    desc = "user module for working with PostgreSQL SQL data";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
}

/*  Version History
    * 2013-xx-xx v1.0: David Nichols <david@qore.org>
      + the initial version of the PgsqlSqlUtil module
*/

/** @mainpage PgsqlSqlUtil Module

    The %SqlUtil module provides a high level API for working with PostgreSQL database objects.

    Usually this module is loaded on demand from the SqlUtil module, however to use this module
    directly, use \c "%requires PgsqlSqlUtil" in your code.
    
    All the public symbols in the module are defined in the PgsqlSqlUtil namespace
*/

#! the PgsqlSqlUtil namespace contains all the objects in the PgsqlSqlUtil module
public namespace PgsqlSqlUtil {
    public PgsqlTable sub get_table(AbstractDatasource nds, string nname, *hash opts) {
	return new PgsqlTable(nds, nname, opts);
    }

    public PgsqlDatabase sub get_database(AbstractDatasource nds, *hash opts) {
	return new PgsqlDatabase(nds, opts);
    }

    public class PgsqlIndex inherits AbstractIndex {
        public {
            #! the tablespace name of the index
            *string tablespace;
        }

        constructor(string n, bool u, hash c, *string t) : AbstractIndex(n, u, c) {
            tablespace = t;
        }

        string getCreateSql(string table_name, *hash opt) {
            string sql = sprintf("create%s %sindex %s on %s (%s)", opt.replace ? " or replace" : "", unique ? "unique " : "", name, table_name, (foldl $1 + ", " + $2, columns.keyIterator()));

            *string ts = opt.index_tablespace ? opt.index_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);
            return sql;
        }
    }

    public class PgsqlForeignConstraint inherits AbstractForeignConstraint {
        constructor(string n, Columns c, ForeignConstraintTarget t) : AbstractForeignConstraint(n, c, t) {
        }

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s foreign key (%s) references %s (%s)", table_name, name, (foldl $1 + ", " + $2, columns.keys()), target.table, (foldl $1 + ", " + $2, target.columns.keys()));
        }
    }

    public class PgsqlCheckConstraint inherits AbstractCheckConstraint {
        constructor(string n, string n_src) : AbstractCheckConstraint(n, n_src) {
        }        

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s check (%s)", table_name, name, src);
        }
    }

    public class PgsqlColumn inherits AbstractColumn {
        public {
            #! byte size of the column
            int byte_size;
        }

        constructor(string n, string nt, *string qt, int sz, bool nul, *string dv, *string cm, softint bs) : AbstractColumn(n, nt, qt, sz, nul, dv, cm) {
            byte_size = bs;
        }

        string getNativeTypeString() {
            string sql = native_type;
            switch (native_type) {
                case =~ /^timestamp/: return splice sql, 9, 0, "(" + string(size) + ")";
                case =~ /^time/: return splice sql, 4, 0, string(size);
            }
            if (size)
                sql += sprintf("(%d)", size);
            #printf("%y: %s\n", self, sql);
            return sql;
        }

        #! returns a list of sql strings that can be used to add the column to an existing table
        /** @par Example:
            @code
my list $l = $col.getCreateSql($t);
            @endcode

            @param t the AbstractTable object to modify
         */
        list getCreateSql(AbstractTable t) {
	    list l += sprintf("alter table %s add %s", t.getSqlName(), getCreateSql());	    
	    if (comment)
		l += sprintf("comment on column %s.%s is %s", t.getSqlName(), name, t.getSqlValue(comment));
            return l;
        }

        #! returns a list of sql strings that can be used to modify the column to the new definition
        /** @par Example:
            @code
my list $l = $col.getModifySql($t, $newcol);
            @endcode

            The column names are assumed to be equal.

            @param t the AbstractTable object to modify
            @param c the new column definition
         */
        list getModifySql(AbstractTable t, AbstractColumn col) {
            list l = ();
            PgsqlColumn c = col;

            # get new native type declaration string
            string nts = c.getNativeTypeString();
            if (getNativeTypeString() != nts) {
                # first drop any default value if it's changing 
                if (def_val != c.def_val)
                    l += sprintf("alter table %s alter %s drop default", t.getSqlName(), name);

                l += sprintf("alter table %s alter %s type %s", t.getSqlName(), name, nts);

                if (def_val != c.def_val && exists c.def_val)
                    l += sprintf("alter table %s alter %s set default %s", t.getSqlName(), name, c.def_val);
            }
            else if (def_val != c.def_val) {
                if (exists c.def_val)
                    l += sprintf("alter table %s alter %s set default %s", t.getSqlName(), name, c.def_val);
                else
                    l += sprintf("alter table %s alter %s drop default", t.getSqlName(), name);                    
            }
            if (nullable != c.nullable) {
                l += sprintf("alter table %s alter %s %s not null", t.getSqlName(), name, c.nullable ? "set" : "drop");
            }

            if (c.comment != comment)
		l += sprintf("comment on column %s.%s is %s", t.getSqlName(), name, t.getSqlValue(c.comment));
            return l;
        }

        #! returns a string that can be used to rename the column
        /** @par Example:
            @code
my string $str = $col.getRenameSql($t, "new_name");
            @endcode

            @param t the AbstractTable object to modify
            @param new_name the new name for the column

            @return a string that can be used to rename the column
        */
        string getRenameSql(AbstractTable t, string new_name) {
            return sprintf("alter table %s rename %s to %s", t.getSqlName(), name, new_name);
        }
    }

    public class PgsqlNumericColumn inherits PgsqlColumn, NumericColumnInfo {
        constructor(string n, string nt, *string qt, int sz, bool nul, *string dv, *string cm, softint bs, softint n_scale) : PgsqlColumn(n, nt, qt, sz, nul, dv, cm, bs), NumericColumnInfo(n_scale) {
        }

        string getNativeTypeString() {
            return NumericColumnInfo::getNativeTypeString(native_type, size);
        }
    }

    public class PgsqlPrimaryKey inherits AbstractPrimaryKey {
        public {
            #! any tablespace for the primary key index
            *string tablespace;
        }

        constructor(string n, *hash c, *string ts) : AbstractPrimaryKey(n, c) {
            tablespace = ts;
        }

        string getCreateSql(string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s primary key (%s)", table_name, name, (foldl $1 + ", " + $2, keyIterator()));
            *string ts = opts.index_tablespace ? opts.index_tablespace : tablespace;
            if (ts)
                sql += sprintf(" using index tablespace %s", ts);
            return sql;
        }
    }

    public class PgsqlTrigger inherits AbstractTrigger {
        #! creates the object and sets its name and the trigger source
        constructor(string n, string n_src) : AbstractTrigger(n, n_src) {
        }

        #! returns a string that can be used to create the trigger in the database
        string getCreateSql(string table_name, *hash opt) {
            return sprintf("create trigger %s %s", name, src);
        }

        #! returns a string that can be used to drop the trigger from the database
        string getDropSql(string table_name) {
            return sprintf("drop trigger %s on %s", name, table_name);
        }
    }

    public class PgsqlFunction inherits AbstractFunction {
        public {
            *string args;
        }

        constructor(string n, string n_src, *string a) : AbstractFunction(n, n_src) {
            args = a;
        }

        #! returns a string that can be used to create the function in the database
        string getCreateSql(*hash opt) {
            return sprintf("create%s function %s(%s) %s", opt.replace ? " or replace" : "", name, args, src);
        }

        #! returns a string that can be used to drop the function from the database
        string getDropSql() {
            return sprintf("drop function %s(%s)", name, args);
        }
    }

    public class PgsqlDatabase inherits AbstractDatabase {
        constructor(AbstractDatasource nds, *hash opts) : AbstractDatabase(nds, opts) {
        }

        AbstractFunction getFunctionImpl(string name) {
            *hash qh = ds.select("select p.proname, t1.typname return_type, a.rolname procedure_owner, l.lanname lang, prosrc body, pg_catalog.pg_get_functiondef(proname::regproc) hdr, case provolatile when 'i' then 'IMMUTABLE' when 's' then 'STABLE' when 'v' then 'VOLATILE' end stability from pg_proc p left join pg_type t1 on p.prorettype = t1.oid left join pg_authid a on p.proowner = a.oid left join pg_language l on p.prolang = l.oid where proname = %v", name);
            if (!qh.proname)
                throw "FUNCTION-ERROR", sprintf("cannot find any function %y", name);
           
            if (!native_case)
                map qh.$1 = qh.$1.lwr(), ("stability");

            trim qh.hdr;
            # remove "create or replace function" from the beginning of hdr
            if (qh.hdr !~ /^create or replace function /i)
                throw "FUNCTION-ERROR", sprintf("function does not begin with 'create or replace function': %y", qh.hdr);

            # remove function name and "(" at beginning of hdr
            int i = qh.hdr.find("(");
            if (i == -1)
                throw "FUNCTION-ERROR", sprintf("cannot find function arguments: %y", qh.hdr);
            int e = qh.hdr.find(")", i + 1);
            if (e == -1)
                throw "FUNCTION-ERROR", sprintf("cannot find function arguments: %y", qh.hdr);

            *string args = extract qh.hdr, i + 1, e - i - 1;
            splice qh.hdr, 0, e + 1;

            printf("args: %y\n", args);
            if (!native_case) {
                qh.hdr =~ s/ RETURNS / returns /;
                qh.hdr =~ s/ LANGUAGE / language /;
                qh.hdr =~ s/ AS / as /;
            }

            return new PgsqlFunction(qh.proname, qh.hdr, args);
        }

        AbstractFunction getProcedureImpl(string name) {
            return getFunctionImpl(name);
        }

        list listTablesImpl() {
            return ds.select("select n.nspname \"schema\", c.relname \"name\", case c.relkind when 'r' then 'table' when 'v' then 'view' when 'i' then 'index' when 'S' then 'sequence' when 's' then 'special' when 'f' then 'foreign table' end \"Type\", pg_catalog.pg_get_userbyid(c.relowner) \"owner\" from pg_catalog.pg_class c left join pg_catalog.pg_namespace n ON n.oid = c.relnamespace
WHERE c.relkind IN ('r','') and n.nspname <> 'pg_catalog' and n.nspname <> 'information_schema' and n.nspname !~ '^pg_toast' and pg_catalog.pg_table_is_visible(c.oid) order by 1,2").name;
        }

        list listFunctionsImpl() {
            *hash qh = ds.select("select n.nspname schema, p.proname name, pg_catalog.pg_get_function_result(p.oid) result_type, pg_catalog.pg_get_function_arguments(p.oid) args, case when p.proisagg then 'agg' when p.proiswindow then 'window' when p.prorettype = 'pg_catalog.trigger'::pg_catalog.regtype then 'trigger' else 'normal' end type from pg_catalog.pg_proc p left join pg_catalog.pg_namespace n ON n.oid = p.pronamespace where n.nspname ~ '^(public)$' order by 1, 2, 4");
            
            return map sprintf("%s(%s)", $1.name, $1.args), qh.contextIterator();            
        }

        list listProceduresImpl() {
            return listFunctionsImpl();
        }

        list listSequencesImpl() {
            return ds.select("select relname from pg_class where relkind = 'S'").relname;
        }

        list listViewsImpl() {
            return ds.select("select table_name from information_schema.views where table_schema = any (current_schemas(false))").table_name;
        }
    }

    public class PgsqlTable inherits AbstractTable {
        public {
            const PgsqlTypeMap = (
                "numeric": ("qore": Type::Number, "size": SZ_NUM,),
                "decimal": ("qore": Type::Number, "size": SZ_NUM,),
                "money": ("qore": Type::Number,),
                "smallint": ("qore": Type::Int,),
                "integer": ("qore": Type::Int,),
                "bigint": ("qore": Type::Int,),
                "smallserial": ("qore": Type::Int,),
                "serial": ("qore": Type::Int,),
                "bigserial": ("qore": Type::Int,),
                "real": ("qore": Type::Float,),
                "double precision": ("qore": Type::Float,),
                "oid": ("qore": Type::Number,),
                "character": ("qore": Type::String, "size": SZ_MAND,),
                "char": ("qore": Type::String, "size": SZ_MAND,),
                "character varying": ("qore": Type::String, "size": SZ_MAND,),
                "varchar": ("qore": Type::String, "size": SZ_MAND,),
                "date": ("qore": Type::Date,),
                "timestamp without time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6),),
                "timestamp": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6),),
                "timestamp with time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6),),
                "time without time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6),),
                "time": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6),),
                "time with time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6),),
                "interval": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 6),),
                "abstime": ("qore": Type::Date,),
                "reltime": ("qore": Type::Date,),
                "text": ("qore": Type::String,),
                "bytea": ("qore": Type::Binary,),
                "bit": ("qore": Type::Binary,),
                "bit varying": ("qore": Type::Binary,),
                "boolean": ("qore": Type::Boolean,),
                "macaddr": ("qore": Type::String,),
                "inet": ("qore": Type::String,),
                "cidr": ("qore": Type::String,),
                );

            const PgsqlNameMap = (
                "character varying": "varchar",
                "timestamp without time zone": "timestamp",
                "time without time zone": "time",
                );

            const QoreTypeMap = (
                "integer": "bigint",
                "float": "double precision",
                "number": "numeric",
                "string": "varchar",
                "date": "timestamp with time zone",
                "binary": "bytea",
                "bool": "boolean",
                );

            const PgsqlColumnOptions = AbstractTable::ColumnOptions;

            const PgsqlTableCreationOptions = AbstractTable::TableCreationOptions + (
                "omit_trigger_functions": Type::Boolean,
                );
        }

        private {
            *string tablespace;

            Functions triggerFunctions;
        }

        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
            # get table info
            *hash row = ds.selectRow("select * from pg_tables where tablename = %v", name);
            tablespace = row.tablespace ? row.tablespace : NOTHING;
        }

        *string getTablespaceName() {
            return tablespace;
        }

        private hash getColumnOptions() {
            return PgsqlColumnOptions;
        }

        private hash getTableCreationOptions() {
            return PgsqlTableCreationOptions;
        }

        private Columns describeImpl() {
            # get column descriptions
            *hash qh = ds.select("select column_name, data_type, character_maximum_length, character_octet_length, numeric_precision, numeric_scale, datetime_precision, is_nullable, column_default, description from information_schema.columns c join pg_catalog.pg_statio_all_tables st on (c.table_schema = st.schemaname and c.table_name = st.relname) left join pg_catalog.pg_description pgd on (st.relid = pgd.objoid and pgd.objsubid = c.ordinal_position) where table_name = %v order by ordinal_position", name);
            if (!qh.column_name)
                throw "TABLE-ERROR", sprintf("cannot retrieve table information for table %y in %y", name, dsdesc);

            hash rv;
            foreach hash row in (qh.contextIterator()) {
                *hash th = PgsqlTypeMap.(row.data_type);
                softint size = row.character_maximum_length ? row.character_maximum_length : row.numeric_precision;
                if (!size)
                    size = row.datetime_precision;
                # use short names in descriptions
                *string an = PgsqlNameMap{row.data_type};
                if (an)
                    row.data_type = an;
                switch (th.qore) {
                    case "int":
                    case "float": {
                        size = 0;
                        break;
                    }
                }

                PgsqlColumn c;
                if (row.numeric_precision)
                    c = new PgsqlNumericColumn(row.column_name, row.data_type, th.qore, row.numeric_precision, row.is_nullable == "YES", row.column_default ? row.column_default : NOTHING, row.description ? row.description : NOTHING, 0, row.numeric_scale);
                else
                    c = new PgsqlColumn(row.column_name, row.data_type, th.qore, exists size ? size : 0, row.is_nullable == "YES", row.column_default ? row.column_default : NOTHING, row.description ? row.description : NOTHING, row.character_octet_length);

                rv.(row.column_name) = c;
            }

            return new Columns(rv);
        }

        private *PgsqlPrimaryKey getPrimaryKeyImpl() {
            hash rv;

            # get primary key description
            *hash qh = ds.select("select c1.relname index_name, a.attname, format_type(a.atttypid, a.atttypmod) coltype, tablespace from pg_index i, pg_class c, pg_attribute a, pg_class c1, pg_indexes xs where c.oid = %v::regclass and indrelid = c.oid and a.attrelid = c.oid and a.attnum = any(i.indkey) and indisprimary and c1.oid = indexrelid and c1.relname = xs.indexname", name);
            if (!qh.index_name)
                return;

            foreach string col in (qh.attname)
                rv{col} = columns{col};

            return new PgsqlPrimaryKey(qh.index_name[0], rv, qh.tablespace[0] ? qh.tablespace[0] : NOTHING);
        }

        private Indexes getIndexesImpl() {
            hash rv;

            # get index description
            *hash qh = ds.select("select i.relname index_name, a.attname column_name, indisunique, tablespace from pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_indexes xs where t.oid = ix.indrelid and i.oid = ix.indexrelid and a.attrelid = t.oid and a.attnum = any(ix.indkey) and t.relkind = 'r' and t.relname = %v and not indisprimary and i.relname = xs.indexname group by i.relname, a.attname, indisunique, tablespace order by i.relname", name);
            if (qh.index_name) {
                hash ih;
                foreach hash row in (qh.contextIterator()) {
                    if (!ih.(row.index_name))
                        ih.(row.index_name) = (
                            "unique": row.indisunique,
                            "tablespace": row.tablespace,
                        );
                    ih.(row.index_name).columns{row.column_name} = columns{row.column_name};
                }

                foreach hash i in (ih.pairIterator())
                    rv.(i.key) = new PgsqlIndex(i.key, i.value.unique, i.value.columns, i.value.tablespace);
            }

            return new Indexes(rv);
        }

        private ForeignConstraints getForeignConstraintsImpl() {
            hash rv;

            # get foreign referential constraints
            *hash qh = ds.select("select tc.constraint_name, kcu.column_name source_column, ccu.table_name target_table, ccu.column_name target_column from information_schema.table_constraints tc join information_schema.key_column_usage kcu on tc.constraint_name = kcu.constraint_name join information_schema.constraint_column_usage as ccu on ccu.constraint_name = tc.constraint_name where constraint_type = 'FOREIGN KEY' and tc.table_name = %v order by ordinal_position", name);
            if (qh.constraint_name) {
                hash ch;
                foreach hash row in (qh.contextIterator()) {
                    reference c = \ch.(row.constraint_name); 
                    c.columns.(row.source_column) = columns{row.source_column};
                    c.target.table = row.target_table;
                    c.target.columns.(row.target_column) = True;
                }
                
                # temporary foreign table buffer hash
                hash fth;
                foreach hash c in (ch.pairIterator()) {
                    # get a description of the target table for the target column descriptions
                    if (!fth{c.value.target.table})
                        fth{c.value.target.table} = new PgsqlTable(ds, c.value.target.table);
                    
                    ForeignConstraintTarget fct(c.value.target.table, fth{c.value.target.table}.describe().subset(c.value.target.columns.keys()));
                    rv.(c.key) = new PgsqlForeignConstraint(c.key, new Columns(c.value.columns), fct);
                }
            }

            return new ForeignConstraints(rv);
        }

        private Constraints getConstraintsImpl() {
            # get check constraints
            *hash qh = ds.select("SELECT c.conname AS constraint_name, CASE WHEN c.condeferrable = 'f' THEN 0 ELSE 1 END AS is_deferrable, CASE WHEN c.condeferred = 'f' THEN 0 ELSE 1 END AS is_deferred, t.relname AS table_name, array_to_string(c.conkey, ' ') AS constraint_key, CASE confupdtype WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END AS on_update, CASE confdeltype WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END AS on_delete, CASE confmatchtype WHEN 'u' THEN 'UNSPECIFIED' WHEN 'f' THEN 'FULL' WHEN 'p' THEN 'PARTIAL' END AS match_type, t2.relname AS references_table, array_to_string(c.confkey, ' ') AS fk_constraint_key, consrc FROM pg_constraint c LEFT JOIN pg_class t  ON c.conrelid  = t.oid LEFT JOIN pg_class t2 ON c.confrelid = t2.oid WHERE c.contype = 'c' and t.relname = %v", name);
            hash rv;
            foreach hash row in (qh.contextIterator())
                rv.(row.constraint_name) = new PgsqlCheckConstraint(row.constraint_name, row.consrc);

            return new Constraints(rv);
        }

        private Triggers getTriggersImpl() {
            hash rv;

            # get trigger description
            *hash qh = ds.select("select * from information_schema.triggers where event_object_table = %v", name);

            # list of trigger functions
            list fl = ();
            foreach hash row in (qh.contextIterator()) {
                *string f = (row.action_statement =~ x/EXECUTE PROCEDURE (\w+)\(\)$/)[0];
                if (f)
                    fl += f;
                    
                if (!native_case)
                    map row.$1 = row.$1.lwr(), ("event_manipulation", "action_statement", "action_timing", "action_orientation");
                if (rv{row.trigger_name}) {
                    # add event to trigger
                    *string px = (rv{row.trigger_name}.src =~ x/(.+) on/i)[0];
                    if (!px)
                        throw "PGSQL-TRIGGER-ERROR", sprintf("cannot find beginning of trigger source: %s", rv{row.trigger_name}.src);
                    splice rv{row.trigger_name}.src, px.size(), 0, " or " + row.event_manipulation;
                    continue;
                }

                string src = sprintf("%s %s on %s for each %s %s", row.action_timing, row.event_manipulation, getSqlName(), row.action_orientation, row.action_statement);
                rv{row.trigger_name} = new PgsqlTrigger(row.trigger_name, src);
            }

            if (fl) {
                hash fh;
                # also get trigger functions
                qh = ds.select("select p.proname, t1.typname return_type, a.rolname procedure_owner, l.lanname lang, prosrc body, pg_catalog.pg_get_functiondef(proname::regproc) hdr, case provolatile when 'i' then 'IMMUTABLE' when 's' then 'STABLE' when 'v' then 'VOLATILE' end stability from pg_proc p left join pg_type t1 on p.prorettype = t1.oid left join pg_authid a on p.proowner = a.oid left join pg_language l on p.prolang = l.oid where proname in (%s)", (foldl $1 + "," + $2, (map sprintf("'%s'", $1), fl)));
                foreach hash row in (qh.contextIterator()) {
                    if (!native_case)
                        map row.$1 = row.$1.lwr(), ("stability");

                    trim row.hdr;
                    # remove "create or replace function" from the beginning of hdr
                    if (row.hdr !~ /^create or replace function /i)
                        throw "PGSQL-TRIGGER-FUNCTION-ERROR", sprintf("function does not begin with 'create or replace function': %y", row.hdr);

                    # remove function name and "()" from beginning of hdr
                    int i = row.hdr.find("()");
                    if (i == -1)
                        throw "PGSQL-TRIGGER-FUNCTION-ERROR", sprintf("cannot find function arguments: %y", row.hdr);
                    splice row.hdr, 0, i + 2;

                    if (!native_case) {
                        row.hdr =~ s/ RETURNS / returns /;
                        row.hdr =~ s/ LANGUAGE / language /;
                        row.hdr =~ s/ AS / as /;
                    }

                    fh{row.proname} = new PgsqlFunction(row.proname, row.hdr);
                }
                triggerFunctions = new Functions(fh);
            }

            #printf("gTI triggerFunctions: %N\n", triggerFunctions);

            return new Triggers(rv);
        }

        string getCreateTableSqlImpl(*hash opt) {
            string sql = sprintf("create table %s (\n", name);

            sql += foldl $1 + ",\n" + $2, (map "  " + $1.getCreateSql(), columns.iterator());
            sql += "\n)";

            *string ts = opt.tablespace ? opt.tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            return sql;
        }

        *list getCreateIndexesSqlImpl(*hash opt) {
            return map $1.getCreateSql(name, opt), indexes.iterator();
        }

        *string getCreatePrimaryKeySqlImpl(*hash opt) {
            return primaryKey.getCreateSql(name, opt);
        }

        *list getCreateForeignConstraintsSqlImpl(*hash opt) {
            return map $1.getCreateSql(name, opt), foreignConstraints.iterator();
        }

        *list getCreateConstraintsSqlImpl(*hash opt) {
            return map $1.getCreateSql(name, opt), constraints.iterator();
        }

        *list getCreateMiscSqlImpl(*hash opt, bool cache) {
            if (cache) {
                getColumnsUnlocked();
                getTriggersUnlocked();
            }
            list l = map sprintf("comment on column %s.%s is '%s'", name, $1.name, $1.comment), columns.iterator(), $1.comment;
            if (!opt.omit_trigger_functions) {
                l += map $1.getCreateSql(opt), triggerFunctions.iterator();
            }
            #printf("gCMSI triggerFunctions: %N\n", triggerFunctions);

            return l;
        }

        *list getCreateTriggersSqlImpl(*hash opt) {
            return map $1.getCreateSql(name, opt), triggers.iterator();
        }

        string getCreateSqlImpl(list l) {
            string str;
            map str += sprintf("%s%s\n", $1, $1 =~ /(;|\$)$/ ? "" : ";"), l;
            return str;
        }

        string getRenameSqlImpl(string new_name) {
            return sprintf("alter table %s rename to %s", getSqlName(), new_name);
        }

        private AbstractColumn addColumnImpl(string cname, hash opt, bool nullable = True) {
            if (opt.precision)
                return new PgsqlNumericColumn(cname, opt.native_type, opt.qore_type, opt.precision, nullable, opt.default_value, opt.comment, 0, opt.scale);
            return new PgsqlColumn(cname, opt.native_type, opt.qore_type, opt.size, nullable, opt.default_value, opt.comment, 0);
        }

        private AbstractPrimaryKey addPrimaryKeyImpl(string cname, hash ch, *hash opt) {
            return new PgsqlPrimaryKey(cname, ch, opt.index_tablespace);
        }

        private AbstractIndex addIndexImpl(string iname, bool enabled, hash ch, *hash opt) {
            return new PgsqlIndex(iname, enabled, ch, opt.index_tablespace);
        }

        private AbstractForeignConstraint addForeignConstraintImpl(string cname, hash ch, string table, hash tch, *hash opt) {
            ForeignConstraintTarget fct(table, new Columns(tch));
            return new PgsqlForeignConstraint(cname, new Columns(ch), fct);
        }

        private AbstractCheckConstraint addCheckConstraintImpl(string cname, string src, *hash opt) {
            return new PgsqlCheckConstraint(cname, src);
        }

        private AbstractTrigger addTriggerImpl(string tname, string src, *hash opt) {
            return new PgsqlTrigger(tname, src);
        }

        private hash getQoreTypeMapImpl() {
            return QoreTypeMap;
        }

        private hash getTypeMapImpl() {
            return PgsqlTypeMap;
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument; returns NOTHING if the type cannot be converted to an SQL string
        private *string getSqlValueImpl(any v) {
            switch (v.typeCode()) {
                case NT_FLOAT:
                case NT_INT: return v.toStr();

                case NT_NUMBER: return string(v);

                # double any single quotes in strings
                case NT_STRING: v =~ s/'/''/g; return "'" + v + "'";

                case NT_NULL:
                case NT_NOTHING: return "null";

                case NT_BOOLEAN: return v ? "true" : "false";

                case NT_DATE: return v.format("'YYYY-MM-DD HH:mm:SS.us'");
            }
        }
    }
}
