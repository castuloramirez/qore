/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  ql_misc.qpp

  Qore Programming Language

  Copyright 2003 - 2011 David Nichols

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <qore/Qore.h>
#include <qore/intern/ql_misc.h>
#include <qore/intern/ssl_constants.h>
#include <qore/intern/QoreSignal.h>

#include <string.h>
#include <zlib.h>
#include <time.h>
#include <errno.h>

#ifdef HAVE_GZ_HEADER
class qore_gz_header : public gz_header {
   DLLLOCAL qore_gz_header(bool n_text, char *n_name, char *n_comment) {
      text = n_text;
      time = ::time(0);
      xflags = 0;
      os = 3; // always set to UNIX
      extra = Z_NULL;
      extra_len = 0;
      extra_max = 0;
      name = (Bytef *)n_name;
      name_max = 0;
      comment = (Bytef *)n_comment;
      comm_max = 0;
      hcrc = 0;
      done = 0;
   }
};
#endif

static const BuiltinFunction *get_builtin_func(const QoreStringNode *str, ExceptionSink *xsink) {
   const BuiltinFunction *f = BuiltinFunctionList::find(str->getBuffer());
   if (!f)
      xsink->raiseException("NO-FUNCTION", "cannot find any builtin function '%s()'", str->getBuffer());
   return f;
}

static void do_zlib_exception(int rc, const char *func, ExceptionSink *xsink) {
   QoreStringNode *desc = new QoreStringNode();
   desc->sprintf("%s(): ", func);
   switch (rc) {
      case Z_ERRNO:
	 q_strerror(*desc, errno);
         break;

      case Z_STREAM_ERROR:
         desc->concat("inconsistent stream state");
         break;

      case Z_DATA_ERROR:
         desc->set("unable to process input data; data corrupted");
         break;

      case Z_MEM_ERROR:
         desc->set("insufficient memory to complete operation");
         break;

      case Z_BUF_ERROR:
         desc->set("qore buffer-handling error (report as bug to qore developers)");
         break;

      case Z_VERSION_ERROR:
         desc->set("version mismatch on zlib shared library, check library requirements");
         break;

      default:
         desc->sprintf("error code %d encountered", rc);
         break;
   }
   xsink->raiseException("ZLIB-ERROR", desc);
}

static void do_deflate_end(z_stream *c_stream, ExceptionSink *xsink) {
   int rc = deflateEnd(c_stream);
   if (rc != Z_OK)
      do_zlib_exception(rc, "deflateEnd", xsink);
}

static void do_inflate_end(z_stream *d_stream, ExceptionSink *xsink) {
   int rc = inflateEnd(d_stream);
   if (rc != Z_OK)
      do_zlib_exception(rc, "inflateEnd", xsink);
}

BinaryNode *qore_deflate(const void *ptr, unsigned long len, int level, ExceptionSink *xsink) {
   z_stream c_stream; // compression stream
   c_stream.zalloc = Z_NULL;
   c_stream.zfree = Z_NULL;
   c_stream.opaque = Z_NULL;
   
   int rc = deflateInit(&c_stream, level);   
   if (rc != Z_OK) {
      do_zlib_exception(rc, "deflateInit", xsink);
      return 0;
   }

   ON_BLOCK_EXIT(do_deflate_end, &c_stream, xsink);
   
   // allocate new buffer
   unsigned long bsize = len / 5 + 100;
   void *buf = malloc(bsize);
   
   c_stream.next_in = (Bytef *)ptr;
   c_stream.next_out = (Bytef *)buf;
   c_stream.avail_in = len;
   c_stream.avail_out = bsize;

   while (c_stream.avail_in) {
      rc = deflate(&c_stream, Z_NO_FLUSH);
      if (rc != Z_OK && rc != Z_BUF_ERROR) {
         free(buf);
         do_zlib_exception(rc, "deflate", xsink);
         return 0;
      }
      
      if (!c_stream.avail_out) {
         int new_space = ((len / 3) + 100);
         //printd(5, "deflate() Z_BUF_ERROR:1 bsize=%d->%d, new_space=%d avail_out=%d -> %d next_out=%p\n", bsize, bsize + new_space, new_space, c_stream.avail_out, c_stream.avail_out + new_space, c_stream.next_out);
         bsize += new_space;
         c_stream.avail_out += new_space;
         buf = realloc(buf, bsize);
         c_stream.next_out = ((Bytef *)buf) + c_stream.total_out;
      }
      //printd(5, "deflate() Z_BUF_ERROR:1 bsize=%d, avail_out=%d, next_out=%p\n", bsize, c_stream.avail_out, c_stream.next_out);
   }

   while (true) {
      rc = deflate(&c_stream, Z_FINISH);
      if (rc == Z_STREAM_END)
         break;
      if (rc != Z_OK && rc != Z_BUF_ERROR) {
         free(buf);
         do_zlib_exception(rc, "deflate", xsink);
         return 0;
      }
      // resize buffer
      int new_space = 2; //((len / 3) + 100);
      //printd(5, "deflate() Z_BUF_ERROR:2 bsize=%d->%d, new_space=%d avail_out=%d -> %d, next_out=%p\n", bsize, bsize + new_space, new_space, c_stream.avail_out, c_stream.avail_out + new_space, c_stream.next_out);
      
      bsize += new_space;
      c_stream.avail_out += new_space;
      buf = realloc(buf, bsize);
      c_stream.next_out = ((Bytef *)buf) + c_stream.total_out;
   }

   //printd(5, "deflate() buf=%p, bsize=%d, avail_out=%d, size=%d, next_out=%p\n", buf, bsize, c_stream.avail_out, bsize - c_stream.avail_out, c_stream.next_out);
   return new BinaryNode(buf, bsize - c_stream.avail_out);
}

QoreStringNode *qore_inflate_to_string(const BinaryNode *b, const QoreEncoding *enc, ExceptionSink *xsink) {
   z_stream d_stream; // decompression stream
   d_stream.zalloc = Z_NULL;
   d_stream.zfree = Z_NULL;
   d_stream.opaque = Z_NULL;

   int rc = inflateInit(&d_stream);
   if (rc != Z_OK) {
      do_zlib_exception(rc, "inflateInit", xsink);
      return 0;
   }

   ON_BLOCK_EXIT(do_inflate_end, &d_stream, xsink);
   
   int len = b->size();

   // allocate new buffer
   unsigned long bsize = len * 2 + 100;
   void *buf = malloc(bsize);
   
   d_stream.next_in = (Bytef *)b->getPtr();
   d_stream.next_out = (Bytef *)buf;
   d_stream.avail_in = b->size();
   d_stream.avail_out = bsize;

   while (true) {
      rc = inflate(&d_stream, Z_NO_FLUSH);
      if (rc == Z_STREAM_END)
         break;
      if (rc == Z_BUF_ERROR) {
         int new_space = ((len * 3) + 100);
         bsize += new_space;
         d_stream.avail_out += new_space;
         buf = realloc(buf, bsize);
         d_stream.next_out = ((Bytef *)buf) + d_stream.total_out;
      }
      else if (rc != Z_OK) {
         free(buf);
         do_zlib_exception(rc, "inflate", xsink);
         return 0;
      }
   }

   // how much data was decompressed
   len = bsize - d_stream.avail_out;

   // create and return the string
   return new QoreStringNode((char *)buf, len, len, enc);
}

BinaryNode *qore_inflate_to_binary(const BinaryNode *b, ExceptionSink *xsink) {
   z_stream d_stream; // decompression stream
   d_stream.zalloc = Z_NULL;
   d_stream.zfree = Z_NULL;
   d_stream.opaque = Z_NULL;

   int rc = inflateInit(&d_stream);
   if (rc != Z_OK) {
      do_zlib_exception(rc, "inflateInit", xsink);
      return 0;
   }

   ON_BLOCK_EXIT(do_inflate_end, &d_stream, xsink);
   
   int len = b->size();

   // allocate new buffer
   unsigned long bsize = len * 2 + 100;
   void *buf = malloc(bsize);
   
   d_stream.next_in = (Bytef *)b->getPtr();
   d_stream.next_out = (Bytef *)buf;
   d_stream.avail_in = b->size();
   d_stream.avail_out = bsize;

   while (true){
      rc = inflate(&d_stream, Z_NO_FLUSH);
      if (rc == Z_STREAM_END)
         break;
      if (rc == Z_BUF_ERROR) {
         int new_space = ((len * 3) + 100);
         bsize += new_space;
         d_stream.avail_out += new_space;
         buf = realloc(buf, bsize);
         d_stream.next_out = ((Bytef *)buf) + d_stream.total_out;
      }
      else if (rc != Z_OK) {
         free(buf);
         do_zlib_exception(rc, "inflate", xsink);
         return 0;
      }
   }
   
   return new BinaryNode(buf, bsize - d_stream.avail_out);
}

BinaryNode *qore_gzip(const void *ptr, unsigned long len, int level, ExceptionSink *xsink) {
   z_stream c_stream; // compression stream
   c_stream.zalloc = Z_NULL;
   c_stream.zfree = Z_NULL;
   c_stream.opaque = Z_NULL;
   c_stream.next_in = (Bytef *)ptr;
   c_stream.avail_in = len;

   int rc = deflateInit2(&c_stream, level, Z_DEFLATED, 31, 8,  Z_DEFAULT_STRATEGY);   
   if (rc != Z_OK) {
      do_zlib_exception(rc, "deflateInit2", xsink);
      return 0;
   }

   ON_BLOCK_EXIT(do_deflate_end, &c_stream, xsink);
   
   // allocate new buffer
   unsigned long bsize = len / 5 + 100;
   void *buf = malloc(bsize);
   
   c_stream.next_out = (Bytef *)buf;
   c_stream.avail_out = bsize;

   while (c_stream.avail_in) {
      rc = deflate(&c_stream, Z_NO_FLUSH);
      if (rc != Z_OK && rc != Z_BUF_ERROR) {
         free(buf);
         do_zlib_exception(rc, "deflate", xsink);
         return 0;
      }

      if (!c_stream.avail_out) {
         int new_space = ((len / 3) + 100);
         //printd(5, "deflate() Z_BUF_ERROR:1 bsize=%d->%d, new_space=%d avail_out=%d -> %d next_out=%p\n", bsize, bsize + new_space, new_space, c_stream.avail_out, c_stream.avail_out + new_space, c_stream.next_out);

         bsize += new_space;
         c_stream.avail_out += new_space;
         buf = realloc(buf, bsize);
         c_stream.next_out = ((Bytef *)buf) + c_stream.total_out;
      }
      //printd(5, "deflate() Z_BUF_ERROR:1 bsize=%d, avail_out=%d, next_out=%p\n", bsize, c_stream.avail_out, c_stream.next_out);
   }

   while (true) {
      rc = deflate(&c_stream, Z_FINISH);
      if (rc == Z_STREAM_END)
         break;
      if (rc != Z_OK && rc != Z_BUF_ERROR) {
         free(buf);
         do_zlib_exception(rc, "deflate", xsink);
         return 0;
      }
      // resize buffer
      int new_space = 2; //((len / 3) + 100);
      //printd(5, "deflate() Z_BUF_ERROR:2 bsize=%d->%d, new_space=%d avail_out=%d -> %d, next_out=%p\n", bsize, bsize + new_space, new_space, c_stream.avail_out, c_stream.avail_out + new_space, c_stream.next_out);

      bsize += new_space;
      c_stream.avail_out += new_space;
      buf = realloc(buf, bsize);
      c_stream.next_out = ((Bytef *)buf) + c_stream.total_out;
   }

   //printd(5, "deflate() buf=%p, bsize=%d, avail_out=%d, size=%d, next_out=%p\n", buf, bsize, c_stream.avail_out, bsize - c_stream.avail_out, c_stream.next_out);
   return new BinaryNode(buf, bsize - c_stream.avail_out);
}

QoreStringNode *qore_gunzip_to_string(const BinaryNode *bin, const QoreEncoding *enc, ExceptionSink *xsink) {
   z_stream d_stream; // decompression stream
   d_stream.zalloc = Z_NULL;
   d_stream.zfree = Z_NULL;
   d_stream.opaque = Z_NULL;

   d_stream.next_in = (Bytef *)bin->getPtr();
   d_stream.avail_in = bin->size();

   int rc = inflateInit2(&d_stream, 47);
   if (rc != Z_OK) {
      do_zlib_exception(rc, "inflateInit2", xsink);
      return 0;
   }

   ON_BLOCK_EXIT(do_inflate_end, &d_stream, xsink);
   
   int len = bin->size();

   // allocate new buffer
   unsigned long bsize = len * 2 + 100;
   void *buf = malloc(bsize);
   
   d_stream.next_out = (Bytef *)buf;
   d_stream.avail_out = bsize;

   while (true) {
      rc = inflate(&d_stream, Z_NO_FLUSH);
      if (rc == Z_STREAM_END)
         break;
      if (rc == Z_BUF_ERROR) {
         int new_space = ((len * 3) + 100);
         bsize += new_space;
         d_stream.avail_out += new_space;
         buf = realloc(buf, bsize);
         d_stream.next_out = ((Bytef *)buf) + d_stream.total_out;
      }
      else if (rc != Z_OK) {
         free(buf);
         do_zlib_exception(rc, "inflate", xsink);
         return 0;
      }
   }

   // how much data was decompressed
   len = bsize - d_stream.avail_out;

   // create and return the string
   return new QoreStringNode((char *)buf, len, len, enc);
}

BinaryNode *qore_gunzip_to_binary(const BinaryNode *bin, ExceptionSink *xsink) {
   z_stream d_stream; // decompression stream
   d_stream.zalloc = Z_NULL;
   d_stream.zfree = Z_NULL;
   d_stream.opaque = Z_NULL;

   d_stream.next_in = (Bytef *)bin->getPtr();
   d_stream.avail_in = bin->size();

   int rc = inflateInit2(&d_stream, 47);
   if (rc != Z_OK) {
      do_zlib_exception(rc, "inflateInit2", xsink);
      return 0;
   }

   ON_BLOCK_EXIT(do_inflate_end, &d_stream, xsink);
   
   int len = bin->size();

   // allocate new buffer
   unsigned long bsize = len * 2 + 100;
   void *buf = malloc(bsize);
   
   d_stream.next_out = (Bytef *)buf;
   d_stream.avail_out = bsize;

   while (true) {
      rc = inflate(&d_stream, Z_NO_FLUSH);
      if (rc == Z_STREAM_END)
         break;
      if (rc == Z_BUF_ERROR) {
         int new_space = ((len * 3) + 100);
         bsize += new_space;
         d_stream.avail_out += new_space;
         buf = realloc(buf, bsize);
         d_stream.next_out = ((Bytef *)buf) + d_stream.total_out;
      }
      else if (rc != Z_OK) {
         free(buf);
         do_zlib_exception(rc, "inflate", xsink);
         return 0;
      }
   }
   
   return new BinaryNode(buf, bsize - d_stream.avail_out);
}

/** @defgroup compresssion_functions Compression Functions
    These functions work with compression and decompression
 */
//@{
//! Performs zlib-based "deflate" data compression (<a href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951</a>) and returns a binary object of the compressed data
/** Note that strings are compressed without the trailing null character.

    @param str The string to compress
    @param level Specifies the compression level; must be an integer between 1 and 9, 9 meaning the highest compression level. The default value Z_DEFAULT_COMPRESSION gives a tradeoff between speed and compression size

    @return a binary object of the compressed data

    @par Example
    @code
my binary $bin = compress($str_data);
    @endcode

    @throw ZLIB-LEVEL-ERROR level must be between 1 - 9 or -1
    @throw ZLIB-ERROR zlib returned an error while processing
*/
binary compress(string str, int level = Z_DEFAULT_COMPRESSION) {
   if ((level < 1 && level != -1) || level > 9) {
      xsink->raiseException("ZLIB-LEVEL-ERROR", "level must be between 1 - 9 or -1 (value passed: %d)", level);
      return 0;
   }
   
   if (!str->strlen())
      return new BinaryNode;
   
   return qore_deflate(str->getBuffer(), str->strlen(), level, xsink);
}

//! Performs zlib-based "deflate" data compression (<a href="http://www.ietf.org/rfc/rfc1951.txt">RFC 1951</a>) and returns a binary object of the compressed data
/** Note that strings are compressed without the trailing null character.

    @param bin The binary object to compress
    @param level Specifies the compression level; must be an integer between 1 and 9, 9 meaning the highest compression level. The default value Z_DEFAULT_COMPRESSION gives a tradeoff between speed and compression size

    @return a binary object of the compressed data

    @par Example
    @code
my binary $bin = compress($bin_data);
    @endcode

    @throw ZLIB-LEVEL-ERROR level must be between 1 - 9 or -1
    @throw ZLIB-ERROR zlib returned an error while processing
*/
binary compress(binary bin, int level = Z_DEFAULT_COMPRESSION) {
   if ((level < 1 && level != -1) || level > 9) {
      xsink->raiseException("ZLIB-LEVEL-ERROR", "level must be between 1 - 9 or -1 (value passed: %d)", level);
      return 0;
   }
   
   if (!bin->size())
      return new BinaryNode;
   
   return qore_deflate(bin->getPtr(), bin->size(), level, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string uncompress_to_string(binary bin, *string encoding) {
   const QoreEncoding *qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   return qore_inflate_to_string(bin, qe, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
binary uncompress_to_binary(binary bin) {
   return qore_inflate_to_binary(bin, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode

    @throw ZLIB-LEVEL-ERROR level must be between 1 - 9 or -1
*/
binary gzip(string str, int level = Z_DEFAULT_COMPRESSION) {
   if (!level || level > 9) {
      xsink->raiseException("ZLIB-LEVEL-ERROR", "level must be between 0 - 9 (value passed: %d)", level);
      return 0;
   }
   
   if (!str->strlen())
      return new BinaryNode;
   
   return qore_gzip(str->getBuffer(), str->strlen(), level, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode

    @throw ZLIB-LEVEL-ERROR level must be between 1 - 9 or -1
*/
binary gzip(binary bin, int level = Z_DEFAULT_COMPRESSION) {
   if (!level || level > 9) {
      xsink->raiseException("ZLIB-LEVEL-ERROR", "level must be between 0 - 9 (value passed: %d)", level);
      return 0;
   }
   
   if (!bin->size())
      return new BinaryNode;
   
   return qore_gzip(bin->getPtr(), bin->size(), level, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string gunzip_to_string(binary bin, *string encoding) {
   const QoreEncoding *qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   return qore_gunzip_to_string(bin, qe, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
binary gunzip_to_binary(binary bin) {
   return qore_gunzip_to_binary(bin, xsink);
}
//@}

/** @defgroup signal_handling_functions Signal Handing Functions
    Signal handing functions
 */
//@{
//! Sets or replaces a signal handler according to the signal number and closure or call reference (function or object method reference) passed
/** @par Platform Availability
    @ref Qore::HAVE_SIGNAL_HANDLING

    @par Restrictions
    @ref Qore::PO_PROCESS_CONTROL

    By the time this function returns, changes to the signal handling thread have already been effected. See @ref signal_handling for more information.

    When a signal is raised and the signal handler code is called, the signal number is passed as an integer argument to the signal handling code.

    @param signal The signal number to process, see @ref signal_constants for possible values
    @param f The code to execute when the signal is caught; this should accept an integer argument giving the signal number

    @par Example
    @code
set_signal_handler(SIGINT, \signal_handler());
    @endcode
*/
nothing set_signal_handler(softint signal, code f) [dom=QDOM_PROCESS] {
#ifdef HAVE_SIGNAL_HANDLING
   if (!signal || signal > QORE_SIGNAL_MAX) {
      xsink->raiseException("SET-SIGNAL-HANDLER-ERROR", "%d is not a valid signal", signal);
      return 0;
   }

   QSM.setHandler(signal, f, xsink);
#else
   xsink->raiseException("MISSING-FEATURE-ERROR", "this platform does not support signal handling, therefore the set_signal_handler() and remove_signal_handler() functions are not available in Qore; for maximum portability, use the constant Option::HAVE_SIGNAL_HANDLING to check if this function is implemented before calling");
#endif
   return 0;
}

//! 
/** @par Platform Availability
    @ref Qore::HAVE_SIGNAL_HANDLING

    @par Example
    @code
    @endcode
*/
nothing remove_signal_handler(softint signal) [dom=QDOM_PROCESS] {
#ifdef HAVE_SIGNAL_HANDLING
   if (!signal || signal > QORE_SIGNAL_MAX) {
      xsink->raiseException("REMOVE-SIGNAL-HANDLER-ERROR", "%d is not a valid signal", signal);
      return 0;
   }
   QSM.removeHandler(signal, xsink);
#else
   xsink->raiseException("MISSING-FEATURE-ERROR", "this platform does not support signal handling, therefore the set_signal_handler() and remove_signal_handler() functions are not available in Qore; for maximum portability, use the constant Option::HAVE_SIGNAL_HANDLING to check if this function is implemented before calling");
#endif
   return 0;
}
//@}

/** @defgroup misc_functions Miscellaneous Functions
    Miscellaneous functions
 */
//@{
//! Calls a function and returns the return value, passing the remaining arguments after the function name to the function
/** 
    @par Example
    @code
    @endcode
*/
any call_function(string name, ...) {
   ReferenceHolder<QoreListNode> vargs(xsink);
   // if there are arguments to pass, create argument list by copying current list
   if (num_args(args) > 1)
      vargs = args->copyListFrom(1);

   return getProgram()->callFunction(name->getBuffer(), *vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
any call_function(code f, ...) {
   ReferenceHolder<QoreListNode> vargs(xsink);
   // if there are arguments to pass, create argument list by copying current list
   if (num_args(args) > 1)
      vargs = args->copyListFrom(1);

   return f->exec(*vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
any call_function_args(string name, *softlist vargs) {
   return getProgram()->callFunction(name->getBuffer(), vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
any call_function_args(code f, *softlist vargs) {
   return f->exec(vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode

    @throw NO-FUNCTION cannot find the given builtin function
*/
any call_builtin_function(string name, ...) {
   const BuiltinFunction *f = get_builtin_func(name, xsink);
   if (!f)
      return 0;

   ReferenceHolder<QoreListNode> vargs(xsink);
   // if there are arguments to pass, create argument list by copying current list
   if (num_args(args) > 1)
      vargs = args->copyListFrom(1);

   return f->evalDynamic(*vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
any call_builtin_function_args(string name, *softlist vargs) {
   const BuiltinFunction *f = get_builtin_func(name, xsink);
   if (!f)
      return 0;

   return f->evalDynamic(vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
bool exists(...) {
   // to emulate the exists operator, we must return True if more than one argument is passed
   // as this will appear to be a list to the exists operator, which is different from NOTHING
   return (num_args(args) <= 1) ? !is_nothing(get_param(args, 0)) : true;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
bool existsFunction(string name) {
   const char *str = name->getBuffer();
   
   if (getProgram()->existsFunction(str))
      return true;

   return builtinFunctions.find(str);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
bool existsFunction(code[doc] c) [flags=QC_NOOP] {
   return true;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*string functionType(string name) {
   const char *str = name->getBuffer();

   if (getProgram()->existsFunction(str))
      return new QoreStringNode("user");

   return builtinFunctions.find(str) ? new QoreStringNode("builtin") : 0;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string html_encode(string str) {
   QoreStringNode *ns = new QoreStringNode(str->getEncoding());
   ns->concatAndHTMLEncode(str->getBuffer());
   return ns;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string html_decode(string str) {
   QoreStringNode *ns = new QoreStringNode(str->getEncoding());
   ns->concatAndHTMLDecode(str);
   return ns;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string get_default_encoding() {
   return new QoreStringNode(QCS_DEFAULT->getCode());
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
nothing parse(string code, string label) {
   getProgram()->parse(code, label, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string getClassName(object obj) {
   return new QoreStringNode(obj->getClass()->getName());
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
hash parse_url(string url) {
   QoreURL qurl(url);
   if (!qurl.isValid()) {
      xsink->raiseException("PARSE-URL-ERROR", "URL '%s' cannot be parsed", url->getBuffer());
      return 0;
   }

   return qurl.getHash();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*hash parseURL(string url) {
   QoreURL qurl(url);
   return qurl.isValid() ? qurl.getHash() : 0;
}

//! Executes a process and returns a string of the output (stdout only)
/** @par Restrictions
    Not available with @ref Qore::PO_NO_EXTERNAL_PROCESS

    @param cmd The shell command to executed as a subprocess
    
    @return The stdout of the shell command that was executed

    @par Example
    @code
my string $files = $files = backquote("ls");
    @endcode

    @throw BACKQUOTE-ERROR An error occurred with the fork() or opening the stdout pipe
*/
string backquote(string cmd) [dom=QDOM_EXTERNAL_PROCESS] {
   return backquoteEval(cmd->getBuffer(), xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string makeBase64String(string str) {
   QoreStringNode *rv = new QoreStringNode;
   rv->concatBase64(str);
   return rv;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string makeBase64String(binary bin) {
   return new QoreStringNode(bin);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
binary parseBase64String(string str) {
   return str->parseBase64(xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string parseBase64StringToString(string str) {
   return str->parseBase64ToString(xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
list getModuleList() {
   return MM.getModuleList();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
hash getModuleHash() {
   return MM.getModuleHash();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
list getFeatureList() {
   return getProgram()->getFeatureList();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
list hash_values(hash h) {
   QoreListNode *l = new QoreListNode;

   ConstHashIterator hi(h);
   while (hi.next())
      l->push(hi.getReferencedValue());

   return l;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
bool has_key(hash h, string key) {
   bool exists;
   h->getKeyValueExistence(key, exists, xsink);
   return exists;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
bool has_key(object obj, string key) {
   AutoVLock vl(xsink);
   AbstractQoreNode **ptr = obj->getExistingValuePtr(key, &vl, xsink);
   return (bool)ptr;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_byte(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= size || offset < 0)
      return 0;

   return new QoreBigIntNode(ptr[offset]);  
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_byte(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= size || offset < 0)
      return 0;

   return new QoreBigIntNode(ptr[offset]);  
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int getByte(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= size || offset < 0)
      return 0;

   return new QoreBigIntNode(ptr[offset]);  
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int getByte(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= size || offset < 0)
      return 0;

   return new QoreBigIntNode(ptr[offset]);  
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_16(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 1) || offset < 0)
      return 0;

   short val = ntohs(*((unsigned short *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_16(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 1) || offset < 0)
      return 0;

   short val = ntohs(*((unsigned short *)&ptr[offset]));

   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_32(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = ntohl(*((unsigned int *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_32(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = ntohl(*((unsigned int *)&ptr[offset]));

   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int getWord32(string str, softint offset = 0) [flags=QC_CONSTANT|QC_DEPRECATED] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = ntohl(*((unsigned int *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int getWord32(binary b, softint offset = 0) [flags=QC_CONSTANT|QC_DEPRECATED] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = ntohl(*((unsigned int *)&ptr[offset]));

   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_64(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 7) || offset < 0)
      return 0;

   int64 val = MSBi8(*((int64 *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_64(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 7) || offset < 0)
      return 0;

   int64 val = MSBi8(*((int64 *)&ptr[offset]));

   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_16_lsb(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 1) || offset < 0)
      return 0;

   short val = LSBi2(*((unsigned short *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_16_lsb(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 1) || offset < 0)
      return 0;

   short val = LSBi2(*((unsigned short *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_32_lsb(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = LSBi4(*((unsigned int *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_32_lsb(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = LSBi4(*((unsigned int *)&ptr[offset]));

   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_64_lsb(string str, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 7) || offset < 0)
      return 0;

   int64 val = LSBi8(*((int64 *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*int get_word_64_lsb(binary b, softint offset = 0) [flags=QC_CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 7) || offset < 0)
      return 0;

   int64 val = LSBi8(*((int64 *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! 
/** 
*/
string splice(string[doc] str) [flags=QC_NOOP] {
   return new QoreStringNode;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string splice(string str, softint start) {
   QoreStringNodeHolder pstr(str->copy());
   pstr->splice(start, xsink);
   return *xsink ? 0 : pstr.release();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string splice(string str, softint start, softint len, *string nstr) {
   QoreStringNodeHolder pstr(str->copy());
   pstr->splice(start, len, nstr, xsink);
   return *xsink ? 0 : pstr.release();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
list splice(list l, softint start) {
   ReferenceHolder<QoreListNode> lst(l->copy(), xsink);
   lst->splice(start, xsink);
   return *xsink ? 0 : lst.release();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
list splice(list l, softint start, softint len, *list nlist) {
   ReferenceHolder<QoreListNode> lst(l->copy(), xsink);
   lst->splice(start, len, nlist, xsink);
   return *xsink ? 0 : lst.release();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string makeHexString(string str) [flags=QC_CONSTANT] {
   QoreStringNode *rv = new QoreStringNode;
   rv->concatHex(str);
   return rv;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
string makeHexString(binary bin) {
   QoreStringNode *str = new QoreStringNode;
   str->concatHex(bin);
   return str;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
binary parseHexString(string hexstr) {
   return hexstr->parseHex(xsink);
}

//! takes a string of hexadecimal digits (like \c "6d4f84e0"; with or without leading \c "x" or \c "0x") and returns the corresponding base-10 integer
/** 
    @par Example
    @code
    @endcode
*/
int hextoint(string str) {
   if (!str->strlen())
      return 0;

   int64 rc = 0;
   int64 pow = 0;
   const char *buf = str->getBuffer();
   qore_size_t len = str->size();
   if (*buf == '0' && *(buf + 1) == 'x') {
      buf += 2;
      len -= 2;
   }
   else if (*buf == 'x') {
      buf++;
      --len;
   }
   for (const char *p = buf + len - 1; p >= buf; p--) {
      int n = get_nibble(*p, xsink);
      if (xsink->isException())
	 return 0;
      if (!pow) {
	 rc = n;
	 pow = 16;
      }
      else {
	 rc += n * pow;
	 pow *= 16;
      }
   }
   return rc;
}

//! parses a string representing a number in a configurable base and returns the integer
/** 
    @par Example
    @code
    @endcode
    
    @throw STRTOINT-ERROR cannot parse string; unsupported base, etc
*/
int strtoint(string num, int base) {
   errno = 0;
   int64 rv = strtoll(num->getBuffer(), 0, base);
   if (errno == EINVAL || errno == ERANGE)
      xsink->raiseException("STRTOINT-ERROR", "could not parse '%s' to an integer", num->getBuffer());
   return rv;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
nothing load_module(string name) [flags=QC_CONSTANT] {
   MM.runTimeLoadModule(name->getBuffer(), xsink);
}

//! returns a string with percent-encodings substituted for characters
/** 
    @par Example
    @code
    @endcode
*/
string decode_url(string url) [flags=QC_CONSTANT] {
   QoreStringNode *str = new QoreStringNode(url->getEncoding());
   
   if (!url->strlen())
      return str;

   const char *c = url->getBuffer();

   while (*c) {
      if (*c == '%' && isxdigit(*(c + 1)) && isxdigit(*(c + 2))) {
         char x[3] = { *(c + 1), *(c + 2), '\0' };
         char code = strtol(x, 0, 16);
         str->concat(code);
         c += 3;
         continue;
      }
      str->concat(*c);
      c++;
   }
   return str;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*string get_script_path() {
   return getProgram()->getScriptPath();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*string get_script_dir() {
   return getProgram()->getScriptDir();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
*string get_script_name() {
   return getProgram()->getScriptName();
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
list get_qore_option_list() [flags=QC_CONSTANT] {
   static const char *tlist[] = { "OPTION", "ALGORITHM", "FUNCTION" };
   QoreListNode *l = new QoreListNode;

   for (unsigned j = 0; j < qore_option_list_size; ++j) {
      QoreHashNode *h = new QoreHashNode;
      h->setKeyValue("option", new QoreStringNode(qore_option_list[j].option), xsink);
      h->setKeyValue("constant", new QoreStringNode(qore_option_list[j].constant), xsink);
      h->setKeyValue("type", new QoreStringNode(tlist[qore_option_list[j].type]), xsink);
      h->setKeyValue("value", get_bool_node(qore_option_list[j].value), xsink);
      l->push(h);
   }
   return l;
}

//! 
/** 
    @par Example
    @code
    @endcode
*/
hash get_qore_library_info() [flags=QC_CONSTANT] {
   QoreHashNode *h = new QoreHashNode;

   h->setKeyValue("PlatformOS", new QoreStringNode(qore_target_os), xsink);
   h->setKeyValue("PlatformCPU", new QoreStringNode(qore_target_arch), xsink);
   h->setKeyValue("VersionString", new QoreStringNode(qore_version_string), xsink);   
   h->setKeyValue("VersionMajor", new QoreBigIntNode(qore_version_major), xsink);
   h->setKeyValue("VersionMinor", new QoreBigIntNode(qore_version_minor), xsink);
   h->setKeyValue("VersionSub", new QoreBigIntNode(qore_version_sub), xsink);
   h->setKeyValue("Build", new QoreStringNode(qore_build_number), xsink);
   h->setKeyValue("ModuleDir", new QoreStringNode(qore_module_dir), xsink);

   h->setKeyValue("BuildHost", new QoreStringNode(qore_build_host), xsink);
   h->setKeyValue("Compiler", new QoreStringNode(qore_cplusplus_compiler), xsink);
   h->setKeyValue("CFLAGS", new QoreStringNode(qore_cflags), xsink);
   h->setKeyValue("LDFLAGS", new QoreStringNode(qore_ldflags), xsink);

   return h;
}
//@}
