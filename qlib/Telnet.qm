# -*- mode: qore; indent-tabs-mode nil -*-
# @file SmtpClient.qm SmtpClient module definition

module Telnet {
       version = "1.0";
       desc = "allows connections to a Telnet server, to remotely execute commands and read their output";
       author = "unknown";
       url = "http://qore.org";
}

public namespace Telnet {
    public const TelnetPort = 23;
    
    # telnet protocol codes
    public const IAC  = 255;
    public const DONT = 254;
    public const DO   = 253;
    public const WONT = 252;
    public const WILL = 251;
    public const theNULL = 0;
    public const SE  = 240;  # Subnegotiation End
    public const NOP = 241;  # No Operation
    public const DM  = 242;  # Data Mark
    public const BRK = 243;  # Break
    public const IP  = 244;  # Interrupt process
    public const AO  = 245;  # Abort output
    public const AYT = 246;  # Are You There
    public const EC  = 247;  # Erase Character
    public const EL  = 248;  # Erase Line
    public const GA  = 249;  # Go Ahead
    public const SB =  250;  # Subnegotiation Begin

    # command name map
    public const CmdMap = (
	IAC : "IAC", 
        DONT : "DONT",
        DO : "DO",
        WONT : "WONT",
        WILL: "WILL",
        theNULL : "theNULL",
        SE : "SubnegotiationEnd",
        NOP : "NoOperation",
        DM: "DataMark",
        BRK : "Break",
        IP : "Interruptprocess",
        AO : "Abortoutput",
        AYT : "AreYouThere",
        EC : "EraseCharacter",
        EL : "EraseLine",
        GA : "GoAhead",
        SB : "SubnegotiationBegin",
	);
    
    public const SUPDUP_OPT = 21; # SUPDUP_OPT display protocol
    
    # telnet option codes
    public const TOPT_BIN = 0;
    public const TOPT_ECHO = 1;
    public const TOPT_RECN = 2;
    public const TOPT_SUPP = 3;
    public const TOPT_APRX = 4;
    public const TOPT_STAT = 5;
    public const TOPT_TIM = 6;
    public const TOPT_REM = 7;
    public const TOPT_OLW = 8;
    public const TOPT_OPS = 9;
    public const TOPT_OCRD = 10;
    public const TOPT_OHT = 11;
    public const TOPT_OHTD = 12;
    public const TOPT_OFD = 13;
    public const TOPT_OVT = 14;
    public const TOPT_OVTD = 15;
    public const TOPT_OLD = 16;
    public const TOPT_EXT = 17;
    public const TOPT_LOGO = 18;
    public const TOPT_BYTE = 19;
    public const TOPT_DATA = 20;
    public const TOPT_SUP = 21;
    public const TOPT_SUPO = 22;
    public const TOPT_SNDL = 23;
    public const TOPT_TERM = 24;
    public const TOPT_EOR = 25;
    public const TOPT_TACACS = 26;
    public const TOPT_OM = 27;
    public const TOPT_TLN = 28;
    public const TOPT_3270 = 29;
    public const TOPT_X3 = 30;
    public const TOPT_NAWS = 31;
    public const TOPT_TS = 32;
    public const TOPT_RFC = 33;
    public const TOPT_LINE = 34;
    public const TOPT_XDL = 35;
    public const TOPT_ENVIR = 36;
    public const TOPT_AUTH = 37;
    public const TOPT_ENVIR_NEW = 39;
    public const TOPT_TN3270 = 40;
    public const TOPT_X_AUTH = 41;
    public const TOPT_CHARSET = 42;
    public const TOPT_RSP = 43;
    public const TOPT_COMPORT = 44;
    public const TOPT_SLE = 45;
    public const TOPT_STARTTLS = 46;
    public const TOPT_KERMIT = 47;
    public const TOPT_SEND_URL = 48;
    public const TOPT_EXTOP = 255;

    # option map
    public const OptMap = (
	TOPT_BIN : "BinaryTransmission",
	TOPT_ECHO : "Echo|Is|Send",
        TOPT_RECN : "Reconnection",
        TOPT_SUPP : "SuppressGoAhead",
        TOPT_APRX : "ApproxMessageSizeNegotiation",
        TOPT_STAT : "Status",
        TOPT_TIM : "TimingMark",
        TOPT_REM : "RemoteControlledTransandEcho",
        TOPT_OLW : "OutputLineWidth",
        TOPT_OPS : "OutputPageSize",
        TOPT_OCRD : "OutputCarriage-ReturnDisposition",
        TOPT_OHT : "OutputHorizontalTabstops",
        TOPT_OHTD : "OutputHorizontalTabDisposition",
        TOPT_OFD : "OutputFormfeedDisposition",
        TOPT_OVT : "OutputVerticalTabstops",
        TOPT_OVTD : "OutputVerticalTabDisposition",
        TOPT_OLD : "OutputLinefeedDisposition",
        TOPT_EXT : "ExtendedASCII",
        TOPT_LOGO : "Logout",
        TOPT_BYTE : "ByteMacro",
        TOPT_DATA : "DataEntryTerminal",
        TOPT_SUP : "SUPDUP",
        TOPT_SUPO : "SUPDUPOutput",
        TOPT_SNDL : "SendLocation",
	TOPT_TERM : "TerminalType",
	TOPT_EOR : "EndofRecord",
        TOPT_TACACS : "TACACSUserIdent",
        TOPT_OM : "OutputMarking",
        TOPT_TLN : "TerminalLocationNumber",
        TOPT_3270 : "Telnet3270Regime",
        TOPT_X3 : "X.3PAD",
        TOPT_NAWS : "NegotiateAboutWindowSize",
        TOPT_TS : "TerminalSpeed",
        TOPT_RFC : "RemoteFlowControl",
        TOPT_LINE : "Linemode",
        TOPT_XDL : "XDisplayLocation",
        TOPT_ENVIR : "TelnetEnvironmentOption",
        TOPT_AUTH : "TelnetAuthenticationOption",
        TOPT_ENVIR_NEW : "TelnetNewEnvironmentOption",
        TOPT_TN3270 : "TN3270Enhancements",
        TOPT_X_AUTH : "TelnetXAUTH",
        TOPT_CHARSET : "TelnetCHARSET",
        TOPT_RSP : "TelnetRemoteSerialPort",
        TOPT_COMPORT : "TelnetComPortControl",
        TOPT_SLE : "TelnetSuppressLocalEcho",
        TOPT_STARTTLS : "TelnetStartTLS",
        TOPT_KERMIT : "TelnetKERMIT",
        TOPT_SEND_URL : "Send-URL",
        TOPT_EXTOP : "Extended-Options-List",
	);

    # default poll timeout
    const DefaultTimeout = 25ms;

    public class Telnet {
  	private {
	    string $.connect;
	    Socket $.conn();
	    
	    bool $.terminalOpened = False; 
	    bool $.logEnabled = False;      # flag controlling debug logging

	    *code $.log_info;
	    *code $.log_debug;

	    list $.iacseq = ();   # buffer for telnet commands
	    list $.sbdataq = ();  # subnegotiation data/command queue
	    bool $.sb = False;    # flag indicating "inside subnegotiation" status
	}

	public {}

	#! creates the SmtpClient object
	/** @param host the hostname of the SMTP server (use [hostname] to explicitly specify an ipv6 connection)
	    @param port the port number of the SMTP server
	    @param log a closure for log messages
	    @param dbglog a closure for debugging/technical log messages
	 */
  	constructor(string $host, softint $port, *code $log, *code $dbgLog) {
	    if ($host.empty())
		throw "TELNET-CONSTRUCTOR-ERROR", "the host parameter may not be empty";

	    $.log_info = $log;
	    $.log_debug = $dbgLog;

	    $.connect = sprintf("%s:%d", $host, $port);
	    $.logDbg("server: %y", $.connect);
	}

	#! creates the Telnet object
	/** @param connect the hostname of the Telnet server or a hostname:port specification (use [hostname] or [address] for ipv6 connections)
	    @param log a closure for log messages
	    @param dbglog a closure for debugging/technical log messages
	 */
	constructor(string $connect, *code $log, *code $dbglog) {
	    $.log_info = $log;
	    $.log_debug = $dbglog;

	    # add default port if the connect string has no port number and:
	    # 1) is not a path (for a UNIX domain socket)
	    # 2) is not an ipv6 address enclosed in '[]' (ex '[2001:0db8:85a3:0000:0000:8a2e:0370:7334]')
	    if ($connect !~ /^\//) {
		my *softint $p = ($connect =~ x/:([0-9]+)$/)[0];
		if (!$p)
		    $connect += ":" + TelnetPort;
	    }

	    $.connect = $connect;
	    $.logDbg("server: %y", $.connect);
	}
  	
  	destructor() {
	    $.disconnect();
  	}
  	
	private log(string $msg) {
	    if ($.log_info.val())
		call_function($.log_info, "Telnet: " + trim(vsprintf($msg, $argv)));
	}

	private logDbg(string $msg) {
	    if ($.log_debug.val())
		call_function($.log_debug, "Telnet: " + trim(vsprintf($msg, $argv)));
	}

  	connect() {
	    $.conn.connect($.connect);
  	}
  	
	bool isConnected() {
	    return $.conn.isOpen();
  	}
  	
  	disconnect() {
	    if ($.isConnected()) {
		$.conn.close();
		$.conn.shutdown();
	    }
  	}
  	
  	checkConn() {
	    if (!$.isConnected())
		throw "NOT-CONNECTED-EXCEPTION", "Cannot perform the operation without being connected to server!";
  	}
  	
  	setLoggingEnabled(softbool $boolflag) {
	    $.logEnabled = $boolflag;
  	}
  	
  	bool getLoggingEnabled() {
	    return $.logEnabled;
  	}
  	
  	private list strToByteList(string $str, bool $double = False, bool $enc = False) {
	    my list $result = ();
	    for (my int $x = 0; $x < $str.size(); ++$x) {
		my int $e = ord($str[$x]); 
		$result += $e;
		if ($double && $e == IAC)
		    $result += $e;
		else if ($enc && $e == 13)
		    $result += 10;
	    }
	    return $result;
  	}
  	
  	private string byteListToStr(list $arr) {
	    my string $result = "";
	    for (my int $x = 0; $x < elements $arr; $x++)
		$result += chr($arr[$x]);
	    return $result;
  	}
  	
  	sendData(softlist $arr) {
	    $.checkConn();
	    foreach my any $val in ($arr) {
		if ($val.typeCode() == NT_STRING)
		    $val = ord($val);
		$.conn.sendi1($val);
	    }
  	}
  	
  	sendTextData(string $str) {
	    $.sendData($.strToByteList($str, True));
  	}

  	sendTerminalTextData(string $str) {
	    $.sendData($.strToByteList($str, True, True));
  	}

  	string openDumbTerminal(string $username, string $password, bool $executeSetupCommands = False, bool $doubleEntries = False) {
	    $.checkConn();
	    
	    # perform initial handshaking
	    $.getAvailableData(); 		
	    
	    if ($executeSetupCommands) {
		$.logDbg("--> sending SGA flag and DONT ECHO to server");
		# set Suppress Go Ahead flag
		$.sendData( (IAC,DO,TOPT_SUPP) );
		# do not echo the commands (do not echo password on terminal)
		$.sendData( (IAC,DONT,TOPT_ECHO) );
	    }
	    
	    $.logDbg("--> sending USERNAME to server");
	    $.sendTextData($username);
	    $.sendData( (13,10) );
	    my string $replyStr = $.getAvailableData();
	    
	    if ($doubleEntries) {
		$.logDbg("--> sending DOUBLED USERNAME to server");
		$.sendTextData($username);
		$.sendData((13,10));
		$replyStr = $.getAvailableData();
	    }
	    
	    $.logDbg("--> sending PASSWORD to server\n");
	    $.sendTextData($password);
	    $.sendData( (13,10) );
	    $replyStr = $.getAvailableData();

	    if ($doubleEntries) {	    
		$.logDbg("--> sending DOUBLED PASSWORD to server\n");
		$.sendTextData($password);
		$.sendData( (13,10) );
		$replyStr = $.getAvailableData();
	    }
	    
	    $.terminalOpened = True;
	    return $replyStr; 
  	}
  	
  	string sendCommand(string $cmd, bool $supressEcho = False) {
	    $.checkConn();
	    if (!$.terminalOpened)
		throw "TERMINAL-NOT-OPENED", "Dumb terminal not opened, please call Telnet::openDumbTerminal() first";
	    
	    if ($supressEcho) {
		$.logDbg("requesting echo supress from server");
		$.sendData( (IAC,DONT,TOPT_ECHO) );
	    }

	    $.sendTextData($cmd);
	    $.sendData( (13,10) );
	    
	    return $.getAvailableData();
  	}

  	string getAvailableData() {
	    my list $buf = ();
	    while ($.conn.isDataAvailable(DefaultTimeout)) {
		my int $char = $.conn.recvu1();
		
		if ($.iacseq.empty()) { # no command sequence started yet
		    if ($.sb && $char != IAC) { # we are inside ongoing subnegotiation 
			$.logDbg("subnegotiation data: %s - %s", $char, $.getOptName($char));
			push $.sbdataq, $char;
			continue;
		    }

		    switch ($char) {
			case theNULL:
			case SUPDUP_OPT:
			    break;
			case < IAC:
			    push $buf, $char;
			    break;
		        default:
			    push $.iacseq, $char;
		    }
		}

		else if (elements $.iacseq == 1) { # inside of a command sequence, IAC is already in the queue
		    if ($char == DO || $char == DONT || $char == WILL || $char == WONT) {
			push $.iacseq, $char;
			#$.logDbg("pushed: %d (%s) into iacseq: %n", $char, CmdMap.$char, $.iacseq);
			continue; # to get the option for DO/DONT/WILL/WONT
		    }
		    $.iacseq = ();
		    switch ($char) {
			case IAC: # doubled IAC is the char 255 itself
			    push $buf, $char;
			    break;

			case SB: # subnegotiation starts
                            $.sbdataq = ();
                            $.sb = True; # entering subnegotiaton 
			    $.logDbg("*** subnegotiation started");
                            break;

			case SE: # subnegotiation ends
                            $.sb = False; # not inside subnegotiation anymore
			    $.logDbg("*** subnegotiation finished, sbdataq: %y", $.sbdataq);
                            $.processSubnegotiationRequest();
                            break;

  		        default:
			    $.logDbg("unknown aic: %d", $char);
		    }
		} # ENDOF if(elements $.iacseq == 1)		

		else if (elements $.iacseq == 2) { # inside of a command sequence, expecting option as next
		    my int $cmd = $.iacseq[1];
		    my int $opt = $char;
		    $.logDbg("received command %d %s option %d %s", $cmd, CmdMap.$cmd, $opt, OptMap.$opt);
		    $.iacseq = ();

		    switch ($cmd) {
			case DO: {
			    switch ($opt) {
				case TOPT_ECHO: {
				    $.logDbg("---> got DO ECHO, sending WONT");
				    $.sendData( (IAC,WONT,$opt) );
				    $.sendData( (IAC,DO,$opt) );
				    break;
				}

				case TOPT_TS:
				case TOPT_XDL:
				case TOPT_ENVIR_NEW: 
				case TOPT_SUPP:
				case TOPT_NAWS:
				case TOPT_TERM: {
				    $.logDbg("---> got DO, sending WILL (WILL: %d, option: %d %s)", WILL, $opt, OptMap.$opt);
				    $.sendData((IAC,WILL,$opt));
				    break;
				}

			        default: {
				    $.logDbg("---> got DO %s, sending WONT and DONT", OptMap.$opt);
				    $.sendData((IAC,WONT,$opt,IAC,DONT,$opt));
				    break;
				}
			    }
			    break;
			}

			case DONT: {
			    if ($opt == TOPT_LINE) {
				$.logDbg("---> got DONT LINEMODE, sending WILL (anyway :-))");
				$.sendData( (IAC,WILL,$opt) );
			    }
			    else { 
			        $.logDbg("---> got DONT, sending WONT (WONT: %d, option: %d %s)", WONT, $opt, OptMap.$opt);
				$.sendData( (IAC,WONT,$opt) );
			    }
			    break;
			}

			case WILL: {
			    $.logDbg("---> got WILL, sending DO (DO: %s, option: %d %s)", DO, $opt, OptMap.$opt);
			    $.sendData( (IAC,DO,$opt) );
			    break;
			}

			case WONT: {
			    $.logDbg("---> got WONT, sending DONT (DONT: %s, option: %d %s)", DONT, $opt, OptMap.$opt);
			    #$.sendData( (IAC,DONT,$opt) );
			    break;
			}
		    }
		} # ENDOF if(elements $.iacseq == 2)
	    } # end of while read loop

	    my string $rv = $.byteListToStr($buf);
	    #$.logDbg("[%s]", $rv);

	    return $rv;
  	}
  	
  	private processSubnegotiationRequest() {
	    my $sbCode = $.sbdataq[1];
	    my $sbOpt = $.sbdataq[0];
	    
	    if ($sbCode == 1) { # server requests us to SEND (code 1) the subnegotiation answer
		switch ($sbOpt) {
		    case TOPT_TS: {
			# send terminal speed string
			$.logDbg("---> sending terminal speed 38400 to server");
			$.sendData( (IAC,SB,TOPT_TS, 0, '3','8','4','0','0',',','3','8','4','0','0' ,IAC, SE) );
			break;
		    }

		    case TOPT_XDL: {
			# display location
			$.logDbg("---> sending display location to server");
			$.sendData( (IAC,SB,TOPT_XDL, 0) );
			$.sendTextData(gethostname()+":1.0"); 
			$.sendData( (IAC,SE) ); 
			break;
		    }

		    case TOPT_ENVIR_NEW: { 
			# set telnet environment vars
			$.logDbg("---> sending telnet environment to server");
			$.sendData( (IAC,SB,TOPT_ENVIR_NEW, 0, 0) );  # first 0=IS, second 0=VAR, see RFC 1572
			$.sendTextData("DISPLAY");
			$.sendData( (1) );  # 1=VALUE
			$.sendTextData(gethostname()+":1.0");
			$.sendData( (IAC,SE) ); 
			break;
		    }

		    case TOPT_TERM: {
			# terminal type
			$.logDbg("---> sending terminal type to server");
			$.sendData( (IAC,SB,TOPT_TERM, 0) ); # see telnet RFC 1091
			#$.sendTextData("xterm");
			$.sendTextData($ENV.TERM);
			$.sendData( (IAC,SE) ); 
			break;
		    }

		    case TOPT_NAWS: {
			my hash $wh = TermIOS::getWindowSize();
			$.logDbg("---> sending window size [%d,%d] to server", $wh.rows, $wh.columns);
			$.sendData((IAC,SB,TOPT_NAWS,0,$wh.rows,0,$wh.columns)); # see telnet RFC 1091
			break;
		    }
		}
	    }
	    else
		$.logDbg("unknown subnegotiation code: %d",$sbCode);
	    
	    $.sbdataq = ();
  	}
  	  	
	# returns textual description of telnet commands
  	string getCmdName(softstring $cmd) {
	    return CmdMap.$cmd;
  	}

	# returns textual description of telnet options
	string getOptName(softstring $opt) {
	    return OptMap.$opt;
	}
    } # end of Telnet class

    /*
    # concrete telnet implementation for SRRI
    public const SRRI_UNSUCCESSFUL_LOGIN = "USER AUTHORIZATION FAILURE";
    public const SRRI_DELAYED_LOGIN = "DELAY APPLIED";
    
    class TelnetSRRI inherits Telnet {
  	constructor($host,$port) : Telnet($host,$port) {
  	}
  	
  	openTerminal($username, $password,$executeSetupCommands, $doubleEntries) {
	    $.checkConn();
	    my $initData = $.getAvailableData(); 		
	    if(index($initData,SRRI_DELAYED_LOGIN)>-1)
		throw "DELAYED-LOGIN","Login delayed by SRRI, please try again later.",$initData;

	    my $logInOutput = $.openDumbTerminal($username, $password, $executeSetupCommands, $doubleEntries);
	    if(index($logInOutput,SRRI_UNSUCCESSFUL_LOGIN)>-1)
		throw "INCORRECT-LOGIN","Either username or password is invalid.";
	    
	    if(index($logInOutput,SRRI_DELAYED_LOGIN)>-1)
		throw "DELAYED-LOGIN","Login rejected by SRRI, please try later.",$logInOutput;
  	}
    }
*/
} 
# END of telnet namespace

# sample main() function
# SRRI simulator
/*
my $client = new Telnet::TelnetSRRI("localhost",18201);
$client.connect();
$client.setLoggingEnabled(True);
$client.openTerminal("USER","PSWD");
printf("Terminal opened\n\n");

printf("sending COMMAND\n");
my $reply = $client.sendCommand("ZM1O:436607370913;");
printf("reply is: [%n]\n",$reply);

printf("GOING TO DISCONNECT\n");
$client.disconnect();
printf("END\n");
*/

/*
my $client = new Telnet::TelnetSRRI("localhost",18400);
$client.connect();
$client.openTerminal("USER","PSWD");

printf("TELNET_CLIENT: sending COMMAND\n");
my $reply = $client.sendCommand("ZM1O:436607370913;");
printf("TELNET_CLIENT: reply is: [%n]\n",$reply);

printf("TELNET_CLIENT: GOING TO DISCONNECT\n");
$client.disconnect();
printf("TELNET_CLIENT: END\n");
*/
