# -*- mode: qore; indent-tabs-mode: nil -*-
# @file SqlUtil.qm Qore user module for working with SQL data

/*  SqlUtil.qm Copyright 2013 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.8 or better
%requires qore >= 0.8.8

# requires the Util module
%requires Util >= 1.0

# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module SqlUtil {
    version = "1.0";
    desc = "user module for working with SQL data";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
}

/*  Version History
    * 2013-xx-xx v1.0: David Nichols <david@qore.org>
      + the initial version of the SqlUtil module
*/

/** @mainpage SqlUtil Module

    @section intro Introduction

    The %SqlUtil module provides a high level API for working with database objects.

    To use this module, use \c "%requires SqlUtil" in your code.
    
    All the public symbols in the module are defined in the SqlUtil namespace

    @section schema_management Schema Management

    @anchor table_desc_hash
    <b>Table Description Hash</b>
    
    Table description hashes have the following structure:
    - \c columns: (required) a hash of column information keyed by column name; the values are @ref column_desc_hash "column description hashes"
    - \c primary_key: (optional) a @ref pk_desc_hash "primary key description hash" describing the primary key for the table
    - \c indexes: (optional) a hash of index information keyed by index name; the values are @ref index_desc_hash "index description hashes"
    - \c triggers: (optional) a hash of trigger information keyed by trigger name; the values are the trigger source code; since triggers are driver-dependent, a driver-independent table description would include trigger hashes under the \c drivers key and the driver key name under that; see below for an example

    Here is an example of a table description hash:
    @code
my hash $table_desc = (
    "columns": (
        "domain": (
            "qore_type": Type::String, 
            "size": 240,
            "notnull": True,
        ),
        "keyname": (
            "qore_type": Type::String,
            "size": 240,
            "notnull": True,
        ),
        "value": (
            "qore_type": Type::String,
            "size": 4000,
        ),
        "created": (
            "qore_type": Type::Date,
            "notnull": True,
            "driver": (
                "oracle": (
                    "native_type": "date",
                ),
            ),
        ),
        "modified": (
            "qore_type": Type::Date,
            "driver": (
                "oracle": (
                    "native_type": "date",
                ),
            ),
        ),
    ),
    "primary_key": ("name": "pk_system_properties", "columns": ("domain", "keyname")),
    "indexes": (
        "sk_system_properties_domain": ("columns": "domain"),
        "driver": (
            "oracle": (
                "pk_system_properties": ("columns": ("domain", "keyname"), "unique": True),
            ),
        ),
    ),
    "driver": (
        "pgsql": (
            "functions": (
                "trig_system_properties()": "returns trigger language plpgsql as $function$
begin
  if (tg_op = 'INSERT') then
    if new.created is null then
      select current_timestamp into new.created;
    end if;
  end if;
  if new.modified is null  then
    select current_timestamp into new.modified;
  end if;
  return new;
end;
$function$",
            ),
        ),
    ),
    "triggers": (
        "driver": (
            "oracle": (
                "trig_system_properties": "BEFORE INSERT OR UPDATE ON SYSTEM_PROPERTIES
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
begin
  if inserting then
    if :new.created is null then
      :new.created := sysdate;
    end if;
  end if;
  --
  if :new.modified is null or :new.modified = :old.modified then
    :new.modified := sysdate;
  end if;
end;",
            ),
            "pgsql": (
                    "trig_system_properties": "before insert or update on system_properties for each row execute procedure trig_system_properties()",
            ),
            "mysql": (
            ),
        ),
    ),
);
    @endcode

    @note the above example includes an additional driver-specific key for the \c "pgsql" driver: \c "functions" which is used by the PgsqlSqlUtil module to create trigger functions used by the table's trigger.

    @anchor column_desc_hash
    <b>Column Description Hash</b>

    Column description hashes have the following structure:
    - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion
    - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
    - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
    - \c scale: for numeric data types, this value gives the scale
    - \c default_value: the default value for the column
    - \c comment: an optional comment for the column
    - \c notnull: if the column should have a "not null" constraint on it; if missing the default value is @ref Qore::False "False"
    - \c driver: this key can optionally contain a hash keyed by driver name which contains a hash of values that will be added to the column description hash before processing; this way a column description hash can contain all the information required for the column including driver-specific options; any driver-specific options will overwrite values in the top level of the hash if there are duplicate hash keys, see below for an example

    Note that the above structure is an extension of the fields in @ref SqlUtil::AbstractTable::ColumnOptions, adding \c notnull and \c driver keys for additional information to create the column in the table.

    Here is an example of a column description hash:
    @code
my hash $date_col_desc = (
    "qore_type": Type::Date,
    "notnull": True,
    "driver": (
        "oracle": (
            "native_type": "date",
        ),
    ),
);
    @endcode

    The above hash describes a column that will be have \c TIMESTAMP type on most databases, but \c DATE on Oracle.

    @anchor pk_desc_hash
    <b>Primary Key Description Hash</b>

    The primary key description hash has the following keys:
    - \c name: (required) the name of the primary key
    - \c columns: (required) a single column name or a list of column names making up the primary key

    Here is an example of a primary key description hash:
    @code
my hash $pk_desc = (
    "name": "pk_queue",
    "columns": "queueid",
);
    @endcode

    @anchor index_desc_hash
    <b>Index Description Hash</b>

    Index description hashes have the following structure:
    - \c columns: (required) a single column or a list of column names making up the index
    - \c unique: a boolean value indicating if the index is unique or not, if missing, then the index is assumed to e not unique
*/

#! the SqlUtil namespace contains all the objects in the SqlUtil module
public namespace SqlUtil {
    /* @defgroup SqlTypeConstants SQL Type Constants
        These constants can be used for the \c "qore_type" values when creating columns to specify additional SQL column types
    */
    #@{
    #! specifies a \c VARCHAR column (equivalent to @ref Qore::Type::String)
    public const VARCHAR = "string";

    #! specifies a \c CHAR column
    public const CHAR = "char";

    #! specifies a large variable-length binary column (ie \c BLOB or \c BYTEA, etc)
    public const BLOB = "blob";

    #! specifies a large variable-length character column (ie \c CLOB or \c TEXT, etc)
    public const CLOB = "clob";
    #@}

    /** @defgroup ColumnSizeOptions Column Size Options
        These constants represent the possible values for column size options
     */
    #@{
    #! the data type does not take a size parameter
    public const SZ_NONE = 0;

    #! the data type takes a mandatory size parameter
    public const SZ_MAND = 1;

    #! the data type takes an optional size parameter
    public const SZ_OPT = 2;

    #! the data type is numeric so takes an optional precision and scale
    public const SZ_NUM = 3;
    #@}

    #! abstract container class that throws an exception if an unknown key is accessed
    public class AbstractHashContainer {
        public {}

        private {
            *hash h;
        }

        #! creates the object with the hash argument passed
        constructor(*hash nh) {
            h = nh;
        }

        #! creates a "deep copy" of the object
        copy(AbstractHashContainer old) {
            map h.$1 = old.h.$1.copy(), old.h.keyIterator();
        }

        #! returns the value of the given key in the contained hash if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code
my any $v = $c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        any memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        #! adds the given value to the hash with the given key name
        add(string k, any val) {
            h{k} = val;
        }

        #! removes the given key from the contained hash and returns the value
        any take(string k) {
            return remove h{k};
        }

        #! renames the given key; maintains the key order
        renameKey(string old_name, string new_name) {
            hash nh;
            foreach hash kh in (h.pairIterator())
                nh{kh.key == old_name ? new_name : kh.key} = kh.value;

            h = nh;
        }

        #! returns the hash contained by this object
        *hash getHash() {
            return h;
        }

        #! returns @ref Qore::True "True" if the hash argument has the same keys (in any order), @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $c.matchKeys($h);
            @endcode

            @param h1 the hash to compare

            @return @ref Qore::True "True" if the hash argument has the same keys (in any order), @ref Qore::False "False" if not
        */
        bool matchKeys(hash h1) {
            if (h.size() != h1.size())
                return False;

            foreach string k in (h.keyIterator()) {
                if (!h1.hasKey(k))
                    return False;
            }

            return True;
        }

        #! returns @ref Qore::True "True" if the container argument has the same keys (in any order), @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $c.matchKeys($c1);
            @endcode

            @param c the container to compare

            @return @ref Qore::True "True" if the container argument has the same keys (in any order), @ref Qore::False "False" if not
        */
        bool matchKeys(AbstractHashContainer c) {
            return matchKeys(c.h);
        }

        #! Returns @ref Qore::False "False" if the contained hash has no keys, @ref Qore::True "True" if it does
        /** @par Example:
            @code
my bool $b = $h.val();
            @endcode

            The opposite of empty()

            @return @ref Qore::False "False" if the contained hash has no keys, @ref Qore::True "True" if it does
        */
        bool val() {
            return h.val();
        }

        #! Returns a list of key names of the contained hash
        /** @par Example:
            @code
my list $l = $h.keys();
            @endcode

            @return a list of key names of the contained hash
        */
        list keys() {
            return h.keys();
        }

        #! Returns a list of values of the contained hash
        /** @par Example:
            @code
my list $l = $h.values();
            @endcode

            @return a list of values of the contained hash
        */
        list values() {
            return h.values();
        }

        #! Returns a @ref Qore::HashIterator "HashIterator" object for the contained hash
        /** @par Example:
            @code
map printf("+ %y\n", $1.value), $h.iterator();
            @endcode

            @return a @ref Qore::HashIterator "HashIterator" object for the contained hash
        */
        AbstractIterator iterator() {
            return h.iterator();
        }

        #! Returns a @ref Qore::HashKeyIterator "HashKeyIterator" object for the contained hash
        /** @par Example:
            @code
map printf("+ %s\n", $1), $h.keyIterator();
            @endcode

            @return a @ref Qore::HashKeyIterator "HashKeyIterator" object for the contained hash
        */
        AbstractIterator keyIterator() {
            return h.keyIterator();
        }

        #! Returns a @ref Qore::HashPairIterator "HashPairIterator" object for the contained hash
        /** @par Example:
            @code
map printf("+ %s: %y\n", $1.key, $1.value), $h.pairIterator();
            @endcode

            @return a @ref Qore::HashPairIterator "HashPairIterator" object for the contained hash
        */
        AbstractIterator pairIterator() {
            return h.pairIterator();
        }

        #! returns @ref Qore::True "True" if the container is empty, @ref Qore::False "False" if not
        bool empty() {
            return h.empty();
        }

        #! Returns the number of keys in the contained hash
        /** @par Example:
            @code
my int $num = $h.size();
            @endcode

            @return the number of keys in the contained hash
        */
        int size() {
            return h.size();
        }

        #! Returns @ref Qore::True "True" if the key exists in the contained hash (may or may not be assigned a value), @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $h.hasKey($key);
            @endcode

            @param k the key name to check

            @return @ref Qore::True "True" if the key exists in the contained hash (may or may not be assigned a value), @ref Qore::False "False" if not
        */
        bool hasKey(string k) {
            return h.hasKey(k);
        }

        #! Returns @ref Qore::True "True" if the key exists in the contained hash and is assigned a value, @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $h.hasKeyValue($key);
            @endcode

            @param k the key name to check

            @return @ref Qore::True "True" if the key exists in the contained hash and is assigned a value, @ref Qore::False "False" if not
        */
        bool hasKeyValue(string k) {
            return h.hasKeyValue(k);
        }

        #! Returns the first key name in the contained hash or @ref nothing if the contained hash has no keys
        /** @par Example:
            @code
my *string $n = $h.firstKey();
            @endcode

            @return the first key name in the contained hash or @ref nothing if the contained hash has no keys

            @see lastKey()
        */
        *string firstKey() {
            return h.firstKey();
        }

        #! Returns the last key name in the contained hash or @ref nothing if the contained hash has no keys
        /** @par Example:
            @code
my *string $n = $h.lastKey();
            @endcode

            @return the last key name in the contained hash or @ref nothing if the contained hash has no keys

            @see firstKey()
        */
        *string lastKey() {
            return h.lastKey();
        }

        #! must return the name of the contained element
        abstract string getElementName();
    }

    #! abstract container class that throws an exception if an unknown key is accessed
    public class AbstractListContainer {
        public {}

        private {
            softlist l;
        }

        #! creates the object with the list argument passed
        constructor(softlist nl) {
            l = nl;
        }

        #! returns the value of the given element in the contained list if it exists, otherwise throws an \c ELEMENT-ERROR exception
        /** @par Example:
            @code
my any $v = $c.get(2);
            @endcode

            @param i the index of the element to access

            @return the value of the given index in the contained list if it exists

            @throw ELEMENT-ERROR the given element does not exist in the contained list
        */
        abstract any get(softint i);

        #! adds the given value to the list
        add(any val) {            
            l += val;
        }

        #! removes the given element from the contained list and returns the value
        any take(int i) {
            checkIndex(i);
            return extract l, i, 1;
        }

        #! returns the list contained by this object
        list getList() {
            return l;
        }

        #! Returns @ref Qore::False "False" if the contained list is empty, @ref Qore::True "True" if not
        /** @par Example:
            @code
my bool $b = $l.val();
            @endcode

            The opposite of empty()

            @return @ref Qore::False "False" if the contained list is empty, @ref Qore::True "True" if not
        */
        bool val() {
            return l.val();
        }

        #! Returns a @ref Qore::ListIterator "ListIterator" object for the contained list
        /** @par Example:
            @code
map printf("+ %s: %y\n", $1), $h.iterator();
            @endcode

            @return a @ref Qore::HashIterator "HashIterator" object for the contained hash
        */
        ListIterator iterator() {
            return l.iterator();
        }

        #! returns @ref Qore::True "True" if the container is empty, @ref Qore::False "False" if not
        bool empty() {
            return l.empty();
        }

        #! Returns the number of elements in the contained list
        /** @par Example:
            @code
my int $num = $l.size();
            @endcode

            @return the number of elements in the contained list
        */
        int size() {
            return l.size();
        }

        #! must return the name of the contained element
        abstract string getElementName();

        private checkIndex(int i) {
            if (i < 0 || i >= l.size())
                throw "ELEMENT-ERROR", sprintf("cannot access %s element %d; total elements: %d", getElementName(), i, l.size());
        }
    }

    #! column container class that throws an exception if an unknown column is accessed
    public class Columns inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! returns the AbstractColumn object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code
my AbstractColumn $c = $cols.id;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        AbstractColumn memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        #! returns a subset of the current columns according to the list argument
        Columns subset(list l) {
            return new Columns(h{l});
        }

        #! returns \c "column" since this object stores column objects
        string getElementName() {
            return "column";
        }

        #! returns @ref Qore::True "True" if the argument has the same columns in the same order as the current object, @ref Qore::False "False" if not
        bool equal(Columns cols) {
            AbstractIterator i = cols.iterator();
            foreach AbstractColumn c in (iterator()) {
                if (!i.next())
                    return False;
                if (!c.equal(i.getValue()))
                    return False;
            }
            return True;
        }
    }

    #! the base class for column information
    public class AbstractColumn {
        public {
            #! the name of the column
            string name;

            #! the native type name of the column
            string native_type;

            #! the equivalent qore type name of the column if known
            *string qore_type;

            #! the size of the column
            int size;

            #! Qore::True "True" if the column can hold a NULL value, @ref Qore::False "False" if not
            bool nullable; 

            #! default value for column
            *string def_val;

            #! comment on the column
            *string comment;
        }

        constructor(string n, string nt, *string qt, int sz, bool nul, *string dv, *string c) {
            name = n;
            native_type = nt;
            qore_type = qt;
            size = sz;
            nullable = nul;
            def_val = dv;
            comment = c;
        }

        #! returns the string describing the native type that can be used in SQL (for example to add the colunn to a table or when creating the table)
        string getNativeTypeString() {
            string sql = native_type;
            if (size)
                sql += sprintf("(%d)", size);
            return sql;
        }

        #! returns an sql string that can be used to add the column to a table
        string getCreateSql() {
            string sql = sprintf("%s %s", name, getNativeTypeString());
            if (exists def_val)
                sql += " default " + def_val + "";
            if (!nullable)
                sql += " not null";
            return sql;
        }

        #! returns a list of sql strings that can be used to add the column to an existing table
        /** @par Example:
            @code
my list $l = $col.getCreateSql($t);
            @endcode

            @param t the AbstractTable object to modify

            @return a list of sql strings that can be used to add the column to an existing table
         */
        abstract list getCreateSql(AbstractTable t);

        #! returns a string that can be used to drop the column from the table
        string getDropSql(string table_name) {
            return sprintf("alter table %s drop column %s", table_name, name);
        }

        #! returns a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $col.getModifySql($t, $newcol);
            @endcode

            The column names are assumed to be equal.

            @param t the AbstractTable object to modify
            @param c the new column definition

            @return a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
         */
        abstract list getModifySql(AbstractTable t, AbstractColumn c);

        #! returns a string that can be used to rename the column
        /** @par Example:
            @code
my string $str = $col.getRenameSql($t, "new_name");
            @endcode

            @param t the AbstractTable object to modify
            @param new_name the new name for the column

            @return a string that can be used to rename the column
        */
        abstract string getRenameSql(AbstractTable t, string new_name);

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equal(AbstractColumn c) {
            if (self.className() != c.className() || name != c.name || native_type != c.native_type || size != c.size || nullable != c.nullable || def_val != c.def_val || comment != c.comment)
                return False;

            return equalImpl(c);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        abstract bool equalImpl(AbstractColumn c);
    }

    #! the base class to use to extend AbstractColumn to implement numeric columns
    public class NumericColumnInfo {
        public {
            #! the scale for numeric columns
            int scale;
        }

        constructor(softint n_scale = 0) {
            scale = n_scale;
        }
 
        #! returns the string describing the native type that can be used in SQL (for example to add the column to a table or when creating the table)
        string getNativeTypeString(string native_type, int precision) {
            string sql = native_type;
            if (precision) {
                sql += sprintf("(%d", precision);
                if (scale)
                    sql += sprintf(",%d", scale);
                sql += ")";
            }
            return sql;
        }
   }
    
    #! index container class that throws an exception if an unknown index is accessed
    public class Indexes inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! returns the AbstractIndex object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code
my AbstractIndex $ix = $indexes.pk_jobs;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        AbstractIndex memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "index";
        }
    }

    #! the abstract base class for index information
    public class AbstractIndex {
        public {
            #! the name of the index
            string name;
            
            #! @ref Qore::True "True" if the index is a unique index, @ref Qore::False "False" if not
            bool unique;

            #! an object of class Columns representing the columns in the index
            Columns columns;
        }

        private {
            #! the AbstractUniqueConstraint that this index supports, if any
            *AbstractUniqueConstraint constraint;
        }

        #! creates the object from the name, a unique flag, and a hash of column information
        constructor(string n, bool u, hash c) {
            name = n;
            unique = u;
            columns = new Columns(c);
        }

        #! returns a string that can be used to create the index in the database
        abstract string getCreateSql(string table_name, *hash opt);

        #! returns a string that can be used to drop the index from the database
        string getDropSql(string table_name) {
            return sprintf("drop index %s", name);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current index, @ref Qore::False "False" if not
        bool equal(AbstractIndex ix) {
            if (ix.className() != self.className())
                return False;

            if (name != ix.name || unique != ix.unique || (columns.keys() != ix.columns.keys()))
                return False;
            
            return equalImpl(ix);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current index, @ref Qore::False "False" if not
        abstract bool equalImpl(AbstractIndex ix);

        #! returns a string that can be used to rename the index in the database
        abstract string getRenameSql(string table_name, string new_name);

        #! tags the index with a unique constraint that the index supports
        setSupportingConstraint(AbstractUniqueConstraint c) {
            constraint = c;
        }

        #! returns a list of strings to drop and recreate the current index; if there are dependent constraints, the list contains commands to disable the constraints before dropping the index and also contains commands to re-enable the contraints after re-creating the index
        list getRecreateSql(string table_name, *hash opt) {
            list l = ();
            list enl;
            # get drop SQL and disable any dependent constraints plus a list of strings to re-enable the constraints
            if (constraint) {
                hash drh = constraint.getDisableReenableSql(table_name, opt);
                l += drh.disable;
                enl = drh.enable;
            }

            ## drop current index
            l += getDropSql(table_name);

            # add new index to table
            l += getCreateSql(table_name, opt);

            # re-enable any constraints disabled when dropping the index
            if (enl)
                l += enl;

            return l;
        }
    }

    #! constraint container class that throws an exception if an unknown constraint is accessed
    public class Constraints inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! returns the AbstractConstraint object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code
my AbstractConstraint $ix = $constraints.uk_jobs;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        AbstractConstraint memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "constraint";
        }
    }

    #! abstract base class for constraints
    public class AbstractConstraint {
        public {}

        private {
            #! the name of the constraint
            string name;
        }
        
        #! creates the object and sets its name
        constructor(string n) {
            name = n;
        }

        #! returns the constraint name
        string getName() {
            return name;
        }

        #! renames the constraint
        rename(string n) {
            name = n;
        }

        #! returns a string that can be used to create the constraint in the database
        abstract string getCreateSql(string table_name, *hash opt);        

        #! returns a string that can be used to drop the constraint from the database
        string getDropSql(string table_name) {
            return sprintf("alter table %s drop constraint %s", table_name, name);
        }

        #! returns a string that can be used to rename the constraint in the database
        abstract string getRenameSql(string table_name, string new_name);

        #! returns a string that can be used to temporarily disable the constraint from the database; if disabling constraints is not supported, then the constraint will be dropped
        string getDisableSql(string table_name) {
            return getDropSql(table_name);
        }

        #! returns a string that can be used to enable the constraint in the database; if disabling constraints is not supported, then the constraint will be dropped
        string getEnableSql(string table_name, *hash opt) {
            return getCreateSql(table_name, opt);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equal(AbstractConstraint c) {
            if (c.className() != self.className() || name != c.name)
                return False;

            return equalImpl(c);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        abstract bool equalImpl(AbstractConstraint c);

        #! returns @ref Qore::True "True" if the object supports an index property and is set, @ref Qore::False "False" if not
        bool setIndexBase(string ix) {
            return False;
        }
    }

    #! abstract class for check constraints
    public class AbstractCheckConstraint inherits AbstractConstraint {
        public {
            #! the source of the check clause
            string src;
        }

        #! creates the object and sets its name and the check clause source
        constructor(string n, string n_src) : AbstractConstraint(n) {
            name = n;
            src = n_src;
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equalImpl(AbstractConstraint c) {
            return src != cast<AbstractCheckConstraint>(c).src ? False : True;
        }
    }

    #! represents a unique column constraint
    public class AbstractUniqueConstraint inherits AbstractConstraint, Columns {
        private {
            # a hash of ForeignConstraintSources, keyed by table name, the value is a hash of foreign constraints keyed by constraint name
            hash sourceConstraints;
        }

        #! creates the object from the name an a hash of column information
        constructor(string n, *hash c) : AbstractConstraint(n), Columns(c) {
        }

        #! returns a string that can be used to create the constraint in the database
        abstract string getCreateSql(string table_name, *hash opts);

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equalImpl(AbstractConstraint c) {
            return (self.keys() != cast<AbstractUniqueConstraint>(c).keys()) ? False : True;
        }

        #! returns lists of SQL strings to disable this constraint plus any dependent constraints and another list of SQL strings to reenable the same constraints; used when updating indexes that depend on constraints
        hash getDisableReenableSql(string table_name, *hash opts) {
            hash ch = (
                "disable": (),
                "enable": (),
                );

            foreach hash sch in (sourceConstraints.pairIterator()) {
                foreach AbstractForeignConstraint fk in (sch.value.iterator()) {
                    ch.disable += fk.getDisableSql(sch.key);
                    unshift ch.enable, fk.getEnableSql(sch.key, opts);
                }
            }
            
            ch.disable += getDisableSql(table_name);
            unshift ch.enable, getEnableSql(table_name, opts);

            return ch;
        }

        #! find an index that matches the constraint and marks both objects as related
        findMatchingIndex(*Indexes indexes) {
            # see if the primary key corresponds to a unique index with the same name & columns
            if (indexes.hasKey(name)) {
                AbstractIndex ix = indexes{name};
                if (ix.columns.matchKeys(h) && setIndexBase(ix.name))
                    ix.setSupportingConstraint(self);
            }
            else {
                # search for an index with matching columns
                # FIXME: should look for best match (however having duplicate indexes on the same columns, one unique, one not unique, would be a pretty bad DB design)
                foreach AbstractIndex ix in (indexes.iterator()) {
                    if (ix.columns.matchKeys(h)) {
                        if (setIndexBase(ix.name))
                            ix.setSupportingConstraint(self);
                        break;
                    }
                }
            }
        }

        #! adds a foreign constraint source to the unique constraint
        /** @par Example:
            @code
$uk.addSourceConstraint($table_name, constraint_name);
            @endcode

            @param tname the name of the source table
            @param fk the source constraint

            @throw SOURCE-CONSTRAINT-ERROR a different source constraint with the given name already exists
        */
        addSourceConstraint(string tname, AbstractForeignConstraint fk) {
            if (sourceConstraints{tname}{fk.getName()})
                throw "SOURCE-CONSTRAINT-ERROR", sprintf("unique constraint %y: already has a source constraint from table %y from foreign constraint %y", name, tname, fk.getName());
            sourceConstraints{tname}{fk.getName()} = fk;
            #printf("added source constraint to %y: %s.%s\n", name, tname, fk.getName());
        }
    }

    #! represents a primary key
    public class AbstractPrimaryKey inherits AbstractUniqueConstraint {
        constructor(string n, *hash c) : AbstractUniqueConstraint(n, c) {
        }
    }

    #! foreign constraint container class that throws an exception if an unknown constraint is accessed
    public class ForeignConstraints inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! returns the AbstractForeignConstraint object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code
my AbstractForeignConstraint $ix = $fcs.fk_jobs_job_defs;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        AbstractForeignConstraint memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "foreign constraint";
        }
    }

    #! a class describing a foreign constraint target
    public class ForeignConstraintTarget {
        public {
            #! the name of the target table
            string table;

            #! columns in the target table
            Columns columns;
        }

        #! creates the object and sets the target table name and the target columns
        constructor(string t, Columns c) {
            table = t;
            columns = c;
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equal(ForeignConstraintTarget targ) {
            return table != targ.table || (columns.keys() != targ.columns.keys()) ? False : True;
        }
    }

    #! the base class for foreign key constraint information
    public class AbstractForeignConstraint inherits AbstractConstraint {
        public {
            #! an object of class Columns giving the source table that make up the constraint
            Columns columns;

            #! a ForeignConstraintTarget object to describe the target table and columns
            ForeignConstraintTarget target;
        }

        constructor(string n, Columns c, ForeignConstraintTarget t) : AbstractConstraint(n) {
            columns = c;
            target = t;
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equalImpl(AbstractConstraint con) {
            AbstractForeignConstraint c = cast<AbstractForeignConstraint>(con);
            return (columns.keys() != c.columns.keys())
                || !target.equal(c.target)
                ? False : True;
        }
    }

    #! base class for sequences
    public class AbstractSequence {
        public {
            #! the name of the sequence
            string name;

            #! the starting number
            number start;

            #! the increment
            number increment;
            
            #! the ending number
            *number max;
        }

        #! creates the object from the arguments
        constructor(string n_name, number n_start = 1, number n_increment = 1, *softnumber n_max) {
            name = n_name;
            start = n_start;
            increment = n_increment;
            max = n_max;
            if (!increment)
                throw "SEQUENCE-ERROR", sprintf("sequence %y: increment cannot be zero", name);
            if (max) {
                if (increment > 0 && max < start)
                    throw "SEQUENCE-ERROR", sprintf("ascending sequence %y increment %d: max value %d is less than the starting value: %d", name, increment, max, start);
                if (increment < 0 && max > start)
                    throw "SEQUENCE-ERROR", sprintf("descending sequence %y increment %d: max value %d is less than the starting value: %d", name, increment, max, start);
            }
        }

        #! returns a string that can be used to create the sequence in the database
        abstract string getCreateSql(*hash opt);        

        #! returns a string that can be used to drop the sequence from the database
        string getDropSql() {
            return sprintf("drop sequence %s", name);
        }

        #! returns a string that can be used to rename the sequence in the database
        abstract string getRenameSql(string new_name);
    }

    #! base class for function or objects with code
    public class AbstractFunctionBase {
        public {
            #! the name of the object
            string name;

            #! the type of object
            string type;
            
            #! the source of the object
            string src;
        }

        #! creates the object from the arguments passed
        /** @param n the name of the object
            @param n_type the type of object
            @param n_src the source of the object
         */
        constructor(string n, string n_type, string n_src) {
            name = n;
            type = n_type;
            src = n_src;
        }
        
        #! returns the type of object
        string getType() {
            return type;
        }
        
        #! returns a string that can be used to drop the function from the database
        string getDropSql() {
            return sprintf("drop %s %s", type, name);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equal(AbstractFunctionBase t) {
            if (self.className() != t.className() || name != t.name || type != t.type) {
                return False;
            }

            string src1 = src;
            src1 =~ s/\n/ /g;
            string src2 = t.src;
            src2 =~ s/\n/ /g;

            if (src1 != src2) {
                #printf("%s\nXXXXXXXXXXXXXXX\n%s\n", src1, src2);
                return False;
            }
            #printf("%s\nXXXXXX EQUAL XXXXXXXXX\n%s\n", src1, src2);
            
            return equalImpl(t);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        abstract bool equalImpl(AbstractFunctionBase t);
    }

    #! base class for functions
    public class AbstractFunction inherits AbstractFunctionBase {
        #! creates the object from the arguments passed
        /** @param n the name of the object
            @param n_type the type of object
            @param n_src the source of the object
         */
        constructor(string n, string n_type, string n_src) : AbstractFunctionBase(n, n_type, n_src) {
        }

        #! returns a list of SQL strings that can be used to create the function in the database
        abstract list getCreateSql(*hash opt);

        #! returns a string that can be used to rename the function in the database
	abstract list getRenameSql(string new_name);

        #! sets the new name of the object
        setName(string new_name) {
            name = new_name;
        }
    }

    #! function container class that throws an exception if an unknown function is accessed
    public class Functions inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! returns the AbstractFunction object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code
my AbstractFunction $f = $funcs.func1;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        AbstractFunction memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "function";
        }
    }

    #! the base class for triggers
    public class AbstractTrigger inherits AbstractFunctionBase {
        #! creates the object and sets its name and the trigger source
        constructor(string n, string n_src) : AbstractFunctionBase(n, "trigger", n_src) {
        }

        #! returns a string that can be used to create the trigger in the database
        abstract list getCreateSql(string table_name, *hash opt);        

        #! returns a string that can be used to rename the trigger in the database
	abstract list getRenameSql(string table_name, string new_name);
    }

    #! trigger container class that throws an exception if an unknown trigger is accessed
    public class Triggers inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! returns the AbstractTrigger object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code
my AbstractTrigger $trig = $trigs.job_trig;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        AbstractTrigger memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "trigger";
        }
    }

    #! represents a database; this class embeds an AbstractDatabase object that is created automatically in the constructor based on the database driver for the AbstractDatasource object providing the database connection
    /** Driver-specific modules that provide the AbstractDatabase implementation embedded in this class are loaded on demand based on the driver's name.
        The driver-specific module's name is generated based on the db-driver's name with the first letter capitalized then with \c "SqlUtil" appended.

        For example:
        - \c "oracle": \c "OracleSqlUtil"
        - \c "pgsql": \c "PgsqlSqlUtil"

        etc.
    */
    public class Database {
        private {
            #! the embedded AbstractDatabase object that actually provides the functionality for this class
            AbstractDatabase db;
        }

        #! creates the Database object
        /** @par Example:
            @code
my Database $db($ds);
            @endcode

            @param ds the AbstractDatasource object used to provide the DB connection
            @param opts a hash of options for the function creation string; see @ref AbstractDatabase::DatabaseOptions for common options; each driver can support additional driver-specific options

            @throw DATABASE-DRIVER-ERROR no database-specific module can be loaded 
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        constructor(AbstractDatasource ds, *hash opts) {
            db = AbstractDatabase::getDatabase(ds, opts);
        }

        #! creates the AbstractDatabase object
        /** @par Example:
            @code
my AbstractDatabase $db("pgsql:user/pass@db%host");
            @endcode

            @param ds a datasource description string in the format that can be parsed by parse_datasource()
            @param opts a hash of options for the function creation string; see @ref AbstractDatabase::DatabaseOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        constructor(string ds, *hash opts) {
            db = AbstractDatabase::getDatabase(ds, opts);
        }
        
        #! creates the AbstractDatabase object
        /** @par Example:
            @code
my AbstractDatabase $db("pgsql:user/pass@db%host");
            @endcode

            @param ds a hash giving parameters for the new datasource with the following possible keys (the \c "type" key is mandatory, also usable with the output of the parse_datasource() function):
            - \c type: (@ref string_or_nothing_type "*string") The name of the database driver to use; this key is mandatory; if not present, an exception will be raised. See @ref sql_constants for builtin constants for DBI drivers shipped with Qore, or see the DBI driver documentation to use an add-on driver (this string should be the name of the driver to be loaded)
            - \c user: (@ref string_or_nothing_type "*string") The user name for the new connection
            - \c pass: (@ref string_or_nothing_type "*string") The password for the new connection
            - \c db: (@ref string_or_nothing_type "*string") The database name for the new connection
            - \c charset: (@ref string_or_nothing_type "*string") The database-specific name of the character encoding to use for the new connection. Also see Qore::SQL::Datasource::setDBCharset() for a method that allows this parameter to be set after the constructor. If no value is passed for this parameter, then the database character encoding corresponding to the default character encoding for the %Qore process will be used instead.
            - \c host: (@ref string_or_nothing_type "*string") The host name for the new connection
            - \c port: (@ref softint_type "softint") The port number for the new connection
            - \c options: (@ref hash_or_nothing_type "*hash") Any options for the new connection
            @param opts a hash of options for the table creation string; see @ref AbstractDatabase::DatabaseOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        constructor(hash ds, *hash opts) {
            db = AbstractDatabase::getDatabase(ds, opts);
        }

        #! accepts a hash argument describing a database schema and returns a list of SQL strings that can be used to align the structure and configuration of the current schema with that of the argument; if the objects described are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $db.getAlignSql($schema_hash);
            @endcode

            @param schema_hash the schema template hash that decribes the target state of the schema
            @param opt a hash of options for the SQL creation strings; see @ref AbstractDatabase::AlignSchemaOptions for common options; each driver can support additional driver-specific options
            @param table_cache an optional reference to a hash to return the cache of AbstractTable objects keyed by table name for the schema template (ie target table definitions)

            @return a list of SQL strings that can be used to align the structure and configuration of the current schema with that of the argument; if the objects described are identical then an empty list is returned

            @throw SCHEMA-DESCRIPTION-ERROR the schema description hash has an error or a required object does not exist
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        list getAlignSql(hash schema_hash, *hash opt, *reference table_cache) {
            return db.getAlignSql(schema_hash, opt, \table_cache);
        }

        #! gets the underlying AbstractDatasource
        AbstractDatasource getDatasource() {
            return db.getDatasource();
        }

        #! executes a method on the contained AbstractDatabase object
        any methodGate(string meth) {
            return callObjectMethodArgs(db, meth, argv);
        }

        #! creates a database-specific AbstractSequence object corresponding to the arguments
        /** @par Example:
            @code
my AbstractSequence $seq = $db.makeSequence("seq_queues");
            @endcode

            @param name the name of the sequence
            @param start the starting value of the sequence
            @param increment the increment value of the sequence
            @param end the endinf value of the sequence, omit for no ending value
            @param opts an optional hash of options for the creation of the sequence; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw SEQUENCE-ERROR end not compatible with start and increment, increment is zero
        */
        AbstractSequence makeSequence(string name, number start = 1, number increment = 1, *softnumber end, *hash opts) {
            return db.makeSequence(name, start, increment, end, opts);
        }

        #! creates a database-specific AbstractFunction object corresponding to the arguments
        /** @par Example:
            @code
my AbstractFunction $f = $db.makeFunction("update_queue", $src);
            @endcode

            @param name the name of the function
            @param src the database-specific source code of the function (see the database-specific documentation for information about the format of this parameter; generally it's simply the normal source code for the function required by the database)
            @param opt an optional hash of options for the creation of the function; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        AbstractFunction makeFunction(string name, string src, *hash opt) {
            return db.makeFunction(name, src, opt);
        }

        #! creates a database-specific AbstractFunction object for a stored procedure corresponding to the arguments
        /** @par Example:
            @code
my AbstractFunction $f = $db.makeProcedure("get_queue_info", $src);
            @endcode

            @param name the name of the stored procedure
            @param src the database-specific source code of the stored procedure (see the database-specific documentation for information about the format of this parameter; generally it's simply the normal source code for the stored procedure required by the database)
            @param opt an optional hash of options for the creation of the stored procedure; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        AbstractFunction makeProcedure(string name, string src, *hash opt) {
            return db.makeProcedure(name, src, opt);
        }

        #! drops the given function if it exists; returns @ref Qore::True "True" if the function was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropFunctionIfExists($name);
            @endcode

            @param name the name of the function
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info
            
            @return @ref Qore::True "True" if the function was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropFunctionIfExists(string name, *hash opt) {
            return db.dropFunctionIfExists(name, opt);
        }

        #! drops the given procedure if it exists; returns @ref Qore::True "True" if the procedure was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropProcedureIfExists($name);
            @endcode

            @param name the name of the procedure
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return @ref Qore::True "True" if the procedure was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropProcedureIfExists(string name, *hash opt) {
            return db.dropProcedureIfExists(name, opt);
        }

        #! drops the given sequence if it exists; returns @ref Qore::True "True" if the sequence was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropSequenceIfExists($name);
            @endcode

            @param name the name of the sequence
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return @ref Qore::True "True" if the sequence was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropSequenceIfExists(string name, *hash opt) {
            return db.dropSequenceIfExists(name, opt);
        }

        #! drops the given table if it exists; returns @ref Qore::True "True" if the table was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropTableIfExists($name);
            @endcode

            @param name the name of the table
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return @ref Qore::True "True" if the table was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropTableIfExists(string name, *hash opt) {            
            return db.dropTableIfExists(name, opt);
        }

        #! returns a list of SQL strings that can be used to update a function in the database to the function definition passed as an argument
        /** @par Example:
            @code
my list $l = $db.getAlignFunctionSql(f);
            @endcode

            @param f the template or target version of the function to compare to the database version
            @param opt an optional hash of options for the generation of the SQL strings; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to update a function in the database to the function definition passed as an argument

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        list getAlignFunctionSql(AbstractFunction f, *hash opt) {
            return db.getAlignFunctionSql(f, opt);
        }

        #! returns a list of SQL strings that can be used to update a stored procedure in the database to the stored procedure definition passed as an argument
        /** @par Example:
            @code
my list $l = $db.getAlignProcedureSql(f);
            @endcode

            @param f the template or target version of the stored procedure to compare to the database version
            @param opt an optional hash of options for the generation of the SQL strings; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to update a stored procedure in the database to the stored procedure definition passed as an argument

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        list getAlignProcedureSql(AbstractFunction f, *hash opt) {
            return db.getAlignProcedureSql(f, opt);
        }

        #! returns an AbstractTable argument for the given table name or @ref nothing if the table cannot be found
        /** @par Example:
            @code
my *AbstractTable $table = $db.getTable("queues");
            @endcode

            @param name the uniquely-identifying name of the table to retrieve

            @return an AbstractTable argument for the given table name or @ref nothing if the table cannot be found
         */
        *AbstractTable getTable(string name) {
            return db.getTable(name);
        }

        #! returns an AbstractSequence argument for the given sequence name or @ref nothing if the sequence cannot be found
        /** @par Example:
            @code
my *AbstractSequence $seq = $db.getSequence("seq_queues");
            @endcode

            @param name the uniquely-identifying name of the sequence to retrieve

            @return an AbstractSequence argument for the given sequence name or @ref nothing if the sequence cannot be found
         */
        *AbstractSequence getSequence(string name) {
            return db.getSequence(name);
        }

        #! returns an AbstractFunction argument for the given function name or @ref nothing if the function cannot be found
        /** @par Example:
            @code
my *AbstractFunction $f = $db.getFunction("update_queue");
            @endcode

            @param name the uniquely-identifying name of the function to retrieve

            @return an AbstractFunction argument for the given function name or @ref nothing if the function cannot be found

            @note for databases that support overloaded functions, the arguments must be passed in parentheses after the name to match overloaded functions properly
         */
        *AbstractFunction getFunction(string name) {
            return db.getFunction(name);
        }

        #! returns an AbstractFunction argument for the given stored procedure name or @ref nothing if the stored procedur  cannot be found
        /** @par Example:
            @code
my *AbstractFunction $f = $db.getProcedure("update_queue");
            @endcode

            @param name the uniquely-identifying name of the stored procedure to retrieve

            @return an AbstractFunction argument for the given stored procedure name or @ref nothing if the stored procedure cannot be found

            @note for databases that support overloaded stored procedures, the arguments must be passed in parentheses after the name to match overloaded stored procedures properly
         */
        *AbstractFunction getProcedure(string name) {
            return db.getProcedure(name);
        }

        #! returns a list of string table names in the database
        list listTables() {
            return db.listTables();
        }
        
        #! returns an iterator listing the string table names in the database
        ListIterator tableIterator() {
            return db.tableIterator();            
        }
 
        #! returns a list of string function names in the database
        list listFunctions() {
            return db.listFunctions();
        }
        
        #! returns an iterator listing the string function names in the database
        ListIterator functionIterator() {
            return db.functionIterator();            
        }

        #! returns a list of string procedure names in the database
        list listProcedures() {
            return db.listProcedures();
        }
        
        #! returns an iterator listing the string procedure names in the database
        ListIterator procedureIterator() {
            return db.procedureIterator();            
        }

        #! returns a list of string sequence names in the database
        list listSequences() {
            return db.listSequences();
        }
        
        #! returns an iterator listing the string sequence names in the database
        ListIterator sequenceIterator() {
            return db.sequenceIterator();            
        }

        #! returns a list of string view names in the database
        list listViews() {
            return db.listViews();
        }
        
        #! returns an iterator listing the string view names in the database
        ListIterator viewIterator() {
            return db.viewIterator();
        }
    }

    #! base class for abstract SqlUtil classes
    public class AbstractSqlUtilBase {
        private {
            #! the connection to the database server
            AbstractDatasource ds;
            #! datasource description
            string dsdesc;
            #! mutex for atomic actions
            Mutex l();
            #! option hash
            *hash opts;
        }

        #! creates the object; private constructor
        /** @param nds the AbstractDatasource for the connection to the database
            @param nopts a hash of options for the table creation string; see @ref TableOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        private constructor(AbstractDatasource nds, *hash nopts) {
            opts = nopts;
            ds = nds;

            # ensure datasource is open
            ds.getServerVersion();
            dsdesc = sprintf("%s:%s@%s", ds.getDriverName(), ds.getUserName(), ds.getDBName());
            if (ds.getHostName())
                dsdesc += "%" + ds.getHostName();
            if (ds.getPort())
                dsdesc += sprintf(":%d", ds.getPort());
        }

        private validateOptionsIntern(string err, hash ropt, reference opt, string tag) {
            # make sure driver-specific options take precedence over generic options            
            string dn = getDriverName();
            if (opt.driver{dn})
                opt += remove opt.driver{dn};
            delete opt.driver;

            # check valid options and option value types
            foreach string k in (opt.keyIterator()) {
                if (!ropt.hasKey(k))
                    throw err, sprintf("%s: unknown key %y; valid keys for %y: %y", tag, k, self.className(), ropt.keys());
                
                if (!exists opt{k}) {
                    delete opt{k};
                    continue;
                }

                validateOptionIntern(err, ropt{k}, \opt{k}, k, tag);
            }
        }

        private validateOptionIntern(string err, string type, reference opt, string k, string tag) {
            switch (type) {
                case Type::Int: {
                    if (opt.type() != type) {
                        if (!opt.intp())
                            throw err, sprintf("%s: key %y has type %y, expecting \"int\" (value: %y)", tag, k, opt.type(), opt);
                        opt = opt.toInt();
                    }
                    break;
                }
                case Type::Number: {
                    if (opt.type() != type) {
                        if (!opt.intp())
                            throw err, sprintf("%s: key %y has type %y, expecting \"number\" (value: %y)", tag, k, opt.type(), opt);
                        opt = number(opt);
                    }
                    break;
                }
                case Type::Boolean: {
                    if (opt.type() != type) {
                        if (!opt.intp())
                            throw err, sprintf("%s: key %y has type %y, expecting \"boolean\" (value: %y)", tag, k, opt.type(), opt);
                        opt = opt.toBool();
                    }
                    break;
                }
                case Type::String: {
                    if (opt.type() != type) {
                        if (!opt.strp())
                            throw err, sprintf("%s: key %y has type %y, expecting \"string\" (value: %y)", tag, k, opt.type(), opt);
                        opt = opt.toString();
                    }
                    break;
                }
                # no validation for NOTHING
                case NOTHING: break;
                
                case "code": if (opt.typeCode() == NT_CLOSURE || opt.typeCode() == NT_CALLREF)
                    break;
                
                # throw an exception if the type is not supported
              default: 
                if (opt.type() != type)
                    throw err, sprintf("key %y requires type %y but type %y was passed (%y)", k, type, opt.type(), opt);
            }
        }

        #! gets the underlying AbstractDatasource
        AbstractDatasource getDatasource() {
            return ds;
        }

        #! returns the database driver name 
        string getDriverName() {
            return ds.getDriverName();
        }

        #! returns a descriptive string for the datasource
        string getDatasourceDesc() {
            return dsdesc;
        }
    }

    #! the base abstract class for the database implementation
    public class AbstractDatabase inherits AbstractSqlUtilBase {
        public {
            #! database options
            const DatabaseOptions = (
                "native_case": Type::Boolean,
                );

            #! generic cache options
            const CacheOptions = (
                "table_cache": Type::Hash,
                );

            #! generic callback options
            const CallbackOptions = (
                "info_callback": "code",
                "sql_callback": "code",
                );

            #! default generic creation options
            const CreationOptions = CallbackOptions + (
                "replace": Type::Boolean,
                "table_cache": Type::Hash,
                "data_tablespace": Type::String,
                "index_tablespace": Type::String,
                );

            #! default generic schema description / alignment options
            const AlignSchemaOptions = CreationOptions;

            #! default generic schema description keys
            const SchemaDescriptionOptions = (
                "tables": Type::Hash,
                "table_map": Type::Hash,

                "sequences": Type::Hash,
                "sequence_map": Type::Hash,

                "functions": Type::Hash,
                "function_map": Type::Hash,

                "procedures": Type::Hash,
                "procedure_map": Type::Hash,

                #"views": Type::Hash,
                #"view_map": Type::Hash,
                );

            #! default generic sequence description keys
            const SequenceDescriptionOptions = (
                "start": Type::Int,
                "increment": Type::Int,
                "end": Type::Int,
                );
        }

        private {
            #! native case option
            bool native_case = False;
        }

        #! creates the object; private constructor
        /** @param nds the AbstractDatasource for the connection to the database
            @param nopts a hash of options for the function creation string; see @ref AbstractDatabase::DatabaseOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        private constructor(AbstractDatasource nds, *hash nopts) : AbstractSqlUtilBase(nds, nopts) {
            validateOptionsIntern("OPTION-ERROR", getDatabaseOptions(), \nopts);
            if (nopts.native_case)
                native_case = True;
        }

        static doTandemCallback(*hash opt, string sql, string fmt) {
            if (opt.info_callback)
                opt.info_callback(vsprintf(fmt, argv));
            if (opt.sql_callback)
                opt.sql_callback(sql);
        }

        static doInfoCallback(*hash opt, string fmt) {
            if (opt.info_callback)
                opt.info_callback(vsprintf(fmt, argv));
        }

        static *string doSqlCallback(*hash opt, *string sql) {
            if (opt.sql_callback)
                opt.sql_callback(sql);
            return sql;
        }

        static list doSqlCallback(*hash opt, list sql) {
            if (opt.sql_callback)
                map opt.sql_callback($1), sql;
            return sql;
        }

        static *string doCallback(*hash opt, *string sql, string fmt) {
            if (!sql)
                return;
            if (opt.info_callback)
                opt.info_callback(vsprintf(fmt, argv));
            if (opt.sql_callback)
                opt.sql_callback(sql);
            return sql;
        }

        static list doCallback(*hash opt, list sql, string fmt) {
            if (sql) {
                if (opt.info_callback)
                    opt.info_callback(vsprintf(fmt, argv));
                if (opt.sql_callback)
                    map opt.sql_callback($1), sql;
            }
            return sql;
        }

        #! accepts a hash argument describing a database schema and returns a list of SQL strings that can be used to align the structure and configuration of the current schema with that of the argument; if the objects described are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $db.getAlignSql($schema_hash);
            @endcode

            @param schema_hash the schema template hash that decribes the target state of the schema
            @param opt a hash of options for the SQL creation strings; see @ref AbstractDatabase::AlignSchemaOptions for common options; each driver can support additional driver-specific options
            @param table_cache an optional reference to a hash to return the cache of AbstractTable objects keyed by table name for the schema template (ie target table definitions)

            @return a list of SQL strings that can be used to align the structure and configuration of the current schema with that of the argument; if the objects described are identical then an empty list is returned

            @throw SCHEMA-DESCRIPTION-ERROR the schema description hash has an error or a required object does not exist
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        list getAlignSql(hash schema_hash, *hash opt, *reference table_cache) {
            validateOptionsIntern("SCHEMA-DESCRIPTION-ERROR", getSchemaDescriptionOptions(), \schema_hash);
            validateOptionsIntern("OPTION-ERROR", getAlignSchemaOptions(), \opt);

            list l = ();

            string drv = getDriverName();
            AbstractDatabase::checkDriverOptions(\schema_hash, drv);

            # call driver-specifc align schema sql function
            list tl = getAlignSqlImpl(schema_hash, opt + ("start": True));
            if (tl) l += tl;

            # rename any sequences
            AbstractDatabase::checkDriverOptions(\schema_hash.sequence_map, drv);
            foreach hash sh in (schema_hash.sequence_map.pairIterator()) {
                if (sh.value.typeCode() != NT_STRING)
                    throw "SCHEMA-DESCRIPTION-ERROR", sprintf("sequence_map %y value is not a string in the schema description hash; got type %y instead (%y)", sh.key, sh.value.type(), sh.value);

                *AbstractSequence seq = getSequence(sh.key);
                if (seq) {
                    l += AbstractDatabase::doSqlCallback(opt, seq.getRenameSql(sh.value), "rename sequence %s to %s", sh.key, sh.value);
                    # remove sequence from list since we know it exists
                    remove schema_hash.sequences{sh.value};
                }
            }

            # create any missing sequences
            AbstractDatabase::checkDriverOptions(\schema_hash.sequences, drv);
            foreach string name in (schema_hash.sequences.keyIterator()) {
                hash sh = schema_hash.sequences{name};

                validateOptionsIntern("SEQUENCE-DESCRIPTION-ERROR", getSequenceDescriptionOptions(), \sh);

                # see if sequence exists
                if (getSequence(name))
                    continue;

                AbstractSequence seq = makeSequence(name, sh.start, sh.increment, sh.end);
                l += AbstractDatabase::doCallback(opt, seq.getCreateSql(), "create sequence %s", name);
            }

            # create template tables
            AbstractDatabase::checkDriverOptions(\schema_hash.tables, drv);
            foreach string name in (schema_hash.tables.keyIterator()) {
                hash th = schema_hash.tables{name} - "rename";
                # create table template
                Table t(ds, th, name, opt + ("table_cache": opt.table_cache));
                # store in table_cache
                opt.table_cache{name} = t.getTable();

                #printf("%N\n", t.describe().domain);exit();
                #printf("%s\n", t.getCreateSqlString(allOptions));
            }

            # rename any tables
            AbstractDatabase::checkDriverOptions(\schema_hash.table_map, drv);
            foreach hash th in (schema_hash.table_map) {                
                if (th.value.typeCode() != NT_STRING)
                    throw "SCHEMA-DESCRIPTION-ERROR", sprintf("table_map %y value is not a string in the schema description hash; got type %y instead (%y)", th.key, th.value.type(), th.value);

                Table t(ds, th.key);
                if (t.checkExistence()) {
                    l += AbstractDatabase::doCallback(opt, t.getRenameSql(th.value), "rename table %s to %s", th.key, th.value);
                    opt.db_table_cache{th.value} = t;
                }
            }

            # now process DB tables
            foreach string name in (schema_hash.tables.keyIterator()) {
                #printf("processing table %y\n", name);
                Table t;
                if (opt.db_table_cache{name})
                    t = opt.db_table_cache{name};
                else {
                    t = new Table(ds, name);
                    # store in db_table_cache
                    opt.db_table_cache{name} = t;
                }

                tl = t.getAlignSql(opt.table_cache{name}, opt + schema_hash.tables{name}.rename + ("table_cache": opt.table_cache, "db_table_cache": opt.db_table_cache));
                if (tl)
                    l += tl;
            }


            tl = alignCodeUnlocked("function", schema_hash, \getFunction(), \makeFunction(), opt, Type::String);
            if (tl) l += tl;

            tl = alignCodeUnlocked("procedure", schema_hash, \getProcedure(), \makeProcedure(), opt, Type::String);
            if (tl) l += tl;

            # call driver-specifc align schema sql function
            tl = getAlignSqlImpl(schema_hash, opt);
            if (tl) l += tl;

            table_cache = opt.table_cache;                
            
            return l;
        }

        private list alignCodeUnlocked(string type, hash schema_hash, code get, code make, *hash opt, string make_arg_type) {
            list l = ();
            hash copt = getCreationOptions();
            string drv = getDriverName();

            hash code_cache;

            # rename objects
            reference fmap = \schema_hash{type + "_map"};
            AbstractDatabase::checkDriverOptions(\fmap, drv);
            foreach hash fh in (fmap.pairIterator()) {                
                if (fh.value.typeCode() != NT_STRING)
                    throw "SCHEMA-DESCRIPTION-ERROR", sprintf("%s %y value is not a string in the schema description hash; got type %y instead (%y)", type + "_map", fh.key, fh.value.type(), fh.value);

                *AbstractFunction f = get(fh.key);
                if (f) {
                    AbstractDatabase::doInfoCallback(opt, "rename %s %s to %s", type, fh.key, fh.value);
                    list tl = AbstractDatabase::doSqlCallback(opt, f.getRenameSql(fh.value));
                    if (tl)
                        l += tl;

                    # add to function cache
                    f.setName(fh.value);
                    code_cache{fh.value} = f;
                }
            }

            # create any missing functions; replace updated functions
            fmap = \schema_hash{type + "s"};
            AbstractDatabase::checkDriverOptions(\fmap, drv);
            foreach string name in (fmap.keyIterator()) {
                validateOptionIntern("SCHEMA-DESCRIPTION-ERROR", make_arg_type, \fmap{name}, name, type + "s");

                # make template function
                AbstractFunction templateFunc = make(name, fmap{name}, opt.(copt.keys()));

                # see if function exists
                *AbstractFunction f;
                if (code_cache{name})
                    f = code_cache{name};
                else {
                    f = get(name);
                    if (!f) {
                        AbstractDatabase::doInfoCallback(opt, "create %s %s", type, name);
                        l += AbstractDatabase::doSqlCallback(opt, templateFunc.getCreateSql(opt));
                        continue;
                    }
                }

                if (!templateFunc.equal(f)) {
                    AbstractDatabase::doInfoCallback(opt, "drop %s %s", type, name);
                    l += AbstractDatabase::doSqlCallback(opt, f.getDropSql());
                    AbstractDatabase::doInfoCallback(opt, "create %s %s", type, name);
                    l += AbstractDatabase::doSqlCallback(opt, templateFunc.getCreateSql(opt));
                }
            }

            return l;
        }

        #! creates a database-specific AbstractSequence object corresponding to the arguments
        /** @par Example:
            @code
my AbstractSequence $seq = $db.makeSequence("seq_queues");
            @endcode

            @param name the name of the sequence
            @param start the starting value of the sequence
            @param increment the increment value of the sequence
            @param end the endinf value of the sequence, omit for no ending value
            @param opts an optional hash of options for the creation of the sequence; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw SEQUENCE-ERROR end not compatible with start and increment, increment is zero
        */
        AbstractSequence makeSequence(string name, number start = 1, number increment = 1, *softnumber end, *hash opts) {
            validateOptionsIntern("OPTION-ERROR", getCreationOptions(), \opts);

            return makeSequenceImpl(name, start, increment, end, opts);
        }

        #! creates a database-specific AbstractFunction object corresponding to the arguments
        /** @par Example:
            @code
my AbstractFunction $f = $db.makeFunction("update_queue", $src);
            @endcode

            @param name the name of the function
            @param src the database-specific source code of the function (see the database-specific documentation for information about the format of this parameter; generally it's simply the normal source code for the function required by the database)
            @param opts an optional hash of options for the creation of the function; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        AbstractFunction makeFunction(string name, string src, *hash opts) {
            validateOptionsIntern("OPTION-ERROR", getCreationOptions(), \opts);

            return makeFunctionImpl(name, src, opts);
        }

        #! creates a database-specific AbstractFunction object for a stored procedure corresponding to the arguments
        /** @par Example:
            @code
my AbstractFunction $f = $db.makeProcedure("get_queue_info", $src);
            @endcode

            @param name the name of the stored procedure
            @param src the database-specific source code of the stored procedure (see the database-specific documentation for information about the format of this parameter; generally it's simply the normal source code for the stored procedure required by the database)
            @param opt an optional hash of options for the creation of the stored procedure; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        AbstractFunction makeProcedure(string name, string src, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCreationOptions(), \opt);

            return makeProcedureImpl(name, src, opt);
        }

        #! drops the given function if it exists; returns @ref Qore::True "True" if the function was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropFunctionIfExists($name);
            @endcode

            @param name the name of the function
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info
            
            @return @ref Qore::True "True" if the function was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropFunctionIfExists(string name, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractFunction f = getFunction(name);
            if (!f)
                return False;
            return AbstractDatabase::doDrop(f.getDropSql(), "function", name, opt);
        }

        #! drops the given procedure if it exists; returns @ref Qore::True "True" if the procedure was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropProcedureIfExists($name);
            @endcode

            @param name the name of the procedure
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return @ref Qore::True "True" if the procedure was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropProcedureIfExists(string name, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractFunction f = getProcedure(name);
            if (!f)
                return False;
            return AbstractDatabase::doDrop(f.getDropSql(), "procedure", name, opt);
        }

        #! drops the given sequence if it exists; returns @ref Qore::True "True" if the sequence was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropSequenceIfExists($name);
            @endcode

            @param name the name of the sequence
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return @ref Qore::True "True" if the sequence was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropSequenceIfExists(string name, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractSequence seq = getSequence(name);
            if (!seq)
                return False;
            return AbstractDatabase::doDrop(seq.getDropSql(), "sequence", name, opt);
        }

        #! drops the given table if it exists; returns @ref Qore::True "True" if the table was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropTableIfExists($name);
            @endcode

            @param name the name of the table
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return @ref Qore::True "True" if the table was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropTableIfExists(string name, *hash opt) {            
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractTable obj = getTable(name);
            if (!obj)
                return False;
            obj.drop(opt);
            return True;
        }

        #! returns the SQL require to drop the given function if it exists or @ref nothing if the named function does not exist
        /** @par Example:
            @code
my string $sql = $db.getDropFunctionSqlIfExists($name);
            @endcode

            @param name the name of the function
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info
            
            @return the SQL require to drop the given function if it exists or @ref nothing if the named function does not exist

            @throw OPTION-ERROR invalid or unknown callback option
        */
        *string getDropFunctionSqlIfExists(string name, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractFunction f = getFunction(name);
            if (!f)
                return;
            return AbstractDatabase::doDropSql(f.getDropSql(), "function", name, opt);
        }

        #! returns the SQL require to drop the given procedure if it exists or @ref nothing if the named procedure does not exist
        /** @par Example:
            @code
my string $sql = $db.getDropProcedureSqlIfExists($name);
            @endcode

            @param name the name of the procedure
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info
            
            @return the SQL require to drop the given procedure if it exists or @ref nothing if the named procedure does not exist

            @throw OPTION-ERROR invalid or unknown callback option
        */
        *string getDropProcedureSqlIfExists(string name, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractFunction f = getProcedure(name);
            if (!f)
                return;
            return AbstractDatabase::doDropSql(f.getDropSql(), "procedure", name, opt);
        }

        #! returns the SQL require to drop the given sequence if it exists or @ref nothing if the named sequence does not exist
        /** @par Example:
            @code
my string $sql = $db.getDropSequenceSqlIfExists($name);
            @endcode

            @param name the name of the sequence
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info
            
            @return the SQL require to drop the given sequence if it exists or @ref nothing if the named sequence does not exist

            @throw OPTION-ERROR invalid or unknown callback option
        */
        *string getDropSequenceSqlIfExists(string name, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractSequence obj = getSequence(name);
            if (!obj)
                return;
            return AbstractDatabase::doDropSql(obj.getDropSql(), "sequence", name, opt);
        }

        #! returns the SQL require to drop the given table if it exists or @ref nothing if the named table does not exist
        /** @par Example:
            @code
my string $sql = $db.getDropTableSqlIfExists($name);
            @endcode

            @param name the name of the table
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info
            
            @return the SQL require to drop the given table if it exists or @ref nothing if the named table does not exist

            @throw OPTION-ERROR invalid or unknown callback option
        */
        *list getDropTableSqlIfExists(string name, *hash opt) {            
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractTable t = getTable(name);
            if (!t)
                return;
            return t.getDropSql(opt);
        }

        doDropSql(*softlist l, string type, string name, *hash opt) {
            if (l)
                AbstractDatabase::doCallback(opt, l, "drop %s %s", type, name);
        }

        bool doDrop(*softlist l, string type, string name, *hash opt) {
            if (l) {
                AbstractDatabase::doCallback(opt, l, "drop %s %s", type, name);
                on_success ds.commit();
                on_error ds.rollback();
                map ds.exec($1), l;
                return True;
            }
            return False;
        }

        #! returns a list of SQL strings that can be used to update a function in the database to the function definition passed as an argument
        /** @par Example:
            @code
my list $l = $db.getAlignFunctionSql(f);
            @endcode

            @param f the template or target version of the function to compare to the database version
            @param opt an optional hash of options for the generation of the SQL strings; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to update a function in the database to the function definition passed as an argument

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        list getAlignFunctionSql(AbstractFunction f, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCreationOptions(), \opt);

            *AbstractFunction of = getFunctionImpl(f.name);

            list l = ();

            if (!of) {
                l += AbstractDatabase::doCallback(opt, f.getCreateSql(opt), "create function %s", f.name);
            }
            else if (!of.equal(f)) {
                l += AbstractDatabase::doCallback(opt, of.getDropSql(), "drop function %s", f.name);
                l += AbstractDatabase::doCallback(opt, of.getCreateSql(opt), "create function %s", f.name);
            }
                
            return l;
        }

        #! returns a list of SQL strings that can be used to update a stored procedure in the database to the stored procedure definition passed as an argument
        /** @par Example:
            @code
my list $l = $db.getAlignProcedureSql(f);
            @endcode

            @param f the template or target version of the stored procedure to compare to the database version
            @param opt an optional hash of options for the generation of the SQL strings; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to update a stored procedure in the database to the stored procedure definition passed as an argument

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        list getAlignProcedureSql(AbstractFunction f, *hash opt) {
            *AbstractFunction of = getProcedureImpl(f.name);

            list l = ();

            if (!of)
                l += f.getCreateSql(opt);
            else if (!of.equal(f)) {
                l += of.getDropSql();
                l += f.getCreateSql(opt);
            }
                
            return l;
        }

        #! returns an AbstractTable argument for the given table name or @ref nothing if the table cannot be found
        /** @par Example:
            @code
my *AbstractTable $table = $db.getTable("queues");
            @endcode

            @param name the uniquely-identifying name of the table to retrieve

            @return an AbstractTable argument for the given table name or @ref nothing if the table cannot be found
         */
        *AbstractTable getTable(string name) {
            AbstractTable t = AbstractTable::getTable(ds, name);
            return t.checkExistence() ? t : NOTHING;
        }

        #! returns an AbstractSequence argument for the given sequence name or @ref nothing if the sequence cannot be found
        /** @par Example:
            @code
my *AbstractSequence $seq = $db.getSequence("seq_queues");
            @endcode

            @param name the uniquely-identifying name of the sequence to retrieve

            @return an AbstractSequence argument for the given sequence name or @ref nothing if the sequence cannot be found
         */
        *AbstractSequence getSequence(string name) {
            return getSequenceImpl(name);
        }

        #! returns an AbstractFunction argument for the given function name or @ref nothing if the function cannot be found
        /** @par Example:
            @code
my *AbstractFunction $f = $db.getFunction("update_queue");
            @endcode

            @param name the uniquely-identifying name of the function to retrieve

            @return an AbstractFunction argument for the given function name or @ref nothing if the function cannot be found

            @note for databases that support overloaded functions, the arguments must be passed in parentheses after the name to match overloaded functions properly
         */
        *AbstractFunction getFunction(string name) {
            return getFunctionImpl(name);
        }

        #! returns an AbstractFunction argument for the given stored procedure name or @ref nothing if the stored procedur  cannot be found
        /** @par Example:
            @code
my *AbstractFunction $f = $db.getProcedure("update_queue");
            @endcode

            @param name the uniquely-identifying name of the stored procedure to retrieve

            @return an AbstractFunction argument for the given stored procedure name or @ref nothing if the stored procedure cannot be found

            @note for databases that support overloaded stored procedures, the arguments must be passed in parentheses after the name to match overloaded stored procedures properly
         */
        *AbstractFunction getProcedure(string name) {
            return getProcedureImpl(name);
        }

        #! returns an SQL string corresponding to the list of commands in the argument
        /** @par Example:
            @code
my string $sql = $t.getSqlFromList($list);
            @endcode

            @param l a list of SQL commands
            
            @return an SQL string corresponding to the list of commands in the argument
        */
        string getSqlFromList(list l) {
            return getCreateSqlImpl(l);
        }

        #! returns a list of string table names in the database
        list listTables() {
            return listTablesImpl();
        }
        
        #! returns an iterator listing the string table names in the database
        ListIterator tableIterator() {
            return listTablesImpl().iterator();            
        }
 
        #! returns a list of string function names in the database
        list listFunctions() {
            return listFunctionsImpl();
        }
        
        #! returns an iterator listing the string function names in the database
        ListIterator functionIterator() {
            return listFunctionsImpl().iterator();            
        }

        #! returns a list of string procedure names in the database
        list listProcedures() {
            return listProceduresImpl();
        }
        
        #! returns an iterator listing the string procedure names in the database
        ListIterator procedureIterator() {
            return listProceduresImpl().iterator();            
        }

        #! returns a list of string sequence names in the database
        list listSequences() {
            return listSequencesImpl();
        }
        
        #! returns an iterator listing the string sequence names in the database
        ListIterator sequenceIterator() {
            return listSequencesImpl().iterator();            
        }

        #! returns a list of string view names in the database
        list listViews() {
            return listViewsImpl();
        }
        
        #! returns an iterator listing the string view names in the database
        ListIterator viewIterator() {
            return listViewsImpl().iterator();            
        }

        private validateOptionsIntern(string err, hash ropt, reference opt) {
            AbstractSqlUtilBase::validateOptionsIntern(err, ropt, \opt, ds.getDBName());
        }

        private validateOptionsIntern(string err, hash ropt, reference opt, string tag) {
            AbstractSqlUtilBase::validateOptionsIntern(err, ropt, \opt, tag);
        }

        static AbstractDatabase getDatabase(AbstractDatasource nds, *hash opts) {
            string drv = nds.getDriverName();

            # generate module and module namespace name
            string mn = drv[0].upr() + drv.substr(1) + "SqlUtil";

            # try to load module
            try {
                load_module(mn);                
            }
            catch (hash ex) {
                throw "DATABASE-DRIVER-ERROR", sprintf("%s: no support for driver %y yet: %s: %s", get_ex_pos(ex), drv, ex.err, ex.desc);
            }

            # try to get AbstractDatabase object
            try {
                return call_function(mn + "::" + "get_database", nds, opts);
            }
            catch (hash ex) {
                throw "DATABASE-DRIVER-ERROR", sprintf("%s: error retrieving AbstractDatabase object for driver %y: %s: %s", get_ex_pos(ex), drv, ex.err, ex.desc);
            }
        }

        static AbstractDatabase getDatabase(string dsstr, *hash opts) {
            Datasource nds(dsstr);
            return AbstractDatabase::getDatabase(nds, opts);
        }

        static AbstractDatabase getDatabase(hash dsh, *hash opts) {
            Datasource nds(dsh);
            return AbstractDatabase::getDatabase(nds, opts);
        }

        static checkDriverOptions(reference h, string drv) {
            if (h.driver) {
                if (h.driver{drv})
                    h += h.driver{drv};
                delete h.driver;
            }
        }

        #! override in subclasses to return driver-specific options
        private hash getDatabaseOptions() {
            return DatabaseOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getCallbackOptions() {
            return CallbackOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getCreationOptions() {
            return CreationOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getCacheOptions() {
            return CacheOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getAlignSchemaOptions() {
            return AlignSchemaOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getSchemaDescriptionOptions() {
            return SchemaDescriptionOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getSequenceDescriptionOptions() {
            return SequenceDescriptionOptions;
        }

        private abstract string getCreateSqlImpl(list l);
        private abstract list getAlignSqlImpl(hash schema_hash, *hash opt);

        private abstract *AbstractSequence getSequenceImpl(string name);
        private abstract *AbstractFunction getFunctionImpl(string name);
        private abstract *AbstractFunction getProcedureImpl(string name);

        private abstract AbstractSequence makeSequenceImpl(string name, number start = 1, number increment = 1, *softnumber end, *hash opts);
        private abstract AbstractFunction makeFunctionImpl(string name, string src, *hash opts);
        private abstract AbstractFunction makeProcedureImpl(string name, string src, *hash opts);

        private abstract list listTablesImpl();
        private abstract list listFunctionsImpl();
        private abstract list listProceduresImpl();
        private abstract list listSequencesImpl();
        private abstract list listViewsImpl();
    }

    #! represents a database table; this class embeds an AbstractTable object that is created automatically in the constructor based on the database driver for the AbstractDatasource object providing the database connection
    /** Driver-specific modules that provide the AbstractTable implementation embedded in this class are loaded on demand based on the driver's name.
        The driver-specific module's name is generated based on the db-driver's name with the first letter capitalized then with \c "SqlUtil" appended.

        For example:
        - \c "oracle": \c "OracleSqlUtil"
        - \c "pgsql": \c "PgsqlSqlUtil"

        etc.
    */
    public class Table {
        private {
            #! the embedded AbstractTable object that actually provides the functionality for this class
            AbstractTable t;
        }

        #! creates the Table object
        /** @par Example:
            @code
my Table $table($ds, "table");
            @endcode

            @param ds the AbstractDatasource object used to provide the DB connection
            @param name the name of the table
            @param opts a hash of options for the table creation string; see @ref AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw TABLE-DRIVER-ERROR no database-specific module can be loaded
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        constructor(AbstractDatasource ds, string name, *hash opts) {
            t = AbstractTable::getTable(ds, name, opts);
        }

        #! creates the Table object
        /** @par Example:
            @code
my Table $table("pgsql:user/pass@db%host", "table");
            @endcode

            @param ds a datasource description string in the format that can be parsed by parse_datasource()
            @param name the name of the table
            @param opts a hash of options for the table creation string; see @ref AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw TABLE-DRIVER-ERROR no database-specific module can be loaded
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        constructor(string ds, string name, *hash opts) {
            t = AbstractTable::getTable(ds, name, opts);
        }
        
        #! creates the Table object
        /** @par Example:
            @code
my Table $table("pgsql:user/pass@db%host", "table");
            @endcode

            @param ds a hash giving parameters for the new datasource with the following possible keys (the \c "type" key is mandatory, also usable with the output of the parse_datasource() function):
            - \c type: (@ref string_or_nothing_type "*string") The name of the database driver to use; this key is mandatory; if not present, an exception will be raised. See @ref sql_constants for builtin constants for DBI drivers shipped with Qore, or see the DBI driver documentation to use an add-on driver (this string should be the name of the driver to be loaded)
            - \c user: (@ref string_or_nothing_type "*string") The user name for the new connection
            - \c pass: (@ref string_or_nothing_type "*string") The password for the new connection
            - \c db: (@ref string_or_nothing_type "*string") The database name for the new connection
            - \c charset: (@ref string_or_nothing_type "*string") The database-specific name of the character encoding to use for the new connection. Also see Qore::SQL::Datasource::setDBCharset() for a method that allows this parameter to be set after the constructor. If no value is passed for this parameter, then the database character encoding corresponding to the default character encoding for the %Qore process will be used instead.
            - \c host: (@ref string_or_nothing_type "*string") The host name for the new connection
            - \c port: (@ref softint_type "softint") The port number for the new connection
            - \c options: (@ref hash_or_nothing_type "*hash") Any options for the new connection
            @param name the name of the table
            @param opts a hash of options for the table creation string; see @ref AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw TABLE-DRIVER-ERROR no database-specific module can be loaded
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        constructor(hash ds, string name, *hash opts) {
            t = AbstractTable::getTable(ds, name, opts);
        }

        #! creates the object from a table description hash
        /** @param ds the AbstractDatasource for the connection to the database
            @param desc a @ref table_desc_hash "table description hash" describing the table
            @param name the name of the table
            @param opts an optional hash of options for the table creation string; see @ref AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw DESCRIPTION-ERROR invalid or unsupported description hash value passed
        */
        constructor(AbstractDatasource ds, hash desc, string name, *hash opts) {
            t = AbstractTable::getTable(ds, name);
            t.setupTable(desc, opts);
        }

        #! returns the name of the table
        string getName() {
            return t.getName();
        }

        #! gets the underlying AbstractDatasource
        AbstractDatasource getDatasource() {
            return t.getDatasource();
        }

        #! returns the AbstractTable object contained by this object
        AbstractTable getTable() {
            return t;
        }

        #! executes a method on the contained AbstractTable object
        any methodGate(string meth) {
            return callObjectMethodArgs(t, meth, argv);
        }

        #! returns @ref Qore::True "True" if the table has been read from or created in the database, @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $table.inDb();
            @endcode

            @return @ref Qore::True "True" if the table has been read from or created in the database, @ref Qore::False "False" if not
         */
        bool inDb() {
            return t.inDb();
        }

        #! drops the table from the database; releases the transaction lock after dropping the table
        /** @par Example:
            @code
$table.drop();
            @endcode

            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @throw OPTION-ERROR invalid or unknown callback option

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref dropNoCommit() to execute without any transaction management
         */
        drop(*hash opt) {
            t.drop(opt);
        }

        #! drops the table from the database without any transaction management
        /** @par Example:
            @code
$table.dropNoCommit();
            @endcode

            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @throw OPTION-ERROR invalid or unknown callback option

            @note Transaction management is normally not performed when dropping tables, however this method uses the Qore::SQL::AbstractDatasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        dropNoCommit(*hash opt) {
            t.dropNoCommit(opt);
        }
        
        #! truncates all the table data; releases the transaction lock after executing
        /** @par Example:
            @code
$table.truncate();
            @endcode

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref truncateNoCommit() to execute without any transaction management
         */
        truncate() {
            t.truncate();
        }

        #! truncates all the table data without any transaction management
        /** @par Example:
            @code
$table.truncateNoCommit();
            @endcode

            @note Transaction management may not be applied when truncating tables depending on the database driver (for example truncating tables in Oracle does not participate in transaction management), however this method uses the Qore::SQL::AbstractDatasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        truncateNoCommit() {
            t.truncateNoCommit();
        }
        
        #! creates the table in the database; releases the transaction lock after creating the table
        /** @par Example:
            @code
$table.create();
            @endcode

            @param opt a hash of options for the SQL creation string; see @ref AbstractTable::TableCreationOptions for common options; each driver can support additional driver-specific options

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref createNoCommit() to execute without any transaction management

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        create(*hash opt) {
            t.create(opt);
        }

        #! creates the table with all associated properties (indexes, constraints, etc) without any transaction management
        /** @par Example:
            @code
$table.createNoCommit();
            @endcode

            @param opt a hash of options for the SQL creation string; see @ref AbstractTable::TableCreationOptions for common options; each driver can support additional driver-specific options

            @note Transaction management is normally not performed when creating tables, however this method uses the Qore::SQL::AbstractDatasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        createNoCommit(*hash opt) {
            t.createNoCommit(opt);
        }

        #! renames the table; if the table already exists in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
$table.rename("new_name");
            @endcode

            @param new_name the new name for the table
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @see getRenameSql()
        */
        rename(string new_name, *reference sql) {
            return t.rename(new_name, \sql);
        }

        #! adds a column to the table; if the table already exists, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
$table.addColumn("name", ("qore_type": Type::String, "size": 50), False);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column
            @param opt a hash describing the column; the following keys are permitted (other column options may be supported depending on the underlying AbstractTable implementation):
            - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion;
            - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
            - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
            - \c scale: for numeric data types, this value gives the scale
            - \c default_value: the default value for the column
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @param nullable if @ref Qore::True "True" then the column can hold NULL values; note that primary key columns cannot be nullable

            @throw COLUMN-ERROR no \c native_type or \c qore_type keys in column option hash, column already exists, invalid column data

            @note make sure and add a \c default_value value when adding a column with a \c "not null" constraint with existing data

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractColumn addColumn(string cname, hash opt, bool nullable = True, *reference lsql) {
            return t.addColumn(cname, opt, nullable, \lsql);
        }

        #! modifies an existing column in the table; if the table already exists, then the changes are effected in the database also immediately; otherwise it is only updated internally and the new column definition will be created when create() is called for example
        /** @par Example:
            @code
$table.modifyColumn("name", ("qore_type": Type::String, "size": 240), False);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column
            @param opt a hash describing the column; the following keys are permitted (other column options may be supported depending on the underlying AbstractTable implementation):
            - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion;
            - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
            - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
            - \c scale: for numeric data types, this value gives the scale
            - \c default_value: the default value for the column
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @param nullable if @ref Qore::True "True" then the column can hold NULL values; note that primary key columns cannot be nullable

            @throw COLUMN-ERROR no \c native_type or \c qore_type keys in column option hash, column does not exist, invalid column data

            @note make sure and add a \c default_value value when modifying a column to have a \c "not null" constraint with existing data

            @see
            - inDb() for a method that tells if the table is already in the database or not
            - renameColumn() for a method that allows the column name to be changed
         */
        AbstractColumn modifyColumn(string cname, hash opt, bool nullable = True, *reference lsql) {
            return t.modifyColumn(cname, opt, nullable, \lsql);
        }

        #! renames an existing column; if the table already exists, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
my AbstractColumn $col = $table.renameColumn("name", "family_name");
            @endcode

            @param old_name the current name of the column
            @param new_name the new name for the column
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)
            @return the column object that was updated

            @throw COLUMN-ERROR if the given column does not exist in the table

            @see modifyColumn() for a method that allows the column definition to be updated

            @note if any primary key or foreign table constraints refer to the column, the internal reprepsentations are also renamed, however check constraints are not updated and will be invalid if they refer to the renamed column
        */
        AbstractColumn renameColumn(string old_name, string new_name, reference sql) {
            return t.renameColumn(old_name, new_name, \sql);
        }

        #! adds a primary key to the table; if the table already exists, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractPrimaryKey $pk = $table.addPrimaryKey("pk_mytable", "id", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new primary key constraint
            @param cols a single column name or a list of columns that make up the primary key
            @param opt a hash of options for the new primary key; each driver may implement its own options; for common options, see @ref AbstractTable::ConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractPrimaryKey object corresponding to the primary key created

            @throw PRIMARY-KEY-ERROR the table already has a primary key or invalid columns passed
            @throw OPTION-ERROR invalid or unsupported option passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractPrimaryKey addPrimaryKey(string cname, softlist cols, *hash opt, *reference sql) {
            return t.addPrimaryKey(cname, cols, opt, \sql);
        }

        #! drops the primary key from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropPrimaryKey();
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the primary key dropped from the table

            @throw PRIMARY-KEY-ERROR no primary key exists

            @note this method retrieves the primary key definition from the database if none has already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractPrimaryKey dropPrimaryKey(*reference sql) {
            return t.dropPrimaryKey(\sql);
        }

        #! adds a unique constraint to the table; if the table is known to be in the database already, then the constraint is added to the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractUniqueConstraint $c = $table.addUniqueConstraint("uk_mytable", "name", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new unique constraint
            @param cols a single column name or a list of columns that make up the unique constraint
            @param opt a hash of options for the new unique constraint; each driver may implement its own options; for common options, see @ref AbstractTable::ConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractUniqueConstraint object corresponding to the unique constraint created

            @throw UNIQUE-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns passed
            @throw OPTION-ERROR invalid or unsupported option passed

            @see 
            - inDb() for a method that tells if the table is already in the database or not
            - dropUniqueConstraint() for a method that allows unique constraints to be dropped from the table
         */
        AbstractUniqueConstraint addUniqueConstraint(string cname, softlist cols, *hash opt, *reference sql) {
            return t.addUniqueConstraint(cname, cols, opt, \sql);
        }

        #! adds an index to the table; if the table already exists, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractIndex $ix = $table.addIndex("uk_mytable_name", True, "name", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param iname the name of the new index
            @param unique a flag to tell if the new index should be unique or not
            @param cols a single column name or a list of columns that make up the index
            @param opt a hash of options for the new index; each driver may implement its own options; for common options, see @ref AbstractTable::IndexOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractIndex object corresponding to the index created

            @throw INDEX-ERROR the table already has an index with the given name or invalid columns were passed
            @throw OPTION-ERROR invalid or unsupported option passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractIndex addIndex(string iname, bool unique, softlist cols, *hash opt, *reference sql) {
            return t.addIndex(iname, unique, cols, opt, \sql);
        }

        #! renames an existing index; if the table is already known to be in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
my AbstractIndex $ix = $table.renameIndex("uk_table_name", "unique_table_name");
            @endcode

            @param old_name the current name of the index
            @param new_name the new name for the index
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)
            @return the index object that was updated

            @throw INDEX-ERROR if the old index does not exist in the table or if the new index name already exists
        */
        AbstractIndex renameIndex(string old_name, string new_name, reference sql) {
            return t.renameIndex(old_name, new_name, \sql);
        }

        #! drops the index from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropIndex("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param iname the name of the index to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the index dropped from the table

            @throw INDEX-ERROR the given index does not exist

            @note this method retrieves all current index definitions from the database if none have already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractIndex dropIndex(string iname, *reference sql) {
            return t.dropIndex(iname, \sql);
        }

        #! adds an foreign constraint to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractForeignConstraint $fc = $table.addForeignConstraint("fk_mytable_other_table", ("name", "version"), "other_table", NOTHING, \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new foreign constraint
            @param cols a single column name or a list of columns in the local table that make up the foreign constraint
            @param table the name of the other table that the constraint targets
            @param tcols a single column name or a list of columns in the foreign table or @ref nothing meaning that the column names are the same as in the local table; if column names are given the same number of columns must be given in the local and foreign tables
            @param opt a hash of options for the new foreign constraint; each driver may implement its own options; for common options, see @ref AbstractTable::ForeignConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractForeignConstraint object corresponding to the foreign constraint created

            @throw FOREIGN-CONSTRAINT-ERROR the table already has an foreign constraint with the given name or invalid columns were passed
            @throw OPTION-ERROR invalid or unsupported option passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractForeignConstraint addForeignConstraint(string cname, softlist cols, string table, *softlist tcols, *hash opt, *reference sql) {
            return t.addForeignConstraint(cname, cols, table, tcols, opt, \sql);
        }

        #! drops the foreign constraint from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropForeignConstraint("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the foreign constraint to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the foreign constraint dropped from the table

            @throw FOREIGN-CONSTRAINT-ERROR the given constraint does not exist

            @note this method retrieves all current foreign constraint definitions from the database if none have already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractForeignConstraint dropForeignConstraint(string cname, *reference sql) {
            return t.dropForeignConstraint(cname, \sql);
        }

        #! adds a check constraint to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractCheckConstraint $cc = $table.addCheckConstraint("check_mytable_id", "id > 10", NOTHING, \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new constraint
            @param src the source of the constraint clause
            @param opt a hash of options for the new foreign constraint; each driver may implement its own options; for common options, see @ref AbstractTable::ConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractCheckConstraint object corresponding to the check constraint created

            @throw CHECK-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns or options were passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractCheckConstraint addCheckConstraint(string cname, string src, *hash opt, *reference sql) {
            return t.addCheckConstraint(cname, src, opt, \sql);
        }

        #! renames an existing constraint; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint; if the table is already known to be in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
my AbstractConstraint $con = $table.renameConstraint("pk_table_name", "pkey_table_name");
            @endcode

            @param old_name the current name of the constraint
            @param new_name the new name for the constraint
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)
            @return the constraint object that was updated

            @throw CONSTRAINT-ERROR if the old constraint does not exist in the table or if the new constraint name already exists
        */
        AbstractConstraint renameConstraint(string old_name, string new_name, reference sql) {
            return t.renameConstraint(old_name, new_name, \sql);
        }

        #! drops a constraint from the table; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropConstraint("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the constraint to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the constraint dropped from the table

            @throw CONSTRAINT-ERROR the given constraint does not exist in the table

            @note this method retrieves current constraint definitions from the database if not already loaded or defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractConstraint dropConstraint(string cname, *reference sql) {
            return t.dropConstraint(cname, \sql); 
        }

        #! adds a trigger to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractTrigger $trig = $table.addTrigger("trig_mytable",x $trigger_source, NOTHING, \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param tname the name of the new trigger
            @param src the database-specific source of the trigger
            @param opt a hash of options for the new trigger; each driver may implement its own options; for common options, see @ref AbstractTable::TriggerOptions
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractTrigger object corresponding to the trigger created

            @throw TRIGGER-ERROR the table already has a trigger with the given name or invalid options were passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractTrigger addTrigger(string tname, string src, *hash opt, *reference lsql) {
            return t.addTrigger(tname, src, opt, \lsql);
        }

        #! drops the given trigger from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropTrigger("trig_mytable");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param tname the name of the trigger to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the database (only executed if the table is already in the database)

            @return the trigger dropped from the table

            @note this method retrieves all current trigger definitions from the database if none have already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractTrigger dropTrigger(string tname, *reference sql) {
            return t.dropTrigger(tname, \sql);
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument
        /** @par Example:
            @code
my string $str = $table.getSqlValue($date);
            @endcode

            @param v the value to convert to an SQL value

            @return a string representing the value usable in SQL strings for the given database driver

            @throw VALUE-ERROR the given value cannot be converted to an SQL string (missing rules for value)
         */
        string getSqlValue(any v) {
            return t.getSqlValue(v);
        }
        
        #! drops a column from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropColumn("notes_2");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @throw COLUMN-ERROR the named column is not present in the table

            @note this method retrieves the table definition from the database if none has already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
         AbstractColumn dropColumn(string cname, *reference sql) {
             return t.dropColumn(cname, \sql);
         }

        #! inserts a row into the table; the transaction is committed if successful, if an error occurs, it is rolled back
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
         */
        insert(hash row) {
            t.insert(row);
        }

        #! inserts a row into the table without any transaction management; a transaction will be in progress after this method is successfully executed
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
         */
        insertNoCommit(hash row) {
            t.insertNoCommit(row);
        }

        #! update or insert the data in the table according to the hash argument; the table must have a unique key to do this; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
$table.upsert($row);
            @endcode

            @param row a hash representing the row to insert or update
            @param upsert_type one of @ref AbstractTable::UpsertInsertFirst, @ref AbstractTable::UpsertUpdateFirst, or @ref AbstractTable::UpsertSelectFirst for the upsert strategy

            @return an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note if upserting multiple rows; it's better to use getUpsertClosure() or getUpsertClosureValidation() and execute the closure on each row; when using this method, the overhead for setting up the upsert is made for each row which is very inefficient

            @see
            - upsertNoCommit()
            - getUpsertClosure()
            - getUpsertClosureWithValidation()
         */
        int upsert(hash row, int upsert_type = AbstractTable::UpsertInsertFirst) {
            return t.upsert(row, upsert_type);
        }

        #! update or insert the data in the table according to the hash argument; the table must have a unique key to do this
        /** @par Example:
            @code
$table.upsertNoCommit($row);
            @endcode

            @param row a hash representing the row to insert or update
            @param upsert_type one of @ref AbstractTable::UpsertInsertFirst, @ref AbstractTable::UpsertUpdateFirst, or @ref AbstractTable::UpsertSelectFirst for the upsert strategy

            @return an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note if upserting multiple rows; it's better to use getUpsertClosure() or getUpsertClosureValidation() and execute the closure on each row; when using this method, the overhead for setting up the upsert is made for each row which is very inefficient

            @see
            - upsert()
            - getUpsertClosure()
            - getUpsertClosureWithValidation()
         */
        int upsertNoCommit(hash row, int upsert_type = AbstractTable::UpsertInsertFirst) {
            return t.upsertNoCommit(row, upsert_type);
        }

        #! returns a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the table must have a unique key to do this; the closure returned does not validate the input hash for validity
        /** @par Example:
            @code
my Datasource $ds("pgsql:user/pass@db%localhost");
my Table $table($ds, "table_name");
my code $upsert = $table.getUpsertClosure($row, AbstractTable::UpsertSelectFirst);
on_success $ds.commit();
on_error $ds.rollback();
map $upsert($1), $row_list;
            @endcode

            @param example_row a hash representing an example row to insert or update; every row passed to the upsert closure returned must have the same keys in the same order
            @param upsert_type one of @ref AbstractTable::UpsertInsertFirst, @ref AbstractTable::UpsertUpdateFirst, or @ref AbstractTable::UpsertSelectFirst for the upsert strategy

            @return a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the closure returned does not validate the input hash for validity; the closure has the following signature: @code int sub upsert(hash $row) {} @endcode The return value of the closuse is an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note the row values passed to the closure for upserting are not checked if they match the example row passed to the getUpsertClosure() method; passing non-conforming data will cause errors; see @ref AbstractTable::getUpsertClosureWithValidation() for a similar method that returns a validating closure; the closure returned by this method is faster than the one returned by @ref AbstractTable::getUpsertClosure() since there is no validation

            @see
            - upsert()
            - upsertNoCommit()
            - getUpsertClosureWithValidation()
         */
        code getUpsertClosure(hash example_row, int upsert_type = AbstractTable::UpsertInsertFirst) {
            return t.getUpsertClosure(example_row, upsert_type);
        }

        #! returns a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the table must have a unique key to do this; the closure returned does not validate the input hash for validity
        /** @par Example:
            @code
my Datasource $ds("pgsql:user/pass@db%localhost");
my Table $table($ds, "table_name");
my code $upsert = $table.getUpsertClosureWithValidation($row, AbstractTable::UpsertSelectFirst);
on_success $ds.commit();
on_error $ds.rollback();
map $upsert($1), $row_list;
            @endcode

            @param example_row a hash representing an example row to insert or update; every row passed to the upsert closure returned must have the same keys in the same order or the closure returned will throw an \c UPSERT-ERROR exception
            @param upsert_type one of @ref AbstractTable::UpsertInsertFirst, @ref AbstractTable::UpsertUpdateFirst, or @ref AbstractTable::UpsertSelectFirst for the upsert strategy

            @return a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the closure has the following signature: @code int sub upsert(hash $row) {} @endcode The return value of the closuse is an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note the row values passed to the closure for upserting are checked if they match the example row passed to the getUpsertClosure() method; passing non-conforming data to the closure will cause the closure to throw an \c UPSERT-ERROR exception; see @ref AbstractTable::getUpsertClosure() for a similar method that returns a non-validating closure; the closure returned by this method is a little slower than the one returned by @ref AbstractTable::getUpsertClosure() since each row is validated

            @see
            - upsert()
            - upsertNoCommit()
            - getUpsertClosure()
         */
        code getUpsertClosureWithValidation(hash example_row, int upsert_type = AbstractTable::UpsertInsertFirst) {
            return t.getUpsertClosureWithValidation(example_row, upsert_type);
        }

        #! returns an SQL string corresponding to the list of commands in the argument
        /** @par Example:
            @code
my string $sql = $t.getSqlFromList($list);
            @endcode

            @param l a list of SQL commands
            
            @return an SQL string corresponding to the list of commands in the argument
        */
        string getSqlFromList(list l) {
            return t.getSqlFromList(l);
        }

        #! returns an SQL string that could be used to rename the table in the database
        /** @par Example:
            @code
my string $sql = $table.getRenameSql("new_name");
            @endcode

            @param new_name the new name for the table

            @return an SQL string that could be used to rename the table in the database

            @note does not rename the table; the new name is only used in the SQL string return value

            @see rename()
        */
        string getRenameSql(string new_name) {
            return t.getRenameSql(new_name);
        }

        #! returns an SQL string that could be used to create the table and all known properties of the table
        /** @par Example:
            @code
printf("%s\n", $table.getCreateSqlString());
            @endcode

            @param opt a hash of options for the SQL creation string; see @ref AbstractTable::TableCreationOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that could be used to create the table and all known properties of the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        string getCreateSqlString(*hash opt) {
            return t.getCreateSqlString(opt);
        }

        #! returns a list of SQL strings that could be used to create the table and all known properties of the table
        /** @par Example:
            @code
map printf("$1;\n", $1), $table.getCreateSql();
            @endcode

            @param opt a hash of options for the SQL creation string; see @ref AbstractTable::TableCreationOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that could be used to create the table and all known properties of the table
        */
        list getCreateSql(*hash opt) {
            return t.getCreateSql(opt);
        }

        #! returns an SQL string that could be used to create the basic table structure without indexes and constraints 
        /** @par Example:
            @code
my string $sql = $table.getCreateTableSql();
            @endcode

            @param opt a hash of options for the SQL creation string; see @ref AbstractTable::TableCreationOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that could be used to create the basic table structure without indexes and constraints 

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        string getCreateTableSql(*hash opt) {
            return t.getCreateTableSql(opt);
        }

        #! returns a list of SQL strings that could be used to create indexes on the table or @ref nothing if there are no indexes on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateIndexesSql();
            @endcode

            @param opt a hash of options for the new index; each driver may implement its own options; for common options, see @ref AbstractTable::IndexOptions

            @return a list of SQL strings that could be used to create indexes on the table or @ref nothing if there are no indexes on the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateIndexesSql(*hash opt) {
            return t.getCreateIndexesSql(opt);
        }

        #! returns an SQL string that could be used to create the primary key on the table
        /** @par Example:
            @code
my *string $sql = $table.getCreatePrimaryKeySql();
            @endcode

            @param opt a hash of options for the new primary key; each driver may implement its own options; for common options, see @ref AbstractTable::ConstraintOptions

            @return an SQL string that could be used to create the primary key on the table or @ref nothing if there is no primary key on the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *string getCreatePrimaryKeySql(*hash opt) {
            return t.getCreatePrimaryKeySql(opt);
        }

        #! returns a list of SQL strings that could be used to create foreign constraints on the table or @ref nothing if there are no foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateForeignConstraintsSql();
            @endcode

            @param opt a hash of options for the new foreign constraint; each driver may implement its own options; for common options, see @ref AbstractTable::ForeignConstraintOptions

            @return a list of SQL strings that could be used to create foreign constraints on the table or @ref nothing if there are no foreign constraints on the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateForeignConstraintsSql(*hash opt) {
            return t.getCreateForeignConstraintsSql(opt);
        }

        #! returns a list of SQL strings that could be used to create non-foreign constraints on the table or @ref nothing if there are no non-foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateConstraintsSql();
            @endcode

            @param opt a hash of options for the non-foreign constraint creation string; see @ref AbstractTable::ConstraintOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that could be used to create non-foreign constraints on the table or @ref nothing if there are no non-foreign constraints on the table

            @throw OPTION-ERROR invalid or unsupported option passed

            @see getCreateForeignConstraintsSql()
        */
        *list getCreateConstraintsSql(*hash opt) {
            return t.getCreateConstraintsSql(opt);
        }

        #! returns a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or @ref nothing if there are none
        /** @par Example:
            @code
my *list $l = $table.getCreateMiscSql();
            @endcode

            @param opt a hash of options for the SQL creation string(s); see @ref AbstractTable::TableCreationOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or @ref nothing if there are none

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateMiscSql(*hash opt) {
            return t.getCreateMiscSql(opt);
        }

        #! returns a list of SQL strings that could be used to create triggers on the table or @ref nothing if there are no triggers on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateTriggersSql();
            @endcode

            @param opt a hash of options for the trigger creation strings; see @ref AbstractTable::TableCreationOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that could be used to create triggers on the table or @ref nothing if there are no triggers on the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateTriggersSql(*hash opt) {
            return t.getCreateTriggersSql(opt);
        }

        #! accepts an AbstractTable argument and returns a list of SQL strings required to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $table.getAlignSql($table2);
            @endcode

            @param table the template table that the current table will be compared to
            @param opt a hash of options for the SQL creation string; see @ref AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings required to align the structure and configuration of the current table with that of the AbstractTable argument; if the tables are identical then an empty list is returned

            @throw TABLE-COMPATIBILITY-ERROR the argument must be of the same class as the current object
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        list getAlignSql(AbstractTable table, *hash opt) {
            return t.getAlignSql(table, opt);
        }

        #! accepts an AbstractTable argument and returns a list of SQL strings required to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $table.getAlignSql($table2);
            @endcode

            @param table the template table that the current table will be compared to
            @param opt a hash of options for the SQL creation string; see @ref AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings required to align the structure and configuration of the current table with that of the AbstractTable argument; if the tables are identical then an empty list is returned

            @throw TABLE-COMPATIBILITY-ERROR the argument must be of the same class as the current object
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        list getAlignSql(Table table, *hash opt) {
            return t.getAlignSql(table.t, opt);
        }

        #! accepts an AbstractTable argument and returns an SQL string that could be executed to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty string is returned
        /** @par Example:
            @code
my string $sql = $table.getAlignSqlString($table2);
            @endcode

            @param table the template table that the current table will be compared to
            @param opt a hash of options for the SQL creation string; see @ref AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that could be executed to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty string is returned

            @throw ALIGN-TABLE-ERROR the argument must be of the same class as the current object; template table has no columns
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        string getAlignSqlString(AbstractTable table, *hash opt) {
            return t.getAlignSqlString(table, opt);
        }

        #! accepts an AbstractTable argument and returns an SQL string that could be executed to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty string is returned
        /** @par Example:
            @code
my string $sql = $table.getAlignSqlString($table2);
            @endcode

            @param table the template table that the current table will be compared to
            @param opt a hash of options for the SQL creation string; see @ref AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that could be executed to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty string is returned

            @throw ALIGN-TABLE-ERROR the argument must be of the same class as the current object; template table has no columns
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        string getAlignSqlString(Table table, *hash opt) {
            return t.getAlignSqlString(table.t, opt);
        }

        #! finds a row in the table with the given primary key value; if no row matches the primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *hash $row = $table.find($id);
            @endcode

            @param id the primary key ID to find

            @return a hash of the row value matching the primary key ID or @ref nothing if no row matches the primary key value passed

            @throw PRIMARY-KEY-ERROR the table has no primary key or the primary key has more than one column
         */
        *hash find(any id) {
            return t.find(id);
        }

        #! finds rows in the table with the given primary key values; if no row matches any primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *list $rows = $table.find($list);
            @endcode

            @param ids the list of primary key IDs to find

            @return a list of hashes of rows matching the primary key IDs passed or @ref nothing if no row matches any primary key value passed

            @throw PRIMARY-KEY-ERROR the table has no primary key or the primary key has more than one column
         */
        *list find(list ids) {
            return t.find(ids);
        }

        #! finds a row in the table with the given primary key value given as a hash; if no row matches the primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *hash $row = $table.find($id);
            @endcode

            @param row a hash giving the primary key value to find; other columns may also appear in the hash, however at least all columns of the primary key must be present

            @return a hash of the row value matching the primary key value passed or @ref nothing if no row matches the primary key value passed

            @throw PRIMARY-KEY-ERROR the table has no primary key or the the hash passed does not contain all columns of the primary key
         */
        *hash find(hash row) {
            return t.find(row);
        }

        #! reads in all attributes of the table from the database
        /** @par Example:
            @code
$table.cache();
            @endcode

            @param opts cache options; see @ref AbstractTable::CacheOptions for common options; each driver can support additional driver-specific options
        */
        cache(*hash opts) {
            t.cache(opts);
        }

        #! returns an object of class Columns describing the Table
        /** @par Example:
            @code
my Columns $cols = $table.describe();
            @endcode

            @return an object of class Columns describing the Table
        */
        Columns describe() {
            return t.describe();
        }

        #! returns an object of class AbstractPrimaryKey describing the primary key of the table
        /** If there is no primary key then the object returned will be empty (see @ref SqlUtil::AbstractPrimaryKey::empty())

            @par Example:
            @code
my AbstractPrimaryKey $cols = $table.getPrimaryKey();
            @endcode

            @return an object of class AbstractPrimaryKey describing the primary key of the table
        */
        AbstractPrimaryKey getPrimaryKey() {
            return t.getPrimaryKey();
        }

        #! returns an object of class Indexes describing the indexes on the table
        /** If there are no indexes on the table then the object returned will be empty (see @ref SqlUtil::Indexes::empty())

            @par Example:
            @code
my Indexes $ix = $table.getIndexes();
            @endcode

            @return an object of class Indexes describing the indexes on the table
        */
        Indexes getIndexes() {
            return t.getIndexes();
        }

        #! returns an object of class Triggers describing the triggers on the table
        /** If there are no triggers on the table then the object returned will be empty (see @ref SqlUtil::Triggers::empty())

            @par Example:
            @code
my Triggers $trig = $table.getTriggers();
            @endcode

            @return an object of class Triggers describing the triggers on the table
        */
        Triggers getTriggers() {
            return t.getTriggers();
        }

        #! returns a ForeignConstraints object describing the foreign constraints that the table has on other tables
        ForeignConstraints getForeignConstraints(*hash opt) {
            return t.getForeignConstraints(opt);
        }

        #! returns a Constraints object describing non-foreign constraints on the table
        Constraints getConstraints() {
            return t.getConstraints();
        }

        #! returns the database driver name 
        string getDriverName() {
            return t.getDriverName();
        }
    }

    #! the base abstract class for the table implementation
    public class AbstractTable inherits AbstractSqlUtilBase {
        public {
            #! table options
            const TableOptions = (
                "native_case": Type::Boolean,
                "table_cache": Type::Hash,
                );

            #! default index options
            const IndexOptions = (
                "index_tablespace": Type::String,
                "replace": Type::Boolean,
                );

            #! default constraint options
            const ConstraintOptions = IndexOptions;

            #! default cache options
            const CacheOptions = (
                "table_cache": Type::Hash,
                );

            #! default foreign constraint options
            const ForeignConstraintOptions = ConstraintOptions + (
                "table_cache": Type::Hash,
                );

            #! default trigger options
            const TriggerOptions = AbstractDatabase::CreationOptions;

            #! table creation options
            const TableCreationOptions = IndexOptions + AbstractDatabase::CreationOptions;

            #! table alignment options
            const AlignTableOptions = TableCreationOptions + (
                "column_map": Type::Hash,
                "index_map": Type::Hash,
                "constraint_map": Type::Hash,
                "trigger_map": Type::Hash,
                "db_table_cache": Type::Hash,
                );

            #! Table description options
            const TableDescriptionHashOptions = (
                "columns": Type::Hash,
                "primary_key": Type::Hash,
                "indexes": Type::Hash,
                "triggers": Type::Hash,
                "foreign_constraints": Type::Hash,
                "unique_constraints": Type::Hash,
                #"check_constraints": Type::Hash,
                "table_cache": Type::Hash,
                );

            #! Column options
            const ColumnOptions = (
                "qore_type": Type::String,
                "native_type": Type::String,
                "size": Type::Int,
                "scale": Type::Int,
                "default_value": NOTHING,
                "comment": Type::String,
                );

            /** @defgroup upsert_options Upsert Options
                These options are used with @ref AbstractTable::upsert() and @ref AbstractTable::upsertNoCommit() when synchornizing table data
             */
            #@{
            #! Upsert option: insert first
            /** with this option an insert is attempted, and if it fails due to a duplicate row, then an update is made unconditionally
             */
            const UpsertInsertFirst = 1;

            #! Upsert option: update first
            /** with this option an update is attempted, and if it fails due to a missing row, then an insert is performed
             */
            const UpsertUpdateFirst = 2;

            #! Upsert option: select first
            /** with this option the row is selected, if it doesn't exist, an insert is made, and an update is made only if the values are different
             */
            const UpsertSelectFirst = 3;
            #@}

            /** @defgroup upsert_results Upsert Result Codes
                @see @ref UpsertResultMap
             */
            #@{
            #! row was inserted
            const UR_Inserted = 1;
            
            #! row was updated
            const UR_Updated = 2;

            #! row was unchanged (only possible with @ref UpsertSelectFirst)
            const UR_Unchanged = 3;
            #@}

            #! hash mapping upsert results to a description
            const UpsertResultMap = (
                UR_Inserted: "inserted",
                UR_Updated: "updated",
                UR_Unchanged: "unchanged",
                );
        }

        private {
            #! the table's name
            string name;
            #! column description object
            Columns columns;
            #! primary key description
            *AbstractPrimaryKey primaryKey;
            #! index descriptions
            Indexes indexes;
            #! foreign constraints description
            ForeignConstraints foreignConstraints;
            #! constraint descriptions
            Constraints constraints;
            #! trigger descriptions
            Triggers triggers;
            #! native case option
            bool native_case = False;
            #! in database
            bool inDb = False;
            #! manual edits
            bool manual = False;
        }

        #! creates the object; private constructor
        /** @param nds the AbstractDatasource for the connection to the database
            @param nname the name of the table
            @param nopts an optional hash of options for the table creation string; see @ref AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        private constructor(AbstractDatasource nds, string nname, *hash nopts) : AbstractSqlUtilBase(nds, nopts) {
            name = nname;
            doTableOptions(nopts);
        }

        private doTableOptions(*hash nopts) {
            validateOptionsIntern("OPTION-ERROR", getTableOptions(), \nopts);
            if (nopts.native_case)
                native_case = True;
        }

        #! returns @ref Qore::True "True" if the table has been read from or created in the database, @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $table.inDb();
            @endcode

            @return @ref Qore::True "True" if the table has been read from or created in the database, @ref Qore::False "False" if not
         */
        bool inDb() {
            return inDb;
        }

        #! drops the table from the database; releases the transaction lock after dropping the table
        /** @par Example:
            @code
$table.drop();
            @endcode

            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @throw OPTION-ERROR invalid or unknown callback option

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref dropNoCommit() to execute without any transaction management
         */
        drop(*hash opt) {
            on_exit ds.commit();
            on_error ds.rollback();
            dropNoCommit(opt);
        }

        #! drops the table from the database without any transaction management
        /** @par Example:
            @code
$table.dropNoCommit();
            @endcode

            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @throw OPTION-ERROR invalid or unknown callback option

            @note Transaction management is normally not performed when dropping tables, however this method uses the Qore::SQL::AbstractDatasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        dropNoCommit(*hash opt) {
            ds.exec(AbstractDatabase::doCallback(opt, getDropSql(), "dropping table %s", getSqlName()));
            inDb = False;
        }

        #! returns the sql required to drop the table; reimplement in subclasses if necessary
        /** @par Example:
            @code
            @endcode

            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return a list of strings that can be used to drop the table and any other objects assocatied with the table (for example: PostgreSQL table trigger function(s))

            @throw OPTION-ERROR invalid or unknown callback option
        */
        softlist getDropSql(*hash opt) {
            return AbstractDatabase::doCallback(opt, getDropSqlImpl(), "dropping table %s", getSqlName());
        }

        #! truncates all the table data; releases the transaction lock after executing
        /** @par Example:
            @code
$table.truncate();
            @endcode

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref truncateNoCommit() to execute without any transaction management
         */
        truncate() {
            on_exit ds.commit();
            on_error ds.rollback();
            truncateNoCommit();
        }

        #! truncates all the table data without any transaction management
        /** @par Example:
            @code
$table.truncateNoCommit();
            @endcode

            @note Transaction management may not be applied when truncating tables depending on the database driver (for example truncating tables in Oracle does not participate in transaction management), however this method uses the Qore::SQL::AbstractDatasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        truncateNoCommit() {
            ds.exec("truncate table %s", getSqlName());
            inDb = False;
        }
        
        #! creates the table in the database; releases the transaction lock after creating the table
        /** @par Example:
            @code
$table.create();
            @endcode

            @param opt a hash of options for the SQL creation strings

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref createNoCommit() to execute without any transaction management
         */
        create(*hash opt) {
            on_exit ds.commit();
            on_error ds.rollback();
            createNoCommit(opt);
        }

        #! creates the table with all associated properties (indexes, constraints, etc) without any transaction management
        /** @par Example:
            @code
$table.createNoCommit();
            @endcode

            @param opt a hash of options for the SQL creation strings

            @note Transaction management is normally not performed when creating tables, however this method uses the Qore::SQL::AbstractDatasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.

            @throw CREATE-TABLE-ERROR table has already been read from or created in the database
         */
        createNoCommit(*hash opt) {
            if (inDb) 
                throw "CREATE-TABLE-ERROR", sprintf("table %s has already been read from or created in the database", getSqlName());

            # get and execute all the creation strings
            map ds.exec($1), getCreateSql(opt, False);
            inDb = True;
            manual = False;
        }

        #! renames the table; if the table is already known to be in the database in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
$table.rename("new_name");
            @endcode

            @param new_name the new name for the table
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @see getRenameSql()
        */
        rename(string new_name, *reference sql) {
            l.lock();
            on_exit l.unlock();

            execSql(sql = getRenameSqlImpl(name, new_name));
            name = new_name;
        }

        #! returns @ref Qore::True "True" if the table has no definitions, @ref Qore::False "False" if not
        bool empty() {
            l.lock();
            on_exit l.unlock();
            return emptyUnlocked();
        }

        private bool emptyUnlocked() {
            if (!columns.empty()
                || !primaryKey.empty()
                || !indexes.empty()
                || !foreignConstraints.empty()
                || !constraints.empty()
                || !triggers.empty())
                return False;

            return emptyImpl();
        }

        #! creates the object from a table description hash
        /** @param desc a @ref table_desc_hash "table description hash" describing the table
            @param opt an optional hash of options for the table creation string; see @ref AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw DESCRIPTION-ERROR invalid or unsupported description hash value passed
        */
        setupTable(hash desc, *hash opt) {
            # check description
            validateOptionsIntern("DESCRIPTION-ERROR", getTableDescriptionHashOptions(), \desc);

            # check options
            hash copt = getColumnOptions();
            validateOptionsIntern("OPTION-ERROR", getTableCreationOptions() + copt, \opt);

            l.lock();
            on_exit l.unlock();

            if (!emptyUnlocked())
                throw "DESCRIPTION-ERROR", sprintf("%s: cannot set up a non-empty table from a hash description", name);

            # add current table to cache
            opt.table_cache{name} = self;

            string drv = ds.getDriverName();

            # extract column options
            *hash oc = opt.(copt.keys());

            # add columns to table
            AbstractDatabase::checkDriverOptions(\desc.columns, drv);
            foreach string cn in (desc.columns.keyIterator()) {
                if (desc.columns{cn}.typeCode() != NT_HASH)
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to column key %y is not a hash, got type %y instead (%y)", name, cn, desc.columns{cn}.type(), desc.columns{cn});
                hash ch = desc.columns{cn};
                softbool nullable = !exists ch.notnull ? True : !(remove ch.notnull);
                addColumnUnlocked(cn, ch + oc, nullable ? True : False, oc);
            }

            # add indexes to table
            AbstractDatabase::checkDriverOptions(\desc.indexes, drv);
            foreach string ixn in (desc.indexes.keyIterator()) {
                if (desc.indexes{ixn}.typeCode() != NT_HASH)
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to index key %y is not a hash, got type %y instead (%y)", name, ixn, desc.indexes{ixn}.type(), desc.indexes{ixn});

                hash ih = desc.indexes{ixn};

                if (!ih.columns || !inlist(ih.columns.typeCode(), (NT_LIST, NT_STRING)))
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to \"columns\" key for index %y is not a list or a string, got type %y instead (%y)", name, ixn, ih.columns.type(), ih.columns);
                
                addIndexUnlocked(ixn, ih.unique ? True : False, ih.columns, opt.(getIndexOptions().keys()));
            }

            # add primary key to table
            AbstractDatabase::checkDriverOptions(\desc.primary_key, drv);
            if (desc.primary_key) {
                if (desc.primary_key.typeCode() != NT_HASH)
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to primary_key is not a hash, got type %y instead (%y)", name, desc.primary_key.type(), desc.primary_key);
                if (!desc.primary_key.name || desc.primary_key.name.typeCode() != NT_STRING)
                    throw "DESCRIPTION-ERROR", sprintf("%s: missing string value for 'name' key in primary_key hash: %y", name, desc.primary_key);
                
                addPrimaryKeyUnlocked(desc.primary_key.name, desc.primary_key.columns, opt.(getConstraintOptions().keys()));
            }

            # add unique constraints to table
            AbstractDatabase::checkDriverOptions(\desc.unique_constraints, drv);
            foreach string un in (desc.unique_constraints.keyIterator()) {
                if (desc.unique_constraints{un}.typeCode() != NT_HASH)
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to index key %y is not a hash, got type %y instead (%y)", name, un, desc.unique_constraints{un}.type(), desc.unique_constraints{un});

                hash ch = desc.unique_constraints{un};

                if (!ch.columns || !inlist(ch.columns.typeCode(), (NT_LIST, NT_STRING)))
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to \"columns\" key for unique constraint %y is not a list or a string, got type %y instead (%y)", name, un, ch.columns.type(), ch.columns);
                
                addUniqueConstraintUnlocked(un, ch.columns, opt.(getConstraintOptions().keys()));
            }
            
            # add foreign constraints to table
            AbstractDatabase::checkDriverOptions(\desc.foreign_constraints, drv);
            foreach string cn in (desc.foreign_constraints.keyIterator()) {
                if (desc.foreign_constraints{cn}.typeCode() != NT_HASH)
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to foreign constraint key %y is not a hash, got type %y instead (%y)", name, cn, desc.foreign_constraints{cn}.type(), desc.foreign_constraints{cn});

                hash ch = desc.foreign_constraints{cn};

                if (!ch.columns || !inlist(ch.columns.typeCode(), (NT_LIST, NT_STRING)))
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to \"columns\" key for foreign constraint %y is not a list or a string, got type %y instead (%y)", name, cn, ch.columns.type(), ch.columns);

                if (!ch.table || ch.table.typeCode() != NT_STRING)
                    throw "DESCRIPTION-ERROR", sprintf("%s: missing string value for \"table\" key in foreign constraint %y description: %y", name, cn, ch);

                if (exists ch.target_columns && !inlist(ch.target_columns.typeCode(), (NT_LIST, NT_STRING)))
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to \"target_columns\" key for foreign constraint %y is not a list or a string, got type %y instead (%y)", name, cn, ch.target_columns.type(), ch.target_columns);
                
                if (!ch.target_columns)
                    ch.target_columns = ch.columns;
                addForeignConstraintUnlocked(cn, ch.columns, ch.table, ch.target_columns, opt.(getForeignConstraintOptions().keys()));
            }

            # add triggers to table
            AbstractDatabase::checkDriverOptions(\desc.triggers, drv);
            foreach string tn in (desc.triggers.keyIterator()) {
                if (desc.triggers{tn}.typeCode() != NT_STRING)
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to trigger key %y is not a string giving the trigger source code, got type %y instead (%y)", name, tn, desc.triggers{tn}.type(), desc.triggers{tn});
                string src = desc.triggers{tn};
                
                addTriggerUnlocked(tn, src, opt.(getTriggerOptions().keys()));
            }
            
            setupTableImpl(desc, opt);
        }

        #! adds a column to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
$table.addColumn("name", ("qore_type": Type::String, "size": 50), False);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column
            @param opt a hash describing the column; the following keys are permitted (other column options may be supported depending on the underlying AbstractTable implementation):
            - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion;
            - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
            - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
            - \c scale: for numeric data types, this value gives the scale
            - \c default_value: the default value for the column
            @param nullable if @ref Qore::True "True" then the column can hold NULL values; note that primary key columns cannot be nullable
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @throw COLUMN-ERROR no \c native_type or \c qore_type keys in column option hash, column already exists, invalid column data

            @note make sure and add a \c default_value value when adding a column with a \c "not null" constraint with existing data

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractColumn addColumn(string cname, hash opt, bool nullable = True, *reference lsql) {
            l.lock();
            on_exit l.unlock();

            return addColumnUnlocked(cname, opt, nullable, \lsql);
        }

        private AbstractColumn addColumnUnlocked(string cname, hash opt, bool nullable = True, *reference lsql) {
            if (!columns)
                columns = new Columns();
            else if (columns.hasKey(cname))
                throw "COLUMN-ERROR", sprintf("%s.%s: this column already exists", name, cname);    

            if (!opt.native_type && !opt.qore_type)
                throw "COLUMN-ERROR", sprintf("%s.%s: no native_type or qore_type keys in column option hash: %y", name, cname, opt);

            validateColumnOptions(cname, \opt, nullable);

            # get the new column object
            AbstractColumn c = addColumnImpl(cname, opt, nullable);

            # add column in table if the table is already known to be in the database
            execSql(lsql = c.getCreateSql(self));

            # add the column to the internal column representation
	    columns.add(cname, c);
            return c;
        }

        #! modifies an existing column in the table; if the table is already known to be in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally and the new column definition will be created when create() is called for example
        /** @par Example:
            @code
$table.modifyColumn("name", ("qore_type": Type::String, "size": 240), False);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column
            @param opt a hash describing the column; the following keys are permitted (other column options may be supported depending on the underlying AbstractTable implementation):
            - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion;
            - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
            - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
            - \c scale: for numeric data types, this value gives the scale
            - \c default_value: the default value for the column
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @param nullable if @ref Qore::True "True" then the column can hold NULL values; note that primary key columns cannot be nullable

            @throw COLUMN-ERROR no \c native_type or \c qore_type keys in column option hash, column does not exist, invalid column data

            @note make sure and add a \c default_value value when modifying a column to have a \c "not null" constraint with existing data

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractColumn modifyColumn(string cname, hash opt, bool nullable = True, *reference lsql) {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            if (!columns.hasKey(cname))
                throw "COLUMN-ERROR", sprintf("%s.%s: the given column does not exist", name, cname);    

            if (!opt.native_type && !opt.qore_type)
                throw "COLUMN-ERROR", sprintf("%s.%s: no native_type or qore_type keys in column option hash: %y", name, cname, opt);

            validateColumnOptions(cname, \opt, nullable);

            # get the new column object
            AbstractColumn c = addColumnImpl(cname, opt, nullable);
            
            # add column in table if the table already exists in the DB
            execSql(lsql = columns{cname}.getModifySql(self, c));

            # replaces the column in the internal column representation with the new definition
	    columns.add(cname, c);
            return c;
        }

        #! renames an existing column; if the table is already known to be in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
my AbstractColumn $col = $table.renameColumn("name", "family_name");
            @endcode

            @return the column object that was updated

            @throw COLUMN-ERROR if the given column does not exist in the table

            @see modifyColumn() for a method that allows the column definition to be updated

            @note if any primary key or foreign table constraints refer to the column, the internal representations are also renamed, however check constraints are not updated and will be invalid if they refer to the renamed column
        */
        AbstractColumn renameColumn(string old_name, string new_name, reference sql) {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            if (!columns.hasKey(old_name))
                throw "COLUMN-ERROR", sprintf("%s.%s: the given column does not exist", name, old_name);

            return renameColumnIntern(old_name, new_name, \sql);
        }

        private AbstractColumn renameColumnIntern(string old_name, string new_name, reference sql) {
            AbstractColumn c = columns{old_name};
            
            # add column in table if the table already exists in the DB
            execSql(sql = c.getRenameSql(self, new_name));

            # rename column after database is updated
            c.name = new_name;

            # replaces the column in the internal column representation with the new definition
	    columns.renameKey(old_name, new_name);

            # now rename column in any constraints
            # check primary key
            if (primaryKey && primaryKey.hasKey(old_name))
                primaryKey.renameKey(old_name, new_name);

            # check foreign constraints
            foreach AbstractForeignConstraint fk in (foreignConstraints.iterator()) {
                if (fk.columns.hasKey(old_name))
                    fk.columns.renameKey(old_name, new_name);
            }

            # check unique constraints
            foreach AbstractConstraint ac in (constraints.iterator()) {
                if (!(ac instanceof AbstractUniqueConstraint))
                    continue;
                AbstractUniqueConstraint uc = cast<AbstractUniqueConstraint>(ac);
                if (uc.hasKey(old_name))
                    uc.renameKey(old_name, new_name);
            }

            # FIXME: check constraints are not updated

            return c;
        }

        private validateOptionsIntern(string err, hash ropt, reference opt) {
            AbstractSqlUtilBase::validateOptionsIntern(err, ropt, \opt, name);
        }

        private validateOptionsIntern(string err, hash ropt, reference opt, string tag) {
            AbstractSqlUtilBase::validateOptionsIntern(err, ropt, \opt, tag);
        }

        private execSql(softlist lsql) {
            #map printf("%s;\n", $1), lsql;
            if (inDb) {
                on_success ds.commit();
                on_error ds.rollback();
                map ds.exec($1), lsql;
            }
            else 
                manual = True;
        }

        #! adds a primary key to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractPrimaryKey $pk = $table.addPrimaryKey("pk_mytable", "id", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param pkname the name of the new primary key constraint
            @param cols a single column name or a list of columns that make up the primary key
            @param opt a hash of options for the new primary key; each driver may implement its own options; for common options, see @ref ConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractPrimaryKey object corresponding to the primary key created

            @throw PRIMARY-KEY-ERROR the table already has a primary key or invalid columns or options passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractPrimaryKey addPrimaryKey(string pkname, softlist cols, *hash opt, *reference sql) {
            l.lock();
            on_exit l.unlock();

            return addPrimaryKeyUnlocked(pkname, cols, opt, \sql);
        }

        private AbstractPrimaryKey addPrimaryKeyUnlocked(string pkname, softlist cols, *hash opt, *reference sql) {
            getColumnsUnlocked();
            if (!manual)
                getIndexesUnlocked();

            # load constraints if needed, verify unique constraint name, validate/process options
            checkUniqueConstraintNameValidateOptions("PRIMARY-KEY-ERROR", pkname, getConstraintOptions(), \opt);

            if (!primaryKey.empty())
                throw "PRIMARY-KEY-ERROR", sprintf("%s add primary key %y: already has primary key %y with columns: %y", name, pkname, primaryKey.getName(), primaryKey.keys());

            if (!cols)
                throw "PRIMARY-KEY-ERROR", sprintf("%s add primary key %y: no column names passed to %s::addPrimaryKey()", name, pkname, self.className());

            hash ch;
            while (cols) {
                any v = shift cols;
                if (v.typeCode() != NT_STRING)
                    throw "PRIMARY-KEY-ERROR", sprintf("%s add primary key %y: %y argument passed as column name to %s::addPrimaryKey(); expecting \"string\" (value: %y)", name, pkname, v.type(), self.className(), v);
                if (!columns.hasKey(v))
                    throw "PRIMARY-KEY-ERROR", sprintf("%s add primary key %y: table has no column named %y", name, pkname, v);
                ch{v} = columns{v};
            }

            # get the new primary key object
            AbstractPrimaryKey pk = addPrimaryKeyImpl(pkname, ch, opt);
            
            # find matching index for unique constraint
            pk.findMatchingIndex(indexes);

            # add pk to table if the table already exists in the DB
            execSql(sql = pk.getCreateSql(getSqlName()));

            # set as primary key for the table
            return primaryKey = pk;
        }

        #! drops the primary key from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropPrimaryKey();
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the primary key dropped from the table

            @throw PRIMARY-KEY-ERROR no primary key exists

            @note this method retrieves the primary key definition from the database if none has already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractPrimaryKey dropPrimaryKey(*reference sql) {
            l.lock();
            on_exit l.unlock();
            getPrimaryKeyUnlocked();
            if (primaryKey.empty())
                throw "PRIMARY-KEY-ERROR", sprintf("%s: has no primary key", name);

            # drop pk from table if the table already exists in the DB
            execSql(sql = primaryKey.getDropSql(getSqlName()));

            return remove primaryKey;
        }
        
        #! adds a unique constraint to the table; if the table is known to be in the database already, then the constraint is added to the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractUniqueConstraint $c = $table.addUniqueConstraint("uk_mytable", "name", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new unique constraint
            @param cols a single column name or a list of columns that make up the unique constraint
            @param opt a hash of options for the new unique constraint; each driver may implement its own options; for common options, see @ref AbstractTable::ConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractUniqueConstraint object corresponding to the unique constraint created

            @throw UNIQUE-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns passed
            @throw OPTION-ERROR invalid or unsupported option passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractUniqueConstraint addUniqueConstraint(string cname, softlist cols, *hash opt, *reference sql) {
            l.lock();
            on_exit l.unlock();
            return addUniqueConstraintUnlocked(cname, cols, opt, \sql);
        }

        private AbstractUniqueConstraint addUniqueConstraintUnlocked(string cname, softlist cols, *hash opt, *reference sql) {
            getColumnsUnlocked();
            if (!manual)
                getIndexesUnlocked();

            # load constraints if needed, verify unique constraint name, validate/process options
            checkUniqueConstraintNameValidateOptions("UNIQUE-CONSTRAINT-ERROR", cname, getConstraintOptions(), \opt);

            if (!cols)
                throw "UNIQUE-CONSTRAINT-ERROR", sprintf("%s add unique constraint %y: no column names passed to %s::addUniqueConstraint()", name, cname, self.className());

            hash ch;
            while (cols) {
                any v = shift cols;
                if (v.typeCode() != NT_STRING)
                    throw "PRIMARY-KEY-ERROR", sprintf("%s add unique constraint %y: %y argument passed as column name to %s::addUniqueConstraint(); expecting \"string\" (value: %y)", name, cname, v.type(), self.className(), v);
                if (!columns.hasKey(v))
                    throw "PRIMARY-KEY-ERROR", sprintf("%s add unique constraint %y: table has no column named %y", name, cname, v);
                ch{v} = columns{v};
            }

            # get the new constraint object
            AbstractUniqueConstraint c = addUniqueConstraintImpl(cname, ch, opt);
            
            # find matching index for unique constraint
            c.findMatchingIndex(indexes);

            # add foreign constraint to table in the DB if the table already exists in the DB
            execSql(sql = c.getCreateSql(getSqlName()));

            # set as constraint for the table
            if (!constraints)
                constraints = new Constraints();
            constraints.add(cname, c);

            # return the new constraint
            return c;
        }

        #! adds an index to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractIndex $ix = $table.addIndex("uk_mytable_name", True, "name", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param iname the name of the new index
            @param unique a flag to tell if the new index should be unique or not
            @param cols a single column name or a list of columns that make up the index
            @param opt a hash of options for the new index; each driver may implement its own options; for common options, see @ref IndexOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractIndex object corresponding to the index created

            @throw INDEX-ERROR the table already has an index with the given name or invalid columns or options were passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractIndex addIndex(string iname, bool unique, softlist cols, *hash opt, *reference sql) {
            l.lock();
            on_exit l.unlock();

            return addIndexUnlocked(iname, unique, cols, opt, \sql);
        }

        private AbstractIndex addIndexUnlocked(string iname, bool unique, softlist cols, *hash opt, *reference sql) {
            getColumnsUnlocked();
            if (inDb)
                getIndexesUnlocked();

            if (!indexes)
                indexes = new Indexes();
            else if (indexes.hasKey(iname))
                throw "INDEX-ERROR", sprintf("%s: already has an index named %y with columns: %y", name, iname, indexes{iname}.columns.keys());

            if (!cols)
                throw "INDEX-ERROR", sprintf("%s: no column names passed to %s::addIndex()", name, self.className());

            hash ch;
            while (cols) {
                any v = shift cols;
                if (v.typeCode() != NT_STRING)
                    throw "INDEX-ERROR", sprintf("%s: %y argument passed as column name to %s::addIndex(); expecting \"string\" (value: %y)", name, v.type(), self.className(), v);
                # only check for column if the index is not a function index
                if (!columns.hasKey(v)) {
                    if (v !~ /\(.*\)/)
                        throw "INDEX-ERROR", sprintf("%s: has no column named %y", name, v);
                    ch{v} = hash();
                }
                else
                    ch{v} = columns{v};
            }

            # validate options
            hash ixopt = getIndexOptions();
            validateOptionsIntern("INDEX-ERROR", ixopt, \opt);

            # get the new index object
            AbstractIndex ix = addIndexImpl(iname, unique, ch, opt);
            
            # add index to table in the DB if the table already exists in the DB
            execSql(sql = ix.getCreateSql(getSqlName(), opt));

            # set as index for the table
            indexes.add(iname, ix);

            # return the new index
            return ix;
        }

        #! renames an existing index; if the table is already known to be in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
my AbstractIndex $ix = $table.renameIndex("uk_table_name", "unique_table_name");
            @endcode

            @param old_name the current name of the index
            @param new_name the new name for the index
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)
            @return the index object that was updated

            @throw INDEX-ERROR if the old index does not exist in the table or if the new index name already exists
        */
        AbstractIndex renameIndex(string old_name, string new_name, reference sql) {
            l.lock();
            on_exit l.unlock();
            getIndexesUnlocked();
            
            AbstractIndex ix;

            code rename;

            if (!indexes || !indexes.hasKey(old_name))
                throw "INDEX-ERROR", sprintf("%s: has no index %y; valid index: %y", name, old_name, indexes.keys());

            ix = indexes{old_name};
            rename = sub () { indexes.renameKey(old_name, new_name); };

            # rename index in table if the table already exists in the DB
            execSql(sql = ix.getRenameSql(getSqlName(), new_name));

            ix.name = new_name;

            # rename index in container structure
            rename();
            
            # return the updated index
            return ix;
        }

        #! drops the given index from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropIndex("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param iname the name of the index to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the index dropped from the table

            @throw INDEX-ERROR the given index does not exist

            @note this method retrieves all current index definitions from the database if none have already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractIndex dropIndex(string iname, *reference sql) {
            l.lock();
            on_exit l.unlock();
            getIndexesUnlocked();
            if (!indexes.hasKey(iname))
                throw "INDEX-ERROR", sprintf("%s: has no index %y; valid indexes: %y", name, iname, indexes.keys());

            # drop index from table if the table already exists in the DB
            execSql(sql = indexes{iname}.getDropSql(getSqlName()));

            # remove from index structure and return removed index
            return indexes.take(iname);
        }

        #! adds a foreign constraint to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractForeignConstraint $fc = $table.addForeignConstraint("fk_mytable_other_table", ("name", "version"), "other_table", NOTHING, \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new foreign constraint
            @param cols a single column name or a list of columns in the local table that make up the foreign constraint
            @param table the name of the other table that the constraint targets
            @param tcols a single column name or a list of columns in the foreign table or @ref nothing meaning that the column names are the same as in the local table; if column names are given the same number of columns must be given in the local and foreign tables
            @param opt a hash of options for the new foreign constraint; each driver may implement its own options; for common options, see @ref ForeignConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractForeignConstraint object corresponding to the foreign constraint created

            @throw FOREIGN-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns or options were passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractForeignConstraint addForeignConstraint(string cname, softlist cols, string table, *softlist tcols, *hash opt, *reference sql) {
            l.lock();
            on_exit l.unlock();

            return addForeignConstraintUnlocked(cname, cols, table, tcols, opt, \sql);
        }

        private Columns getReferencedTableColumnsUnlocked(string table, reference cache, string err = "FOREIGN-CONSTRAINT-ERROR") {
            if (table == name) {
                getColumnsUnlocked();
                return columns;
            }
            if (cache{table}) {
                if (cache{table} instanceof Table)
                    return cache{table}.getTable().describe();
                else if (cache{table} instanceof AbstractTable)
                    return cache{table}.describe();
                throw err, sprintf("cached table %y is not a Table or AbstractTable object; got %y instead (%y)", table, cache{table}.type(), cache{table});
            }
            return (cache{table} = new Table(ds, table).getTable()).describe();
        }

        private AbstractForeignConstraint addForeignConstraintUnlocked(string cname, softlist cols, string table, *softlist tcols, *hash opt, *reference sql) {
            getColumnsUnlocked();
            # load constraints if needed, verify unique constraint name, validate/process options
            checkUniqueConstraintNameValidateOptions("FOREIGN-CONSTRAINT-ERROR", cname, getForeignConstraintOptions(), \opt);

            if (!cols)
                throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y: no column names passed to %s::addForeignConstraint()", name, self.className());

            hash ch;
            while (cols) {
                any v = shift cols;
                if (v.typeCode() != NT_STRING)
                    throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y: %y argument passed as column name to %s::addForeignConstraint(); expecting \"string\" (value: %y)", name, v.type(), self.className(), v);
                if (!columns.hasKey(v))
                    throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y: has no column named %y", name, v);
                ch{v} = columns{v};
            }

            if (!tcols)
                tcols = ch.keys();

            # get target table description
            Columns targ_cols = getReferencedTableColumnsUnlocked(table, \opt.table_cache);
            hash tch;
            while (tcols) {
                any v = shift tcols;
                if (v.typeCode() != NT_STRING)
                    throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y target %y: %y argument passed as target column name to %s::addForeignConstraint(); expecting \"string\" (value: %y)", name, table, v.type(), self.className(), v);
                if (!targ_cols.hasKey(v))
                    throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y target %y: target table has no column named %y", name, table, v);
                tch{v} = targ_cols{v};
            }

            # get the new foreign constraint object
            AbstractForeignConstraint fk = addForeignConstraintImpl(cname, ch, table, tch, opt);
            
            # add foreign constraint to table in the DB if the table already exists in the DB
            execSql(sql = fk.getCreateSql(getSqlName()));

            # update cached tables with foreign constraint source info
            if (opt.table_cache{fk.target.table})
                opt.table_cache{fk.target.table}.addSourceConstraint(getSqlName(), fk);

            # set as foreign constraint for the table
            if (!foreignConstraints)
                foreignConstraints = new ForeignConstraints();
            foreignConstraints.add(cname, fk);

            # return the new foreign constraint
            return fk;
        }

        #! drops a foreign constraint from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropForeignConstraint("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the foreign constraint to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the foreign constraint dropped from the table

            @throw FOREIGN-CONSTRAINT-ERROR the given constraint does not exist

            @note this method retrieves all current foreign constraint definitions from the database if none have already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractForeignConstraint dropForeignConstraint(string cname, *reference sql) {
            l.lock();
            on_exit l.unlock();
            getForeignConstraintsUnlocked();
            if (!foreignConstraints.hasKey(cname))
                throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%s: has no foreign constraint %y; valid foreign constraints: %y", name, cname, foreignConstraints.keys());

            # drop foreign constraint from table if the table already exists in the DB
            execSql(sql = foreignConstraints{cname}.getDropSql(getSqlName()));

            # remove from foreign constraint structure and return removed foreign constraint
            return foreignConstraints.take(cname);
        }

        #! adds a check constraint to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractCheckConstraint $cc = $table.addCheckConstraint("check_mytable_id", "id > 10", NOTHING, \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new constraint
            @param src the source of the constraint clause
            @param opt a hash of options for the new constraint; each driver may implement its own options; for common options, see @ref ConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractCheckConstraint object corresponding to the check constraint created

            @throw CHECK-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns or options were passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractCheckConstraint addCheckConstraint(string cname, string src, *hash opt, *reference sql) {
            l.lock();
            on_exit l.unlock();
            return addCheckConstraintUnlocked(cname, src, opt, \sql);
        }

        private AbstractCheckConstraint addCheckConstraintUnlocked(string cname, string src, *hash opt, *reference sql) {
            # load constraints if needed, verify unique constraint name, validate/process options
            checkUniqueConstraintNameValidateOptions("CHECK-CONSTRAINT-ERROR", cname, getConstraintOptions(), \opt);

            # get the new constraint object
            AbstractCheckConstraint cc = addCheckConstraintImpl(cname, src, opt);
            
            # add foreign constraint to table in the DB if the table already exists in the DB
            execSql(sql = cc.getCreateSql(getSqlName()));

            # set as constraint for the table
            if (!constraints)
                constraints = new Constraints();
            constraints.add(cname, cc);

            # return the new constraint
            return cc;
        }

        #! renames an existing constraint; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint; if the table is already known to be in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
my AbstractConstraint $con = $table.renameConstraint("pk_table_name", "pkey_table_name");
            @endcode

            @param old_name the current name of the constraint
            @param new_name the new name for the constraint
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)
            @return the constraint object that was updated

            @throw CONSTRAINT-ERROR if the old constraint does not exist in the table or if the new constraint name already exists
        */
        AbstractConstraint renameConstraint(string old_name, string new_name, reference sql) {
            l.lock();
            on_exit l.unlock();
            getAllConstraintsUnlocked();
            
            AbstractConstraint c;

            code rename;

            if (constraints && constraints.hasKey(old_name)) {
                c = constraints{old_name};
                rename = sub () { constraints.renameKey(old_name, new_name); };
            }
            else {
                if (inDb) {
                    getPrimaryKeyUnlocked();
                    if (primaryKey && primaryKey.getName() == old_name) {
                        c = primaryKey;
                        # no need to update any container if the primary key is being updated
                        rename = sub () { };
                    }
                    else {
                        getForeignConstraintsUnlocked();
                        if (foreignConstraints && foreignConstraints.hasKey(old_name)) {
                            c = foreignConstraints{old_name};
                            rename = sub () { foreignConstraints.take(old_name); };
                        }
                    }
                }
            }
            
            if (!c) {
                list cl = ();
                # get a list of all constraint names
                cl += constraints.keys();
                if (primaryKey)
                    cl += primaryKey.getName();
                if (foreignConstraints)
                    cl += foreignConstraints.keys();
                throw "CONSTRAINT-ERROR", sprintf("%s: has no constraint %y; valid constraints: %y", name, old_name, cl);
            }

            # rename foreign constraint in table if the table already exists in the DB
            execSql(sql = c.getRenameSql(getSqlName(), new_name));

            c.rename(new_name);

            # rename constraint in container structure
            rename();
            
            # return the updated constraint
            return c;
        }

        #! drops a constraint from the table; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropConstraint("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the constraint to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the constraint dropped from the table

            @throw CONSTRAINT-ERROR the given constraint does not exist in the table

            @note this method retrieves current constraint definitions from the database if not already loaded or defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractConstraint dropConstraint(string cname, *reference sql) {
            l.lock();
            on_exit l.unlock();
            getAllConstraintsUnlocked();
            
            AbstractConstraint c;

            code rmv;

            if (constraints && constraints.hasKey(cname)) {
                c = constraints{cname};
                rmv = sub () { constraints.take(cname); };
            }
            else {
                if (inDb) {
                    getPrimaryKeyUnlocked();
                    if (primaryKey && primaryKey.getName() == cname) {
                        c = primaryKey;
                        rmv = sub () { remove primaryKey; };
                    }
                    else {
                        getForeignConstraintsUnlocked();
                        if (foreignConstraints && foreignConstraints.hasKey(cname)) {
                            c = foreignConstraints{cname};
                            rmv = sub () { foreignConstraints.take(cname); };
                        }
                    }
                }
            }
            
            if (!c) {
                list cl = ();
                # get a list of all constraint names
                cl += constraints.keys();
                if (primaryKey)
                    cl += primaryKey.getName();
                if (foreignConstraints)
                    cl += foreignConstraints.keys();
                throw "CONSTRAINT-ERROR", sprintf("%s: has no constraint %y; valid constraints: %y", name, cname, cl);
            }

            # drop foreign constraint from table if the table already exists in the DB
            execSql(sql = c.getDropSql(getSqlName()));

            # remove from foreign constraint structure and return removed foreign constraint
            rmv();
            return c;
        }

        #! adds a trigger to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractTrigger $trig = $table.addTrigger("trig_mytable", "", NOTHING, \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param tname the name of the new trigger
            @param src the source of the trigger
            @param opt a hash of options for the new trigger; each driver may implement its own options; for common options, see @ref TriggerOptions
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractTrigger object corresponding to the trigger created

            @throw TRIGGER-ERROR the table already has a trigger with the given name or invalid options were passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractTrigger addTrigger(string tname, string src, *hash opt, *reference lsql) {
            l.lock();
            on_exit l.unlock();

            return addTriggerUnlocked(tname, src, opt, \lsql);
        }

        private AbstractTrigger addTriggerUnlocked(string tname, string src, *hash opt, *reference lsql) {
            # load triggers if needed
            if (!manual)
                getTriggersUnlocked();

            # verify unique trigger name
            if (triggers && triggers.hasKey(tname))
                throw "TRIGGER-ERROR", sprintf("%y: already has a trigger named %y, drop the trigger before adding it", name, tname);

            # validate/process options
            validateOptionsIntern("TRIGGER-ERROR", getTriggerOptions(), \opt);

            # get the new constraint object
            AbstractTrigger trig = addTriggerImpl(tname, src, opt);
            
            # add foreign constraint to table in the DB if the table already exists in the DB
            execSql(lsql = trig.getCreateSql(getSqlName()));

            # store trigger in trigger container
            if (!triggers)
                triggers = new Triggers();

            triggers.add(tname, trig);

            # return the new trigger
            return trig;
        }

        #! drops the given trigger from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropTrigger("trig_mytable");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param tname the name of the trigger to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the database (only executed if the table is already in the database)

            @return the trigger dropped from the table

            @throw TRIGGER-ERROR the given trigger does not exist

            @note this method retrieves all current trigger definitions from the database if none have already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractTrigger dropTrigger(string tname, *reference sql) {
            l.lock();
            on_exit l.unlock();
            getTriggersUnlocked();
            if (!triggers.hasKey(tname))
                throw "TRIGGER-ERROR", sprintf("%s: has no trigger %y; valid triggers: %y", name, tname, triggers.keys());

            # drop trigger from table if the table already exists in the DB
            execSql(sql = triggers{tname}.getDropSql(getSqlName()));

            # remove from trigger structure and return removed trigger
            return triggers.take(tname);
        }

        private getAllConstraintsUnlocked(*hash opt) {
            if (manual)
                return;

            getPrimaryKeyUnlocked();
            getForeignConstraintsUnlocked(opt);
            getConstraintsUnlocked();
        }

        private checkUniqueConstraintName(string err, string cname) {
            getAllConstraintsUnlocked();
            if (foreignConstraints.hasKey(cname))
                throw err, printf("%y: already has a foreign constraint named %y with columns: %y", name, cname, foreignConstraints{cname}.columns.keys());

            if (constraints.hasKey(cname))
                throw err, printf("%y: already has a constraint named %y", name, cname);

            if (primaryKey && primaryKey.getName() == cname)
                throw err, printf("%y: already has a primary key constraint named %y with columns: %y", name, cname, primaryKey.columns.keys());
        }

        private checkUniqueConstraintNameValidateOptions(string err, string cname, hash ropt, reference opt) {
            checkUniqueConstraintName(err, cname);
            # validate options
            validateOptionsIntern(err, ropt, \opt);
        }

        #! validates column options
        private validateColumnOptions(string cname, reference opt, bool nullable) {
            hash copt = getColumnOptions();

            # check valid options and option value types
            validateOptionsIntern("COLUMN-ERROR", copt, \opt, sprintf("%s.%s", name, cname));
            
            hash otm = getTypeMapImpl();

            if (!opt.native_type) {
                hash qtm = getQoreTypeMapImpl();
                opt.native_type = qtm{opt.qore_type};
                if (!opt.native_type)
                    throw "COLUMN-ERROR", sprintf("%s.%s: qore type %y cannot be mapped to a column type (valid values: %y)", name, cname, opt.qore_type, qtm.keys());
            }
            else if (!otm{opt.native_type})
                throw "COLUMN-ERROR", sprintf("%s.%s: unknown native_type %y (valid values: %y)", name, cname, opt.native_type, otm.keys());

            # get native type description
            hash th = otm{opt.native_type};

            # reset qore type from native type
            opt.qore_type = th.qore;
            opt.local_def = th;

            if (exists opt.size) {
                if (!th.size)
                    throw "COLUMN-ERROR", sprintf("%s.%s: size %y given but type %y does not take a size attribute", name, cname, opt.size, opt.native_type);
                if (th.size_range && (opt.size < th.size_range[0] || opt.size > th.size_range[1]))
                    throw "COLUMN-ERROR", sprintf("%s.%s: size %y is not valid for type %y; must be between %d and %d inclusive", name, cname, opt.size, opt.native_type, th.size_range[0], th.size_range[1]);
            }
            else {
                if (th.size == SZ_MAND)
                    throw "COLUMN-ERROR", sprintf("%s.%s: type %y requires a size argument but none was supplied (options: %y)", name, cname, opt.native_type, opt);
                opt.size = 0;
            }

            if (th.size == SZ_NUM) {
                opt.precision = opt.size;
                opt.size = 0;
                if (opt.scale) {
                    if (th.scale_range && (opt.scale < th.scale_range[0] || opt.scale > th.scale_range[1]))
                        throw "COLUMN-ERROR", sprintf("%s.%s: scale %y is not valid for type %y; must be between %d and %d inclusive", name, cname, opt.scale, opt.native_type, th.scale_range[0], th.scale_range[1]);
                }
                else
                    opt.scale = 0;
            }
            else if (opt.scale) 
                throw "COLUMN-ERROR", sprintf("%s.%s: scale %y is not valid for type %y; it is not a numeric type", name, cname, opt.scale, opt.native_type);
            else
                opt.precision = opt.scale = 0;

            if (!opt.size && th.default_size)
                opt.size = th.default_size;
            
            # check type of default value (must match column type)
            if (exists opt.default_value) {
                checkValue(cname, "default_value", \opt.default_value, th.qore);
                opt.default_value = getSqlValue(opt.default_value);
            }
        }

        #! drops a column from the table
        /** @par Example:
            @code
$table.dropColumn("notes_2");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the AbstractColumn object representing the column dropped from the table

            @throw COLUMN-ERROR the named column is not present in the table

            @note this method retrieves the table definition from the database if none has already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractColumn dropColumn(string cname, *reference sql) {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            if (!columns.hasKey(cname))
                throw "COLUMN-ERROR", sprintf("%s.%s: no such column (valid columns: %y)", name, cname, columns.keys());
            # drop column from table if the table already exists in the DB
            execSql(sql = columns{cname}.getDropSql(getSqlName()));
            return columns.take(cname);
        }

        #! inserts a row into the table; the transaction is committed if successful, if an error occurs, it is rolled back
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
         */
        insert(hash row) {
            on_success ds.commit();
            on_error ds.rollback();

            insertNoCommit(row);
        }

        #! inserts a row into the table without any transaction management; a transaction will be in progress after this method is successfully executed
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
         */
        insertNoCommit(hash row) {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            string sql = sprintf("insert into %s (", getSqlName());
            foreach string k in (row.keyIterator()) {
                if (!columns{k})
                    throw "COLUMN-ERROR", sprintf("%s.%s is not a valid column (valid columns: %y)", name, k, columns.keys());
            }
            sql += (foldl $1 + "," + $2, row.keyIterator());
            sql += ") values (";
            sql += (foldl $1 + "," + $2, (map "%v", row.keyIterator()));
            sql += ")";

            ds.vexec(sql, row.values());
        }

        #! update or insert the data in the table according to the hash argument; the table must have a unique key to do this; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
$table.upsert($row);
            @endcode

            @param row a hash representing the row to insert or update
            @param upsert_type one of @ref UpsertInsertFirst, @ref UpsertUpdateFirst, or @ref UpsertSelectFirst for the upsert strategy

            @return an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note if upserting multiple rows; it's better to use getUpsertClosure() or getUpsertClosureValidation() and execute the closure on each row; when using this method, the overhead for setting up the upsert is made for each row which is very inefficient
         */
        int upsert(hash row, int upsert_type = UpsertInsertFirst) {
            on_success ds.commit();
            on_error ds.rollback();

            return upsertNoCommit(row, upsert_type);
        }

        #! update or insert the data in the table according to the hash argument; the table must have a unique key to do this
        /** @par Example:
            @code
$table.upsertNoCommit($row);
            @endcode

            @param row a hash representing the row to insert or update
            @param upsert_type one of @ref UpsertInsertFirst, @ref UpsertUpdateFirst, or @ref UpsertSelectFirst for the upsert strategy

            @return an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note if upserting multiple rows; it's better to use getUpsertClosure() or getUpsertClosureValidation() and execute the closure on each row; when using this method, the overhead for setting up the upsert is made for each row which is very inefficient
         */
        int upsertNoCommit(hash row, int upsert_type = UpsertInsertFirst) {
            l.lock();
            on_exit l.unlock();

            code upsert = getUpsertClosureUnlocked(row, upsert_type);

            return upsert(row);
        }

        #! returns a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the table must have a unique key to do this; the closure returned does not validate the input hash for validity
        /** @par Example:
            @code
my Datasource $ds("pgsql:user/pass@db%localhost");
my Table $table($ds, "table_name");
my code $upsert = $table.getUpsertClosure($row, AbstractTable::UpsertSelectFirst);
on_success $ds.commit();
on_error $ds.rollback();
map $upsert($1), $row_list;
            @endcode

            @param example_row a hash representing an example row to insert or update; every row passed to the upsert closure returned must have the same keys in the same order
            @param upsert_type one of @ref UpsertInsertFirst, @ref UpsertUpdateFirst, or @ref UpsertSelectFirst for the upsert strategy

            @return a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the closure returned does not validate the input hash for validity; the closure has the following signature: @code int sub upsert(hash $row) {} @endcode The return value of the closuse is an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note the row values passed to the closure for upserting are not checked if they match the example row passed to the getUpsertClosure() method; passing non-conforming data will cause errors; see @ref AbstractTable::getUpsertClosureWithValidation() for a similar method that returns a validating closure; the closure returned by this method is faster than the one returned by @ref AbstractTable::getUpsertClosure() since there is no validation
         */
        code getUpsertClosure(hash example_row, int upsert_type = UpsertInsertFirst) {
            l.lock();
            on_exit l.unlock();

            return getUpsertClosureUnlocked(example_row, upsert_type);
        }

        #! returns a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the table must have a unique key to do this; the closure returned does not validate the input hash for validity
        /** @par Example:
            @code
my Datasource $ds("pgsql:user/pass@db%localhost");
my Table $table($ds, "table_name");
my code $upsert = $table.getUpsertClosureWithValidation($row, AbstractTable::UpsertSelectFirst);
on_success $ds.commit();
on_error $ds.rollback();
map $upsert($1), $row_list;
            @endcode

            @param example_row a hash representing an example row to insert or update; every row passed to the upsert closure returned must have the same keys in the same order or the closure returned will throw an \c UPSERT-ERROR exception
            @param upsert_type one of @ref UpsertInsertFirst, @ref UpsertUpdateFirst, or @ref UpsertSelectFirst for the upsert strategy

            @return a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the closure has the following signature: @code int sub upsert(hash $row) {} @endcode The return value of the closuse is an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note the row values passed to the closure for upserting are checked if they match the example row passed to the getUpsertClosure() method; passing non-conforming data to the closure will cause the closure to throw an \c UPSERT-ERROR exception; see @ref AbstractTable::getUpsertClosure() for a similar method that returns a non-validating closure; the closure returned by this method is a little slower than the one returned by @ref AbstractTable::getUpsertClosure() since each row is validated
         */
        code getUpsertClosureWithValidation(hash example_row, int upsert_type = UpsertInsertFirst) {
            code upsert = getUpsertClosure(example_row, upsert_type);

            return int sub (hash row) {
                if (!row.compareKeys(example_row))
                    throw "UPSERT-ERROR", sprintf("the keys in the row passed to the upsert closure (%y) do not match the keys passed to AbstractTable::getUpsertClosureWithValidation() (%y)", row.keys, example_row.keys());
                return upsert(row);
            };
        }        

        private code getUpsertClosureUnlocked(hash row, int upsert_type = UpsertInsertFirst) {
            # unique column source
            string csrc;

            # get unique columns
            Columns cols = getUpsertColumns(\csrc);

            # column list: make sure all columns in the key are used and have a value
            list cl = ();
            foreach string k in (row.keyIterator()) {
                if (!columns{k})
                    throw "COLUMN-ERROR", sprintf("%s.%s is not a valid column (valid columns: %y)", name, k, columns.keys());
                if (cols.hasKey(k))
                    cl += k;
            }

            # if not all columns of the unique constraint are used, then throw an exception
            if (cl.size() != cols.size())
                throw "UPSERT-ERROR", sprintf("not all columns from %s are used in the upsert statement; required: %y; used: %y", csrc, columns.keys(), cl);

            # use UpsertSelectFirst if the row size == the key size (ie only key values are used)
            if (cols.size() == row.size())
                upsert_type = UpsertSelectFirst;

            switch (upsert_type) {
                case UpsertInsertFirst:
                    return getUpsertInsertFirst(cols, row);

                case UpsertUpdateFirst:
                    return getUpsertUpdateFirst(cols, row);

                case UpsertSelectFirst:
                    return getUpsertSelectFirst(cols, row);
            }

            throw "UPSERT-ERROR", sprintf("invalid upsert code: %d", upsert_type);
        }

        private code getUpsertInsertFirst(Columns cols, hash example_row) {
            string insert_sql = getInsertSql(example_row);
            list updc = ();
            string update_sql = getUpdateSql(example_row, cols, \updc);

            return int sub (hash row) {
                if (tryInsertImpl(insert_sql, row))
                    return UR_Inserted;
            
                tryUpdate(update_sql, row, cols, updc);
                return UR_Updated;            
            };
        }

        private code getUpsertUpdateFirst(Columns cols, hash example_row) {
            list updc = ();
            string update_sql = getUpdateSql(example_row, cols, \updc);
            string insert_sql = getInsertSql(example_row);

            return int sub (hash row) {
                if (tryUpdate(update_sql, row, cols, updc))
                    return UR_Updated;
                
                ds.vexec(insert_sql, row.values());
                return UR_Inserted;
            };
        }

        private code getUpsertSelectFirst(Columns cols, hash example_row) {
            #printf("getUpsertSelectFirst() %s: %y\n", name, cols.keys()); 
            list updc = ();
            string select_sql = getSelectSql(example_row, cols, \updc);
            string insert_sql = getInsertSql(example_row);
            string update_sql = getUpdateSql(example_row, cols, \updc);

            return int sub (hash row) {
                list args = row.(cols.keys()).values();
                #printf("select_sql: %s args: %y\n", select_sql, args);
                *hash dbrow = ds.vselectRow(select_sql, args);
                if (!dbrow) {
                    ds.vexec(insert_sql, row.values());
                    return UR_Inserted;
                }
                if (dbrow == row{updc})
                    return UR_Unchanged;

                printf("dbrow: %y row{%y}: %y\n", dbrow, updc, row{updc});
                tryUpdate(update_sql, row, cols, updc);
                return UR_Updated;
            };
        }

        private Columns getUpsertColumns(reference csrc) {
            getColumnsUnlocked();
            getPrimaryKeyUnlocked();

            Columns cols;

            if (!primaryKey.empty()) {
                cols = primaryKey;
                csrc = sprintf("primary key %s", primaryKey.getName());
            }
            else {
                getConstraintsUnlocked();
                # find first unique constraint
                foreach AbstractConstraint c in (constraints.iterator()) {
                    if (c instanceof AbstractUniqueConstraint) {
                        cols = cast<AbstractUniqueConstraint>(c);
                        csrc = sprintf("unique constraint %s", c.getName());
                        break;
                    }
                }
                if (!cols) {
                    getIndexesUnlocked();
                    foreach AbstractIndex ix in (indexes.iterator()) {
                        if (ix.unique) {
                            cols = ix.columns;
                            csrc = sprintf("unique index %s", ix.name);
                            break;
                        }
                    }

                    if (!cols)
                        throw "UPSERT-ERROR", sprintf("cannot perform an upsert on %s because it has no primary key, unique constraint, or unique index", name);
                }
            }

            return cols;
        }

        private string getSelectSql(hash row, Columns cols, reference updc) {
            if (cols.size() != row.size()) {
                # make list of columns not in unique key
                map updc += $1, row.keyIterator(), !cols.hasKey($1);
            }
            else
                updc = cols.keys();

            return sprintf("select %s from %s where %s", 
                           (foldl $1 + "," + $2, updc),
                           getSqlName(),
                           (foldl $1 + " and " + $2, (map sprintf("%s = %v", $1), cols.keyIterator()))
                );            
        }

        private string getInsertSql(hash row) {
            string sql = sprintf("insert into %s (", getSqlName());
            sql += (foldl $1 + "," + $2, row.keyIterator());
            sql += ") values (";
            sql += (foldl $1 + "," + $2, (map "%v", row.keyIterator()));
            sql += ")";
            return sql;
        }

        private string getUpdateSql(hash row, Columns cols, reference updc) {
            # make list of columns not in unique key if necessary
            if (!updc)
                map updc += $1, row.keyIterator(), !cols.hasKey($1);

            # make sql
            string sql = sprintf("update %s set ", getSqlName());
            sql += foldl $1 + "," + $2, (map sprintf("%s = %v", $1), updc);
            sql += " where ";
            sql += foldl $1 + " and " + $2, (map sprintf("%s = %v", $1), cols.keyIterator());

            return sql;
        }

        private softbool tryUpdate(string sql, hash row, Columns cols, list updc) {
            list args = row{updc}.values() + row{cols.keys()}.values();
            #printf("sql: %s args: %y\n", sql, args);
            return ds.vexec(sql, args);
        }

        private checkValue(string cname, string argname, reference val, string type) {
            if (val === NULL) {
                delete val;
                return;
            }
                
            switch (type) {
                case Type::Int: {
                    if (!val.intp())
                        throw "COLUMN-ERROR", sprintf("%s.%s: %s has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                    if (val.type() != type)
                        val = val.toInt();
                    break;
                }
                case Type::Float: {
                    if (!val.intp())
                        throw "COLUMN-ERROR", sprintf("%s.%s: %s has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                    if (val.type() != type)
                        val = val.toFloat();
                    break;
                }
                case Type::Number: {
                    if (!val.intp())
                        throw "COLUMN-ERROR", sprintf("%s.%s: %s has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                    if (val.type() != type)
                        val = number(val);
                    break;
                }
                case Type::Boolean: {
                    if (!val.intp())
                        throw "COLUMN-ERROR", sprintf("%s.%s: %s has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                    if (val.type() != type)
                        val = val.toBool();
                    break;
                }
                case Type::String: {
                    if (!val.strp())
                        throw "COLUMN-ERROR", sprintf("%s.%s: %s has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                    if (val.type() != type)
                        val = val.toString();
                    break;
                }
              default: {
                  if (val.type() != type)
                      throw "COLUMN-ERROR", sprintf("%s.%s: %s value for has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                  break;
                }
            }
        }

        #! returns an SQL string corresponding to the list of commands in the argument
        /** @par Example:
            @code
my string $sql = $t.getSqlFromList($list);
            @endcode

            @param l a list of SQL commands
            
            @return an SQL string corresponding to the list of commands in the argument
        */
        string getSqlFromList(list l) {
            return getCreateSqlImpl(l);
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument
        /** @par Example:
            @code
my string $str = $table.getSqlValue($date);
            @endcode

            @param v the value to convert to an SQL value

            @return a string representing the value usable in SQL strings for the given database driver

            @throw VALUE-ERROR the given value cannot be converted to an SQL string (missing rules for value)
         */
        string getSqlValue(any v) {
            *string str = getSqlValueImpl(v);
            if (!exists str)
                throw "VALUE-ERROR", sprintf("class %s cannot convert type %y to an SQL string (value: %y)", self.className(), v.type(), v);

            return str;
        }
        
        #! returns the name of the table
        string getName() {
            return name;
        }

        #! reads in all attributes of the table from the database
        /** @par Example:
            @code
$table.cache();
            @endcode

            @param opts cache options; see @ref AbstractTable::CacheOptions for common options; each driver can support additional driver-specific options
        */
        cache(*hash opts) {
            l.lock();
            on_exit l.unlock();
            cacheUnlocked(opts);
        }

        #! returns an object of class Columns describing the table
        /** @par Example:
            @code
my hash $h = $table.describe();
            @endcode

            @return an object of class Columns describing the table
        */
        Columns describe() {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            return columns;
        }

        #! returns an object of class AbstractPrimaryKey describing the primary key of the table
        /** If there is no primary key then the object returned will be empty (see @ref SqlUtil::AbstractPrimaryKey::empty())

            @par Example:
            @code
            @endcode

            @return an object of class AbstractPrimaryKey describing the primary key of the table
        */
        *AbstractPrimaryKey getPrimaryKey() {
            l.lock();
            on_exit l.unlock();
            getPrimaryKeyUnlocked();
            return primaryKey;
        }

        #! returns an object of class Indexes describing the indexes on the table
        /** If there are no indexes on the table then the object returned will be empty (see @ref SqlUtil::Indexes::empty())

            @par Example:
            @code
my Indexes $ix = $table.getIndexes();
            @endcode

            @return an object of class Indexes describing the indexes on the table
        */
        Indexes getIndexes() {
            l.lock();
            on_exit l.unlock();
            getIndexesUnlocked();
            return indexes;
        }

        #! returns a ForeignConstraints object describing the foreign constraints that the table has on other tables
        ForeignConstraints getForeignConstraints(*hash opt) {
            l.lock();
            on_exit l.unlock();
            getForeignConstraintsUnlocked(opt);
            return foreignConstraints;
        }

        #! returns a Constraints object describing the non-foreign constraints on the table
        Constraints getConstraints() {
            l.lock();
            on_exit l.unlock();
            getConstraintsUnlocked();
            return constraints;
        }

        #! returns an object of class Triggers describing the triggers on the table
        /** If there are no triggers on the table then the object returned will be empty (see @ref SqlUtil::Triggers::empty())

            @par Example:
            @code
my Triggers $trig = $table.getTriggers();
            @endcode

            @return an object of class Triggers describing the triggers on the table
        */
        Triggers getTriggers() {
            l.lock();
            on_exit l.unlock();
            getTriggersUnlocked();
            return triggers;
        }

        #! returns an SQL string that could be used to rename the table in the database
        /** @par Example:
            @code
my string $sql = $table.getRenameSql("new_name");
            @endcode

            @param new_name the new name for the table

            @return an SQL string that could be used to rename the table in the database

            @note does not rename the table; the new name is only used in the SQL string return value

            @see rename()
        */
        string getRenameSql(string new_name) {
            l.lock();
            on_exit l.unlock();
            return getRenameSqlImpl(new_name);
        }

        #! returns an SQL string that could be used to create the table and all known properties of the table
        /** @par Example:
            @code
printf("%s\n", $table.getCreateSql());
            @endcode

            @param opt a hash of options for the SQL creation string

            @return an SQL string that could be used to create the table and all known properties of the table
        */
        string getCreateSqlString(*hash opt) {
            l.lock();
            on_exit l.unlock();

            if (!manual)
                cacheUnlocked(opt);

            return getCreateSqlImpl(getCreateSqlUnlocked(opt));
        }

        #! returns a list of SQL strings that could be used to create the table and all known properties of the table
        /** @par Example:
            @code
map printf("$1;\n", $1), $table.getCreateSql();
            @endcode

            @param opt a hash of options for the table, index, and constraint creation strings; see @ref TableCreationOptions for common options; each driver can support additional driver-specific options
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create the table and all known properties of the table
        */
        list getCreateSql(*hash opt, bool cache = True) {
            l.lock();
            on_exit l.unlock();
            if (!manual)
                cacheUnlocked(opt);
            return getCreateSqlUnlocked(opt, cache);
        }

        #! returns an SQL string that could be used to create the basic table structure without indexes and constraints 
        /** @par Example:
            @code
my string $sql = $table.getCreateTableSql();
            @endcode

            @param opt a hash of options for the table creation string; see @ref TableCreationOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that could be used to create the basic table structure without indexes and constraints 

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        string getCreateTableSql(*hash opt) {
            validateOptionsIntern("OPTION-ERROR", getTableCreationOptions(), \opt);
            l.lock();
            on_exit l.unlock();
            return getCreateTableSqlUnlocked(opt);
        }

        #! returns @ref Qore::True "True" if the table exists in the database, @ref Qore::False "False" if not
        bool checkExistence() {
            l.lock();
            on_exit l.unlock();
            if (inDb)
                return True;
            return checkExistenceImpl();
        }

        #! accepts an AbstractTable argument and returns a list of SQL strings required to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $table.getAlignSql($table2);
            @endcode

            @param t the template table that the current table will be compared to
            @param opt a hash of options for the SQL creation string; see @ref AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings required to align the structure and configuration of the current table with that of the AbstractTable argument; if the tables are identical then an empty list is returned

            @throw ALIGN-TABLE-ERROR the argument must be of the same class as the current object; template table has no columns
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        list getAlignSql(AbstractTable t, *hash opt) {
            if (self.className() != t.className())
                throw "ALIGN-TABLE-ERROR", sprintf("cannot align table %y of class %y with table %y of class %y", name, self.className(), t.name, t.className());

            hash ato = getAlignTableOptions();

            validateOptionsIntern("OPTION-ERROR", ato, \opt);

            l.lock();
            on_exit l.unlock();
            # lock "template" table
            t.l.lock();
            on_exit t.l.unlock();
            
            # cache tables if not already cached
            if (!manual) {
                # if the table does not exist, then just return the create table strings for the template table
                if (!checkExistenceImpl())
                    return t.getCreateSqlUnlocked(opt, False);

                # use db_table_cache for table_cache when caching DB objects
                *hash db_opt = opt;
                db_opt.table_cache = remove db_opt.db_table_cache;
                cacheUnlocked(db_opt);
            }
            if (!t.manual)
                t.cacheUnlocked(opt);

            if (!t.columns || t.columns.empty())
                throw "ALIGN-TABLE-ERROR", sprintf("cannot align table %y with table %y: table %y has no columns", name, t.name, t.name);

            if (!columns)
                columns = new Columns();

            list l = ();

            # check name
            if (name != t.name) {
                AbstractDatabase::doInfoCallback(opt, "rename table %s to %s", name, t.name);
                l += AbstractDatabase::doSqlCallback(opt, getRenameSql(t.name));
            }

            # first check for columns in the template that are not present or different in the current table
            foreach AbstractColumn c in (t.columns.iterator()) {
                if (!columns.hasKey(c.name)) {
                    AbstractDatabase::doInfoCallback(opt, "add column %s to %s", c.name, name);
                    # add column to table
                    l += AbstractDatabase::doSqlCallback(opt, c.getCreateSql(self));
                }
                else {
                    # get any delta SQL
                    list cl = columns{c.name}.getModifySql(self, c);
                    # add delta SQL to list if there is any to add
                    if (cl) {
                        AbstractDatabase::doInfoCallback(opt, "updating column %s in %s", c.name, name);
                        l += AbstractDatabase::doSqlCallback(opt, cl);
                    }
                }
            }

            # check for columns not in the template and drop them
            foreach AbstractColumn c in (columns.iterator()) {
                if (!t.columns.hasKey(c.name)) {
                    AbstractDatabase::doInfoCallback(opt, "dropping column %s in %s", c.name, name);
                    l += AbstractDatabase::doSqlCallback(opt, c.getDropSql(getSqlName()));
                }
            }

            # copy indexes
            *Indexes indexes_copy = indexes ? indexes.copy() : NOTHING;

            # process index_map: rename indexes
            foreach hash rh in (opt.index_map.pairIterator()) {
                if (indexes_copy.hasKey(rh.key)) {
                    AbstractIndex ix = indexes_copy{rh.key};
                    AbstractDatabase::doInfoCallback(opt, "renaming index %s on %s to %s", ix.name, name, rh.value);
                    l += AbstractDatabase::doSqlCallback(opt, ix.getRenameSql(getSqlName(), rh.value));
                    indexes_copy.renameKey(rh.key, rh.value);
                    ix.name = rh.value;
                }
            }

            # check for indexes in the template that are not present or different in the current table
            foreach AbstractIndex ix in (t.indexes.iterator()) {
                if (!indexes_copy.hasKey(ix.name)) {
                    # add index to table
                    AbstractDatabase::doInfoCallback(opt, "adding index %s to %s", ix.name, name);
                    l += AbstractDatabase::doSqlCallback(opt, ix.getCreateSql(getSqlName(), opt));
                }
                else if (!ix.equal(indexes_copy{ix.name})) {
                    AbstractDatabase::doInfoCallback(opt, "recreating index %s on %s", ix.name, name);
                    l += AbstractDatabase::doSqlCallback(opt, ix.getRecreateSql(getSqlName(), opt));
                }
            }

            # check for indexes not in the template and drop them
            foreach AbstractIndex ix in (indexes_copy.iterator()) {
                if (!t.indexes.hasKey(ix.name)) {
                    # make sure there is no unique constraint or primary key for the unique index if the "index" option is supported
                    # in which case update the constraint to be based on the index and do not drop the index
                    if (ix.unique) {
                        if (t.primaryKey && t.primaryKey.matchKeys(ix.columns)) {
                            if (t.primaryKey.setIndexBase(ix.name)) {
                                ix.setSupportingConstraint(primaryKey);
                                continue;
                            }
                        }
                        else {
                            # see if a unique constraint with the same name and columns exists
                            if (t.constraints.hasKey(ix.name) && t.constraints{ix.name} instanceof AbstractUniqueConstraint) {
                                AbstractUniqueConstraint uk = cast<AbstractUniqueConstraint>(t.constraints{ix.name});
                                if (uk.matchKeys(ix.columns) && uk.setIndexBase(ix.name)) {
                                    ix.setSupportingConstraint(uk);
                                    continue;
                                }
                            }
                        }
                    }
                    AbstractDatabase::doInfoCallback(opt, "dropping index %s on %s", ix.name, name);
                    l += AbstractDatabase::doSqlCallback(opt, ix.getDropSql(getSqlName()));
                }
            }

            # copy constraints
            *Constraints constraints_copy = constraints ? constraints.copy() : NOTHING;
            *AbstractPrimaryKey primaryKey_copy = primaryKey ? primaryKey.copy() : NOTHING;
            *ForeignConstraints foreignConstraints_copy = foreignConstraints ? foreignConstraints.copy() : NOTHING;

            # process constraint_map: rename constraints
            foreach hash rh in (opt.constraint_map.pairIterator()) {
                *AbstractConstraint c;

                if (foreignConstraints_copy.hasKey(rh.key)) {
                    c = foreignConstraints_copy{rh.key};
                    foreignConstraints_copy.renameKey(rh.key, rh.value);
                }
                else if (constraints_copy.hasKey(rh.key)) {
                    c = constraints_copy{rh.key};
                    constraints_copy.renameKey(rh.key, rh.value);
                }
                else if (primaryKey_copy && primaryKey_copy.getName() == rh.key)
                    c = primaryKey_copy;

                if (c) {
                    AbstractDatabase::doInfoCallback(opt, "renaming constraint %s on %s to %s", c.getName(), name, rh.value);
                    l += AbstractDatabase::doSqlCallback(opt, c.getRenameSql(getSqlName(), rh.value));
                    c.rename(rh.value);
                }
            }

            # check for primary key differences
            if (t.primaryKey) {
                if (primaryKey_copy && !primaryKey_copy.equal(t.primaryKey)) {
                    AbstractDatabase::doInfoCallback(opt, "updating primary key %s on %s", t.primaryKey.getName(), name);
                    l += AbstractDatabase::doSqlCallback(opt, primaryKey_copy.getDropSql(getSqlName()));
                    l += AbstractDatabase::doSqlCallback(opt, t.primaryKey.getCreateSql(getSqlName(), opt));
                }
                else if (!primaryKey_copy) {
                    AbstractDatabase::doInfoCallback(opt, "creating primary key %s on %s", t.primaryKey.getName(), name);
                    l += AbstractDatabase::doSqlCallback(opt, t.primaryKey.getCreateSql(getSqlName(), opt));
                }
            }
            else if (primaryKey_copy && !primaryKey_copy.empty()) {
                AbstractDatabase::doInfoCallback(opt, "dropping primary key %s on %s", primaryKey_copy.getName(), name);
                l += AbstractDatabase::doSqlCallback(opt, primaryKey_copy.getDropSql(getSqlName()));
            }

            # check for foreign constraints in the template that are not present or different in the current table
            foreach AbstractForeignConstraint c in (t.foreignConstraints.iterator()) {
                if (!foreignConstraints_copy.hasKey(c.getName())) {
                    # add constraint to table
                    AbstractDatabase::doInfoCallback(opt, "adding foreign constraint %s to %s", c.getName(), name);
                    l += AbstractDatabase::doSqlCallback(opt, c.getCreateSql(getSqlName(), opt));
                }
                else if (!c.equal(foreignConstraints_copy{c.getName()})) {
                    AbstractDatabase::doInfoCallback(opt, "updating foreign constraint %s on %s", c.getName(), name);
                    # drop current constraint
                    l += AbstractDatabase::doSqlCallback(opt, foreignConstraints_copy{c.getName()}.getDropSql(getSqlName()));
                    # add new constraint to table
                    l += AbstractDatabase::doSqlCallback(opt, c.getCreateSql(getSqlName(), opt));
                }
            }

            # check for foreign constraints not in the template and drop them
            foreach AbstractForeignConstraint c in (foreignConstraints_copy.iterator()) {
                if (!t.foreignConstraints.hasKey(c.getName())) {
                    AbstractDatabase::doInfoCallback(opt, "dropping foreign constraint %s on %s", c.getName(), name);
                    l += AbstractDatabase::doSqlCallback(opt, c.getDropSql(getSqlName()));
                }
            }

            # check for other constraints in the template that are not present or different in the current table
            foreach AbstractConstraint c in (t.constraints.iterator()) {
                if (!constraints_copy.hasKey(c.getName())) {
                    # add constraint to table
                    AbstractDatabase::doInfoCallback(opt, "adding constraint %s to %s", c.getName(), name);
                    l += AbstractDatabase::doSqlCallback(opt, c.getCreateSql(getSqlName(), opt));
                }
                else if (!c.equal(constraints_copy{c.getName()})) {
                    AbstractDatabase::doInfoCallback(opt, "updating constraint %s on %s", c.getName(), name);
                    # drop current constraint
                    l += AbstractDatabase::doSqlCallback(opt, constraints_copy{c.getName()}.getDropSql(getSqlName()));
                    # add new constraint to table
                    l += AbstractDatabase::doSqlCallback(opt, c.getCreateSql(getSqlName(), opt));
                }
            }

            # check for other constraints not in the template and drop them
            foreach AbstractConstraint c in (constraints_copy.iterator()) {
                if (!t.constraints.hasKey(c.getName())) {
                    AbstractDatabase::doInfoCallback(opt, "dropping constraint %s on %s", c.getName(), name);
                    l += AbstractDatabase::doSqlCallback(opt, c.getDropSql(getSqlName()));
                }
            }

            # check for table-specific alignment actions before triggers
            {
                *list fl = getAlignSqlImpl(t, opt);
                if (fl)
                    l += fl;
            }

            # check for triggers in the template that are not present or different in the current table
            foreach AbstractTrigger trig in (t.triggers.iterator()) {
                if (!triggers.hasKey(trig.name)) {
                    # add trigger to table
                    AbstractDatabase::doInfoCallback(opt, "adding trigger %s on %s", trig.name, name);
                    l += AbstractDatabase::doSqlCallback(opt, trig.getCreateSql(getSqlName(), opt));
                }
                else if (!trig.equal(triggers{trig.name})) {
                    AbstractDatabase::doInfoCallback(opt, "updating trigger %s on %s", trig.name, name);
                    # drop current trigger
                    l += AbstractDatabase::doSqlCallback(opt, triggers{trig.name}.getDropSql());
                    # add new trigger to table
                    l += AbstractDatabase::doSqlCallback(opt, trig.getCreateSql(getSqlName(), opt));
                }
            }

            # check for triggers not in the template and drop them
            foreach AbstractTrigger trig in (triggers.iterator()) {
                if (!t.triggers.hasKey(trig.name)) {
                    AbstractDatabase::doInfoCallback(opt, "dropping trigger %s on %s", trig.name, name);
                    l += AbstractDatabase::doSqlCallback(opt, trig.getDropSql());
                }
            }

            return l;
        }

        #! accepts an AbstractTable argument and returns an SQL string that could be executed to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty string is returned
        /** @par Example:
            @code
my string $sql = $table.getAlignSqlString($table2);
            @endcode

            @param t the template table that the current table will be compared to
            @param opt a hash of options for the SQL creation string; see @ref AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that could be executed to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty string is returned

            @throw ALIGN-TABLE-ERROR the argument must be of the same class as the current object; template table has no columns
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        string getAlignSqlString(AbstractTable t, *hash opt) {
            return getCreateSqlImpl(getAlignSql(t, opt));
        }

        #! returns a list of SQL strings that could be used to create indexes on the table or @ref nothing if there are no indexes on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateIndexesSql();
            @endcode

            @param opt a hash of options for the index creation string; see @ref IndexOptions for common options; each driver can support additional driver-specific options
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create indexes on the table or @ref nothing if there are no indexes on the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateIndexesSql(*hash opt, bool cache = True) {
            validateOptionsIntern("OPTION-ERROR", getIndexOptions(), \opt);
            l.lock();
            on_exit l.unlock();
            return getCreateIndexesSqlUnlocked(opt, cache);
        }

        #! returns an SQL string that could be used to create the primary key on the table
        /** @par Example:
            @code
my *string $sql = $table.getCreatePrimaryKeySql();
            @endcode

            @param opt a hash of options for the primary key creation string; see @ref ConstraintOptions for common options; each driver can support additional driver-specific options
            @param cache read in data from the database for uncached properties of the table

            @return an SQL string that could be used to create the primary key on the table or @ref nothing if there is no primary key on the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *string getCreatePrimaryKeySql(*hash opt, bool cache = True) {
            validateOptionsIntern("OPTION-ERROR", getConstraintOptions(), \opt);
            l.lock();
            on_exit l.unlock();
            return getCreatePrimaryKeySqlUnlocked(opt, cache);
        }

        #! returns a list of SQL strings that could be used to create foreign constraints on the table or @ref nothing if there are no foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateForeignConstraintsSql();
            @endcode

            @param opt a hash of options for the foreign constraint creation string; see @ref ForeignConstraintOptions for common options; each driver can support additional driver-specific options
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create foreign constraints on the table or @ref nothing if there are no foreign constraints on the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateForeignConstraintsSql(*hash opt, bool cache = True) {
            validateOptionsIntern("OPTION-ERROR", getForeignConstraintOptions(), \opt);
            l.lock();
            on_exit l.unlock();
            return getCreateForeignConstraintsSqlUnlocked(opt, cache);
        }

        #! returns a list of SQL strings that could be used to create non-foreign constraints on the table or @ref nothing if there are no non-foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateConstraintsSql();
            @endcode

            @param opt a hash of options for the non-foreign constraint creation string; see @ref ConstraintOptions for common options; each driver can support additional driver-specific options
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create non-foreign constraints on the table or @ref nothing if there are no non-foreign constraints on the table

            @see getCreateForeignConstraintsSql()

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateConstraintsSql(*hash opt, bool cache = True) {
            validateOptionsIntern("OPTION-ERROR", getConstraintOptions(), \opt);
            l.lock();
            on_exit l.unlock();
            return getCreateConstraintsSql(opt, cache);
        }

        #! returns a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or @ref nothing if there are none
        /** @par Example:
            @code
my *list $l = $table.getCreateMiscSql();
            @endcode

            @param opt a hash of options for the SQL creation string; see @ref TableCreationOptions for common options; each driver can support additional driver-specific options
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or @ref nothing if there are none

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateMiscSql(*hash opt, bool cache = True) {
            validateOptionsIntern("OPTION-ERROR", getTableCreationOptions(), \opt);
            l.lock();
            on_exit l.unlock();
            return getCreateMiscSqlUnlocked(opt, cache);
        }

        #! returns a list of SQL strings that could be used to create triggers on the table or @ref nothing if there are no triggers on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateTriggersSql();
            @endcode

            @param opt a hash of options for the trigger creation strings; see @ref TableCreationOptions for common options; each driver can support additional driver-specific options
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create triggers on the table or @ref nothing if there are no triggers on the table

            @throw OPTION-ERROR invalid or unsupported option passed

            @see getCreateTriggersSql()
        */
        *list getCreateTriggersSql(*hash opt, bool cache = True) {
            validateOptionsIntern("OPTION-ERROR", getTableCreationOptions(), \opt);
            l.lock();
            on_exit l.unlock();
            return getCreateTriggersSqlUnlocked(opt, cache);
        }

        #! finds a row in the table with the given primary key value; if no row matches the primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *hash $row = $table.find($id);
            @endcode

            @throw PRIMARY-KEY-ERROR the table has no primary key or the primary key has more than one column
         */
        *hash find(any id) {
            string cname = getPrimaryKeyColumn();

            return ds.selectRow("select * from %s where %s = %v", getSqlName(), cname, id);
        }

        #! finds rows in the table with the given primary key values; if no row matches any primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *list $rows = $table.find($list);
            @endcode

            @param ids the list of primary key IDs to find; if the list is empty then @ref nothing is returned

            @return a list of hashes of rows matching the primary key IDs passed or @ref nothing if no row matches any primary key value passed

            @throw PRIMARY-KEY-ERROR the table has no primary key or the primary key has more than one column
            */
        *list find(list ids) {
            string cname = getPrimaryKeyColumn();

            if (!ids)
                return;

            string sql = sprintf("select * from %s where %s in (%s)", getSqlName(), cname, (foldl $1 + "," + $2, (map "%v", ids)));

            return ds.vselectRows(sql, ids);
        }

        private string getPrimaryKeyColumn() {
            l.lock();
            on_exit l.unlock();
            getPrimaryKeyUnlocked();
            if (primaryKey.empty())
                throw "PRIMARY-KEY-ERROR", sprintf("table %s has no primary key", name);
            if (primaryKey.size() > 1)
                throw "PRIMARY-KEY-ERROR", sprintf("table %s has a primary key with %d columns (%y)", name, primaryKey.size(), primaryKey.keys());
            return primaryKey.firstKey();
        }

        #! finds a row in the table with the given primary key value given as a hash; if no row matches the primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *hash $row = $table.find($id);
            @endcode

            @param row a hash giving the primary key value to find; other columns may also appear in the hash, however at least all columns of the primary key must be present

            @return a hash of the row value matching the primary key value passed or @ref nothing if no row matches the primary key value passed

            @throw PRIMARY-KEY-ERROR the table has no primary key or the the hash passed does not contain all columns of the primary key

            @note a table with a primary key with a single column can also be used with this method; just pass a hash with one key
         */
        *hash find(hash row) {
            Columns cols;
            {
                l.lock();
                on_exit l.unlock();
                getPrimaryKeyUnlocked();
                if (primaryKey.empty())
                    throw "PRIMARY-KEY-ERROR", sprintf("table %s has no primary key", name);
                cols = primaryKey;
            }

            # make sure all columns of the primary key are included in the row
            foreach string k in (cols.keyIterator()) {
                if (!row.hasKey(k))
                    throw "PRIMARY-KEY-ERROR", sprintf("row passed is missing column %y of primary key (%y)", k, cols.keys());
            }

            # make query
            string sql = sprintf("select * from %s where ", getSqlName());
            sql += foldl $1 + " and " + $2, (map sprintf("%s = %v", $1), row.keyIterator());
            return ds.vselectRow(sql, row.values());
        }

        #! returns the name of the table to be used in SQL (with a possible qualifiers for schema, etc)
        string getSqlName() {
            return name;
        }

        private string getCreateTableSqlUnlocked(*hash opt) {
            getColumnsUnlocked();
            AbstractDatabase::doInfoCallback(opt, "create table %s", name);
            return AbstractDatabase::doSqlCallback(opt, getCreateTableSqlImpl(opt));
        }

        private *list getCreateIndexesSqlUnlocked(*hash opt, bool cache = True) {
            if (cache)
                getIndexesUnlocked();
            if (!indexes)
                return;

            *list l = getCreateIndexesSqlImpl(opt);

            if (l)
                map AbstractDatabase::doTandemCallback(opt, l[$#], "create index %s on %s", $1, name), indexes.keyIterator();

            return l;
        }

        private *string getCreatePrimaryKeySqlUnlocked(*hash opt, bool cache = True) {
            if (cache)
                getPrimaryKeyUnlocked();
            if (!primaryKey)
                return;
            *string sql = getCreatePrimaryKeySqlImpl(opt);

            if (sql)
                AbstractDatabase::doTandemCallback(opt, sql, "create primary key %s on %s", primaryKey.getName(), name);

            return sql;
        }

        private *list getCreateConstraintsSqlUnlocked(*hash opt, bool cache = True) {
            if (cache)
                getConstraintsUnlocked();
            if (!constraints)
                return;
            *list l = getCreateConstraintsSqlImpl(opt);

            if (l)
                map AbstractDatabase::doTandemCallback(opt, l[$#], "create constraint %s on %s", $1, name), constraints.keyIterator();

            return l;
        }

        private *list getCreateForeignConstraintsSqlUnlocked(*hash opt, bool cache = True) {
            if (cache)
                getForeignConstraintsUnlocked(opt);
            if (!foreignConstraints)
                return;
            *list l = getCreateForeignConstraintsSqlImpl(opt);

            if (l)
                map AbstractDatabase::doTandemCallback(opt, l[$#], "create foreign constraint %s on %s", $1, name), foreignConstraints.keyIterator();

            return l;
        }

        private *list getCreateMiscSqlUnlocked(*hash opt, bool cache = True) {
            return getCreateMiscSqlImpl(opt, cache);
        }

        private *list getCreateTriggersSqlUnlocked(*hash opt, bool cache = True) {
            if (cache)
                getTriggersUnlocked();
            if (!triggers)
                return;
            *list l = getCreateTriggersSqlImpl(opt);

            if (l)
                map AbstractDatabase::doTandemCallback(opt, l[$#], "create trigger %s on %s", $1, name), triggers.keyIterator();

            return l;
        }

        private list getCreateSqlUnlocked(*hash opt, bool cache = True) {
            # make sure driver options take precedence over generic options
            if (opt) {
                string dn = getDriverName();
                if (opt.driver{dn})
                    opt += remove opt.driver{dn};
                delete opt.driver;
            }

            list l += getCreateTableSqlUnlocked(opt);
            *list tl = getCreateIndexesSqlUnlocked(opt, cache); if (tl) l += tl;
            *string sql = getCreatePrimaryKeySqlUnlocked(opt, cache); if (sql) l += sql;
            tl = getCreateForeignConstraintsSqlUnlocked(opt, cache); if (tl) l += tl;
            tl = getCreateConstraintsSqlUnlocked(opt, cache); if (tl) l += tl;
            tl = getCreateMiscSqlUnlocked(opt, cache); if (tl) l += tl;
            tl = getCreateTriggersSqlUnlocked(opt, cache); if (tl) l += tl;

            return l;
        }

        private cacheUnlocked(*hash opt) {
            getColumnsUnlocked();
            getPrimaryKeyUnlocked();
            getIndexesUnlocked();
            getForeignConstraintsUnlocked(opt);
            getConstraintsUnlocked();
            getTriggersUnlocked();
        }

        static AbstractTable getTable(AbstractDatasource nds, string nname, *hash opts) {
            string drv = nds.getDriverName();

            # generate module and module namespace name
            string mn = drv[0].upr() + drv.substr(1) + "SqlUtil";

            # try to load module
            try {
                load_module(mn);                
            }
            catch (hash ex) {
                throw "TABLE-DRIVER-ERROR", sprintf("%s: no support for driver %y yet: %s: %s", get_ex_pos(ex), drv, ex.err, ex.desc);
            }

            # try to get AbstractTable object
            try {
                return call_function(mn + "::" + "get_table", nds, nname, opts);
            }
            catch (hash ex) {
                throw "TABLE-DRIVER-ERROR", sprintf("%s: error retrieving AbstractTable object for driver %y: %s: %s", get_ex_pos(ex), drv, ex.err, ex.desc);
            }
        }

        static AbstractTable getTable(string dsstr, string nname, *hash opts) {
            Datasource nds(dsstr);
            return AbstractTable::getTable(nds, nname, opts);
        }

        static AbstractTable getTable(hash dsh, string nname, *hash opts) {
            Datasource nds(dsh);
            return AbstractTable::getTable(nds, nname, opts);
        }

        private getColumnsUnlocked() {
            if (columns)
                return;
            columns = describeImpl();
            inDb = True;
        }

        private getPrimaryKeyUnlocked() {
            if (primaryKey)
                return;
            getColumnsUnlocked();
            primaryKey = getPrimaryKeyImpl();

            # get indexes
            if (!manual && !indexes)
                indexes = getIndexesImpl();

            if (!primaryKey.empty())
                primaryKey.findMatchingIndex(indexes);

            inDb = True;
        }

        # also loads primary key and constraints (for unique constraints)
        private getIndexesUnlocked() {
            if (indexes)
                return;
            # make sure columns are loaded
            getColumnsUnlocked();
            if (!manual) {
                # make sure any primary key is loaded
                getPrimaryKeyUnlocked();
                # make sure constraints are also loaded
                getConstraintsUnlocked();
            }
            indexes = getIndexesImpl();
            inDb = True;
        }

        private getForeignConstraintsUnlocked(*hash opt) {
            if (foreignConstraints)
                return;
            getColumnsUnlocked();
            foreignConstraints = getForeignConstraintsImpl(opt);

            # update cached tables with foreign constraint source info
            if (opt.table_cache) {
                foreach AbstractForeignConstraint fk in (foreignConstraints.iterator())
                    opt.table_cache{fk.target.table}.addSourceConstraint(getSqlName(), fk);
            }
            inDb = True;
        }

        private addSourceConstraint(string table_name, AbstractForeignConstraint fk) {
            bool lock = !l.lockOwner();
            if (lock) l.lock();
            on_exit if (lock) l.unlock();

            # find unique constraint with the given columns
            if (primaryKey && primaryKey.matchKeys(fk.target.columns)) {
                primaryKey.addSourceConstraint(table_name, fk);
                return;
            }
            foreach AbstractConstraint c in (constraints.iterator()) {
                if (!(c instanceof AbstractUniqueConstraint))
                    continue;
                AbstractUniqueConstraint uk = cast<AbstractUniqueConstraint>(c);
                if (uk.matchKeys(fk.target.columns)) {
                    uk.addSourceConstraint(table_name, fk);
                    return;
                }
            }
        }

        private getConstraintsUnlocked() {
            if (constraints)
                return;
            getColumnsUnlocked();
            constraints = getConstraintsImpl();
            # get indexes
            if (!manual && !indexes)
                indexes = getIndexesImpl();

            foreach AbstractConstraint c in (constraints.iterator()) {
                if (!(c instanceof AbstractUniqueConstraint))
                    continue;
                AbstractUniqueConstraint uk = cast<AbstractUniqueConstraint>(c);
                uk.findMatchingIndex(indexes);
            }

            inDb = True;
        }

        private getTriggersUnlocked() {
            if (triggers)
                return;
            triggers = getTriggersImpl();
            inDb = True;
        }

        #! override in subclasses to return driver-specific options
        private hash getTableOptions() {
            return TableOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getForeignConstraintOptions() {
            return ForeignConstraintOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getConstraintOptions() {
            return ConstraintOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getCacheOptions() {
            return CacheOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getTableCreationOptions() {
            return TableCreationOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getAlignTableOptions() {
            return AlignTableOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getTableDescriptionHashOptions() {
            return TableDescriptionHashOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getColumnOptions() {
            return ColumnOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getIndexOptions() {
            return IndexOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getTriggerOptions() {
            return TriggerOptions;
        }

        private softlist getDropSqlImpl() {
            return sprintf("drop table %s", getSqlName());
        }
        
        private abstract bool emptyImpl();

        #! returns @ref Qore::True "True" if the table exists in the DB, @ref Qore::False "False" if not
        /** this method will only be called if inDb is @ref Qore::False "False" and 
            should set inDb = True if it returns @ref Qore::True "True"
         */
        private abstract bool checkExistenceImpl();

        private abstract setupTableImpl(hash desc, *hash opt);

        private abstract Columns describeImpl();
        private abstract *AbstractPrimaryKey getPrimaryKeyImpl();
        private abstract Indexes getIndexesImpl();
        private abstract ForeignConstraints getForeignConstraintsImpl(*hash opt);
        private abstract Constraints getConstraintsImpl();
        private abstract Triggers getTriggersImpl();

        private abstract string getCreateTableSqlImpl(*hash opt);
        private abstract *list getCreateIndexesSqlImpl(*hash opt);
        private abstract *string getCreatePrimaryKeySqlImpl(*hash opt);
        private abstract *list getCreateForeignConstraintsSqlImpl(*hash opt);
        private abstract *list getCreateConstraintsSqlImpl(*hash opt);
        private abstract *list getCreateMiscSqlImpl(*hash opt, bool cache);
        private abstract *list getCreateTriggersSqlImpl(*hash opt);
        private abstract string getCreateSqlImpl(list l);
        private abstract string getRenameSqlImpl(string new_name);
        private abstract *list getAlignSqlImpl(AbstractTable t, *hash opt);
        
        private abstract AbstractColumn addColumnImpl(string cname, hash opt, bool nullable = True);
        private abstract AbstractPrimaryKey addPrimaryKeyImpl(string cname, hash ch, *hash opt);
        private abstract AbstractIndex addIndexImpl(string iname, bool enabled, hash ch, *hash opt);
        private abstract AbstractForeignConstraint addForeignConstraintImpl(string cname, hash ch, string table, hash tch, *hash opt);
        private abstract AbstractCheckConstraint addCheckConstraintImpl(string cname, string src, *hash opt);
        private abstract AbstractUniqueConstraint addUniqueConstraintImpl(string cname, hash ch, *hash opt);

        private abstract AbstractTrigger addTriggerImpl(string tname, string src, *hash opt);

        #! tries to insert a row, if there is a duplicate key, then it returns @ref Qore::False "False", if successful, returns @ref Qore::True "True"
        private abstract bool tryInsertImpl(string sql, hash row);

        #! returns the qore type -> column type map
        private abstract hash getQoreTypeMapImpl();

        #! returns the type name -> type description hash
        private abstract hash getTypeMapImpl();

        #! returns a string for use in SQL queries representing the DB-specific value of the argument; returns @ref nothing if the type cannot be converted to an SQL string
        private abstract *string getSqlValueImpl(any v);
    }

/*
    public class Sqlite3Table inherits AbstractTable {

        public {
            const Sqlite3TypeMap = (
                "INTEGER": ("qore": "integer",),
                "NUMERIC": ("qore": "number",),
                "TEXT": ("qore": "string",),
                "BLOB": ("qore": "binary",),
                "NONE": ("qore": "any",),
                "REAL": ("qore": "float",),
                );

            const QoreTypeMap = (
                "integer": "INTEGER",
                "float": "NUMBER",
                "number": "NUMBER",
                "string": "VARCHAR2",
                #"date": "TIMESTAMP",
                "binary": "BLOB",
                );
        }

        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
        }

        private hash describeImpl() {
            hash rv;
            
            # NOTE: sqlite3's pragmas cannot use %v binding
            
            # table info - PK is part of the table description
            hash tableInfo = ds.select("pragma table_info(%s)", name);
            context(tableInfo) {
                rv.columns{%name} = (
                        "native_type"   : %type,
                        "qore_type"     : Sqlite3TypeMap{%type}.qore,
                        "size"          : NOTHING,
                        "nullable"      : %notnull == 1 ? NOTHING : "YES",
                    );
                if (%pk)
                    rv.primary_key{%name} = True;
            }
            
            # get index description
            hash indexes = ds.select("pragma index_list(%s)", name);
            context(indexes) {
                rv.indexes{%name}.unique = %unique == 0 ? False : True;
                hash indexColumns = ds.select("pragma index_info(%s)", %name);
                string columnName = %name;
                context (indexColumns) {
                    rv.indexes{columnName}.columns{%name} = True;
                }
            }
            
            # TODO/FIXME: FKs
            
            return rv;
        }
    }
*/
}

