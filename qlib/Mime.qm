# -*- mode: qore; indent-tabs-mode: nil -*-
# @file Mime.qm Mime module definition

/*  Mime.qm Copyright 2012 David Nichols

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

%requires qore >= 0.8.4

module Mime {
    version = "1.2.1";
    desc = "Mime module giving MIME-related definitions";
    author = "David Nichols";
    url = "http://qore.org";
}

/*  Version History
    * 2012-09-17 v1.2.1: David Nichols <david@qore.org>: fixed q-encoding mail headers (always encode '_' chars otherwise they will be decoded as spaces)
    * 2012-06-14 v1.2: David Nichols <david@qore.org>: added MIME decoding functions
    * 2012-05-31 v1.1: David Nichols <david@qore.org>: added initial MultiPartMessage classes
    * 2012-05-24 v1.0: David Nichols <david@qore.org>: pulled MIME implementation out of other code and made a user module to aggregate MIME definitions and functions

    based on:
    - http://tools.ietf.org/html/rfc1521: quoted printable & base 64 transfer encodings
    - http://tools.ietf.org/html/rfc2045: mime headers, content types, etc
    - http://tools.ietf.org/html/rfc2047: "Q" and "B" encoded words (implemented by the Mime module)
*/

/** @mainpage Mime Module

    The %Mime module provides definitions and functions related to MIME processing.  MIME concepts are used in HTTP and SMTP communications, among others.

    To use this module, use \c "%requires Mime" in your code.  See the SmtpClient and the HttpServer modules for examples of %Qore code using this module.
    
    All the public symbols in the module are defined in the Mime namespace

    The main definitions and functions are:
    - @ref MimeTypeDefinitions "MimeTypeDefinitions": constant for common MIME types
    - @ref Mime::MimeTypes "MimeTypes": a map of common file name extensions to the default MIME type
    - @ref MimeEncodingFunctions "MimeEncodingFunctions": functions for encoding MIME data
    - @ref MimeDecodingFunctions "MimeDecodingFunctions": functions for decoding MIME data
    - @ref MultiPartConstants "MultiPartConstants": constants for the MultiPartMessage classes
    - @ref Mime::MultiPartMessage "MultiPartMessage": the base class for MultiPartMessage classes
    - @ref Mime::MultiPartRelatedMessage "MultiPartRelatedMessage": a class for handling multipart/related messages
 */

#! public Mime namespace defines constants and functions relevant to MIME
public namespace Mime {
    /** @defgroup MimeTypeDefinitions MIME Type Definitions
	These are constants for common MIME types
     */
    #@{
    #! MIME type for unknown file types
    public const MimeTypeUnknown = "application/octet-stream";

    #! MIME type for text
    public const MimeTypeText = "text/plain";

    #! MIME type for HTML
    public const MimeTypeHtml = "text/html";

    #! MIME type for csv files (http://tools.ietf.org/html/rfc4180)
    public const MimeTypeCsv = "text/csv";

    #! MIME type for jpeg images
    public const MimeTypeJpeg = "image/jpeg";

    #! MIME type for png images
    public const MimeTypePng = "image/png";

    #! Mime type for SOAP XML messages (XML MIME type reference: http://tools.ietf.org/html/rfc3023)
    public const MimeTypeSoapXml = "application/soap+xml";

    #! Mime type for yaml data files
    public const MimeTypeYaml = "text/x-yaml";

    #! Mime type for plain (human-readable) xml files
    public const MimeTypeXml = "text/xml";

    #! Mime type for more complicated (not human-readable) xml files
    public const MimeTypeXmlApp = "application/xml";

    #! Mime type for JSON-RPC
    public const MimeTypeJsonRpc = "application/json";

    #! Mime type for XML-RPC
    public const MimeTypeXmlRpc = MimeTypeXml;

    #! Mime type for YAML-RPC
    public const MimeTypeYamlRpc = "application/x-yaml";

    #! A map of default mime types per file extension; the hash keys are file extensions in lower-case without the dot (ex: \c "txt")
    /** @showinitializer
     */
    public const MimeTypes = (
	"7z": "application/x-7z-compressed",
	"ai": "application/postscript",
	"aif": "audio/x-aiff",
	"aifc": "audio/x-aiff",
	"aiff": "audio/x-aiff",
	"asc": MimeTypeText,
	"atom": "application/atom+xml",
	"au": "audio/basic",
	"avi": "video/x-msvideo",
	"bcpio": "application/x-bcpio",
	"bin": MimeTypeUnknown,
	"bmp": "image/bmp",
	"bz2": "application/x-bzip",
	"cc": MimeTypeText,
	"cdf": "application/x-netcdf",
	"cgm": "image/cgm",
	"class": MimeTypeUnknown,
	"cpio": "application/x-cpio",
	"cpp": MimeTypeText,
	"cpt": "application/mac-compactpro",
	"csh": "application/x-csh",
	"css": "text/css",
	"csv": MimeTypeCsv,
	"dcr": "application/x-director",
	"dif": "video/x-dv",
	"dir": "application/x-director",
	"djv": "image/vnd.djvu",
	"djvu": "image/vnd.djvu",
	"dll": MimeTypeUnknown,
	"dmg": MimeTypeUnknown,
	"dms": MimeTypeUnknown,
	"doc": "application/msword",
	"dtd": "application/xml-dtd",
	"dv": "video/x-dv",
	"dvi": "application/x-dvi",
	"dxr": "application/x-director",
	"eps": "application/postscript",
	"etx": "text/x-setext",
	"exe": MimeTypeUnknown,
	"ez": "application/andrew-inset",
	"gif": "image/gif",
	"gram": "application/srgs",
	"grxml": "application/srgs+xml",
	"gtar": "application/x-gtar",
	"gz": "application/x-gzip",
	"h": MimeTypeText,
	"hdf": "application/x-hdf",
	"hh": MimeTypeText,
	"hpp": MimeTypeText,
	"hqx": "application/mac-binhex40",
	"htm": MimeTypeHtml,
	"html": MimeTypeHtml,
	"ice": "x-conference/x-cooltalk",
	"ico": "image/x-icon",
	"ics": "text/calendar",
	"ief": "image/ief",
	"ifb": "text/calendar",
	"iges": "model/iges",
	"igs": "model/iges",
	"jar": "application/java-archive",
	"java": MimeTypeText,
	"jnlp": "application/x-java-jnlp-file",
	"jp2": "image/jp2",
	"jpe": MimeTypeJpeg,
	"jpeg": MimeTypeJpeg,
	"jpg": MimeTypeJpeg,
	"js": "application/x-javascript",
	"kar": "audio/midi",
	"latex": "application/x-latex",
	"lha": MimeTypeUnknown,
	"lzh": MimeTypeUnknown,
	"m3u": "audio/x-mpegurl",
	"m4a": "audio/mp4a-latm",
	"m4b": "audio/mp4a-latm",
	"m4p": "audio/mp4a-latm",
	"m4u": "video/vnd.mpegurl",
	"m4v": "video/x-m4v",
	"mac": "image/x-macpaint",
	"man": "application/x-troff-man",
	"mathml": "application/mathml+xml",
	"me": "application/x-troff-me",
	"mesh": "model/mesh",
	"mid": "audio/midi",
	"midi": "audio/midi",
	"mif": "application/vnd.mif",
	"mov": "video/quicktime",
	"movie": "video/x-sgi-movie",
	"mp2": "audio/mpeg",
	"mp3": "audio/mpeg",
	"mp4": "video/mp4",
	"mpe": "video/mpeg",
	"mpeg": "video/mpeg",
	"mpg": "video/mpeg",
	"mpga": "audio/mpeg",
	"ms": "application/x-troff-ms",
	"msh": "model/mesh",
	"mxu": "video/vnd.mpegurl",
	"nc": "application/x-netcdf",
	"oda": "application/oda",
	"ogg": "application/ogg",
	"pbm": "image/x-portable-bitmap",
	"pct": "image/pict",
	"pdb": "chemical/x-pdb",
	"pdf": "application/pdf",
	"pgm": "image/x-portable-graymap",
	"pgn": "application/x-chess-pgn",
	"pic": "image/pict",
	"pict": "image/pict",
	"png": MimeTypePng,
	"pnm": "image/x-portable-anymap",
	"pnt": "image/x-macpaint",
	"pntg": "image/x-macpaint",
	"ppm": "image/x-portable-pixmap",
	"ppt": "application/vnd.ms-powerpoint",
	"ps": "application/postscript",

	# Qore script
	"q": MimeTypeText,

	# Qore class include file
	"qc": MimeTypeText,

	# Qore include file
	"ql": MimeTypeText,

	# Qore user module source
	"qm": MimeTypeText,

	"qt": "video/quicktime",
	"qti": "image/x-quicktime",
	"qtif": "image/x-quicktime",
	"ra": "audio/x-pn-realaudio",
	"ram": "audio/x-pn-realaudio",
	"ras": "image/x-cmu-raster",
	"rdf": "application/rdf+xml",
	"rgb": "image/x-rgb",
	"rm": "application/vnd.rn-realmedia",
	"roff": "application/x-troff",
	"rtf": "text/rtf",
	"rtx": "text/richtext",
	"sgm": "text/sgml",
	"sgml": "text/sgml",
	"sh": "application/x-sh",
	"shar": "application/x-shar",
	"silo": "model/mesh",
	"sit": "application/x-stuffit",
	"skd": "application/x-koan",
	"skm": "application/x-koan",
	"skp": "application/x-koan",
	"skt": "application/x-koan",
	"smi": "application/smil",
	"smil": "application/smil",
	"snd": "audio/basic",
	"so": MimeTypeUnknown,
	"spl": "application/x-futuresplash",
	"src": "application/x-wais-source",
	"sv4cpio": "application/x-sv4cpio",
	"sv4crc": "application/x-sv4crc",
	"svg": "image/svg+xml",
	"swf": "application/x-shockwave-flash",
	"t": "application/x-troff",
	"tar": "application/x-tar",
	"tar.bz2": "application/x-bzip-compressed-tar",
	"tar.gz": "application/x-tar-gz",	
	"tbz": "application/x-bzip-compressed-tar",
	"tcl": "application/x-tcl",
	"tex": "application/x-tex",
	"texi": "application/x-texinfo",
	"texinfo": "application/x-texinfo",
	"text": MimeTypeText,
	"tgz": "application/x-tar-gz",	
	"tif": "image/tiff",
	"tiff": "image/tiff",
	"tr": "application/x-troff",
	"tsv": "text/tab-separated-values",
	"txt": MimeTypeText,
	"ustar": "application/x-ustar",
	"vcd": "application/x-cdlink",
	"vrml": "model/vrml",
	"vxml": "application/voicexml+xml",
	"wav": "audio/x-wav",
	"wbmp": "image/vnd.wap.wbmp",
	"wbmxl": "application/vnd.wap.wbxml",
	"wml": "text/vnd.wap.wml",
	"wmlc": "application/vnd.wap.wmlc",
	"wmls": "text/vnd.wap.wmlscript",
	"wmlsc": "application/vnd.wap.wmlscriptc",
	"wrl": "model/vrml",
	"xbm": "image/x-xbitmap",
	"xht": "application/xhtml+xml",
	"xhtml": "application/xhtml+xml",
	"xls": "application/vnd.ms-excel",
	"xml": MimeTypeXml,
	"xpm": "image/x-xpixmap",
	"xsl": "application/xml",
	"xslt": "application/xslt+xml",
	"xul": "application/vnd.mozilla.xul+xml",
	"xwd": "image/x-xwindowdump",
	"xyz": "chemical/x-xyz",
	"yaml": MimeTypeYaml,
	"zip": "application/zip",
	);
    #@}

    /** @defgroup MimeContentTransferEncodingConstants MIME Content Transfer Encoding Constants
     */
    #@{
    #! default Content-Transfer-Encoding if none is present; implies lines < 1000 chars (= no encoding)
    public const ContentTransEnc7Bit = "7bit";

    #! implies lines < 1000 chars (= no encoding)
    public const ContentTransEnc8Bit = "8bit";

    #! binary transfer encoding; implies no maximum line length (= no encoding)
    public const ContentTransEncBinary = "binary";

    #! base-64 Content-Transfer-Encoding
    public const ContentTransEncBase64 = "base64";

    #! quoted-printable Content-Transfer-Encoding
    public const ContentTransEncQuotedPrintable = "quoted-printable";

    #! maximum line length for base64 encoding
    /** <a href="http://tools.ietf.org/html/rfc2045#section-6.8">RFC 2045 section 6.8</a>
     */
    public const MimeBase64LineLen = 76;

    #! maximum line length for quoted-printable encoding
    /** <a href="http://tools.ietf.org/html/rfc2045#section-6.7">RFC 2045 section 6.7</a>
     */
    public const MimeQuotedPrintableLineLen = 76;
    #@}

    /** @defgroup MimeEncodingFunctions MIME Encoding Functions
     */
    #@{ 
    #! returns a string in "BASE64" encoding according to <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a>
    /** @param str the string to encode
	@param len the maximum line length

	@note this function is basically just a wrapper for the standard %Qore function makeBase64String()
     */
    public string sub mime_encode_base64(data $str, int $len = MimeBase64LineLen) {
	return makeBase64String($str, $len);
    }

    #! returns a string in "quoted-printable" (or "QP") encoding according to <a href="http://tools.ietf.org/html/rfc2045#section-6.7">RFC 2045 section 6.7</a>
    /** @param str the string to encode
	@param hdr use rules for a MIME header (<a href="http://tools.ietf.org/html/rfc2047">RFC 2047</a>)
     */
    public string sub mime_encode_quoted_printable(string $str, bool $hdr = False) {
	my string $rv;
	my int $lp = 0;

	for (my int $i = 0; $i < $str.size(); ++$i) {
	    my int $c = get_byte($str, $i);

	    # check if we're processing a UNIX '\n' line break
	    if ($c == 10) {
		# we MUST encode this as a CRLF sequence (we assume it's a UNIX line break)
		$rv += "\r\n";
		$lp = 0;
		continue;
	    }

	    # check if we're processing a CRLF line break
	    if ($c == 13 && get_byte($str, $i + 1) == 10) {
		$rv += "\r\n";
		$lp = 0;
		++$i;
		continue;
	    }

	    # new string to append
	    my string $nc;
	    # if we are encoding a header and we have a space, transform to "_"
	    if ($hdr && $c == 32)
		$nc = "_";
	    # check if the high bit is set or if it's an ASCII control character or '=', or we are encoding a header and the char is not '?' and '_', encode
	    else if (($c & 0x80) || $c < 32 || $c == 61 || ($hdr && ($c == 63 || $c == 95 || $c == 137)))
		$nc = sprintf("=%02x", $c).upr();
	    else
		$nc = chr($c);

	    # we MUST break up lines longer than 76 characters (the line length includes the '=' but not the CRLF
	    if (($nc.size() + $lp) >= (MimeQuotedPrintableLineLen - 1)) {
		# insert soft line break
		$rv += "=\r\n";
		$lp = 0;
	    }

	    $rv += $nc;
	    $lp += $nc.size();
	}
	return $rv;
    }

    #! encodes data according to the given encoding
    /** @param data the data to encode
        @param enc the encoding to use; see @ref MimeContentTransferEncodingConstants for possible values (case is ignored)

        @throw MIME-TRANSFER-ENCODING-ERROR unknown transfer encoding
     */
    public data sub mime_encode_transfer_data(data $data, string $enc) {
        $enc = $enc.lwr();
        switch ($enc) {
            case ContentTransEnc7Bit:
            case ContentTransEnc8Bit:
            case ContentTransEncBinary:
                return $data;

            case ContentTransEncBase64:
                return mime_encode_base64($data, MimeBase64LineLen);

            case ContentTransEncQuotedPrintable:
                return mime_encode_quoted_printable($data);
        }

        throw "MIME-TRANSFER-ENCODING-ERROR", sprintf("Content-Transfer-Encoding: %y is unknown", $enc);
    }

    #! returns a string in "B" ("BASE64") encoding for MIME header string words according to <a href="http://tools.ietf.org/html/rfc2047">RFC 2047</a>
    public string sub mime_encode_header_word_b(string $str) {
	return sprintf("=?%s?B?%s?=", get_encoding($str), makeBase64String($str, MimeBase64LineLen));
    }

    #! returns a string in "Q" ("quoted-printable") encoding for MIME header string words according to <a href="http://tools.ietf.org/html/rfc2047">RFC 2047</a>
    public string sub mime_encode_header_word_q(string $str) {
	return sprintf("=?%s?Q?%s?=", get_encoding($str), mime_encode_quoted_printable($str, True));
    }
    #@}

    /** @defgroup MimeDecodingFunctions MIME Decoding Functions
     */
    #@{ 
    #! returns a binary value from a string in "BASE64" encoding according to <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a>
    /** @param str the string to decode

	@note this function is basically just a wrapper for the standard %Qore function parseBase64String()
     */
    public binary sub mime_decode_base64(data $str) {
	return parseBase64String($str);
    }

    #! returns a string value from a string in "BASE64" encoding according to <a href="http://tools.ietf.org/html/rfc2045">RFC 2045</a>
    /** @param str the string to decode
        @param encoding the character encoding to use for the string returned (if not present the default encoding is used)

	@note this function is basically just a wrapper for the standard %Qore function parseBase64StringtoString()
     */
    public string sub mime_decode_base64_to_string(data $str, *string $encoding) {
	return parseBase64StringToString($str, $encoding);
    }

    #! returns a string parsed from "quoted-printable" (or "QP") encoding according to <a href="http://tools.ietf.org/html/rfc2045#section-6.7">RFC 2045 section 6.7</a>
    /** @param str the string to decode
        @param encoding the character encoding to use for the string returned (if not present the default encoding is used)

        @throw QUOTED-PRINTABLE-DECODE-ERROR an error occurred decoding the quoted-printable string
     */
    public string sub mime_decode_quoted_printable(string $str, *string $encoding) {
        $str = force_encoding($str, "us-ascii");

        if ($encoding.empty())
            $encoding = get_default_encoding();

	my string $rv;
	my int $lp = 0;

        # recombine broken lines
        $str = replace($str, "=\r\n", "");

%ifdef Unix
        # substitute all \r\n occurrences with \n
        $str = replace($str, "\r\n", "\n");
%endif

        # substitute all "_" occurrences with " "
        $str = replace($str, "_", " ");

        my int $i = 0;
        while (True) {
            $i = $str.find("=", $i);
            if ($i == -1)
                break;

            my string $hex = extract $str, $i + 1, 2;
            # according to RFC 2045 sec 6.7 rule (1): we have to use upper-case characters
            if ($hex !~ /[0-9A-Z][0-9A-Z]/)
                throw "QUOTED-PRINTABLE-DECODE-ERROR", sprintf("invalid hex byte code found: %y", $hex);
            # replace the code with the given character
            splice $str, $i, 1, chr(int($hex, 16), "us-ascii");
            ++$i;
        }

        return force_encoding($str, $encoding);
    }

    #! decodes data according to the given encoding
    /** @param data the data to decode
        @param enc the decoding to use; see @ref MimeContentTransferEncodingConstants for possible values (case is ignored)
        @param ct the content-type of the data; if there is a \c "charset=xxx" component and the data is decoded to a string, then it will be returned in the given character encoding

        @throw MIME-TRANSFER-ENCODING-ERROR unknown transfer encoding
     */
    public data sub mime_decode_transfer_data(data $data, string $enc, *string $ct) {
        $enc = $enc.lwr();
        switch ($enc) {
            case ContentTransEnc7Bit:
            case ContentTransEnc8Bit:
            case ContentTransEncBinary:
                break;

            case ContentTransEncBase64: {
                $data = mime_decode_base64($data);
                break;
            }

            case ContentTransEncQuotedPrintable: {
                $data = mime_decode_quoted_printable($data);
                break;
            }

            default:
                throw "MIME-TRANSFER-ENCODING-ERROR", sprintf("Content-Transfer-Encoding: %y is unknown", $enc);
        }

        if ($data.typeCode() == NT_STRING) {
            # see if there is a character encoding specification in the content-type
            my *string $senc = ($ct =~ x/charset="?([^"]+)"?/)[0];
            if (exists $senc)
                $data = force_encoding($data, $senc);
        }

        return $data;
    }

    #! decodes a header string; if any part of the string is encoded with "B" ("BASE64") or "Q" ("quoted-printable") encodings according to <a href="http://tools.ietf.org/html/rfc2045#section-6.7">RFC 2045 section 6.7</a>, then those parts are decoded and the decoded string is returned
    /** @param hdr the header value string to decode
        @return the decoded value of the header
     */
    public string sub mime_decode_header(string $hdr) {
        while (True) {
            my (*string $enc, *string $he, *string $hw) = ($hdr =~ x/=\?([^?]+)\?(Q|B)\?(.+)\?=/i);
            if (!$enc.val() || !$he.val() || !$hw.val())
                break;
            my string $dv = $he.upr() == "Q" ? mime_decode_quoted_printable($hw, $enc) : mime_decode_base64_to_string($hw, $enc);
            my string $os = sprintf("=?%s?%s?%s?=", $enc, $he, $hw);
            $hdr = replace($hdr, $os, $dv);
        }
        return $hdr;
    }
    #@}
    
    /** @defgroup MultiPartConstants MultiPartMessage Constants
     */
    #@{
    #! for form data (http://tools.ietf.org/html/rfc1867, http://tools.ietf.org/html/rfc2388)
    public const MPT_FORM_DATA   = "form-data";

    #! for sending files with different "Content-Type" headers (http://tools.ietf.org/html/rfc2046#section-5.1.3)
    public const MPT_MIXED       = "mixed";

    #! for email/MIME messages with headers (http://tools.ietf.org/html/rfc2046)
    public const MPT_MESSAGE     = "message";

    #! for sending multiple text messages (http://tools.ietf.org/html/rfc2046#section-5.1.5)
    public const MPT_DIGEST      = "digest";

    #! for sending multiple "alternatives" of the same content (http://tools.ietf.org/html/rfc2046#section-5.1.4)
    public const MPT_ALTERNATIVE = "alternative";

    #! for sending multiple components of an aggregated whole (http://tools.ietf.org/html/rfc2387)
    public const MPT_RELATED     = "related";

    #! to attach a digital signature to a message (http://tools.ietf.org/html/rfc1847#section-2.1)
    public const MPT_SIGNED      = "signed";

    #! for sending encrypted messages (http://tools.ietf.org/html/rfc1847#section-2.2)
    public const MPT_ENCRYPTED   = "encrypted";

    #! for sending noncontiguous byte ranges of a single message (http://tools.ietf.org/html/rfc2616)
    public const MPT_BYTERANGES  = "byteranges";
    #@}
        
    #! MultiPartMessage class implementation
    public class MultiPartMessage {
        const MP_DEFAULT_MSG = "This is a MIME multipart message";

        #! @cond nodoc
        private {
            #! the type of multi-part message: see @ref MultiPartConstants for possible values
            string $.mptype;

            #! the boundary to use between parts
            string $.boundary;

            #! the content type for the message as a whole
            string $.ct;

            #! list of the parts of the message
            list $.l = ();

            #! a hash of the headers of the message
            hash $.hdr;
        }
        #! @endcond

        #! creates the object
        /** @param mptype the type of multi-part message: see @ref MultiPartConstants for possible values
            @param boundary the boundary to use between parts
         */
        constructor(string $mptype, string $boundary = MultiPartMessage::getBoundary()) {
            $.mptype = $mptype;
            $.boundary = $boundary;
            $.ct = sprintf("multipart/%s;boundary=%s", $mptype, $boundary);
            $.boundary = "--" + $.boundary;
        }

        #! returns a string embedded with the current timestamp designed to be used as MultiPart boundary string
        static string getBoundary() {
            return "------Qore-MIME-Boundary" + now_us().format("YYYYMMDDHHmmSS.uuuZ") + "------";
        }

        #! returns a string of random characters
        /** @param len the length of the string to return

            @throw GET-RANDOM-STRING-ERROR error opending /dev/random;
         */
        static string getRandomString(int $len) {
            my File $f();
            # throw an exception if /dev/random cannot be opened for reading
            if ($f.open("/dev/random"))
                throw "GET-RANDOM-STRING-ERROR", "error opening /dev/random: ", strerror(errno());

            my binary $bin = $f.readBinary($len);
            my string $str;
            while ($len--) {
                my int $b = $bin[$len] % 62;
                my string $c;
                switch ($b) {
                    case < 10: { $c = chr(48 + $b); break; }
                    case < 36: { $c = chr(55 + $b); break; }
                    default:   { $c = chr(61 + $b); break; }
                }
                $str += $c;
            }
            return $str;
        }

        #! serializes the message and returns a binary object ready to send over a socket
        binary serialize() {
            my hash $h = $.getMsgAndHeaders();
            my binary $rv = MultiPartMessage::serializeHeaders($h.hdr);
            $rv += $h.body;
            return $rv;
        }

        #! serializes a header hash to a binary object
        /** @param hdr the hash to serialize

            @return the binary object representing the hash with each header separated by \c "\r\n"
         */
        static binary serializeHeaders(hash $hdr) {
            my binary $b;
            foreach my string $k in (keys $hdr)
                $b += sprintf("%s: %s\r\n", $k, $hdr.$k); 
            $b += "\r\n";
            return $b;
        }

        #! @cond nodoc
        # FIXME: replace with ab abstract method when Qore supports them
        hash getMsgAndHeaders() {
            throw "ABSTRACT-METHOD-ERROR", "MultiPartMessage::getMsgAndHeaders() is abstract; reimplement this method in your subclass";
        }

        # don't reimplement this method; fix/enhance it in the module
        final private hash getMsgAndHeadersIntern(*string $content_type, bool $conlen = True) {
            if (!exists $content_type)
                $content_type = $.ct;

            if ($.l.empty())
                throw "HTTP-MULTIPART-ERROR", "the message has no parts";

            my binary $msg = binary(MP_DEFAULT_MSG);
            foreach my hash $m in ($.l) {
                my binary $bd = binary($m.data);
                $msg += "\r\n" + $.boundary + "\r\n";
                $msg += MultiPartMessage::serializeHeaders($m.hdr + ($conlen ? ("Content-Length": $bd.size()) : NOTHING));
                $msg += $bd;
            }
            $msg += "\r\n" + $.boundary + "--";
            
            return (
                "hdr": $.hdr + ("Content-Type": $content_type),
                "body": $msg,
                );
        }

        # don't reimplement this method; fix/enhance it in the module
        private splicePartIntern(data $data, hash $hdr) {
            splice $.l, 0, 0, MultiPartMessage::getPart($data, $hdr);
        }

        # don't reimplement this method; fix/enhance it in the module
        private addPartIntern(data $data, hash $hdr) {
            $.l += MultiPartMessage::getPart($data, $hdr);
        }

        private static hash getPart(data $data, hash $hdr) {
            if (exists $hdr."Content-Length")
                throw "HTTP-MULTIPART-ERROR", "illegal part header 'Content-Length': the Content-Length header will be generated automatically according to the size of each part";

            switch ($data.typeCode()) {
                case NT_STRING: {
                    my string $ct = $hdr."Content-Type";
                    # NOTE we do not check if the charset matches the actual encoding here
                    # we just add the charset= text if it's not already present
                    if ($ct !~ /charset=/) {
                        if (!$ct.empty())
                            $ct += ";";
                        $ct += sprintf("charset=%s", get_encoding($data));
                        $hdr."Content-Type" = $ct;		
                    }
                    if (!exists $hdr."Content-Transfer-Encoding")
                        $hdr."Content-Transfer-Encoding" = "8bit";
                    break;
                }
                case NT_BINARY: {
                    if (!exists $hdr."Content-Transfer-Encoding")
                        $hdr."Content-Transfer-Encoding" = "binary";		
                }
            }
            return (
                "data": $data,
                "hdr": $hdr,
                );
        }
        #! @endcond
    }

    #! implements a MultiPartRelatedMessage class, a specialization of MultiPartMessage
    public class MultiPartRelatedMessage inherits MultiPartMessage {
        #! @cond nodoc
        private {
            # the starting part ID
            string $.startid;
        }
        #! @endcond

        #! creates the object
        /** @param boundary the boundary to use between parts
         */
        constructor(string $boundary = MultiPartMessage::getBoundary()) : MultiPartMessage(MPT_RELATED, $boundary) {
        }

        #! adds a message part to the start of the list
        /** @param data the data for the part
            @param id the multipart/related ID for the part
            @param content_type the content_type for the part
            @param hdr an optional hash of headers for the part

            @throw MULTIPART-RELATED-ERROR if the id parameter is empty, this exception is thrown
         */
        splicePart(data $data, string $id, string $content_type, *hash $hdr) {
            if ($id.empty())
                throw "MULTIPART-RELATED-ERROR", "missing second argument giving the Content-ID identifying the part; this header is required for each part as this is how the parts are related to the main message";

            $.startid = $id;
            $.splicePartIntern($data, $hdr + ("Content-ID": $id, "Content-Type": $content_type));
        }

        #! adds a message part to the end of the list
        /** @param data the data for the part
            @param id the multipart/related ID for the part
            @param content_type the content_type for the part
            @param hdr an optional hash of headers for the part

            @throw MULTIPART-RELATED-ERROR if the id parameter is empty, this exception is thrown
         */
        addPart(data $data, string $id, string $content_type, *hash $hdr) {
            if ($id.empty())
                throw "MULTIPART-RELATED-ERROR", "missing second argument giving the Content-ID identifying the part; this header is required for each part as this is how the parts are related to the main message";

            if (!exists $.startid)
                $.startid = $id;

            $.addPartIntern($data, $hdr + ("Content-ID": $id, "Content-Type": $content_type));
        }

        #! returns a hash of the message
        /** @return a hash of the message with the following keys:
            - \c hdr: a hash of header information
            - \c msg: a binary object of serialized message parts
         */
        hash getMsgAndHeaders() {
            return $.getMsgAndHeadersIntern($.ct + ";start=" + $.startid);
        }
    }

    #! implements a MultiPartMixedMessage class, a specialization of MultiPartMessage
    public class MultiPartMixedMessage inherits MultiPartMessage {
        #! creates the object
        /** @param boundary the boundary to use between parts
         */
        constructor(string $boundary = MultiPartMessage::getBoundary()) : MultiPartMessage(MPT_MIXED, $boundary) {
            $.hdr = (
                "MIME-Version": "1.0",
                );
        }

        #! adds a message part to the start of the list; the data muyst already be encoded and any Content-Transfer-Encoding header must already be present in hdr
        /** @param data the data for the part
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartMixedMessage::addPart()
            - MultiPartMixedMessage::spliceEncodePart()
            - MultiPartMixedMessage::addEncodePart()
         */
        splicePart(data $data, string $content_type = MimeTypeText, string $disp = "inline", *hash $hdr) {
            if ($content_type.empty())
                throw "PART-ERROR", "empty content type argument passed";

            $.splicePartIntern($data, $hdr + ("Content-Type": $content_type, "Content-Disposition": $disp));
        }

        #! adds a message part to the end of the list; the data muyst already be encoded and any Content-Transfer-Encoding header must already be present in hdr
        /** @param data the data for the part
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartMixedMessage::splicePart()
            - MultiPartMixedMessage::spliceEncodePart()
            - MultiPartMixedMessage::addEncodePart()
         */
        addPart(data $data, string $content_type = MimeTypeText, string $disp = "inline", *hash $hdr) {
            if ($content_type.empty())
                throw "PART-ERROR", "empty content type argument passed";

            $.addPartIntern($data, $hdr + ("Content-Type": $content_type, "Content-Disposition": $disp));
        }

        #! adds a message part to the start of the list; encodes the data according to the transfer encoding argument passed
        /** @param data the unencoded data for the part
            @param enc the transfer encoding to use for the part; see @ref MimeContentTransferEncodingConstants for possible values
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw MIME-TRANSFER-ENCODING-ERROR unknown transfer encoding
            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartMixedMessage::splicePart()
            - MultiPartMixedMessage::addPart()
            - MultiPartMixedMessage::addEncodePart()
         */
        spliceEncodePart(data $data, string $enc, string $content_type = MimeTypeText, string $disp = "inline", *hash $hdr) {
            if ($content_type.empty())
                throw "PART-ERROR", "empty content type argument passed";

            if ($data.typeCode() == NT_STRING && $content_type !~ /charset=/ && $disp == "inline")
                $content_type += sprintf(";charset=%s", get_encoding($data));
            $.splicePartIntern(mime_encode_transfer_data($data, $enc), $hdr + ("Content-Type": $content_type, "Content-Disposition": $disp, "Content-Transfer-Encoding": $enc));
        }

        #! adds a message part to the end of the list; encodes the data according to the transfer encoding argument passed
        /** @param data the unencoded data for the part
            @param enc the transfer encoding to use for the part; see @ref MimeContentTransferEncodingConstants for possible values
            @param content_type the content_type for the part
            @param disp the Content-Disposition header (ex: \c 'inline', \c 'attachment; filename="file.txt"')
            @param hdr an optional hash of headers for the part

            @throw MIME-TRANSFER-ENCODING-ERROR unknown transfer encoding
            @throw PART-ERROR empty content type argument passed

            @see
            - MultiPartMixedMessage::addPart()
            - MultiPartMixedMessage::splicePart()
            - MultiPartMixedMessage::spliceEncodePart()
         */
        addEncodePart(data $data, string $enc, string $content_type = MimeTypeText, string $disp = "inline", *hash $hdr) {
            if ($content_type.empty())
                throw "PART-ERROR", "empty content type argument passed";

            if ($data.typeCode() == NT_STRING && $content_type !~ /charset=/ && $disp == "inline")
                $content_type += sprintf(";charset=%s", get_encoding($data));
            $.addPartIntern(mime_encode_transfer_data($data, $enc), $hdr + ("Content-Type": $content_type, "Content-Disposition": $disp, "Content-Transfer-Encoding": $enc));
        }

        #! returns a hash of the message
        /** @return a hash of the message with the following keys:
            - \c hdr: a hash of header information
            - \c msg: a binary object of serialized message parts
         */
        hash getMsgAndHeaders() {
            return $.getMsgAndHeadersIntern(NOTHING, False);
        }
    }
}
