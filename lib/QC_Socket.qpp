/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  QC_Socket.qpp

  Socket class definition

  Qore Programming Language

  Copyright 2003 - 2011 David Nichols

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.
  
  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <qore/Qore.h>
#include <qore/intern/QC_Socket.h>
#include <qore/intern/ssl_constants.h>
#include <qore/intern/QC_Queue.h>

#include <errno.h>
#include <string.h>

qore_classid_t CID_SOCKET;
QoreClass *QC_SOCKET;

static AbstractQoreNode *doReadResult(int rc, int64 val, const char *method_name, int timeout_ms, ExceptionSink *xsink) {
   if (rc > 0)
      return new QoreBigIntNode(val);

   QoreSocket::doException(rc, method_name, timeout_ms, xsink);
   return 0;
}

static AbstractQoreNode *doSendResult(int rc, const char *method_name, ExceptionSink *xsink) {
   if (rc == -2)
      xsink->raiseException("SOCKET-NOT-OPEN", "socket must be opened before Socket::%s() call", method_name);
   else if (rc)
      xsink->raiseErrnoException("SOCKET-SEND-ERROR", rc, "Socket::%s() failed with error code %d", method_name, rc);
   return 0;
}

static AbstractQoreNode *checkOpenResult(int rc, const char *method_name, ExceptionSink *xsink) {
   if (*xsink)
      return 0;
   if (rc == -2) {
      xsink->raiseException("SOCKET-NOT-OPEN", "socket must be open before Socket::%s() call", method_name);
      return 0;
   }
   return new QoreBigIntNode(rc);
}

//! The Socket class allows Qore programs safe access to network sockets
/** @note This class is not available with the @ref PO_NO_NETWORK parse option.

    Non-blocking socket I/O can be performed by appending a timeout value in milliseconds to all Socket::recv*() methods, or by using the Socket::isDataAvailable() method with a timeout value in milliseconds (1000 ms = 1 second). Note that as with all Qore functions and methods accepting a timeout value, relative date/time values can be given instead of integers to make the source more readable, for example:

    <code>my bool $rc = $socket.isDataAvailable(1250ms); # times out in 1.25 seconds</code>

    Socket objects can automatically convert character encodings if desired when sending string data with Socket::send(). Use the Socket::setCharset() method to set the character encoding for the socket. If a character encoding is set, and string data is read with the Socket::recv() method, then it will be tagged with the encoding of the socket as well.

    Client applications should call Socket::connect() to connect to a remote port or a UNIX domain socket (socket file on the local server). However, if the remote end is expecting a TLS/SSL connection, use Socket::connectSSL() instead.

    Server applications should call Socket::bind(), Socket::listen(), and Socket::accept() in this order to accept incoming connections. Normally a new thread should be started after the Socket::accept() call to handle the new connection in a separate thread (Socket::accept() returns a new Socket object for the accepted connection).

    To support TLS/SSL server connections, first set the certificate and private key with the Socket::setCertificate() and Socket::setPrivateKey() methods (see the SSLCertificate Class and the SSLPrivateKey Class for more information on the parameters required for these methods). Then Socket::acceptSSL() should be called after the socket is in a listening state to accept client connections and negotiate a TLS/SSL connection.

    This class supports posting events to a Queue. See @ref event-handling for more information.

    The events raised by this object are listed in the following table:

    <b>Socket Events</b>

    |!Name|!Description
    |@ref EVENT_PACKET_READ|Raised when a network packet is received.
    |@ref EVENT_PACKET_SENT|Raised when a network packet is sent.
    |@ref EVENT_CHANNEL_CLOSED|Raised when a socket is closed.
    |@ref EVENT_DELETED|Raised when the object being monitored is deleted.
    |@ref EVENT_HOSTNAME_LOOKUP|Raised when a hostname lookup is attempted.
    |@ref EVENT_HOSTNAME_RESOLVED|Raised when a hostname lookup is resolved.
    |@ref EVENT_HTTP_SEND_MESSAGE|Raised when an HTTP message is sent.
    |@ref EVENT_HTTP_MESSAGE_RECEIVED|Raised when an HTTP message is received.
    |@ref EVENT_CONNECTING|Raised right before a socket connection attempt is made.
    |@ref EVENT_CONNECTED|Raised when the socket connection has been established.
    |@ref EVENT_START_SSL|Raised when socket SSL negotiation starts.
    |@ref EVENT_SSL_ESTABLISHED|Raised when SSL communication has been negotiated and established.

    @section socket_info_hash Socket Information Hash

    |!Key|!Description
    |\c hostname|The interface name if available (ex: \c "localhost"; note that this key is not present when retrieving information about UNIX sockets)
    |\c hostname_desc|A descriptive string giving the hostname and the address family if the hostname is available (ex: \c "ipv6[localhost]"; note that this key is not present when retrieving information about UNIX sockets)
    |\c address|A string giving the address (ex: \c "::ffff:0.0.0.0")
    |\c address_desc|A descriptive string giving the address and the address family (ex: \c "ipv6[::ffff:0.0.0.0]")
    |\c port|An integer port number if available (note that this key is not present when retrieving information about UNIX sockets)
    |\c family|The network address family (see @ref network_address_family_constants)
    |\c familystr|A string describing the network address family (ex: \c "ipv4")
 */
qclass Socket [types=SSLCert,SSLPrivKey; flags=unsetPublicMemberFlag; arg=mySocket* s; dom=NETWORK];

//! Creates the socket object
Socket::constructor() {
   self->setPrivate(CID_SOCKET, new mySocket);
}

//! Creates a new Socket object, not based on the source being copied
Socket::copy() {
   self->setPrivate(CID_SOCKET, new mySocket);
}

//! Connects to a remote port (if the string has a format "host:port") or UNIX domain socket file with an optional timeout value with a millisecond resolution
/** Connects the socket to a remote (or local) port or UNIX domain socket file, for network (ipv4 and ipv6) connections, accepts an optional timeout value in milliseconds (@ref relative_dates "relative date/time values" can be given instead of an integer in milliseconds to make the source more readable; ex: 20s). If any errors occur, an exception is thrown.

    Examples:
    <code># connect to ipv4 adress 192.168.1.45 port 8080 with a 30 second timeout
$sock.connect("192.168.1.45:8080", 30s);</code>

    <code># connect to ipv6 adress 2001:0db8:85a3:0000:0000:8a2e:0370:7334 port 80 with a 10 second timeout
$sock.connect("[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:80", 10s);</code>

    <code># connect to localhost using ipv6 (::1) port 80 with a 10 second timeout
$sock.connect("[localhost]:80", 15s);</code>

    <code># connect to UNIX domain socket file "/tmp/socket"
$sock.connect("/tmp/socket");</code>

    @par Events
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED

    @param target If a colon appears in the string, the string will be assumed to be a hostname:port specification to connect to. If the string contains no colon, the socket will try to connect to a UNIX domain socket file on the local filesystem with the given name.  Enclose ipv6 addresses in square brackets (ex: \c "[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:80", will connect to port 80 on the given ipv6 address); also if a hostname is enclosed in squark brackets, it will be resolved as an ipv6 adress (ex: \c "[localhost]:80" will connect to port \c 80 on \c ::1, assuming \c "localhost" can be resolved to the ipv6 loopback address on the system).

    @param timeout_ms If a timeout value is passed and the connection takes longer to establish than the timeout, a \c "SOCKET-CONNECT-ERROR" exception is thrown.

    @throw SOCKET-CONNECT-ERROR An error occured connecting to the remote socket (cannot resolve hostname, no listener, timeout exceeded, etc).

    @see Socket::connectUNIX(), Socket::connectUNIX(), Socket::connectSSL(), Socket::connectINETSSL(), and Socket::connectUNIXSSL()
 */
nothing Socket::connect(string target, timeout timeout_ms = -1) {
   s->connect(target->getBuffer(), timeout_ms, xsink);
}

//! Connects to the given host and port with an optional timeout value with a millisecond resolution
/** Connects the socket to a remote (or local) port; accepts an optional timeout value in milliseconds (@ref relative_dates "relative date/time values" can be given instead of an integer in milliseconds to make the source more readable; ex: \c 20s). If any errors occur, an exception is thrown.

    Do not use square brackets to designate ipv6 addresses with this method; just give the address in its normal form (ex: \c "2001:0db8:85a3:0000:0000:8a2e:0370:7334").

    Examples:
    <code># connect to ipv4 address 192.168.1.45 port 8080 with a 30 second timeout
$sock.connectINET("192.168.1.45", 8080, 30s);</code>

    <code># connect to ipv6 address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 port 80 with a 20 second timeout
$sock.connectINET("2001:0db8:85a3:0000:0000:8a2e:0370:7334", 80, 20s);</code>

    @par Events
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED

    @param host The host name or IP address to connect to
    @param service The service name (ex: \c "http" or port number (given as or converted to a string) to connect to
    @param timeout_ms If a timeout value is passed and the connection takes longer to establish than the timeout, a \c "SOCKET-CONNECT-ERROR" exception is thrown
    @param family The address family to use to connect to the remote socket; see @ref network-address-family-constants
    @param socktype The type of socket; see @ref socket-type-constants; typically @ref SOCK_STREAM for TCP sockets
    @param protocol The protocol number for the socket (if not sure leave this 0)

    @throw SOCKET-CONNECT-ERROR An error occured connecting to the remote socket (cannot resolve hostname, no listener, timeout exceeded, etc)

    @see Socket::connect(), Socket::connectUNIX(), Socket::connectSSL(), Socket::connectINETSSL(), and Socket::connectUNIXSSL()
 */
nothing Socket::connectINET(string host, softstring service, timeout timeout_ms = -1, softint family = AF_UNSPEC, softint socktype = SOCK_STREAM, softint protocol = 0) {
   s->connectINET2(host->getBuffer(), service->getBuffer(), family, socktype, protocol, timeout_ms, xsink);
}

//! Connects to a UNIX domain socket file
/** Connects the socket to the given UNIX domain socket file; if any errors occur, an exception is thrown

    Example:
    @code # connect to UNIX domain socket file "/tmp/socket"
$sock.connectUNIX("/tmp/socket");@endcode

    @par Events
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED

    @param path The socket will try to connect to a UNIX domain socket file on the local filesystem with the given name
    @param socktype The type of socket; see @ref socket-type-constants; typically @ref SOCK_STREAM for TCP sockets
    @param protocol The protocol number for the socket (if not sure leave this 0)

    @throw SOCKET-CONNECT-ERROR An error occured connecting to the socket

    @see Socket::connect(), Socket::connectINET(), Socket::connectSSL(), Socket::connectINETSSL(), and Socket::connectUNIXSSL()

    @note UNIX domain sockets are not available on native Windows ports
 */
nothing Socket::connectUNIX(string path, softint socktype = SOCK_STREAM, softint protocol = 0) {
   s->connectUNIX(path->getBuffer(), socktype, protocol, xsink);
}

//! Connects to a remote socket and attempts to establish a TLS/SSL connection; accepts an optional timeout value with a millisecond resolution
/** Connects to a remote socket and attempts to establish a TLS/SSL connection, for network (INET) connections, accepts an optional timeout value in milliseconds (@ref relative_dates "relative date/time values" can be given instead of an integer in milliseconds to make the source more readable; ex: \c 20s). If any errors occur, an exception is thrown.

    Enclose ipv6 addresses in square brackets (ex: \c "[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:80", will connect to port 80 on the given ipv6 address); also if a hostname is enclosed in square brackets, it will be resolved as an ipv6 adress (ex: \c "[localhost]:80" will connect to port \c 80 on \c ::1, assuming \c "localhost" can be resolved to the ipv6 loopback address on the system).

    Examples:
    @code # connect to ipv4 adress 192.168.1.45 port 8080 with a 30 second timeout
$sock.connectSSL("192.168.1.45:8080", 30s);@endcode

    @code # connect to ipv6 adress 2001:0db8:85a3:0000:0000:8a2e:0370:7334 port 80 with a 10 second timeout
$sock.connectSSL("[2001:0db8:85a3:0000:0000:8a2e:0370:7334]:80", 10s);@endcode

    @code # connect to localhost using ipv6 (::1) port 80 with a 10 second timeout
$sock.connectSSL("[localhost]:80", 15s);@endcode

    @code # connect to UNIX domain socket file "/tmp/socket"
$sock.connectSSL("/tmp/socket");@endcode

    @par Events
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED

    @param dest if a colon appears in the string, the string will be assumed to be a \c "target:port" specification to connect to (unless the host address is enclosed in square brackets, in which case it's interpreted as an IPv6 address). If the string contains no colon, the socket will try to connect to a UNIX domain socket file on the local filesystem with the given name.
    @param timeout_ms if a timeout value is passed and the connection takes longer to establish than the timeout, an exception is thrown

    @throw SOCKET-CONNECT-ERROR An error occured connecting to the remote socket (cannot resolve hostname, no listener, timeout exceeded, etc)
    @throw SOCKET-SSL-ERROR An error occurred establishing the TLS/SSL connection
    @throw SOCKET-CLOSED The TLS/SSL connection was shut down by the remote end

    @see Socket::connect(), Socket::connectUNIX(), Socket::connectUNIXSSL(), Socket::connectINETSSL(), and Socket::connectINET()
 */
nothing Socket::connectSSL(string $dest, timeout $timeout_ms = -1) {
   s->connectSSL(args->getBuffer(), timeout_ms, xsink);
}

//! Connects to the given host and port and attempts to establish a TLS/SSL connection; accepts an optional timeout value with a millisecond resolution
/** Connects the socket to a remote (or local) port and attempts to establish a TLS/SSL connection; accepts an optional timeout value in milliseconds (@ref relative_dates "relative date/time values" can be given instead of an integer in milliseconds to make the source more readable; ex: \c 20s). If any errors occur, an exception is thrown.
    
    Do not use square brackets to designate ipv6 addresses with this method; just give the address in its normal form (ex: \c "2001:0db8:85a3:0000:0000:8a2e:0370:7334").

    Examples:
    @code # connect to 192.168.1.45 port 8080 with a 30 second timeout
$sock.connectINETSSL("192.168.1.45", 8080, 30s);@endcode

    @code # connect to ipv6 address 2001:0db8:85a3:0000:0000:8a2e:0370:7334 port 80 with a 20 second timeout
$sock.connectINETSSL("2001:0db8:85a3:0000:0000:8a2e:0370:7334", 80, 20s);@endcode

    @par Events
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED

    @param host The host name or IP address to connect to
    @param service The service name (ex: \c "http" or port number (given as or converted to a string) to connect to
    @param timeout_ms If a timeout value is passed and the connection takes longer to establish than the timeout, a \c "SOCKET-CONNECT-ERROR" exception is thrown
    @param family The address family to use to connect to the remote socket; see @ref network-address-family-constants
    @param socktype The type of socket; see @ref socket-type-constants; typically @ref SOCK_STREAM for TCP sockets
    @param protocol The protocol number for the socket (if not sure leave this 0)

    @throw SOCKET-CONNECT-ERROR An error occured connecting to the remote socket (cannot resolve hostname, no listener, timeout exceeded, etc)
    @throw SOCKET-SSL-ERROR An error occurred establishing the TLS/SSL connection
    @throw SOCKET-CLOSED The TLS/SSL connection was shut down by the remote end

    @see Socket::connect(), Socket::connectUNIX(), Socket::connectSSL(), Socket::connectINET(), and Socket::connectUNIXSSL()
 */
nothing Socket::connectINETSSL(string host, softstring service, timeout timeout_ms = -1, softint family = AF_UNSPEC, softint socktype = SOCK_STREAM, softint protocol = 0) {
   s->connectINET2SSL(host->getBuffer(), service->getBuffer(), family, socktype, protocol, timeout_ms, xsink);
}

//! Connects to the given UNIX domain socket file and attempts to establish a TLS/SSL connection
/** Connects the socket to a UNIX domain socket file and attempts to establish a TLS/SSL connection. If any errors occur, an exception is thrown.

    Example:
    @code # connect to UNIX domain socket file "/tmp/socket"
$sock.connectUNIXSSL("/tmp/socket");@endcode

    @par Events
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED

    @param path The socket will try to connect to a UNIX domain socket file on the local filesystem with the given name
    @param socktype The type of socket; see @ref socket-type-constants; typically @ref SOCK_STREAM for TCP sockets
    @param protocol The protocol number for the socket (if not sure leave this 0)

    @throw SOCKET-CONNECT-ERROR An error occured connecting to the socket
    @throw SOCKET-SSL-ERROR An error occurred establishing the TLS/SSL connection
    @throw SOCKET-CLOSED The TLS/SSL connection was shut down by the remote end

    @see Socket::connect(), Socket::connectUNIX(), Socket::connectSSL(), Socket::connectINETSSL(), and Socket::connectINET()

    @note UNIX domain sockets are not available on native Windows ports
 */
nothing Socket::connectUNIXSSL(string path, softint socktype = SOCK_STREAM, softint protocol = 0) {
   s->connectUNIXSSL(path->getBuffer(), socktype, protocol, xsink);
}

//! Opens and binds the socket to a port, interface and port (if the $bind_to string has a format "host:port"), or UNIX domain socket file. 
/** If the second parameter is \c True, then the socket will set the \c SO_REUSEADDR option, which will allow the socket to be bound to a port that is not yet closed (for example, in a \c TIME_WAIT state). 

    If any errors occur a non-zero error code is returned.

    This method tries to automatically pick the appropriate address family from the arguments; note that a hostname or address in square brackets (ex: \c "[localhost]") will be looked up and bound as an IPv6 address; additionally, the method recognizes ipv6 addresses by embedded colons (:) in the address string and binds them as such.

    Internally, the getaddrinfo() function is used to look up bind addresses; internal \c bind() operations are tried in sequence for each address returned; as soon as a bind operation is successful, the method returns. If none of the addresses can be bound, then an error code is returned.

    @param str If a colon appears in the string, the string will be assumed to be a \c "bind_address:port" specification, and the port on the named IP address will be bound, otherwise, if the string contains no colon, the socket will be bound to a UNIX domain socket file on the local filesystem with the given name.  Note that a hostname or address in square brackets (ex: \c "[localhost]") will be looked up and bound as an IPv6 address; additionally, the method recognizes ipv6 addresses by embedded colons (:) in the address string (if surrounded by square brackets) and binds them as such.
    @param reuseaddr If this optional argument evaluates to \c True, the \c SO_REUSEADDR option will be set on the socket, which will allow the socket to be bound to a port that is not yet closed (for example, in a \c TIME_WAIT state); note that this only applies to IPv4 (@ref AF_INET) and IPv6 (@ref AF_INET6) sockets; this option is ignored for UNIX (@ref AF_UNIX) sockets.
    
    @see Socket::bindINET() and Socket::bindUNIX()

    @note UNIX domain sockets are not available on native Windows ports
*/
int Socket::bind(string str, softbool reuseaddr = False) {
   return s->bind(str->getBuffer(), reuseaddr);
}

//! Opens and binds the socket to an INET port on all interfaces 
/** If the second parameter is \c True, then the socket will set the \c SO_REUSEADDR option, which will allow the socket to be bound to a port that is not yet closed (for example, in a \c TIME_WAIT state). 

    If any errors occur a non-zero error code is returned.

    Example:
    @code # bind to port 80 on all interfaces on the local system and reuse the address, check return code
if ($sock.bind(80, True))
    @throw "BIND-ERROR", strerror(errno());@endcode
    
    @param port A port number to bind to on all interfaces
    @param reuseaddr If this optional argument evaluates to \c True, the \c SO_REUSEADDR option will be set on the socket, which will allow the socket to be bound to a port that is not yet closed (for example, in a \c TIME_WAIT state)
    
    @see Socket::bindINET() and Socket::bindUNIX()
*/
int Socket::bind(int port, softbool reuseaddr = False) {
   return s->bind(port, reuseaddr);
}

//! Opens and binds the socket to the given UNIX domain socket file as given by the filename argument. If any errors occur, an exception is thrown
/** Opens and binds the socket to the given UNIX domain socket file as given by the filename argument. Note that the socket file is automatically deleted in the destructor when a UNIX socket is closed. If any errors occur, an exception is thrown.

    Example
    @code # bind to UNIX domain socket file "/tmp/socket"
$sock.bindUNIX("/tmp/socket");@endcode

    @param path The path of the UNIX domain socket to create and bind to
    @param socktype the type of socket; see Socket Type Constants; typically \c SOCK_STREAM for TCP sockets
    @param protocol the protocol number for the socket; use 0 for the default protocol

    @throw SOCKET-BIND-ERROR Error opening socket for bind; error binding on socket

    @see Socket::bind() and Socket::bindINET()

    @note UNIX domain sockets are not available on native Windows ports
 */
nothing Socket::bindUNIX(string name, softint socktype = SOCK_STREAM, softint protocol = 0) {
   s->bindUNIX(name->getBuffer(), socktype, protocol, xsink);
}

//! Opens and binds the socket to the given IPv4 or IPv6 interface (or if no interface is given, then to all interfaces on the local system) and port (the port number will be derived from the service name if a numeric port number is not given)
/** Opens and binds the socket to a port, interface and port (if the interface string has a format \c "host:port"), or UNIX domain socket file (if no port or service name appears in the bind string). If the second parameter is \c True, then the socket will set the \c SO_REUSEADDR option, which will allow the socket to be bound to a port that is not yet closed (for example, in a \c TIME_WAIT state).

    Internally, the getaddrinfo() function is used to look up bind addresses; internal bind() operations are tried in sequence for each address returned; as soon as a bind operation is successful, the method returns. If none of the addresses can be bound, then an error code is returned.

    If any errors occur, an exception is thrown.

    Examples
    @code # bind to port 80 on all interfaces on the local system and reuse the address
$sock.bindINET(NOTHING, 80, True);@endcode
    @code # bind to interface 192.168.2.23 port 8080 and do not reuse the address
$sock.bindINET("192.168.2.23", 8080);@endcode
    @code # bind to localhost port 8080 with ipv6 and do not reuse the address
$sock.bindINET("localhost", 8080, False, AF_INET6);@endcode
    @code # bind to ipv6 host address fe80::21c:42ff:fe00:8, port 1001, reuse the address
$sock.bindINET("fe80::21c:42ff:fe00:8", 1001, True);@endcode

    @param interface the host name or IP address to bind to
    @param service the service name (ex: "http" or port number (given as or converted to a string) to bind to
    @param reuseaddr if this optional argument evaluates to True, the \c SO_REUSEADDR option will be set on the socket, which will allow the socket to be bound to a port that is not yet closed (for example, in a \c TIME_WAIT state)
    @param family the address family to use to bind; see Network Address Family Constants; \c AF_UNSPEC means to try all possible addres families
    @param socktype the type of socket; see @ref socket_type_constants; typically \c SOCK_STREAM for TCP sockets
    @param protocol the protocol number for the socket; use 0 for the default protocol

    @throw SOCKET-BIND-ERROR Both hostname and service name are empty or not set; error opening socket for bind; error binding on socket.
    @throw QOREADDRINFO-GETINFO-ERROR error looking up either nodename or servicename (or not known)

    @see Socket::bind() and Socket::bindUNIX()
 */
nothing bindINET(*string interface, *softstring service, softbool reuseaddr = False, softint family = AF_UNSPEC, softint socktype = SOCK_STREAM, softint protocol = 0) {
   if ((!interface || interface->empty())
       && (!service || service->empty())) {
      xsink->raiseException("SOCKET-BIND-ERROR", "both interace (first parameter) and service (second parameter) were either not present or empty strings; at least one of the first 2 parameters must be present for a successful call to Socket::bindINET()");
      return 0;
   }

   s->bindINET(interface ? interface->getBuffer() : 0, service ? service->getBuffer() : 0, reuseaddr, family, socktype, protocol, xsink);
   return 0;
}

//! Accepts connections on a listening socket
/** Accepts connections on a listening socket; if any errors occur, an exception is thrown.

    The new Socket object returned will have the same character encoding as the current object. Once a new connection has been accepted, call Socket::getPeerInfo() to get information about the remote socket.

    Example
    @code my Socket $new_socket = $sock.accept();@endcode

    @return a new Socket object is returned for the new connection

    @throw SOCKET-NOT-OPEN The socket is not bound
    @throw SOCKET-ACCEPT-ERROR Error in accepting connection

    @see Socket::acceptSSL(), Socket::listen(), Socket::getPeerInfo()
 */
Socket Socket::accept() {
   mySocket *n = s->accept(-1, xsink);
   if (!n) {
      assert(*xsink);
      return 0;
   }

   assert(n);

   // ensure that a socket object is returned (and not a subclass)
   QoreObject *ns = new QoreObject(QC_SOCKET, getProgram(), n);

   // save backwards-compatible peer parameters as members in new object (deprecated: Socket::getPeerInfo() should be used in the future)
   n->setAccept(ns);

   return ns;
}

//! Accepts connections on a listening socket (see Socket::listen()) accepting a timeout value with a millisecond resolution
/** If any errors occur, an exception is thrown.

    The new Socket object returned will have the same character encoding as the current object. Once a new connection has been accepted, call Socket::getPeerInfo() to get information about the remote socket.

    Example
    @code my *Socket $new_socket = $sock.accept(30s);@endcode

    @param timeout_ms If a timeout value is passed and the connection takes longer to establish than the timeout, then NOTHING is returned

    @return If no connection is accepted within the timeout period, then NOTHING is returned, otherwise a Socket object for the new connection is returned.

    @throw SOCKET-NOT-OPEN The socket is not bound
    @throw SOCKET-ACCEPT-ERROR Error in accepting connection 

    @see Socket::acceptSSL(), Socket::listen(), Socket::getPeerInfo()
 */
*Socket Socket::accept(timeout timeout_ms) {
   mySocket *n = s->accept(timeout_ms, xsink);
   if (!n)
      return 0;

   // ensure that a socket object is returned (and not a subclass)
   QoreObject *ns = new QoreObject(QC_SOCKET, getProgram(), n);

   // save backwards-compatible peer parameters as members in new object (deprecated: Socket::getPeerInfo() should be used in the future)
   n->setAccept(ns);

   return ns;
}

//! Accepts connections on a listening socket and attempts to negotiate a TLS/SSL connection
/** Accepts connections on a listening socket and attempts to negotiate a TLS/SSL connection; if any errors occur, an exception is thrown.

    The new Socket object returned will have the same character encoding as the current object. Once a new connection has been accepted, call Socket::getPeerInfo() to get information about the remote socket.

    Example
    @code my Socket $new_socket = $sock.acceptSSL();@endcode

    @return When a new connection is accepted and a TLS/SSL session has been successfully negotated, a new Socket object is returned for the new connectio

    @throw SOCKET-NOT-OPEN The socket is not bound
    @throw SOCKET-ACCEPT-ERROR Error in accepting connection

    @see Socket::accept(), Socket::listen(), Socket::getPeerInfo()
 */

Socket Socket::acceptSSL() {
   mySocket *n = s->acceptSSL(-1, xsink);
   if (!n) {
      assert(*xsink);
      return 0;
   }

   // ensure that a socket object is returned (and not a subclass)
   QoreObject *ns = new QoreObject(QC_SOCKET, getProgram(), n);

   // save backwards-compatible peer parameters as members in new object (deprecated: Socket::getPeerInfo() should be used in the future)
   n->setAccept(ns);
   
   return ns;
}

//! Accepts connections on a listening socket and attempts to negotiate a TLS/SSL connection accepting a timeout value with a millisecond resolution
/** If any errors occur, an exception is thrown.

    The new Socket object returned will have the same character encoding as the current object. Once a new connection has been accepted, call Socket::getPeerInfo() to get information about the remote socket.

    Example
    @code my *Socket $new_socket = $sock.acceptSSL(30s);@endcode

    @param timeout_ms If a timeout value is passed and the connection takes longer to establish than the timeout, then NOTHING is returned

    @return If no connection is accepted within the timeout period, then NOTHING is returned, otherwise a Socket object for the new connection is returned.

    @throw SOCKET-NOT-OPEN The socket is not bound
    @throw SOCKET-ACCEPT-ERROR Error in accepting connection 

    @see Socket::acceptSSL(), Socket::listen(), Socket::getPeerInfo()
 */
*Socket Socket::acceptSSL(timeout timeout_ms) {
   mySocket *n = s->acceptSSL(timeout_ms, xsink);
   if (!n)
      return 0;

   // ensure that a socket object is returned (and not a subclass)
   QoreObject *ns = new QoreObject(QC_SOCKET, getProgram(), n);

   // save backwards-compatible peer parameters as members in new object (deprecated: Socket::getPeerInfo() should be used in the future)
   n->setAccept(ns);
   
   return ns;
}

//! Listens for connections on a bound socket; sets the socket in a listening state
/** Listens for new connections on a bound socket.

    Example
    @code $sock.listen();@endcode

    @return Returns 0 for success, -1 for error

    @throw SOCKET-NOT-OPEN The socket is not bound
 */
int Socket::listen() {
   return checkOpenResult(s->listen(), "listen", xsink);
}

//! Sends binary data over the socket
/** If an error occurs, -1 will be returned; in this case check errno() for the error number.

    Example
    @code if ($sock.send($data) == -1)
    printf("error sending data: %s\n", strerror(errno()));@endcode

    @par Events
    @ref EVENT_PACKET_SENT

    @param Sends the binary data over the socket

    @return 0 for success, -1 for error; in this case check errno() for the error number

    @throw SOCKET-NOT-OPEN The socket is not connected

    @see Socket::sendBinary()
 */
int Socket::send(binary bin) {
   return checkOpenResult(s->send(bin), "send", xsink);
}

//! Sends string data over the socket; string data is converted to the socket's encoding if necessary
/** String data will be converted to the encoding set for the socket if necessary. If an error occurs, -1 will be returned; in this case check errno() for the error number.

    Example
    @code if ($sock.send($str) == -1)
    printf("error sending data: %s\n", strerror(errno()));@endcode

    @par Events
    @ref EVENT_PACKET_SENT

    @param data dends the string data over the socket without the trailing null ('\0') character; the string's encoding is converted to the socket's encoding if necessary

    @return 0 for success, -1 for error; in this case check errno() for the error number

    @throw SOCKET-NOT-OPEN The socket is not connected

    @see Socket::sendBinary()
 */
int Socket::send(string str) {
   return checkOpenResult(s->send(str, xsink), "send", xsink);
}

//! Sends string data over the socket without converting the string to the socket's encoding, but instead is sent exactly as-is
/** If an error occurs, -1 will be returned; in this case check errno() for the error number.

    Example
    @code if ($sock.sendBinary($str) == -1)
    printf("error sending data: %s\n", strerror(errno()));@endcode

    @par Events
    @ref EVENT_PACKET_SENT

    @param data dends the string data over the socket without the trailing null ('\0') character

    @return 0 for success, -1 for error; in this case check errno() for the error number

    @throw SOCKET-NOT-OPEN The socket is not connected

    @see Socket::send()
 */
int Socket::sendBinary(string str) {
   return checkOpenResult(s->send(str->getBuffer(), str->strlen()), "send", xsink);
}

//! Sends binary data over the socket
/** If an error occurs, -1 will be returned; in this case check errno() for the error number.

    Example
    @code if ($sock.sendBinary($data) == -1)
    printf("error sending data: %s\n", strerror(errno()));@endcode

    @par Events
    @ref EVENT_PACKET_SENT

    @param Sends the binary data over the socket

    @return 0 for success, -1 for error; in this case check errno() for the error number

    @throw SOCKET-NOT-OPEN The socket is not connected

    @see Socket::sendBinary()
 */
int Socket::sendBinary(binary bin) {
   return checkOpenResult(s->send(bin), "send", xsink);
}

//! Sends a 1-byte integer over the socket
/** If an error occurs, -1 will be returned; in this case check errno() for the error number

    Example
    @code if ($sock.sendi1($val) == -1)
    printf("error sending data: %s\n", strerror(errno()));@endcode

    @par Events
    @ref EVENT_PACKET_SENT

    @param i the integer to send; only the least-significant byte will be sent

    @return 0 for success, -1 for error; in this case check errno() for the error number

    @throw SOCKET-NOT-OPEN The socket is not connected    
 */
int Socket::sendi1(softint i = 0) {
   return checkOpenResult(s->sendi1((char)i), "sendi1", xsink);
}

//! Sends a 2-byte (16-bit) integer in big-endian format (network byte order) over the socket
/** If an error occurs, -1 will be returned; in this case check errno() for the error number

    Example
    @code if ($sock.sendi2($val) == -1)
    printf("error sending data: %s\n", strerror(errno()));@endcode

    @par Events
    @ref EVENT_PACKET_SENT

    @param i the integer to send; only the least-significant 2 bytes will be sent

    @return 0 for success, -1 for error; in this case check errno() for the error number

    @throw SOCKET-NOT-OPEN The socket is not connected    
 */
int Socket::sendi2(softint i = 0) {
   return checkOpenResult(s->sendi2((short)i), "sendi2", xsink);
}

//! Sends a 4-byte (32-bit) integer in big-endian format (network byte order) over the socket
/** If an error occurs, -1 will be returned; in this case check errno() for the error number

    Example
    @code if ($sock.sendi4($val) == -1)
    printf("error sending data: %s\n", strerror(errno()));@endcode

    @par Events
    @ref EVENT_PACKET_SENT

    @param i the integer to send; only the least-significant 4 bytes will be sent

    @return 0 for success, -1 for error; in this case check errno() for the error number

    @throw SOCKET-NOT-OPEN The socket is not connected    
 */
int Socket::sendi4(softint i = 0) {
   return checkOpenResult(s->sendi4((int)i), "sendi4", xsink);
}

//! Sends an 8-byte (64-bit) integer in big-endian format (network byte order) over the socket
/** If an error occurs, -1 will be returned; in this case check errno() for the error number

    Example
    @code if ($sock.sendi8($val) == -1)
    printf("error sending data: %s\n", strerror(errno()));@endcode

    @par Events
    @ref EVENT_PACKET_SENT

    @param i the integer to send

    @return 0 for success, -1 for error; in this case check errno() for the error number

    @throw SOCKET-NOT-OPEN The socket is not connected    
 */
int Socket::sendi8(softint i = 0) {
   return checkOpenResult(s->sendi8(i), "sendi8", xsink);
}

//! Sends a 2-byte (16-bit) integer in little-endian format over the socket
/** If an error occurs, -1 will be returned; in this case check errno() for the error number

    Example
    @code if ($sock.sendi2LSB($val) == -1)
    printf("error sending data: %s\n", strerror(errno()));@endcode

    @par Events
    @ref EVENT_PACKET_SENT

    @param i the integer to send; only the least-significant 2 bytes will be sent

    @return 0 for success, -1 for error; in this case check errno() for the error number

    @throw SOCKET-NOT-OPEN The socket is not connected    
 */
int Socket::sendi2LSB(softint i = 0) {
   return checkOpenResult(s->sendi2LSB((short)i), "sendi2LSB", xsink);
}

//! Sends a 4-byte (32-bit) integer in little-endian format over the socket
/** If an error occurs, -1 will be returned; in this case check errno() for the error number

    Example
    @code if ($sock.sendi4LSB($val) == -1)
    printf("error sending data: %s\n", strerror(errno()));@endcode

    @par Events
    @ref EVENT_PACKET_SENT

    @param i the integer to send; only the least-significant 4 bytes will be sent

    @return 0 for success, -1 for error; in this case check errno() for the error number

    @throw SOCKET-NOT-OPEN The socket is not connected    
 */
int Socket::sendi4LSB(softint i = 0) {
   return checkOpenResult(s->sendi4LSB((int)i), "sendi4LSB", xsink);
}

//! Sends an 8-byte (64-bit) integer in little-endian format over the socket
/** If an error occurs, -1 will be returned; in this case check errno() for the error number

    Example
    @code if ($sock.sendi8LSB($val) == -1)
    printf("error sending data: %s\n", strerror(errno()));@endcode

    @par Events
    @ref EVENT_PACKET_SENT

    @param i the integer to send

    @return 0 for success, -1 for error; in this case check errno() for the error number

    @throw SOCKET-NOT-OPEN The socket is not connected    
 */
int Socket::sendi8LSB(softint i = 0) {
   return checkOpenResult(s->sendi8LSB(i), "sendi8LSB", xsink);
}

//! Receives data from the socket and returns a string tagged with the Socket's character encoding
/** If any errors occur reading from the socket, an exception is raised

    Example
    @code my string $data = $sock.recv(-1); # read all data available@endcode

    @par Events
    @ref EVENT_PACKET_READ
    
    @param size the amount of data to read in bytes; to read until the remote closes the connection, use -1
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been read or the remote end closes the connection

    @return the data read, returned as a string tagged with the Socket's character encoding

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection.
    @throw SOCKET-RECV-ERROR there was an error receiving the data.
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::setEncoding()
 */
string Socket::recv(int size = 0, timeout timeout_ms -1) {
   int rc;
   QoreStringNodeHolder msg(size > 0 ? s->recv(size, timeout_ms, &rc) : s->recv(timeout_ms, &rc));
   //printd(5, "SOCKET_recv() rc=%d msglen=%d\n", rc, msg ? msg->strlen() : -1);
   if (rc <= 0) {
      QoreSocket::doException(rc, "recv", timeout_ms, xsink);
      return 0;
   }
   return msg.release();
}

//! Receives data from the socket and returns a binary object
/** If any errors occur reading from the socket, an exception is raised

    Example
    @code my binary $data = $sock.recvBinary(-1); # read all data available@endcode

    @par Events
    @ref EVENT_PACKET_READ
    
    @param size the amount of data to read in bytes; to read until the remote closes the connection, use -1
    @param timeout_ms the timeout in milliseconds (1/1000 second). If no timeout is passed, then the call will not time out and will not return until all the data has been read or the remote end closes the connection

    @return the data read, returned as a binary object

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection.
    @throw SOCKET-RECV-ERROR there was an error receiving the data.
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket
 */
binary Socket::recvBinary(softint size = 0, timeout timeout_ms = -1) {
   int rc;
   SimpleRefHolder<BinaryNode> b(size > 0 ? s->recvBinary(size, timeout_ms, &rc) : s->recvBinary(timeout_ms, &rc));
   if (rc <= 0) {
      QoreSocket::doException(rc, "recvBinary", timeout_ms, xsink);
      return 0;
   }
   return b.release();
}

//! Receives a 1-byte signed integer from the socket
/** If any errors occur reading from the socket, an exception is raised

    Example
    @code my int $val = $sock.recvi1();@endcode

    @par Events
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection

    @return The 1-byte signed integer read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvu1()
 */
int Socket::recvi1(timeout timeout_ms = -1) {
   char b;
   int rc = s->recvi1(timeout_ms, &b);
   return doReadResult(rc, (int64)b, "recvi1", timeout_ms, xsink);
}

//! Receives a 2-byte (16-bit) signed integer in big-endian format (network byte order) from the socket
/** If any errors occur reading from the socket, an exception is raised

    Example
    @code my int $val = $sock.recvi2();@endcode

    @par Events
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection

    @return The 2-byte signed integer in big-endian format (network byte order) read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvu2(), Socket::recvi2LSB(), Socket::recvu2LSB()
 */
int Socket::recvi2(timeout timeout_ms = -1) {
   short b;
   int rc = s->recvi2(timeout_ms, &b);
   return doReadResult(rc, (int64)b, "recvi2", timeout_ms, xsink);
}

//! Receives a 4-byte (32-bit) signed integer in big-endian format (network byte order) from the socket
/** If any errors occur reading from the socket, an exception is raised

    Example
    @code my int $val = $sock.recvi4();@endcode

    @par Events
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection

    @return The 4-byte signed integer in big-endian format (network byte order) read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvu4(), Socket::recvi4LSB(), Socket::recvu4LSB()
 */
int Socket::recvi4(timeout timeout_ms = -1) {
   int b;
   int rc = s->recvi4(timeout_ms, &b);
   return doReadResult(rc, (int64)b, "recvi4", timeout_ms, xsink);
}

//! Receives an 8-byte (64-bit) signed integer in big-endian format (network byte order) from the socket
/** If any errors occur reading from the socket, an exception is raised

    Example
    @code my int $val = $sock.recvi8();@endcode

    @par Events
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection

    @return The 8-byte signed integer in big-endian format (network byte order) read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi8LSB()
 */
int Socket::recvi8(timeout timeout_ms = -1) {
   int64 b;
   int rc = s->recvi8(timeout_ms, &b);
   return doReadResult(rc, b, "recvi8", timeout_ms, xsink);
}

//! Receives a 2-byte (16-bit) signed integer in little-endian format from the socket
/** If any errors occur reading from the socket, an exception is raised

    Example
    @code my int $val = $sock.recvi2LSB();@endcode

    @par Events
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection

    @return The 2-byte signed integer in little-endian format read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi2(), Socket::recvu2(), Socket::recvu2LSB()
 */
int Socket::recvi2LSB(timeout timeout_ms = -1) {
   short b;
   int rc = s->recvi2LSB(timeout_ms, &b);
   return doReadResult(rc, (int64)b, "recvi2LSB", timeout_ms, xsink);
}

//! Receives a 4-byte (32-bit) signed integer in little-endian format from the socket
/** If any errors occur reading from the socket, an exception is raised

    Example
    @code my int $val = $sock.recvi4LSB();@endcode

    @par Events
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection

    @return The 4-byte signed integer in little-endian format read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi4(), Socket::recvu4(), Socket::recvu4LSB()
 */
int Socket::recvi4LSB(timeout timeout_ms = -1) {
   int b;
   int rc = s->recvi4LSB(timeout_ms, &b);
   return doReadResult(rc, (int64)b, "recvi4LSB", timeout_ms, xsink);
}

//! Receives an 8-byte (64-bit) signed integer in little-endian format from the socket
/** If any errors occur reading from the socket, an exception is raised

    Example
    @code my int $val = $sock.recvi8LSB();@endcode

    @par Events
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection

    @return The 8-byte signed integer in little-endian format read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi8()
 */
int Socket::recvi8LSB(timeout timeout_ms = -1) {
   int64 b;
   int rc = s->recvi8LSB(timeout_ms, &b);
   return doReadResult(rc, b, "recvi8LSB", timeout_ms, xsink);
}

//! Receives a 1-byte unsigned integer from the socket
/** If any errors occur reading from the socket, an exception is raised

    Example
    @code my int $val = $sock.recvu1();@endcode

    @par Events
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection

    @return The 1-byte unsigned integer read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi1()
 */
int Socket::recvu1(timeout timeout_ms = -1) {
   unsigned char b;
   int rc = s->recvu1(timeout_ms, &b);
   return doReadResult(rc, (int64)b, "recvu1", timeout_ms, xsink);
}

//! Receives a 2-byte (16-bit) unsigned integer in big-endian format (network byte order) from the socket
/** If any errors occur reading from the socket, an exception is raised

    Example
    @code my int $val = $sock.recvu2();@endcode

    @par Events
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection

    @return The 2-byte unsigned integer in big-endian format (network byte order) read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi2(), Socket::recvi2LSB(), Socket::recvu2LSB()
 */
int Socket::recvu2(timeout timeout_ms = -1) {
   unsigned short b;
   int rc = s->recvu2(timeout_ms, &b);
   return doReadResult(rc, (int64)b, "recvu2", timeout_ms, xsink);
}

//! Receives a 4-byte (32-bit) unsigned integer in big-endian format (network byte order) from the socket
/** If any errors occur reading from the socket, an exception is raised

    Example
    @code my int $val = $sock.recvu4();@endcode

    @par Events
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection

    @return The 4-byte unsigned integer in big-endian format (network byte order) read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi4(), Socket::recvi4LSB(), Socket::recvu4LSB()
 */
int Socket::recvu4(timeout timeout_ms = -1) {
   unsigned int b;
   int rc = s->recvu4(timeout_ms, &b);
   return doReadResult(rc, (int64)b, "recvu4", timeout_ms, xsink);
}

//! Receives a 2-byte (16-bit) unsigned integer in little-endian format from the socket
/** If any errors occur reading from the socket, an exception is raised

    Example
    @code my int $val = $sock.recvi2LSB();@endcode

    @par Events
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection

    @return The 2-byte unsigned integer in little-endian format read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi2(), Socket::recvu2(), Socket::recvi2LSB()
 */
int Socket::recvu2LSB(timeout timeout_ms = -1) {
   unsigned short b;
   int rc = s->recvu2LSB(timeout_ms, &b);
   return doReadResult(rc, (int64)b, "recvu2LSB", timeout_ms, xsink);
}

//! Receives a 4-byte (32-bit) unsigned integer in little-endian format from the socket
/** If any errors occur reading from the socket, an exception is raised

    Example
    @code my int $val = $sock.recvu4LSB();@endcode

    @par Events
    @ref EVENT_PACKET_READ

    @param timeout_ms the timeout in milliseconds (1/1000 second); If no timeout is passed or is negative, then the call will not time out and will not return until all the data has been read or the remote end closes the connection

    @return The 4-byte unsigned integer in little-endian format read; if any errors occur reading from the socket, an exception is raised

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-CLOSED the remote end has closed the connection
    @throw SOCKET-RECV-ERROR there was an error receiving the data
    @throw SOCKET-TIMEOUT the data requested was not received in the timeout period
    @throw SOCKET-SSL-ERROR there was an SSL error while reading data from the socket

    @see Socket::recvi4(), Socket::recvu4(), Socket::recvi4LSB()
 */
int Socket::recvu4LSB(timeout timeout_ms = -1) {
   unsigned b;
   int rc = s->recvu4LSB(timeout_ms, &b);
   return doReadResult(rc, (int64)b, "recvu4LSB", timeout_ms, xsink);
}

//! Sends an HTTP message with a method and user-defined headers given as a hash and an optional message body
/** Creates a properly-formatted HTTP message and sends it over the Socket

    Example
    @code $sock.sendHTTPMessage("POST", "/RPC2", "1.1", ("Content-Type" : "text/xml"), $xml);@endcode

    @par Events
    @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_SEND_MESSAGE

    @param method the HTTP method name to send (i.e. POST, HEAD, etc)
    @param path the path component of the URL
    @param http_version the HTTP protocol version (\c "1.0" or \c "1.1")
    @param headers a hash of additional headers to send (key-value pairs)
    @param body if present (and does not have a length of zero), the body to be sent with the message (if present, the \c "Content-Length" header will be automatically set)

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-SEND-ERROR Send failed

    @see Socket::sendHTTPResponse(), Socket::readHTTPHeader()
 */
nothing Socket::sendHTTPMessage(string method, string path, string http_version, hash headers, *string data) {
static AbstractQoreNode *SOCKET_sendHTTPMessage(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   const void *ptr = data ? data->getBuffer() : 0;
   qore_size_t size = data ? data->strlen() : 0;
   int rc = s->sendHTTPMessage(method, path, http_version, headers, ptr, size);
   return doSendResult(rc, "sendHTTPMessage", xsink);
}

//! Sends an HTTP message with a method and user-defined headers given as a hash and an optional message body
/** Creates a properly-formatted HTTP message and sends it over the Socket

    Example
    @code $sock.sendHTTPMessage("POST", "/RPC2", "1.1", ("Content-Type" : "text/xml"), $xml);@endcode

    @par Events
    @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_SEND_MESSAGE

    @param method the HTTP method name to send (i.e. POST, HEAD, etc)
    @param path the path component of the URL
    @param http_version the HTTP protocol version (\c "1.0" or \c "1.1")
    @param headers a hash of additional headers to send (key-value pairs)
    @param body if it does not have a length of zero, the body to be sent with the message (if present, the \c "Content-Length" header will be automatically set)

    @throw SOCKET-NOT-OPEN the socket is not connected
    @throw SOCKET-SEND-ERROR Send failed

    @see Socket::sendHTTPResponse(), Socket::readHTTPHeader()
 */
nothing Socket::sendHTTPMessage(string method, string path, string http_version, hash headers, binary data) {
   int rc = s->sendHTTPMessage(method, path, http_version, headers, data->getPtr(), data->size());
   return doSendResult(rc, "sendHTTPMessage", xsink);
}

// nothing Socket::sendHTTPResponse(softint $status_code, string $desc, string $http_version, hash $headers, data $data = binary())  
static AbstractQoreNode *SOCKET_sendHTTPResponse(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   int status_code = (int)HARD_QORE_INT(args, 0);

   if (status_code < 100 || status_code >= 600) {
      xsink->raiseException("SOCKET-SENDHTTPRESPONSE-PARAMETER-ERROR", "expecting valid HTTP status code between 100 and 599 as first parameter of Socket::sendHTTPResponse() call, got value %d instead", status_code);
      return 0;
   }

   const char *status_desc = HARD_QORE_STRING(args, 1)->getBuffer();
   const char *http_version = HARD_QORE_STRING(args, 2)->getBuffer();
   const QoreHashNode *headers = HARD_QORE_HASH(args, 3);

   // see if there is data to send as well
   const AbstractQoreNode *p4 = get_param(args, 4);
   const void *ptr = 0;
   int size = 0;

   if (p4->getType() == NT_STRING) {
      const QoreStringNode *str = reinterpret_cast<const QoreStringNode *>(p4);
      ptr = str->getBuffer();
      size = str->strlen();
   }
   else {
      assert(p4->getType() == NT_BINARY);
      const BinaryNode *b = reinterpret_cast<const BinaryNode *>(p4);
      ptr = b->getPtr();
      size = b->size();
   }

   int rc = s->sendHTTPResponse(status_code, status_desc, http_version, headers, ptr, size);
   return doSendResult(rc, "sendHTTPResponse", xsink);
}

// string Socket::readHTTPHeader(timeout $timeout_ms = -1)  |hash
static AbstractQoreNode *SOCKET_readHTTPHeader(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   int timeout = (int)HARD_QORE_INT(args, 0);
   int rc;

   // when rc = -3 it's a timeout, but rv will be NULL anyway, so we do nothing
   AbstractQoreNode *rv = s->readHTTPHeader(timeout, &rc);
      
   if (rc <= 0)
      QoreSocket::doException(rc, "readHTTPHeader", timeout, xsink);

   return rv;
}

// hash Socket::readHTTPChunkedBody(timeout $timeout_ms = -1)  
static AbstractQoreNode *SOCKET_readHTTPChunkedBody(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   int timeout = (int)HARD_QORE_INT(args, 0);

   // when rc = -3 it's a timeout, but rv will be NULL anyway, so we do nothing
   return s->readHTTPChunkedBody(timeout, xsink);
}

// hash Socket::readHTTPChunkedBodyBinary(timeout $timeout_ms = -1)  
static AbstractQoreNode *SOCKET_readHTTPChunkedBodyBinary(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   int timeout = (int)HARD_QORE_INT(args, 0);

   // when rc = -3 it's a timeout, but rv will be NULL anyway, so we do nothing
   return s->readHTTPChunkedBodyBinary(timeout, xsink);
}

static AbstractQoreNode *SOCKET_close(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   return new QoreBigIntNode(s->close());
}

static AbstractQoreNode *SOCKET_shutdown(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   return new QoreBigIntNode(s->shutdown());
}

static AbstractQoreNode *SOCKET_shutdownSSL(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   s->shutdownSSL(xsink);
   return 0;
}

static AbstractQoreNode *SOCKET_getPort(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   return new QoreBigIntNode(s->getPort());
}

static AbstractQoreNode *SOCKET_getSocket(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   return new QoreBigIntNode(s->getSocket());
}

// int Socket::setSendTimeout(timeout $timeout_ms)  
static AbstractQoreNode *SOCKET_setSendTimeout_int(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   int timeout_ms = (int)HARD_QORE_INT(args, 0);
   return new QoreBigIntNode(s->setSendTimeout(timeout_ms));
}

// int Socket::setRecvTimeout(timeout $timeout_ms)  
static AbstractQoreNode *SOCKET_setRecvTimeout_int(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   int timeout_ms = (int)HARD_QORE_INT(args, 0);
   return new QoreBigIntNode(s->setRecvTimeout(timeout_ms));
}

static AbstractQoreNode *SOCKET_getSendTimeout(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   return new QoreBigIntNode(s->getSendTimeout());
}

static AbstractQoreNode *SOCKET_getRecvTimeout(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   return new QoreBigIntNode(s->getRecvTimeout());
}

//! Returns the @ref character_encoding "character encoding" for the socket
/** @return the @ref character_encoding "character encoding" for the socket
 */
string Socket::getEncoding() [flags=QC_CONSTANT] {
   return new QoreStringNode(s->getEncoding()->getCode());
}

//! Sets the @ref character_encoding "character encoding" for the socket
/** @param encoding the @ref character_encoding "character encoding" for the socket  
 */
nothing Socket::setEncoding(string encoding) {
   s->setEncoding(QEM.findCreate(encoding));
}

//! Returns the @ref character_encoding "character encoding" for the socket
/** A method synonym for Socket::getEncoding(), kept for backwards-compatibility
    @return the @ref character_encoding "character encoding" for the socket
 */
string Socket::getCharset() [flags=QC_CONSTANT] {
   return new QoreStringNode(s->getEncoding()->getCode());
}
//! Sets the @ref character_encoding "character encoding" for the socket
/** A method synonym for Socket::setEncoding(), kept for backwards-compatibility
    @param encoding The @ref character_encoding "character encoding" for the socket
 */
nothing Socket::setCharset(string encoding) {
   s->setEncoding(QEM.findCreate(encoding));
}

// Socket::isDataAvailable(timeout $timeout_ms = 0)
static AbstractQoreNode *SOCKET_isDataAvailable(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   return get_bool_node(s->isDataAvailable((int)HARD_QORE_INT(args, 0)));
}

static AbstractQoreNode *SOCKET_isWriteFinished(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   return get_bool_node(s->isWriteFinished((int)HARD_QORE_INT(args, 0)));
}

static AbstractQoreNode *SOCKET_isOpen(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   return get_bool_node(s->isOpen());
}

// *string Socket::getSSLCipherName()  
static AbstractQoreNode *SOCKET_getSSLCipherName(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   const char *str = s->getSSLCipherName();
   return str ? new QoreStringNode(str) : 0;
}

// *string Socket::getSSLCipherVersion()  
static AbstractQoreNode *SOCKET_getSSLCipherVersion(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   const char *str = s->getSSLCipherVersion();
   return str ? new QoreStringNode(str) : 0;
}

static AbstractQoreNode *SOCKET_isSecure(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   return get_bool_node(s->isSecure());
}

// *string Socket::verifyPeerCertificate()  
static AbstractQoreNode *SOCKET_verifyPeerCertificate(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   const char *c = getSSLCVCode(s->verifyPeerCertificate());
   return c ? new QoreStringNode(c) : 0;
}

// nothing Socket::setCertificate(SSLCertificate $cert)  
static AbstractQoreNode *SOCKET_setCertificate_cert(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   HARD_QORE_OBJ_DATA(cert, QoreSSLCertificate, args, 0, CID_SSLCERTIFICATE, "Socket::setCertificate()", "SSLCertificate", xsink);
   if (*xsink)
      return 0;

   // pass reference from QoreObject::getReferencedPrivateData() to mySocket::setCertificate()
   s->setCertificate(cert);
   return 0;
}

// nothing Socket::setCertificate(string $cert_pem)  
static AbstractQoreNode *SOCKET_setCertificate_string(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   const QoreStringNode *p0 = HARD_QORE_STRING(args, 0);
   SimpleRefHolder<QoreSSLCertificate> cert(new QoreSSLCertificate(p0, xsink));
   if (*xsink)
      return 0;

   // mySocket::setCertificate() takes over ownership of certificate reference
   s->setCertificate(cert.release());
   return 0;   
}

// nothing Socket::setCertificate(binary $cert_der)  
static AbstractQoreNode *SOCKET_setCertificate_bin(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   const BinaryNode *p0 = HARD_QORE_BINARY(args, 0);
   SimpleRefHolder<QoreSSLCertificate> cert(new QoreSSLCertificate(p0, xsink));
   if (*xsink)
      return 0;

   // mySocket::setCertificate() takes over ownership of certificate reference
   s->setCertificate(cert.release());
   return 0;   
}

// Socket::setPrivateKey(SSLPrivateKey $key)
static AbstractQoreNode *SOCKET_setPrivateKey_key(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   HARD_QORE_OBJ_DATA(key, QoreSSLPrivateKey, args, 0, CID_SSLPRIVATEKEY, "Socket::setPrivateKey()", "SSLPrivateKey", xsink);
   if (*xsink)
      return 0;

   // pass reference from QoreObject::getReferencedPrivateData() to mySocket::setPrivateKey()
   s->setPrivateKey(key);
   return 0;
}

// Socket::setPrivateKey(string $key_pem)
static AbstractQoreNode *SOCKET_setPrivateKey_str(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   const QoreStringNode *p0 = HARD_QORE_STRING(args, 0);
   SimpleRefHolder<QoreSSLPrivateKey> key(new QoreSSLPrivateKey(p0, 0, xsink));
   if (*xsink)
      return 0;

   s->setPrivateKey(key.release());
   return 0;
}

// Socket::setPrivateKey(string $key_pem, string $pass)
static AbstractQoreNode *SOCKET_setPrivateKey_str_str(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   const QoreStringNode *p0 = HARD_QORE_STRING(args, 0);
   const QoreStringNode *p1 = HARD_QORE_STRING(args, 1);
   SimpleRefHolder<QoreSSLPrivateKey> key(new QoreSSLPrivateKey(p0, p1->getBuffer(), xsink));
   if (*xsink)
      return 0;

   s->setPrivateKey(key.release());
   return 0;
}

// Socket::setPrivateKey(binary $key_der)
static AbstractQoreNode *SOCKET_setPrivateKey_bin(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   const BinaryNode *p0 = HARD_QORE_BINARY(args, 0);
   SimpleRefHolder<QoreSSLPrivateKey> key(new QoreSSLPrivateKey(p0, xsink));
   if (*xsink)
      return 0;

   s->setPrivateKey(key.release());
   return 0;
}

static AbstractQoreNode *SOCKET_setEventQueue_nothing(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   s->setEventQueue(0, xsink);
   return 0;
}

static AbstractQoreNode *SOCKET_setEventQueue_queue(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   HARD_QORE_OBJ_DATA(q, Queue, args, 0, CID_QUEUE, "Queue", "Socket::setEventQueue", xsink);
   if (*xsink)
      return 0;
   // pass reference from QoreObject::getReferencedPrivateData() to function
   s->setEventQueue(q, xsink);
   return 0;
}

static AbstractQoreNode *SOCKET_setNoDelay(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   return new QoreBigIntNode(s->setNoDelay(HARD_QORE_BOOL(args, 0)));
}

static AbstractQoreNode *SOCKET_getNoDelay(QoreObject *self, mySocket *s, const QoreListNode *args, ExceptionSink *xsink) {
   return get_bool_node(s->getNoDelay());
}

//! Returns a @ref socket_info_hash "hash of information" about the remote end for connected sockets
/** If the socket is not connected, an exception is thrown

    Example
    @code my hash $h = $sock.getPeerInfo();@endcode

    @return a @ref socket_info_hash "hash of information" about the local socket

    @throw SOCKET-GETPEERINFO-ERROR Socket is not open or error in getpeername()
 */
hash Socket::getPeerInfo() {
   return s->getPeerInfo(xsink);
}

//! Returns information about the local socket as a hash
/** If the socket is not open, an exception is thrown

    Example
    @code my hash $h = $sock.getSocketInfo();@endcode

    @return a @ref socket_info_hash "hash of information" about the remote end for connected sockets

 */
hash Socket::getSocketInfo() {
   return s->getSocketInfo(xsink);
}

QoreClass *initSocketClass(QoreClass *SSLCert, QoreClass *SSLPrivKey) {
   QORE_TRACE("initSocketClass()");

   assert(QC_QUEUE);

   QC_SOCKET = new QoreClass("Socket", QDOM_NETWORK);
   CID_SOCKET = QC_SOCKET->getID();

   // register public members
   QC_SOCKET->addPublicMember("source", stringOrNothingTypeInfo);
   QC_SOCKET->addPublicMember("source_host", stringOrNothingTypeInfo);

   // unset the public member flag for backwards-compatibility
   // this allows older code where a user class inherits this class to still be able
   // to be run in new Qore >= 0.8
   QC_SOCKET->unsetPublicMemberFlag();
   
   QC_SOCKET->setConstructorExtended(SOCKET_constructor);

   QC_SOCKET->setCopy(SOCKET_copy);

   // Socket::connect(string $sock, timeout $timeout_ms = -1)
   QC_SOCKET->addMethodExtended("connect",                   (q_method_t)SOCKET_connect_str_timeout, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 2, stringTypeInfo, QORE_PARAM_NO_ARG, timeoutTypeInfo, new QoreBigIntNode(-1));

   // nothing Socket::connectINET(string $host, softstring $service, timeout $timeout_ms = -1, softint $family = AF_UNSPEC, softint $socktype = SOCK_STREAM, softint $protocol = 0) 
   QC_SOCKET->addMethodExtended("connectINET",               (q_method_t)SOCKET_connectINET, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 6, stringTypeInfo, QORE_PARAM_NO_ARG, softStringTypeInfo, QORE_PARAM_NO_ARG, timeoutTypeInfo, new QoreBigIntNode(-1), softBigIntTypeInfo, new QoreBigIntNode(AF_UNSPEC), softBigIntTypeInfo, new QoreBigIntNode(SOCK_STREAM), softBigIntTypeInfo, zero());

   // nothing Socket::connectUNIX(string $path, softint $socktype = SOCK_STREAM, softint $protocol = 0)
   QC_SOCKET->addMethodExtended("connectUNIX",               (q_method_t)SOCKET_connectUNIX, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 3, stringTypeInfo, QORE_PARAM_NO_ARG, softBigIntTypeInfo, new QoreBigIntNode(SOCK_STREAM), softBigIntTypeInfo, zero());

   // Socket::connectSSL(string $sock, timeout $timeout_ms = -1)
   QC_SOCKET->addMethodExtended("connectSSL",                (q_method_t)SOCKET_connectSSL_str_timeout, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 2, stringTypeInfo, QORE_PARAM_NO_ARG, timeoutTypeInfo, new QoreBigIntNode(-1));

   // nothing Socket::connectINETSSL(string $host, softstring $service, timeout $timeout_ms = -1, softint $family = AF_UNSPEC, softint $socktype = SOCK_STREAM, softint $protocol = 0)
   QC_SOCKET->addMethodExtended("connectINETSSL",            (q_method_t)SOCKET_connectINETSSL, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 6, stringTypeInfo, QORE_PARAM_NO_ARG, softStringTypeInfo, QORE_PARAM_NO_ARG, timeoutTypeInfo, new QoreBigIntNode(-1), softBigIntTypeInfo, new QoreBigIntNode(AF_UNSPEC), softBigIntTypeInfo, new QoreBigIntNode(SOCK_STREAM), softBigIntTypeInfo, zero());

   // nothing Socket::connectUNIXSSL(string $path, softint $socktype = SOCK_STREAM, softint $protocol = 0)  
   QC_SOCKET->addMethodExtended("connectUNIXSSL",            (q_method_t)SOCKET_connectUNIXSSL, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 3, stringTypeInfo, QORE_PARAM_NO_ARG, softBigIntTypeInfo, new QoreBigIntNode(SOCK_STREAM), softBigIntTypeInfo, zero());

   // int Socket::bind(string $str, softbool $reuseaddr = False)  
   QC_SOCKET->addMethodExtended("bind",                      (q_method_t)SOCKET_bind_str_bool, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 2, stringTypeInfo, QORE_PARAM_NO_ARG, softBoolTypeInfo, &False);

   // int Socket::bind(int $port, softbool $reuseaddr = False)  
   QC_SOCKET->addMethodExtended("bind",                      (q_method_t)SOCKET_bind_int_bool, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 2, bigIntTypeInfo, QORE_PARAM_NO_ARG, softBoolTypeInfo, &False);

   // nothing bindUNIX(string $name, softint $socktype = SOCK_STREAM, softint $protocol = 0)
   QC_SOCKET->addMethodExtended("bindUNIX",                  (q_method_t)SOCKET_bindUNIX, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 3, stringTypeInfo, QORE_PARAM_NO_ARG, softBigIntTypeInfo, new QoreBigIntNode(SOCK_STREAM), bigIntTypeInfo, zero());

   // nothing bindINET(*string $interface, *softstring $service, softbool $reuseaddr = False, softint $family = AF_UNSPEC, softint $socktype = SOCK_STREAM, int $protocol = 0)
   QC_SOCKET->addMethodExtended("bindINET",                  (q_method_t)SOCKET_bindINET, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 6, stringOrNothingTypeInfo, QORE_PARAM_NO_ARG, softStringOrNothingTypeInfo, QORE_PARAM_NO_ARG, softBoolTypeInfo, &False, softBigIntTypeInfo, new QoreBigIntNode(AF_UNSPEC), softBigIntTypeInfo, new QoreBigIntNode(SOCK_STREAM), bigIntTypeInfo, zero());

   // *Socket Socket::accept(timeout timeout_ms)
   QC_SOCKET->addMethodExtended("accept",                    (q_method_t)SOCKET_accept_timeout, false, QC_NO_FLAGS, QDOM_DEFAULT, QC_SOCKET->getOrNothingTypeInfo(), 1, timeoutTypeInfo, QORE_PARAM_NO_ARG);
   // Socket Socket::accept()
   QC_SOCKET->addMethodExtended("accept",                    (q_method_t)SOCKET_accept, false, QC_NO_FLAGS, QDOM_DEFAULT, QC_SOCKET->getTypeInfo());

   // *Socket Socket::acceptSSL(timeout timeout_ms)
   QC_SOCKET->addMethodExtended("acceptSSL",                 (q_method_t)SOCKET_acceptSSL_timeout, false, QC_NO_FLAGS, QDOM_DEFAULT, QC_SOCKET->getOrNothingTypeInfo(), 1, timeoutTypeInfo, QORE_PARAM_NO_ARG);
   // Socket Socket::acceptSSL()
   QC_SOCKET->addMethodExtended("acceptSSL",                 (q_method_t)SOCKET_acceptSSL, false, QC_NO_FLAGS, QDOM_DEFAULT, QC_SOCKET->getTypeInfo());

   QC_SOCKET->addMethodExtended("listen",                    (q_method_t)SOCKET_listen, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo);

   // int Socket::send(binary $bin)  
   QC_SOCKET->addMethodExtended("send",                      (q_method_t)SOCKET_send_bin, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, binaryTypeInfo, QORE_PARAM_NO_ARG);

   // int Socket::send(string $str)  
   QC_SOCKET->addMethodExtended("send",                      (q_method_t)SOCKET_send_str, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, stringTypeInfo, QORE_PARAM_NO_ARG);

   // int Socket::sendBinary(binary $bin)  
   QC_SOCKET->addMethodExtended("sendBinary",                (q_method_t)SOCKET_send_bin, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, binaryTypeInfo, QORE_PARAM_NO_ARG);

   // int Socket::sendBinary(string $str)  
   QC_SOCKET->addMethodExtended("sendBinary",                (q_method_t)SOCKET_sendBinary_str, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, stringTypeInfo, QORE_PARAM_NO_ARG);

   QC_SOCKET->addMethodExtended("sendi1",                    (q_method_t)SOCKET_sendi1, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, softBigIntTypeInfo, zero());
   QC_SOCKET->addMethodExtended("sendi2",                    (q_method_t)SOCKET_sendi2, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, softBigIntTypeInfo, zero());
   QC_SOCKET->addMethodExtended("sendi4",                    (q_method_t)SOCKET_sendi4, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, softBigIntTypeInfo, zero());
   QC_SOCKET->addMethodExtended("sendi8",                    (q_method_t)SOCKET_sendi8, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, softBigIntTypeInfo, zero());
   QC_SOCKET->addMethodExtended("sendi2LSB",                 (q_method_t)SOCKET_sendi2LSB, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, softBigIntTypeInfo, zero());
   QC_SOCKET->addMethodExtended("sendi4LSB",                 (q_method_t)SOCKET_sendi4LSB, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, softBigIntTypeInfo, zero());
   QC_SOCKET->addMethodExtended("sendi8LSB",                 (q_method_t)SOCKET_sendi8LSB, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, softBigIntTypeInfo, zero());

   // string Socket::recv(softint $size = 0, timeout $timeout = -1)  
   QC_SOCKET->addMethodExtended("recv",                      (q_method_t)SOCKET_recv, false, QC_NO_FLAGS, QDOM_DEFAULT, stringTypeInfo, 2, softBigIntTypeInfo, zero(), timeoutTypeInfo, new QoreBigIntNode(-1));

   // binary Socket::recvBinary(softint $size = 0, timeout $timeout = -1)  
   QC_SOCKET->addMethodExtended("recvBinary",                (q_method_t)SOCKET_recvBinary, false, QC_NO_FLAGS, QDOM_DEFAULT, binaryTypeInfo, 2, softBigIntTypeInfo, zero(), timeoutTypeInfo, new QoreBigIntNode(-1));

   // int Socket::recvi1(timeout $timeout = -1)  
   QC_SOCKET->addMethodExtended("recvi1",                    (q_method_t)SOCKET_recvi1, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, timeoutTypeInfo, new QoreBigIntNode(-1));

   // int Socket::recvi2(timeout $timeout = -1)  
   QC_SOCKET->addMethodExtended("recvi2",                    (q_method_t)SOCKET_recvi2, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, timeoutTypeInfo, new QoreBigIntNode(-1));

   // int Socket::recvi4(timeout $timeout = -1)  
   QC_SOCKET->addMethodExtended("recvi4",                    (q_method_t)SOCKET_recvi4, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, timeoutTypeInfo, new QoreBigIntNode(-1));

   // int Socket::recvi8(timeout $timeout = -1)  
   QC_SOCKET->addMethodExtended("recvi8",                    (q_method_t)SOCKET_recvi8, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, timeoutTypeInfo, new QoreBigIntNode(-1));

   // int Socket::recvi2LSB(timeout $timeout = -1)  
   QC_SOCKET->addMethodExtended("recvi2LSB",                 (q_method_t)SOCKET_recvi2LSB, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, timeoutTypeInfo, new QoreBigIntNode(-1));

   // int Socket::recvi4LSB(timeout $timeout = -1)  
   QC_SOCKET->addMethodExtended("recvi4LSB",                 (q_method_t)SOCKET_recvi4LSB, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, timeoutTypeInfo, new QoreBigIntNode(-1));

   // int Socket::recvi8LSB(timeout $timeout = -1)  
   QC_SOCKET->addMethodExtended("recvi8LSB",                 (q_method_t)SOCKET_recvi8LSB, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, timeoutTypeInfo, new QoreBigIntNode(-1));

   // int Socket::recvu1(timeout $timeout = -1)  
   QC_SOCKET->addMethodExtended("recvu1",                    (q_method_t)SOCKET_recvu1, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, timeoutTypeInfo, new QoreBigIntNode(-1));

   // int Socket::recvu2(timeout $timeout = -1)  
   QC_SOCKET->addMethodExtended("recvu2",                    (q_method_t)SOCKET_recvu2, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, timeoutTypeInfo, new QoreBigIntNode(-1));

   // int Socket::recvu4(timeout $timeout = -1)  
   QC_SOCKET->addMethodExtended("recvu4",                    (q_method_t)SOCKET_recvu4, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, timeoutTypeInfo, new QoreBigIntNode(-1));

   // int Socket::recvu2LSB(timeout $timeout = -1)  
   QC_SOCKET->addMethodExtended("recvu2LSB",                 (q_method_t)SOCKET_recvu2LSB, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, timeoutTypeInfo, new QoreBigIntNode(-1));

   // int Socket::recvu4LSB(timeout $timeout = -1)  
   QC_SOCKET->addMethodExtended("recvu4LSB",                 (q_method_t)SOCKET_recvu4LSB, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, timeoutTypeInfo, new QoreBigIntNode(-1));

   // nothing Socket::sendHTTPMessage(string $method, string $path, string $http_version, hash $headers, data $data = binary())  
   QC_SOCKET->addMethodExtended("sendHTTPMessage",           (q_method_t)SOCKET_sendHTTPMessage, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 5, stringTypeInfo, QORE_PARAM_NO_ARG, stringTypeInfo, QORE_PARAM_NO_ARG, stringTypeInfo, QORE_PARAM_NO_ARG, hashTypeInfo, QORE_PARAM_NO_ARG, dataTypeInfo, new BinaryNode);

   // nothing Socket::sendHTTPResponse(softint $status_code, string $desc, string $http_version, hash $headers, data $data = binary())  
   QC_SOCKET->addMethodExtended("sendHTTPResponse",          (q_method_t)SOCKET_sendHTTPResponse, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 5, softBigIntTypeInfo, QORE_PARAM_NO_ARG, stringTypeInfo, QORE_PARAM_NO_ARG, stringTypeInfo, QORE_PARAM_NO_ARG, hashTypeInfo, QORE_PARAM_NO_ARG, dataTypeInfo, new BinaryNode);

   // string Socket::readHTTPHeader(timeout $timeout_ms = -1)  |hash
   QC_SOCKET->addMethodExtended("readHTTPHeader",            (q_method_t)SOCKET_readHTTPHeader, false, QC_NO_FLAGS, QDOM_DEFAULT, 0, 1, timeoutTypeInfo, new QoreBigIntNode(-1));

   // hash Socket::readHTTPChunkedBody(timeout $timeout_ms = -1)  
   QC_SOCKET->addMethodExtended("readHTTPChunkedBody",       (q_method_t)SOCKET_readHTTPChunkedBody, false, QC_NO_FLAGS, QDOM_DEFAULT, hashTypeInfo, 1, timeoutTypeInfo, new QoreBigIntNode(-1));

   // hash Socket::readHTTPChunkedBodyBinary(timeout $timeout_ms = -1)  
   QC_SOCKET->addMethodExtended("readHTTPChunkedBodyBinary", (q_method_t)SOCKET_readHTTPChunkedBodyBinary, false, QC_NO_FLAGS, QDOM_DEFAULT, hashTypeInfo, 1, timeoutTypeInfo, new QoreBigIntNode(-1));

   QC_SOCKET->addMethodExtended("close",                     (q_method_t)SOCKET_close, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo);

   QC_SOCKET->addMethodExtended("shutdown",                  (q_method_t)SOCKET_shutdown, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo);

   QC_SOCKET->addMethodExtended("shutdownSSL",               (q_method_t)SOCKET_shutdownSSL, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo);

   QC_SOCKET->addMethodExtended("getPort",                   (q_method_t)SOCKET_getPort, false, QC_RET_VALUE_ONLY, QDOM_DEFAULT, bigIntTypeInfo);

   QC_SOCKET->addMethodExtended("getSocket",                 (q_method_t)SOCKET_getSocket, false, QC_RET_VALUE_ONLY, QDOM_DEFAULT, bigIntTypeInfo);

   // int Socket::setSendTimeout(timeout $timeout_ms)  
   QC_SOCKET->addMethodExtended("setSendTimeout",            (q_method_t)SOCKET_setSendTimeout_int, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, timeoutTypeInfo, QORE_PARAM_NO_ARG);

   // int Socket::setRecvTimeout(timeout $timeout_ms)  
   QC_SOCKET->addMethodExtended("setRecvTimeout",            (q_method_t)SOCKET_setRecvTimeout_int, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, timeoutTypeInfo, QORE_PARAM_NO_ARG);

   QC_SOCKET->addMethodExtended("getSendTimeout",            (q_method_t)SOCKET_getSendTimeout, false, QC_RET_VALUE_ONLY, QDOM_DEFAULT, bigIntTypeInfo);

   QC_SOCKET->addMethodExtended("getRecvTimeout",            (q_method_t)SOCKET_getRecvTimeout, false, QC_RET_VALUE_ONLY, QDOM_DEFAULT, bigIntTypeInfo);

   QC_SOCKET->addMethodExtended("getCharset",                (q_method_t)SOCKET_getCharset, false, QC_RET_VALUE_ONLY, QDOM_DEFAULT, stringTypeInfo);

   QC_SOCKET->addMethodExtended("setCharset",                (q_method_t)SOCKET_setCharset, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 1, stringTypeInfo, QORE_PARAM_NO_ARG);

   // Socket::isDataAvailable(timeout $timeout_ms = 0)
   QC_SOCKET->addMethodExtended("isDataAvailable",           (q_method_t)SOCKET_isDataAvailable, false, QC_NO_FLAGS, QDOM_DEFAULT, boolTypeInfo, 1, timeoutTypeInfo, zero());

   // Socket::isWriteFinished(timeout $timeout_ms = 0)
   QC_SOCKET->addMethodExtended("isWriteFinished",           (q_method_t)SOCKET_isWriteFinished, false, QC_NO_FLAGS, QDOM_DEFAULT, boolTypeInfo, 1, timeoutTypeInfo, zero());

   // *string Socket::getSSLCipherName()  
   QC_SOCKET->addMethodExtended("getSSLCipherName",          (q_method_t)SOCKET_getSSLCipherName, false, QC_RET_VALUE_ONLY, QDOM_DEFAULT, stringOrNothingTypeInfo);

   // *string Socket::getSSLCipherVersion()  
   QC_SOCKET->addMethodExtended("getSSLCipherVersion",       (q_method_t)SOCKET_getSSLCipherVersion, false, QC_RET_VALUE_ONLY, QDOM_DEFAULT, stringOrNothingTypeInfo);

   QC_SOCKET->addMethodExtended("isSecure",                  (q_method_t)SOCKET_isSecure, false, QC_RET_VALUE_ONLY, QDOM_DEFAULT, boolTypeInfo);

   // *string Socket::verifyPeerCertificate()  
   QC_SOCKET->addMethodExtended("verifyPeerCertificate",     (q_method_t)SOCKET_verifyPeerCertificate, false, QC_RET_VALUE_ONLY, QDOM_DEFAULT, stringOrNothingTypeInfo);

   // nothing Socket::setCertificate(SSLCertificate $cert)  
   QC_SOCKET->addMethodExtended("setCertificate",            (q_method_t)SOCKET_setCertificate_cert, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 1, SSLCert->getTypeInfo(), QORE_PARAM_NO_ARG);
   // nothing Socket::setCertificate(string $cert_pem)  
   QC_SOCKET->addMethodExtended("setCertificate",            (q_method_t)SOCKET_setCertificate_string, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 1, stringTypeInfo, QORE_PARAM_NO_ARG);
   // nothing Socket::setCertificate(binary $cert_der)  
   QC_SOCKET->addMethodExtended("setCertificate",            (q_method_t)SOCKET_setCertificate_bin, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 1, binaryTypeInfo, QORE_PARAM_NO_ARG);

   // Socket::setPrivateKey(SSLPrivateKey $key)
   QC_SOCKET->addMethodExtended("setPrivateKey",             (q_method_t)SOCKET_setPrivateKey_key, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 1, SSLPrivKey->getTypeInfo(), QORE_PARAM_NO_ARG);
   // Socket::setPrivateKey(string $key_pem)
   QC_SOCKET->addMethodExtended("setPrivateKey",             (q_method_t)SOCKET_setPrivateKey_str, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 1, stringTypeInfo, QORE_PARAM_NO_ARG);
   // Socket::setPrivateKey(string $key_pem, string $pass)
   QC_SOCKET->addMethodExtended("setPrivateKey",             (q_method_t)SOCKET_setPrivateKey_str_str, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 2, stringTypeInfo, QORE_PARAM_NO_ARG, stringTypeInfo, QORE_PARAM_NO_ARG);
   // Socket::setPrivateKey(binary $key_der)
   QC_SOCKET->addMethodExtended("setPrivateKey",             (q_method_t)SOCKET_setPrivateKey_bin, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 1, binaryTypeInfo, QORE_PARAM_NO_ARG);

   QC_SOCKET->addMethodExtended("isOpen",                    (q_method_t)SOCKET_isOpen, false, QC_RET_VALUE_ONLY, QDOM_DEFAULT, boolTypeInfo);

   // nothing Socket::setEventQueue()  
   QC_SOCKET->addMethodExtended("setEventQueue",             (q_method_t)SOCKET_setEventQueue_nothing, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo);

   // nothing Socket::setEventQueue(Queue $queue)  
   QC_SOCKET->addMethodExtended("setEventQueue",             (q_method_t)SOCKET_setEventQueue_queue, false, QC_NO_FLAGS, QDOM_DEFAULT, nothingTypeInfo, 1, QC_QUEUE->getTypeInfo(), QORE_PARAM_NO_ARG);

   QC_SOCKET->addMethodExtended("setNoDelay",                (q_method_t)SOCKET_setNoDelay, false, QC_NO_FLAGS, QDOM_DEFAULT, bigIntTypeInfo, 1, boolTypeInfo, &True);

   QC_SOCKET->addMethodExtended("getNoDelay",                (q_method_t)SOCKET_getNoDelay, false, QC_RET_VALUE_ONLY, QDOM_DEFAULT, boolTypeInfo);

   // hash Socket::getPeerInfo()
   QC_SOCKET->addMethodExtended("getPeerInfo",               (q_method_t)SOCKET_getPeerInfo, false, QC_RET_VALUE_ONLY, QDOM_DEFAULT, hashTypeInfo);

   // hash Socket::getSocketInfo()
   QC_SOCKET->addMethodExtended("getSocketInfo",             (q_method_t)SOCKET_getSocketInfo, false, QC_RET_VALUE_ONLY, QDOM_DEFAULT, hashTypeInfo);

   return QC_SOCKET;
}
