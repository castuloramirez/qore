/** @mainpage Programming with the Qore Library

    @section introduction Introduction to the Qore Library

    The Qore library is designed to facilitate dynamic embedding of code in applications.  The Qore library is thread-safe, and Qore code taking advantage of Qore's threading facilities is highly scalable on SMP machines.

    Qore data is generally atomically referenced counted (with some exceptions for performance and memory usage reasons), and the library supplies some special classes and functions in order to reduce the number of atomic operations and avoid evaluations wherever possible.

    @note The Qore library currently does not throw C++ exceptions; Qore-language exceptions are managed via the ExceptionSink class.

    @section embedding Embedding Qore Code

    All code using the qore library should include the header file Qore.h as follows:

    @code
    #include <qore/Qore.h>
    @endcode

    @subsection initializing_and_closing_library Initializing and Closing the Qore Library

    The first step is to initialize the library.  To do this, call qore_init() as follows (note that this function can only be called once and must be called before any other functionality of the Qore library is used):

    @code
    // qore_init() optionally takes several arguments as well
    qore_init();
    @endcode

    When your program terminates, you should call qore_cleanup() as follows:

    @code
    qore_cleanup();
    @endcode

    @subsection parsing_and_running Parsing and Running Qore Code
    
    First you should declare a variable of type ExceptionSink to capture and manage Qore exceptions (declare an additional variable if you want to capture and manage warnings when parsing Qore code):

    @code
    ExceptionSink xsink, wsink;
    @endcode

    Then you can use the QoreProgramHelper class to manage QoreProgram objects.  The QoreProgramHelper class contains a QoreProgram object and calls QoreProgram::waitForTerminationAndDeref() in the destructor.  The constructor takes a pointer to an ExceptionSink object, so make sure that the ExceptionSink object has at least as long a scope as the QoreProgramHelper object, as follows:

    @code
    ExceptionSink xsink, wsink;
    {
       // creates and manages a QoreProgram object
       QoreProgramHelper pgm(&xsink);
       // ... rest of code here
    }
    @endcode

    Then the QoreProgramHelper object can be used like a QoreProgram object.  For example, to parse a file named "test.q" and run it, do the following:

    @code
    ExceptionSink xsink, wsink;
    {
       // creates and manages a QoreProgram object
       QoreProgramHelper pgm(&xsink);

       pgm->parseFile("test.q", &xsink, &wsink, QP_WARN_ALL);

       // display any warnings immediately
       wsink.handleWarnings();

       // execute program if there were no parse exceptions
       if (!xsink)
          pgm->run(&xsink);
    }
    // display any exceptions on stdout
    xsink.handleExceptions();
    @endcode

    There are many functions for parsing and running Qore code; see the QoreProgram class documentation for more information.

    @section module_dev Qore Module development

    @subsection module_header Module Header Info

    To develop a Qore module, several functions and several global variables must be declared in the module with public visibility so the module can be initialized and used by the Qore library.

    The global variables are as follows:
    - char \c qore_module_name[] - must give the name of the feature provided by the module.
    - char \c qore_module_version[] - must give the version of the module
    - char \c qore_module_description[] - a description of the module
    - char \c qore_module_author[] - the author of the module
    - char \c qore_module_url[] - a URL for the module
    - int \c qore_module_api_major - must be assigned to \ref QORE_MODULE_API_MAJOR
    - int \c qore_module_api_minor - must be assigned to \ref QORE_MODULE_API_MINOR

    The functions are as follows:
    - \ref qore_module_init_t \c qore_module_init - the module initialization function
    - \ref qore_module_ns_init_t \c qore_module_ns_init - the module namespace delta functions
    - \ref qore_module_delete_t \c qore_module_delete - the module deletion function

    @note All variables and all functions are required, even if the functions are empty.

    Here is an example:
    @code
    DLLEXPORT char qore_module_name[] = "ncurses";
    DLLEXPORT char qore_module_version[] = "0.1";
    DLLEXPORT char qore_module_description[] = "ncurses class module";
    DLLEXPORT char qore_module_author[] = "David Nichols";
    DLLEXPORT char qore_module_url[] = "http://qore.sourceforge.net";
    DLLEXPORT int qore_module_api_major = QORE_MODULE_API_MAJOR;
    DLLEXPORT int qore_module_api_minor = QORE_MODULE_API_MINOR;

    DLLEXPORT qore_module_init_t qore_module_init = ncurses_module_init;
    DLLEXPORT qore_module_ns_init_t qore_module_ns_init = ncurses_module_ns_init;
    DLLEXPORT qore_module_delete_t qore_module_delete = ncurses_module_delete;
    @endcode

    Note that the module name (or the module's feature name) as given by \c qore_module_name is used to uniquely identify the feature provided by the module.  Therefore if a module is loaded that provides feature "widget" and another module also claims to provided feature "widget", the second module cannot be loaded in the Qore library after the first has been loaded due to the duplicate feature name.

    The \c qore_module_api_major and \c qore_module_api_minor variables are used to determine if the module corresponds to the API (and ABI) of the Qore library trying to load it.

    @subsection module_functions Module Functions

    The module initialization function \c qore_module_init() will be run when the module is loaded by the Qore library.  If any errors occur when initializing the module, a description should be returned as a QoreString pointer (the library will own the pointer and delete it later).  If a non-zero pointer is returned by the \c qore_module_init() function, the feature will not be added to the Qore library and the module load will fail.

    If the module provides any namespaces, classes or constants, they will be added on demand to QoreProgram objects by calling the module's \c qore_module_ns_init() function.  In this case, the namespace additions should be initialized in the \c qore_module_init() function and copies should be provisioned in the \c qore_module_ns_init() function.  In particular classes must not be created more than once, because a Qore class gets a unique ID assigned when it is created, and this ID must be unique in the entire Qore library.

    Here are example functions from the ncurses module:

    @code
    // this is the reference namespace for the ncurses module
    static QoreNamespace NCNS("NCurses");

    // this function is called when the module is loaded
    QoreStringNode *ncurses_module_init()
    {
       // the NCurses reference namespace is set up here
       NCNS.addSystemClass(initWindowClass());
       NCNS.addSystemClass(initPanelClass());

       init_constants(&NCNS); // here constants are added to the NCurses namespace
    
       builtinFunctions.add("initscr",          f_initscr, QDOM_TERMINAL_IO);
       builtinFunctions.add("printw",           f_printw, QDOM_TERMINAL_IO);
       builtinFunctions.add("refresh",          f_refresh, QDOM_TERMINAL_IO);
       //... more builtin functions are added

       return 0;
    }

    // this function is called when the Qore library needs to provision the NCurses namespace 
    // to a new QoreProgram object (or to a QoreProgram object that existed before the module
    // was loaded by another QoreProgram object and then later requests the feature "ncurses")
    void ncurses_module_ns_init(QoreNamespace *rns, QoreNamespace *qns)
    {
       // add the NCurses namespace as a subnamespace to the Qore namespace
       qns->addInitialNamespace(NCNS.copy());
    }

    // this function is called when the module is deleted (when the qore library is closed)
    // it should free all resources allocated in the module's initilization function
    void ncurses_module_delete()
    {
       // calls endwin() if necessary
       q_nc_init.close();
    }
    @endcode

    @section builtin_functions Qore Builtin Functions

    To add a builtin function to the library, you have to call BuiltinFunctionList::add().  The BuiltinFunctionList class only contains static functions, but it can also be accessed through the global \c builtinFunctions object.

    Builtin functions must have the following signature:

    @code
    // "testfunction()" ignores all arguments and returns the string "testing"
    AbstractQoreNode *f_testfunction(const QoreListNode *params, ExceptionSink *xsink)
    {
       return new QoreStringNode("testing");
    }
    @endcode

    Then the function can be added to the library's builtin function list with the following command:
    @code
    builtinFunctions.add("testfunction", f_testfunction);
    @endcode

    @subsection handling_function_arguments Handling Function Arguments

    Use the inline functions in params.h to access function arguments.  These are:
    - num_params() - returns the number of arguments passed to the function
    - get_param() - returns the argument in the position given or 0 if there is none

    The following inline functions provide arguments of a specific type:
    - test_binary_param() - returns a const BinaryNode pointer or 0
    - test_string_param() - returns a const QoreStringNode pointer or 0
    - test_object_param() - returns a QoreObject pointer or 0
    - test_date_param() - returns a const DateTimeNode pointer or 0
    - test_hash_param() - returns a const QoreHashNode pointer or 0
    - test_list_param() - returns a const QoreListNode pointer or 0
    - test_funcref_param() - returns a const ResolvedFunctionReferenceNode pointer or 0
    - test_reference_param() - returns a const ReferenceNode pointer or 0
    - test_nothing_param() - returns true if there is no value at the given position

    Note that there are no functions for the integer (\ref NT_INT) and floating-point (\ref NT_FLOAT) types.  These values should be acquired as necessary using the AbstractQoreNode::getAsInt(), AbstractQoreNode::getAsBigInt(), and AbstractQoreNode::getAsFloat() functions to allow for transparent type conversion from other data types.

    Here are some examples:

    @code
    AbstractQoreNode *f_testfunction(const QoreListNode *params, ExceptionSink *xsink)
    {
       // get the first integer argument
       const AbstractQoreNode *p = get_param(params, 0);
       int64 i = p ? p->getAsBigInt() : 0;
       
       // get the second floating-point argument
       p = get_param(params, 1);
       double f = p ? p->getAsFloat() : 0.0;

       int64 rc = do_something(i, f);

       // returns an integer value
       return new QoreBigIntNode(rc);
    }
    @endcode

    To use a string value, but accept conversion from other data types, use the QoreStringValueHelper class.  This class is best for getting QoreString values or simply getting a "char *" for the converted value.  The QoreStringValueHelper class also provides a constructor that allows the target character encoding to be specified (there is an example in the class documentation).  If you need a QoreStringNode (\ref NT_STRING) value, then use the QoreStringNodeValueHelper class instead.

    Here is an example of interpreting a function argument as a string value using the QoreStringValueHelper class:

    @code
    AbstractQoreNode *f_testfunction(const QoreListNode *params, ExceptionSink *xsink)
    {
       // get a pointer to the first argument
       const AbstractQoreNode *p = get_param(params, 0);
       
       // this will convert p to a string if necessary
       QoreStringValueHelper str(p);

       // call a function with the "const char *" to the string buffer of str
       do_something(str->getBuffer());

       return 0;
    }
    @endcode

    To process arguments meant to be timeout values (or meant to specify a period of time) where an integer implies certain units (such as milliseconds or seconds) but also allow relative DateTimeNode (\ref NT_DATE) values to be processed, use the following functions:
    - getSecZeroInt(const AbstractQoreNode *a)
    - getSecZeroBigInt(const AbstractQoreNode *a)
    - getSecMinusOneInt(const AbstractQoreNode *a)
    - getSecMinusOneBigInt(const AbstractQoreNode *a)
    - getMsZeroInt(const AbstractQoreNode *a)
    - getMsZeroBigInt(const AbstractQoreNode *a)
    - getMsMinusOneInt(const AbstractQoreNode *a)
    - getMsMinusOneBigInt(const AbstractQoreNode *a)
    - getMicroSecZeroInt(const AbstractQoreNode *a)

    Each of the above functions returns an integer, assuming a certain unit for non DateTimeNode values, and also returns a default value if no argument was present (either 0 or -1). 

    The following is an example of using getMsZeroInt():

    @anchor MUTEX_lock
    @code
    static AbstractQoreNode *MUTEX_lock(QoreObject *self, SmartMutex *m, const QoreListNode *params, ExceptionSink *xsink)
    {
       // the the first argument
       const AbstractQoreNode *p = get_param(params, 0);

       // we only return a return value if we have a timeout, otherwise we save allocating a QoreBigIntNode
       if (!is_nothing(p)) {
          // get the timeout value in milliseconds from the argument
          int timeout_ms = getMsZeroInt(p);
	  // grab the lock with a timeout value
	  int rc = m->grab(xsink, timeout_ms);
	  // return the return code if there was no exception
	  if (!*xsink)
	     return new QoreBigIntNode(rc);
       }
       else // grab the lock unconditionally (without a timeout)
          m->grab(xsink); 

       return 0;
    }
    @endcode

    @subsection function_return_value Function Return Value

    Each Qore function should return a pointer to an AbstractQoreNode giving the return value of the function.  If the function does not return a value, then it should simply return 0 as follows:

    @code
    // "testfunction()" ignores all arguments and returns no value
    AbstractQoreNode *f_testfunction(const QoreListNode *params, ExceptionSink *xsink)
    {
       return 0;
    }
    @endcode

    Otherwise, the pointer's reference count will be owned by the caller of builtin function, so returning a descendent of AbstractQoreNode created with the C++ new operator is OK, otherwise you have to make sure that the value returned by the builtin function is referenced for the return.  In other words, returning AbstractQoreNode descendents that have an incremented reference count is OK, but, for example, to return an argument of the function as the return value of the function, you have to increment the reference count manually -- the easiest way to do this is to call AbstractQoreNode::refSelf() on the value to be returned, as in the following example:

    @code
    static AbstractQoreNode *f_return_first_argument(const QoreListNode *params, ExceptionSink *xsink)
    {
       const AbstractQoreNode *p = get_param(params, 0);
       return p ? p->refSelf() : 0;
    }
    @endcode

    See the section below on Handling Qore Data for more information.
    
    @subsection function_raising_exceptions Raising Exceptions in a Function

    If your function raises an exception, then you must call ExceptionSink::raiseException() against the ExceptionSink argument to the function.  In the case that your function raises a Qore-language exception, the function must \b always return 0 as a return value.  The following is an example:

    @code
    static AbstractQoreNode *f_remove_signal_handler(const QoreListNode *params, ExceptionSink *xsink)
    {
       const AbstractQoreNode *p0 = get_param(params, 0);
       int signal = p0 ? p0->getAsInt() : 0;
       if (!signal || signal > QORE_SIGNAL_MAX) {
          xsink->raiseException("REMOVE-SIGNAL-HANDLER-ERROR", "%d is not a valid signal", signal);
	  return 0;
       }
       QoreSignalManager::removeHandler(signal, xsink);
       return 0;
    }
    @endcode

    @section handling_data Handling Qore Data

    All data value in Qore (and, in fact, all elements of Qore parse trees) are descended from AbstractQoreNode.

    The following are the basic data types in Qore, implemented as C++ classes descended from AbstractQoreNode, and their type codes, accessed via AbstractQoreNode::getType():
    - QoreBoolNode (\ref NT_BOOLEAN) for the boolean data type
    - QoreBigIntNode (\ref NT_INT) for the 64-bit integer data type
    - QoreFloatNode (\ref NT_FLOAT) for the double-precision floating-point type
    - QoreStringNode (\ref NT_STRING) for the string data type
    - DateTimeNode (\ref NT_DATE) for the date/time data type
    - BinaryNode (\ref NT_BINARY) for the opaque binary data type
    - QoreNothingNode (\ref NT_NOTHING) for a type signifying no value (also equivalent to 0!)
    - QoreNullNode (\ref NT_NULL) for the SQL NULL data type
    - QoreHashNode (\ref NT_HASH) for an associative array or hash data type
    - QoreListNode (\ref NT_LIST) for a list or array data type
    - QoreObject (\ref NT_OBJECT) for the data type representing the instantiation of a Qore class (QoreClass)

    Additionally, the following classes are exposed in the library:
    - ReferenceNode (\ref NT_REFERENCE)
    - AbstractFunctionReferenceNode (\ref NT_FUNCREF)

    @see node_types.h for a complete list of all type codes.

    @subsection simple_value_types Simple Value Types: QoreBigIntNode, QoreFloatNode, QoreStringNode, DateTimeNode, BinaryNode

    The QoreBigIntNode, QoreFloatNode, QoreStringNode, DateTimeNode, BinaryNode and classes are reference counted and can only be dynamically allocated.

    They are all descendents of SimpleQoreNode, meaning that dereferencing their objects cannot cause a Qore-language exception to be thrown, therefore the SimpleRefHolder class can be used to manage temporary references to objects of these types.

    For example:

    @code
    {
       // here a QoreBigIntNode value is returned with an incremented reference count
       SimpleRefHolder<QoreBigIntNode> qint(getQoreBigIntNode());
       printf("the result is: %lld\n", qint->val);
       // when qint goes out of scope, the reference count is decremented
    }
    @endcode

    @subsection unique_value_types Unique Value Types: QoreBoolNode, QoreNullNode, QoreNothingNode

    None of these classes can be directly instantiated with the new operator.  They are all represented by single objects managed directly by the Qore library.  Each of these classes represents a type that has only one value, therefore as a memory and performance optimization, reference counting is disabled for these objects.  Actually in the case of QoreBoolNode the subclasses QoreBoolTrueNode and QoreBoolFalseNode have actual instantiations.

    For the QoreBoolNode class, you can use these objects by referring to the global \ref True and \ref False objects, or by calling get_bool_node() as follows in the example function:

    @code
    static AbstractQoreNode *f_convert_first_argument_to_bool(const QoreListNode *params, ExceptionSink *xsink)
    {
       const AbstractQoreNode *p = get_param(params, 0);
       return get_bool_node(p ? p->getAsBool() : false);
    }
    @endcode

    Or, some even simpler functions:

    @code
    static AbstractQoreNode *f_return_true(const QoreListNode *params, ExceptionSink *xsink)
    {
       return &True; // QoreBoolNode objects are not reference counted (reference counting operations are ignored)
    }

    static AbstractQoreNode *f_return_false(const QoreListNode *params, ExceptionSink *xsink)
    {
       return &False; // QoreBoolNode objects are not reference counted (reference counting operations are ignored)
    }
    @endcode

    Similarly, for QoreNullNode there is the global \ref Null object or the inline function null() that returns a pointer to this object.

    QoreNothingNode has the gobal \ref Nothing object and the inline function nothing() that returns a pointer to it as well.

    @note that in Qore a C++ null pointer (0) is the same as \c NOTHING, therefore the inline function is_nothing() should always be used to test for \c NOTHING.

    @subsection container_types Container Value Types: QoreHashNode, QoreListNode, QoreObject

    The QoreHashNode, QoreListNode, and QoreObject classes define container types in Qore.  QoreObject objects in particular could throw an exception when dereferenced (if the object goes out of scope and its destructor is run, the destructor could throw an exception).  Because container types can hold any type, when they are deferenced it could cause a QoreObject to go out of scope, and therefore the possibility that a Qore-language exception could be thrown must be taken into consideration.  Therefore, to dereference these objects a pointer to an ExceptionSink object must be passed to AbstractQoreNode::deref().
    
    The ReferenceHolder class can be used to manage temporary reference counts as follows:

    @code
    {
       // here a QoreHashNode value is returned with an incremented reference count
       // note that xsink must be "ExceptionSink *"
       ReferenceHolder<QoreHashNode> qhash(getQoreHashNode(), xsink);
       printf("there are %ld elements in the hash\n", qhash->size());
       // when qhash goes out of scope, the reference count is decremented
    }
    @endcode

    @subsection qoreobject Object Value Type: QoreObject

    QoreObject is special in that the implementation for objects in Qore mirrors that of Java, in that objects are pased by reference when used as function or method arguments, unlike other types.  However, like Java, the reference to the object is passed, and not the variable, so, while an object passed as an argument to a function can be modified by that function (modifications are made to the original object), in order to write a swap method, for example, you would need to pass the variables by reference (or the lvalue expression by reference, as the case may be) to the swap function.  Unlike Java, Qore does support passing arguments by reference.

    @section class_implementation Implementing Qore Classes

    In order to implement a Qore-language class, you have to create an object of type QoreClass and add it somewhere to a namespace to be included in QoreProgram objects.  In a module, for example, this is done by adding the class the reference namespace in the \c module_init() function.

    Once the QoreClass object has been created, the class' unique class identifier should be saved and all methods should be added to the class object, as in the following example:

    @code
    // returns the QoreClass definition for the "Mutex" class to be added to the Qore system namespace
    QoreClass *initMutexClass()
    {
       // creates the QoreClass object representing the "Mutex" class
       QoreClass *QC_MUTEX = new QoreClass("Mutex", QDOM_THREAD_CLASS);

       // save the class ID for use in the constructor method
       CID_MUTEX = QC_MUTEX->getID();

       // set the constructor method
       QC_MUTEX->setConstructor(MUTEX_constructor);

       // set the destructor method
       QC_MUTEX->setDestructor((q_destructor_t)MUTEX_destructor);

       // set the copy method
       QC_MUTEX->setCopy((q_copy_t)MUTEX_copy);

       // set the regular methods of the class
       QC_MUTEX->addMethod("lock",          (q_method_t)MUTEX_lock);
       QC_MUTEX->addMethod("trylock",       (q_method_t)MUTEX_trylock);
       QC_MUTEX->addMethod("unlock",        (q_method_t)MUTEX_unlock);

       // return the new class to be added to the Qore system namespace
       return QC_MUTEX;
    }
    @endcode

    @subsection constructor_methods Constructor Methods

    The goal of the constructor method is to create and save the object's private data against the QoreObject object representing the object in Qore by using the class ID.

    A Qore object's private data must be descended from the AbstractPrivateData class.  Normally the actual class implementation is made as the class representing the private data, and the bindings to Qore are provided as the QoreClass methods.  This way, the methods added to QoreClass can handle Qore-language argument processing and the actual work of the method can be performed by the class repsenting the object's private data.

    Here is an example for the Mutex class (note that all constructor method arguments are ignored, for argument handling see the section on function argument handling), for each method in the class the SmartMutex class performs the actual work:

    @code
    static void MUTEX_constructor(QoreObject *self, const QoreListNode *params, ExceptionSink *xsink)
    {
       // unconditionally save the SmartMutex object as the private data for the QoreObject 
       // using the class ID CID_MUTEX as saved in initMutexClass()
       self->setPrivate(CID_MUTEX, new SmartMutex());
    }
    @endcode

    If there are any Qore-language exceptions raised in the constructor, it's important that no private data is saved against the object, therefore all setup and argument processing code should be executed before the QoreObject::setPrivate() function is run.

    @subsection copy_methods Copy Methods

    Copy methods are similar to constructor methods, in so far as they also should create and save private data representing the state of the object against the QoreObject object by using the class ID.  Copy methods also get a pointer to the original object and the original private data to facilitate the copy operation.

    Like constructors, if a Qore-language exception is raised in the copy method, no private data should be stored against the new QoreObject.

    The original object should not be modified by a copy method.

    Here is an example of the Mutex' class copy method:

    @code
    static void MUTEX_copy(QoreObject *self, QoreObject *old, SmartMutex *m, ExceptionSink *xsink)
    {
       // the "old" and "m" parameters representing the old object are ignored
       self->setPrivate(CID_MUTEX, new SmartMutex());
    }
    @endcode

    Notice that the third parameter of the function is defined as "SmartMutex *" and not as "AbstractPrivateData *".  This is for convenience to avoid a cast in the function, there is a cast when the copy method is assigned to the QoreClass object as follows:

    @code
    // set the copy method
    QC_MUTEX->setCopy((q_copy_t)MUTEX_copy);
    @endcode

    @note Copy methods are run after the object's hash members have already been copied to the new QoreObject

    @subsection destructor_methods Destructor Methods

    Destructor methods are optional.  If no destructor method is defined, then the private data's AbstractPrivateData::deref(ExceptionSink *) method is run when the destructor would otherwise be run.  This is suitable for objects that simply expire when the last reference count reaches zero and where the destructor takes no action (the qore library will mark the object as deleted when the destructor is run anyway, so no more access can be made to the object after the destructor is run even if the reference count is not zero).

    If the destructor could throw an exception, or should otherwise take some special action, then a destructor method must be defined in the class.  In this case, the destructor method must also call AbstractPrivateData::deref() on it's private data.

    The Mutex class can throw an exception when deleted (for example, if a thread is still holding the lock when the object should be deleted), here is the code:

    @code
    static void MUTEX_destructor(QoreObject *self, SmartMutex *m, ExceptionSink *xsink)
    {
       // run the actual destructor code implemented in SmartMutex
       m->destructor(xsink);

       // dereference the SmartMutex private data
       m->deref(xsink);
    }
    @endcode

    As with the copy method, a cast is used when the destructor is assigned to the QoreClass object as follows:

    @code
    // set the destructor method
    QC_MUTEX->setDestructor((q_destructor_t)MUTEX_destructor);
    @endcode

    @subsection regular_class_methods Regular Class Methods

    Regular, or non-special class methods (the constructor, destructor, and copy method are special methods, all other methods are regular methods; note that it's currently not possible to define builtin memberGate or methodGate methods, this restriction will be lifted in a future version of the Qore library) are defined in a similar manner.  A pointer to the QoreObject is passed to the method, along with the private data and an ExceptionSink pointer in case the method needs to raise a Qore-language exception.

    As with functions, if the method raises a Qore-language exception against the ExceptionSink pointer, the return value should be 0.  Argument handling is the same as with builtin functions.

    Previously the \ref MUTEX_lock function implementation (for Qore class method Mutex::lock()) was given as an example, and here you can see how it's bound to the QoreClass object:

    @code
       QC_MUTEX->addMethod("lock",          (q_method_t)MUTEX_lock);
    @endcode

    Note the cast to q_method_t so that "SmartLock *" can be given directly in the function signature.

    @subsection object_threading_issues Threading Issues in Class Implementation

    Note that the highly-threaded nature of Qore means that all Qore code including classes can be executed in a multi-threaded context.  By using atomic reference counts, the qore library guarantees that the private data object will stay valid during the execution of each method, however any method could be executed in parallel with any other method.

    @note the only exception to this rule is the contructor, which is always executed in a single thread without the possibility of access in another thread, as no pointers to the object are yet available outside this method.

    Therefore it's also possible that a class method could be in progress while the destructor method is run.  If your class should guarantee that the destructor (or any other method) should run with exclusive access to the object, then appropriate locking must be implemented in the implementation of the private data class (descended from AbstractPrivateData).

   @subsection class_hierarchies Implementing Class Hierarchies

   There are two methods of implementing class hierarchies in builing classes in Qore:
   - use QoreClass::addDefaultBuiltinBaseClass() to use a base class' private data in the child clas
   - use QoreClass::addBuiltinVirtualBaseClass() to speficy that the child class' private data is a child of the parent's private data class

   One of these functions (but never both for the same QoreClass object) must be called when setting up the QoreClass object.  However, they have very different implications for handling private data in the class implementation.

   After executing QoreClass::addDefaultBuiltinBaseClass(), this tells the Qore library that this child class will not save its own private data against the QoreObject.  Instead, the private data from the parent class will be passed to all methods.  The constructor method of the child class should not save any private data against the QoreObject.

   Here is an example of the XmlRpcClient class implementation calling QoreClass::addDefaultBuiltinBaseClass() to add the HTTPClient class as the default base class:

   @code
   // to set up the XmlRpcClient class, a pointer to the HTTPClient class implementation is passed as an argument
   QoreClass *initXmlRpcClientClass(QoreClass *http_client)
   {
      // create the XmlRpcClient QoreClass object
      QoreClass* client = new QoreClass("XmlRpcClient", QDOM_NETWORK); 

      // get the class ID (although it's not used anywhere at the moment)
      CID_XMLRPCCLIENT = client->getID();

      // add the HTTPClient class as the default base class
      client->addDefaultBuiltinBaseClass(http_client);

      // set the constructor
      client->setConstructor(XRC_constructor);

      // set the copy method
      client->setCopy((q_copy_t)XRC_copy);

      // add the regular methods
      client->addMethod("callArgs", (q_method_t)XRC_callArgs);
      client->addMethod("call",     (q_method_t)XRC_call);
      
      // return the new class implementation
      return client;
   }
   @endcode

   However, the parent's constructor will have already been run by the time the child's constructor is run, so the parent's private data may be retrieved and modified by the child' constructor, for example as in the implementation of the XmlRpcClient class in the Qore library (which adds the HTTPClient as the default base class) as follows:

   @code
   static void XRC_constructor(QoreObject *self, const QoreListNode *params, ExceptionSink *xsink)
   {
      // get HTTPClient object's private data
      safe_httpclient_t client((QoreHTTPClient *)getStackObject()->getReferencedPrivateData(CID_HTTPCLIENT, xsink), xsink);
      if (!client)
         return;

      // set options for XML-RPC communication
      client->setDefaultPath("RPC2");
      client->setDefaultHeaderValue("Content-Type", "text/xml");
      client->setDefaultHeaderValue("Accept", "text/xml");
      client->setDefaultHeaderValue("User-Agent", "Qore XML-RPC Client v" PACKAGE_VERSION);
      
      client->addProtocol("xmlrpc", 80, false);
      client->addProtocol("xmlrpcs", 443, true);

      // set user-defined options if the options hash is present
      const QoreHashNode* n = test_hash_param(params, 0);
      if (n && client->setOptions(n, xsink))
         return;

      // connect to the client in the constructor
      client->connect(xsink); 

      // NOTE there is no call to QoreObject::setPrivateData() - this object only uses the
      // parent class' (HTTPClient) private data due to the call to 
      // QoreClass::addDefaultBuiltinBaseClass() when registering the class
   }
   @endcode

   To add a parent class and specify that the child class' private data is actually a descendent of a parent class' private data, call QoreClass::addBuiltinVirtualBaseClass().

   In this case, the parent class' constructor will never be called.  The child class' constructor is responsible for saving the private data against the QoreObject, and when the parent class' methods are called, the child class' private data is passed to the parent class' method functions.

   This means that the child class' private data must be directly descended from the parent class' private data class, and objects of the child class' private data class must be valid pointers of the parent class' private data class as well.

   In this case the parent class' copy and destructor methods also will not be run.

   Here is an example (in the Qt module) of the QWidget class adding two builtin virtual base classes:

   @code
   QoreClass *initQWidgetClass(QoreClass *qobject, QoreClass *qpaintdevice)
   {
      QC_QWidget = new QoreClass("QWidget", QDOM_GUI);
      CID_QWIDGET = QC_QWidget->getID();

      // set QObject as a virtual base class
      QC_QWidget->addBuiltinVirtualBaseClass(qobject);
      // set QPaintDevice as a virtual base class
      QC_QWidget->addBuiltinVirtualBaseClass(qpaintdevice);
      
      QC_QWidget->setConstructor(QWIDGET_constructor);
      QC_QWidget->setCopy((q_copy_t)QWIDGET_copy);

      QC_QWidget->addMethod("acceptDrops",                  (q_method_t)QWIDGET_acceptDrops);

      // more methods added...

      return QC_QWidget;
   }
   @endcode

   In this case the class' constructor, copy, and destructor methods are implemented normally, and the constructor, copy, and destructor methods of the parent classes (in this case QObject and QPaintDevice) are never run, instead the child class' special methods must take care to provide all the required functionality of the parent class' special methods.
 
   @section dbi_drivers Implementing DBI Qore Drivers

   @subsection dbi_function_overview DBI Function Overview

   To write a DBI driver, you have to provide implementations for the following functions supporting the Datasource class (listed by their function signatures):
   - \ref dbi_open "open": opens the connection to the database
   - \ref dbi_close "close": closes the connection to the database
   - \ref dbi_select "select": executes a select statement and returns the result as a QoreHashNode (columns) of QoreListNode objects (rows)
   - \ref dbi_select_rows "select_rows": executes a select statement and returns the result as a QoreListNode (rows) or QoreHashNode objects (columns and values)
   - \ref dbi_exec "exec": executes arbitrary SQL on the connection and returns the result
   - \ref dbi_commit "commit": commits a transaction
   - \ref dbi_rollback "rollback": rolls back a transaction

   For databases where transactions must be started explicitly (for example, with a "begin transaction" statement), the following two functions should be implemented (and must not be implemented for databases where transactions are started implicitly):
   - \ref dbi_begin_transaction "begin_transaction()": explicitly starts a transaction (ex: executes a "begin transaction" statement)
   - \ref dbi_abort_transaction_start "abort_transaction_start()": rolls back the transation, necessary for databases where an error in the first statement of a transaction where "begin_transaction" was implicitly executed by the Qore DBI subsystem requires a "rollback" statement to be executed in order to use the datasource further (ex: pgsql driver)

   The following functions are always optional:
   - \ref dbi_get_server_version "get_server_version()": returns the version of the server
   - \ref dbi_get_client_version "get_client_version()": returns the version of the client library

   More detail about each function is provided in the following sections.

   These functions must be registered in the DBI subsystem by populating a qore_dbi_method_list structure with pointers to the methods and then calling DBIDriverList::registerDriver() on the \ref DBI object.  This should be done in the \c module_init() function as in the following example from the mysql driver:

   @code
   QoreStringNode *qore_mysql_module_init()
   {
      // initialize thread key to test for mysql_thread_init()
      pthread_key_create(&ptk_mysql, NULL);
      tclist.push(mysql_thread_cleanup, NULL);
      my_init();
      
      // populate the method list structure with the method pointers
      qore_dbi_method_list methods;
      methods.add(QDBI_METHOD_OPEN,               qore_mysql_open_datasource);
      methods.add(QDBI_METHOD_CLOSE,              qore_mysql_close_datasource);
      methods.add(QDBI_METHOD_SELECT,             qore_mysql_select);
      methods.add(QDBI_METHOD_SELECT_ROWS,        qore_mysql_select_rows);
      methods.add(QDBI_METHOD_EXEC,               qore_mysql_exec);
      methods.add(QDBI_METHOD_COMMIT,             qore_mysql_commit);
      methods.add(QDBI_METHOD_ROLLBACK,           qore_mysql_rollback);
      methods.add(QDBI_METHOD_GET_SERVER_VERSION, qore_mysql_get_server_version);
      methods.add(QDBI_METHOD_GET_CLIENT_VERSION, qore_mysql_get_client_version);
      
      // register database functions with DBI subsystem
      DBID_MYSQL = DBI.registerDriver("mysql", methods, mysql_caps);
      
      return 0;
   }
   @endcode
   
   @note Any functions requiring an open connection (\ref dbi_select "select", \ref dbi_select_rows "select_rows", \ref dbi_exec "exec", \ref dbi_commit "commit", \ref dbi_rollback "rollback", and \ref dbi_get_server_version "get_server_version") will have a connection opened implicitly before the call is executed by the Qore library.  Therefore any function requiring an open database connection can assume that the connection has already been established (and therefore that the private data representing the state of the connection) is available.

   @subsection dbi_open DBI Open Method

   Function signature: \ref q_dbi_open_t

   This method will be called whenever the connection to the database must be opened.  The connection parameters can be queried from the Datasource argument as follows:
   - Datasource::getUsername() gives the username to use for the connection
   - Datasource::getPassword() gives the password to use for the connection
   - Datasource::getHostName() gives the host name to use for the connection
   - Datasource::getDBName() gives the name of the database or schema
   - Datasource::getDBEncoding() gives the name of the database-specific character encoding to use for the connection
   
   If Datasource::getDBEncoding() returns 0, then the character encoding for the connection should be set based on \ref QCS_DEFAULT.

   Here is a connection example from the sybase driver:

   @code
   static int sybase_open(Datasource *ds, ExceptionSink *xsink)
   {
      // username is a required parameter
      if (!ds->getUsername()) {
         xsink->raiseException("DATASOURCE-MISSING-USERNAME", "Datasource has an empty username parameter");
	 return -1;
      }

      // DB name is a required parameter
      if (!ds->getDBName()) {
         xsink->raiseException("DATASOURCE-MISSING-DBNAME", "Datasource has an empty dbname parameter");
	 return -1;
      }

      // set the encoding for the connection
      if (ds->getDBEncoding()) {
         const QoreEncoding *enc = name_to_QoreEncoding(ds->getDBEncoding());
	 ds->setQoreEncoding(enc);
      } 
      else {
         const char *enc = QoreEncoding_to_SybaseName(QCS_DEFAULT);
	 // if the encoding cannot be mapped, throw a Qore-language exception and return
	 if (!enc) {
	    xsink->raiseException("DBI:SYBASE:UNKNOWN-CHARACTER-SET", "cannot find the Sybase character encoding equivalent for '%s'", QCS_DEFAULT->getCode());
	    return -1;
	 }
	 ds->setDBEncoding(enc);
	 ds->setQoreEncoding(QCS_DEFAULT);
      }
  
      // create the connection object
      std::auto_ptr<connection> sc(new connection);
  
      // make the actual connection to the database
      sc->init(ds->getUsername(), ds->getPassword() ? ds->getPassword() : "", ds->getDBName(), ds->getDBEncoding(), ds->getQoreEncoding(), xsink);
      
      // return with an error if it didn't work
      if (*xsink)
         return -1;

      // set the private data
      ds->setPrivateData(sc.release());

      // return 0 for OK
      return 0;
   }
   @endcode

   If the connection is successfully established, then Datasource::setPrivateData() should be called to save the connection state and 0 should be returned.  This state will lated be retrieved in each DBI method with Datasource::getPrivateData().

   If a connection cannot be established, then -1 should be returned and a Qore-language exception should be added to the ExceptionSink object.

   Qore DBI drivers must initialize each connection manually to use transaction isolation level "read committed" if necessary when opening the connection.  For example the mysql driver does this for each connection as follows after opening a connection:

   @code
   // set transaction handling
   if (mysql_query(db, "set transaction isolation level read committed")) {
      xsink->raiseException("DBI:MYSQL:INIT-ERROR", (char *)mysql_error(db));
      mysql_close(db);
      return 0;
   }   
   @endcode

   @subsection dbi_close DBI Close Method

   Function signature: \ref q_dbi_close_t

   This method should unconditionally close the connection to the database.  There is currently no facility for registering errors when closing a connection; the return value for this function is currently ignored.

   This function must clear the private data structure by calling Datasource::setPrivateData() with the argument 0.  The private data structure should also be deleted here.

   Here is the implementation of this function in the sybase driver:

   @code
   static int sybase_close(Datasource *ds)
   {
      connection* sc = (connection*)ds->getPrivateData();
      ds->setPrivateData(0);
      delete sc;

      return 0;
   }
   @endcode

   @subsection dbi_select DBI Select Method

   Function signature: \ref q_dbi_select_t

   This function must be capable of executing an SQL select against an open connection and returning the result as a QoreHashNode (the columns) of QoreListNode objects (the rows).  This is the minimum requirement for this function, but some Qore DBI drivers use the same implementation for this and the \ref dbi_exec exec method.  It depends on the database's API if it's possible or not.  Some database API's have a different functions for each operation.

   Note that the SQL string passed as an argument may not be in the encoding required by the connection.  It is the resposibility of this function to convert the string to the proper encoding before passing it to the database's API for execution.

   Furthermore, DBI placeholders and bind specifications must be processed as well before executing the query.  The following DBI-specific format codes can appear in the query string:
   - \c %v means bind the corresponding argument by value
   - \c :<name> means \c <name> is an output parameter and should be returned as an output value in an output hash (only valid for \ref dbi_exec exec)
   - \c %s means include the string directly in the query as-is without any escaping (useful for table or database name prefixes)
   - \c %d means interpret the corresponding argument as a number (either integer or float, depending on the type of the argument) and include directly in the string

   If an Qore-language exceptions are thrown due to errors while processing the select request, 0 must be returned.

   @subsection dbi_select_rows DBI SelectRows Method

   Function signature: \ref q_dbi_select_rows_t

   This function is the same as the \ref dbi_select "select" method, except that a QoreListNode (the rows) of QoreHashNode objects (the columns) should be returned.

   This format is less efficient than the QoreHashNode or QoreListNode objects, but is easier to work with in some circumstances by Qore code.

   @subsection dbi_exec DBI Exec Method

   Function signature: \ref q_dbi_exec_t

   This function is designed for executing \c insert or \c update statements or for executing stored procedures, functions, or other database code.  The same rules about placeholders and bind specifications apply as documented in the \ref dbi_select "select" method.

   For \c insert and \c update statements, the number of affected rows should be returned as an integer.

   For all other statements, a data structure appropriate to the action executed should be returned.

   @subsection dbi_commit DBI Commit Method

   Function signature: \ref q_dbi_commit_t

   This function should commit any open transaction in the database.

   Here is an example from the mysql driver (simplified for the example):

   @code
   static int qore_mysql_commit(Datasource *ds, ExceptionSink *xsink)
   {
      checkInit();
      MySQLConnection *d_mysql =(MySQLConnection *)ds->getPrivateData();

      // calls mysql_commit() on the connection
      if (d_mysql->commit()) {
         xsink->raiseException("DBI:MYSQL:COMMIT-ERROR", d_mysql->error());
         return -1;
      }
      return 0;
   }
   @endcode

   @note For databases having implicit transactions (i.e. a transaction is always in effect even without an explicit "begin transaction" statement), this method is executed after every statement when the Datasource object is in auto commit mode.

   @subsection dbi_rollback DBI Rollback Method

   Function signature: \ref q_dbi_rollback_t

   This function should roll back any open transaction in the database.

   Here is an example from the mysql driver (simplified for the example):

   @code
   static int qore_mysql_rollback(Datasource *ds, ExceptionSink *xsink)
   {
      checkInit();
      MySQLConnection *d_mysql =(MySQLConnection *)ds->getPrivateData();

      // calls mysql_rollback() on the connection
      if (d_mysql->rollback()) {
         xsink->raiseException("DBI:MYSQL:ROLLBACK-ERROR", d_mysql->error());
	 return -1;
      }
      return 0;
   }
   @endcode

   @subsection dbi_begin_transaction DBI BeginTransaction Method

   Function signature: \ref q_dbi_begin_transaction_t

   This function should only be implemented for datasources that require an explicit "begin transaction" statement to begin a transaction (such as the pgsql driver).

   Here is an example from the pgsql driver:

   @code
   static int qore_pgsql_begin_transaction(class Datasource *ds, ExceptionSink *xsink)
   {
      QorePGConnection *pc = (QorePGConnection *)ds->getPrivateData();
      // executes "begin" on the connection and returns the return value
      return pc->begin_transaction(ds, xsink);
   }
   @endcode

   @subsection dbi_abort_transaction_start DBI AbortTransactionStart Method

   Function signature: \ref q_dbi_abort_transaction_start_t

   This function is required for datasources that implement the \ref dbi_begin_transaction "begin_transaction" method, and if an error occurs as the first statement of after the  \ref dbi_begin_transaction "begin_transaction" method is implictly executed, a \ref dbi_rollback "rollback" call must immediately be made in order to continue to use the connection.

   This method is implemented for the pgsql driver by aliasing it to the \ref dbi_rollback "rollback" function, for example.

   @subsection dbi_get_server_version DBI GetServerVersion Method

   Function signature: \ref q_dbi_get_server_version_t

   This function should return version information for the database server.  As such it requires an active connection (which will be established by the Qore library before this function is called).

   There is no pre-defined format for the output of this function.  Here is the implementation of this method for the oracle driver:

   @code
   #define VERSION_BUF_SIZE 512
   static AbstractQoreNode *oracle_get_server_version(Datasource *ds, ExceptionSink *xsink)
   {
      // get private data structure for connection
      OracleData *d_ora = (OracleData *)ds->getPrivateData();

      // buffer for version information
      char version_buf[VERSION_BUF_SIZE + 1];

      // execute OCIServerVersion and check status code
      ora_checkerr(d_ora->errhp, 
                   OCIServerVersion(d_ora->svchp, d_ora->errhp, (OraText *)version_buf, VERSION_BUF_SIZE, OCI_HTYPE_SVCCTX),
		   "oracle_get_server_version", ds, xsink);
      if (*xsink)
         return 0;
   
      return new QoreStringNode(version_buf);   
   }
   @endcode

   @subsection dbi_get_client_version DBI GetClientVersion Method

   Function signature: \ref q_dbi_get_client_version_t
   
   This function should return version information for the database client library in use, and therefore does not require an open connection to the database.

   Like the \ref dbi_get_server_version "get_server_version" method, there is no pre-defined format for the output of this function.  Here is the implementation of this method for the oracle driver:

   @code
   static AbstractQoreNode *oracle_get_client_version(const Datasource *ds, ExceptionSink *xsink)
   {
      sword major, minor, update, patch, port_update;

      OCIClientVersion(&major, &minor, &update, &patch, &port_update);

      QoreHashNode *h = new QoreHashNode();
      h->setKeyValue("major", new QoreBigIntNode(major), NULL);
      h->setKeyValue("minor", new QoreBigIntNode(minor), NULL);
      h->setKeyValue("update", new QoreBigIntNode(update), NULL);
      h->setKeyValue("patch", new QoreBigIntNode(patch), NULL);
      h->setKeyValue("port_update", new QoreBigIntNode(port_update), NULL);
      return h;
   }
   @endcode
*/
