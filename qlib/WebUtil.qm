# -*- mode: qore; indent-tabs-mode: nil -*-
# @file WebUtil.qm Qore user module supprting web server operations

/*  WebUtil.qm Copyright 2013 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.8 or better
%requires qore >= 0.8.8

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module WebUtil {
    version = "1.0";
    desc = "user module supprting web server operations";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
}

/*  Version History
    * 2013-xx-xx v1.0: David Nichols <david@qore.org>
      + the initial version of the WebUtil module
*/

/** @mainpage WebUtil Module

    The %WebUtil module provides code that support web server operations.

    To use this module, use \c "%requires WebUtil" in your code.
    
    All the public symbols in the module are defined in the WebUtil namespace

    Classes:
    - @ref WebUtil::TemplateManager "TemplateManager"

*/

#! the WebUtil namespace contains all the objects in the WebUtil module
public namespace WebUtil {
    #! A container for holding text templates with mixed text and Qore code
    /** To give the template programs a specific imported API, subclass this object and use the following methods in your subclass's initImpl() method:
        - @ref Qore::Program::importClass()
        - @ref Qore::Program::importFunction()
        - @ref Qore::Program::importGlobalVariable()
     */
    public class TemplateManager {
        private {
            #! Holds the template generation functions
            Program $.p;

            #! Maps template names to function names and automatic renderer objects
            hash $.th;

            #! Sequence for template function names
            Sequence $.seq();
        }

        public {
            #! default parse options for template Programs
            const DefaultProgramOptions = PO_REQUIRE_OUR|PO_NO_TOP_LEVEL_STATEMENTS|PO_NO_INHERIT_USER_FUNC_VARIANTS|PO_NO_INHERIT_GLOBAL_VARS|PO_NO_USER_CLASSES|PO_NO_TERMINAL_IO;
        }

        #! sets up the object
        constructor(int $po = DefaultProgramOptions) {
            # create Program
            $.p = new Program($po);

            # perform Program initialization
            $.initImpl();
        }

        #! adds a template to the object
        /** @par Example:
            @code
my string $qhtml = "<form id=\"upload_form\" enctype=\"multipart/form-data\" method=\"post\" action=\"{{ $URL_PREFIX }}upload-file">
    <fieldset class=\"workflow_list\">
        <legend>Step 1: Select Workflow</legend>
          <select class=\"worfklows\" name=\"workflow\" id=\"workflow\">
            {% while ($hi.next()) { %}
            <option value="{{ $hi.getKey() }}">{{ $hi.getValue().label }}</option>
            {% } %}
          </select>
    </fieldset>
</form>";
my string $code = $tm.add("/html/index.qhtml", $qhtml);
            @endcode

            @param name the name of the template
            @param src the source of the template; %Qore source code is delimited as follows:
            - expressions: %Qore expressions are delimited by double curly brackets: <tt>{{ }}</tt>; such expressions are expected to return a string value that will be inserted directly into the text generated by the template
            - statements: %Qore statements are delimited by a curly bracket and percent sign: <tt>{% %}</tt>; these statements can be any %Qore code legal for the template @ref Qore::Program "Program" object; for example loop constructs are often used (see the example above)

            @return the source code of the generated template (without @ref Qore::Program "Program" overhead)
        */
        string add(string $name, string $src) {
            # generate function name
            my string $fn = sprintf("t%d", $.seq.next());

            # break down source into components
            my list $l = ();

            my int $i = 0;
            while ($src) {
                $i = $src.find("{", $i);
                if ($i == -1)
                    break;
                ++$i;
                my string $c = $src[$i];
                if ($c == "{") {
                    if ($.doBlock("}}", \$src, "exp", \$i, \$l))
                        break;
                    continue;
                }
                if ($c == "%") {
                    if ($.doBlock("%}", \$src, "stmt", \$i, \$l))
                        break;
                    continue;
                }
            }

            # add any remaining text as a text element
            if ($src)
                $l += (
                    "type": "text",
                    "text": $src,
                );

            #printf("DBG l: %N\n", $l);

            # now process and rebuild source
            $src = "";
            foreach my hash $h in (\$l) {
                switch ($h.type) {
                    case "text": $h.text =~ s/"/\"/g; $src += $h.text; break;
                    case "exp": $src += "\"+("+ $h.text + ")+\""; break;
                    case "stmt": $src += "\";" + $h.text + "$rv_TEMPLATE_str+=\""; break;
                }
            }

            #printf("template %y: found vars: %y\n", $name, $vh.keys());

            # build function source
            my string $tpl = sprintf("string sub %s(*hash $ctx) {\n", $fn);
            $tpl += sprintf("    my string $rv_TEMPLATE_str = \"%s\";\n    return $rv_TEMPLATE_str;\n}\n", $src);
            $.p.parse($tpl, $name);

            # add entry in template hash
            $.th.$name.func = $fn;

            # return the final source string produced
            return $src;
        }

        #! returns @ref Qore::True "True" if the given template exists, @ref Qore::False "False" if not
        bool hasTemplate(string $tname) {
            return boolean($.th.$tname);
        }

        #! returns @ref Qore::True "True" if the given template exists and has an auto-renderer, @ref Qore::False "False" if not
        bool hasTemplateWithRenderer(string $tname) {
            return $.th.$tname.code ? True : False;
        }

        #! explicitly renders the given template with the given argument
        string render(string $tname, *hash $ctx) {
            my *string $fn = $.th.$tname.func;
            if (!$fn)
                throw "TEMPLATE-ERROR", sprintf("no template %y exists; known templates: %y", $tname, $.th.keys());

            return $.p.callFunction($fn, $ctx);
        }

        #! explicitly renders the given template with the given argument context hash if the template exists
        *string tryRender(string $tname, *hash $ctx) {
            my *string $fn = $.th.$tname.func;
            if (!$fn)
                return;

            return $.p.callFunction($fn, $ctx);
        }

        #! adds an automatic renderer to a template
        addRenderer(string $tname, code $code) {
            if (!$.th.$tname)
                throw "TEMPLATE-ERROR", sprintf("no template %y exists; known templates: %y", $tname, $.th.keys());

            $.th.$tname.code = $code;
        }

        #! renders a template using an automatic renderer
        string autoRender(string $tname, hash $cx) {
            my *hash $th = $.th.$tname;
            if (!$th)
                throw "TEMPLATE-ERROR", sprintf("no template %y exists; known templates: %y", $tname, $.th.keys());

            if (!$th.code)
                throw "TEMPLATE-ERROR", sprintf("template %y has no renderer", $tname);

            return $.p.callFunction($th.func, $th.code($cx));
        }

        #! renders a template using an automatic renderer if the template and a renderer exist
        *string tryAutoRender(string $tname, hash $cx) {
            my *hash $th = $.th.$tname;
            if (!$th || !$th.code)
                return;

            return $.p.callFunction($th.func, $th.code($cx));
        }

        #! returns a hash of template names, values are @ref Qore::True "True" or @ref nothing if no templates are currently cached
        *hash getTemplateHash() {
            my hash $h;
            map $h.$1 = True, $.th.keyIterator();
            return $h;
        }

        #! returns a list of template names, an empty list is returned if there are no templates
        list getTemplateList() {
            return $.th.keys();
        }

        #! returns a hash of template names with auto-renderers, values are @ref Qore::True "True" or @ref nothing if no templates with auto-renderers are currently cached
        *hash getAutoTemplateHash() {
            my hash $h;
            map $h.$1 = True, $.th.keyIterator(), $.th.$1.code;
            return $h;
        }

        #! returns a list of template names with auto-renderers, an empty list is returned if there are no templates with auto-renderers currently cached
        list getAutoTemplateList() {
            return map $1, $.th.keyIterator(), $.th.$1.code;
        }

        #! called in the constructor after default initialization; by default does nothing, override in subclasses to customize the template Program initialization
        private initImpl() {
        }

        private bool doBlock(string $end, reference $src, string $type, reference $i, reference $l) {
            my int $j = $src.find($end, $i + 1);
            if ($j == -1)
                return True;
            if ($i > 1)
                $l += (
                    "type": "text",
                    "text": extract $src, 0, $i - 1,
                );
            # remove open brackets
            splice $src, 0, 2;
            $j -= $i;
            # add source expression reference
            $l += (
                "type": $type,
                "text": extract $src, 0, $j - 1,
                );
            # remove close brackets
            splice $src, 0, 2;
            $i = 0;
            return False;
        }
    }
}
