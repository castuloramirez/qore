# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file RestHandler.qm Qore @brief handler definition for the HttpServer module for exporting REST services

/*  RestHandler.qm Copyright 2013 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.8 or better
%requires qore >= 0.8.8

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

%requires HttpServer >= 0.3.7
%requires Mime >= 1.3

%try-module yaml
%define NoYaml
%endtry

%try-module xml
%define NoXml
%endtry

%try-module json
%define NoJson
%endtry

module RestHandler {
    version = "0.1";
    desc = "user module for implementing REST services with the Qore HTTP server";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
}

/*  Version History
    * 2013-xx-xx v1.0: David Nichols <david@qore.org>
      + the initial version of the RestHandler module
*/

/** @mainpage RestHandler Module

    The %RestHandler module provides functionality for implementing REST services with the Qore HTTP server.

    To use this module, use \c "%requires RestHandler" in your code.
    
    All the public symbols in the module are defined in the RestHandler namespace.

    The main classes are:
    - @ref RestHandler::AbstractRestClass "AbstractRestClass": this class provides the functionality of the REST object currently being accessed (and access to subobjects or subclasses)
    - @ref RestHandler::RestHandler "RestHandler": this class can be used to plug in to the Qore <a href="../../HttpServer/html/index.html">HttpServer</a> to expose REST services

    see example file \c "restserver.q" in the examples directory for an example of using this module to implement REST services.
*/

#! the RestHandler namespace contains all the objects in the RestHandler module
public namespace RestHandler {
    #! the base abstract class for REST handler classes
    public class AbstractRestClass {
        public {}

        constructor() {
        }

        abstract string name();

        #! this method will be called to find a sub-class (ie with GET /invoices/1 - if this class represents "invoices", then subClass("1") will be called to return invoice 1; return NOTHING if the object doesn't exist
        /** @param name the name of the subclass
            @param cx call context hash; this hash will have the following keys:
            - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
            - \c socket-info: a hash of socket information for the listening socket (as returned by Qore::Socket::getSocketInfo())
            - \c peer-info: a hash of socket information for the remote socket (as returned by Qore::Socket::getPeerInfo())
            - \c url: a hash of broken-down URL information (as returned from parseURL())
            - \c id: the unique HTTP connection ID
            - \c listener-id: the HTTP server listener ID (see HttpServer::getListenerInfo())
            - \c user: the current RBAC username (if any)
            - \c hdr: a hash of header information as returned by @ref Qore::Socket::readHTTPHeader()
            - \c body: the deserialized message body
            - \c aih: a hash of \c "Accept" values
            @param args any URI arguments in the request

            @return an object corresponding to the \c name argument or @ref nothing if none can be matched
         */
        *AbstractRestClass subClass(string $name, hash $cx, *hash $args) {
        }

        #! this method is called by the RestHandler class to match the right object with incoming requests
        hash handleRequest(RestHandler $rh, *list $cl, string $mn, hash $cx, *hash $args) {            
            if ($cl) {
                my string $cname = shift $cl;
                my *AbstractRestClass $cls = $.subClass($cname, $cx, $args);
                if (!$cls) {
                    $rh.logDebug("class %y: unknown subclass %y: method %y args: %y", $.name(), $cname, $mn, $args);
                    return $.unknownSubClassError($cname);
                }

                $rh.logDebug("class %y: dispatching to subclass class %y: method %y args: %y", $.name(), $cname, $mn, $args);
                return $cls.handleRequest($rh, $cl, $mn, $cx, $args);
            }
            
            $rh.logDebug("class %y: dispatching method %y args: %y", $.name(), $mn, $args);
            return $.dispatch($rh, NOTHING, $mn, $args, $cx);
        }

        #! this method is called to dispatch requests on the given object
        private hash dispatch(RestHandler $rh, *string $oname, string $mn, *hash $ah, hash $cx) {
            try {
                return callObjectMethodArgs($self, $mn, ($cx, $ah));
            }
            catch (hash $ex) {
                if ($ex.err == "METHOD-DOES-NOT-EXIST") {
                    $rh.logDebug("DISPATCH-ERROR: cannot dispatch to unimplemented method %y: class %y, args: %y", $mn, $.name(), $ah);
                    # see if alternate methods would work
                    my list $hl = ();
                    foreach my hash $mh in (RestHandler::Methods.pairIterator()) {
                        my string $nmn = $mh.value + $cx.rest_method;
                        if ($self.hasCallableMethod($nmn))
                            $hl += $mh.key;
                    }
                    if (!$hl)
                        return RestHandler::make501("REST class %y (%s) does not implement method %y", $.name(), $self.className(), $cx.orig_method);
 
                    my string $ml = foldl $1 + "," + $2, $hl;
                    my string $desc = sprintf("HTTP method %s is unimplemented in REST class %y (%s)", $cx.hdr.method, $.name(), $self.className());
                    if ($cx.orig_method)
                        $desc += sprintf(" REST method %y", $cx.orig_method);
                    $desc += sprintf(", available methods: %s", $ml);
                    return AbstractHttpRequestHandler::makeResponse(("Allow": $ml), 405, $desc);
                }
                $rh.logDebug("class %y: method %y: %s: %s: %s", $.name(), $mn, get_ex_pos($ex), $ex.err, $ex.desc);
                rethrow;
            }
        }

        #! throws a \c "REST-CLASS-ERROR" exception when a request tries to access an unknown subclass
        private hash unknownSubClassError(string $name) {
            throw "REST-CLASS-ERROR", sprintf("class %y has no subclass %y", $.name(), $name);
        }
    }

    #! this is the main handler class to be registered with the HttpServer
    public class RestHandler inherits AbstractHttpRequestHandler, AbstractRestClass {
        public {
            #! a hash for a 501 Unimplemented error message
            const Err501 = (
                "code": 501,
                "body": "not implemented",
                );

            #! supported HTTP methods
            const Methods = (
                "GET": "get",
                "POST": "post",
                "PUT": "put",
                "DELETE": "del",
                );

            #! supported mime types for de/serializing responses
            const MimeDataTypes = (
%ifndef NoJson
                MimeTypeJsonRpc: (
                    "serialize": \makeJSONString(),
                    "deserialize": \parseJSON(),
                ),
%endif
%ifndef NoYaml
                MimeTypeYaml: (
                    "serialize": \makeYAML(),
                    "deserialize": \parseYAML(),
                ),

                MimeTypeYamlRpc: (
                    "serialize": \makeYAML(),
                    "deserialize": \parseYAML(),
                ),
%endif
%ifndef NoXml
                MimeTypeXml: (
                    "serialize": \makeXMLRPCValueString(),
                    "deserialize": \parseXMLRPCValue(),
                ),
%endif
                MimeTypeHtml: (
                    "serialize": string sub (any $body) { return sprintf("<pre>%N</pre>", $body); },
                ),
                );
        }
        
        private {
            #! class hash: name -> AbstractRestClass
            hash $.ch;

            #! mutex lock
            Mutex $.mx();
        }

        #! create the object optionally with the given AbstractAuthenticator
        /** @param auth the authentication object to use to authenticate connections (see AbstractAuthenticator); if no AbstractAuthenticator object is passed, then by default no authentication will be required
         */
        constructor(*AbstractAuthenticator $auth) : AbstractHttpRequestHandler($auth) {
        }

        #! returns the name of the root REST class
        string name() {
            return "/";
        }

        #! called by the HTTP server to handle incoming HTTP requests
        /** Requests will be dispatched to REST classes registered with this object

            @param cx call context hash; this hash will have the following keys:
            - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
            - \c socket-info: a hash of socket information for the listening socket (as returned by Qore::Socket::getSocketInfo())
            - \c peer-info: a hash of socket information for the remote socket (as returned by Qore::Socket::getPeerInfo())
            - \c url: a hash of broken-down URL information (as returned from parseURL())
            - \c id: the unique HTTP connection ID
            - \c listener-id: the HTTP server listener ID (see HttpServer::getListenerInfo())
            - \c user: the current RBAC username (if any)
            @param hdr incoming header hash; all keys will be converted to lower-case, additionally the following keys will be present:
            - \c method: the HTTP method received (ie \c "GET", \c "POST", etc)
            - \c path: the HTTP path given in the request, after processing by decode_url() (Qore function)
            - \c http_version: the HTTP version number in the request (either \c "1.0" or \c "1.1")
            @param b message body, if any

            @return a hash with the following keys:
            - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
            - \c "body": the message body to return in the response
            - \c "close": (optional) set this key to @ref Qore::True "True" if the connection should be unconditionally closed when the handler returns
            - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response
         */
        hash handleRequest(hash $cx, hash $hdr, *data $b) {
            #$.logDebug("cx: %N", $cx);
            #$.logDebug("hdr: %N", $hdr);
            if ($b)
                $.logDebug("body: %s", $b.typeCode() == NT_STRING ? trim($b) : sprintf("%y", $b));

            my any $body = $b;
            
            # get rest class name
            my *string $path = $cx.url.path;

            $.removeRootPath(\$path);

            # get object and args
            my hash $ah = $path ? parse_uri_query($path) : hash();

            my *hash $args;
            if (exists $ah.params[0]) {
                if ($ah.params[0].typeCode() != NT_HASH)
                    return RestHandler::make400("cannot parse arguments in REST call %y, the first argument must be a hash with an 'action' key; got type %y instead", $path, $ah.params[0].type());
                if ($ah.params.size() > 1)
                    return RestHandler::make400("invalid arguments in REST call %y, only a single hash argument is accepted; got %y instead", $path, $ah.params);
                $args = $ah.params[0];
            }

            # deserialize body according to Content-Type
            if ($body) {
                my *code $ds = MimeDataTypes.($hdr."content-type").deserialize;
                if (!$ds) {
                    $.requestDeserializationError($hdr, $cx, $body);
                    return RestHandler::make501("cannot deserialize request body; content-type is: %y; types supported: %y; discarding request body: %y", $hdr."content-type", MimeDataTypes.keys(), $body);
                }

                $body = $ds($body);
            }
            else
                $body = $args;

            # reflect body in arguments if body is a hash and there are no args
            if (!$args && $body && $body.typeCode() == NT_HASH)
                $args = $body;

            # make method name
            my string $mn;
            if ($args.action) {
                if ($args.action.typeCode() != NT_STRING)
                    return RestHandler::make400("cannot parse arguments in REST call %y, the 'action' key is not assigned to a string; got %y instead", $path, $args.action.type());
                $mn = $args.action;
                $args -= "action";
                # ensure first letter of the action is in upper case
                $cx.orig_method = $mn;
                splice $mn, 0, 1, $mn[0].upr();
                $cx.rest_method = $mn;
                $mn = Methods.($hdr.method) + $mn;
            }
            else if ($body.action) {
                if ($body.action.typeCode() != NT_STRING)
                    return RestHandler::make400("cannot parse arguments in REST call %y, the 'action' key is not assigned to a string; got %y instead", $path, $args.action.type());
                $mn = $body.action;
                $cx.orig_method = $mn;
                # ensure first letter of the action is in upper case
                splice $mn, 0, 1, $mn[0].upr();
                $cx.rest_method = $mn;
                $mn = Methods.($hdr.method) + $mn;
            }
            else
                $mn = Methods.($hdr.method);

            # remove leading slash from method name
            if ($ah.method =~ /^\//)
                splice $ah.method, 0, 1;
            
            # get class chain
            my *list $cl = $ah.method ? $ah.method.split("/") : NOTHING;

            # get initial class
            my *string $cls = shift $cl;

            # make a hash of "accept" values
            my *string $astr = $hdr.accept;
            my hash $aih;
            if ($astr) {
                $astr =~ s/;.*//;#/;
                $astr =~ s/ +//g;
                map $aih.$1 = True, $astr.split(",");
            }
            else {
                # http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html: If no Accept header field is present, then it is assumed that the client accepts all media types
                $aih."*/*" = True;
            }

            #$.logDebug("aih: %y", $aih);

            # set up context hash
            $cx += ("hdr": $hdr, "body": $body, "aih": $aih);

            my AbstractRestClass $rcls;

            if (!$cls)
                $rcls = $self;
            else {
                if (!$.ch{$cls}) {
                    my *AbstractRestClass $c = $.subClass($cls, $cx, $args);
                    if (!$c)
                        return RestHandler::make400("unknown REST class %y in path %y (valid classes: %y)", $cls, $cx.url.path, $.ch.keys());
                    $rcls = $c;
                }
                else
                    $rcls = $.ch{$cls};
            }

            # check method
            if (!Methods.($hdr.method))
                return RestHandler::make501("cannot handle HTTP method %y; valid methods: %y", $hdr.method, Methods.keys());
            
            # handle call with class
            my hash $rv;
            
            try {
                $rv = $rcls.handleRequest($self, $cl, $mn, $cx, $args);
            }
            catch (hash $ex) {
                # if there is an exception, return a 409 Conflict error to the client with the exception information
                $.logDebug("%s: %s: %s", get_ex_pos($ex), $ex.err, $ex.desc);
                $rv = (
                    "code": 409,
                    "body": $ex,
                    );
            }

            # serialize response according to client's capabilities if necessary
            if (!exists $rv.body)
                $rv.body = "OK";

            my bool $encoded;
            if ($rv.already_encoded)
                $encoded = True;

            # process Accept values in the order sent by the sender
            if (!$encoded) {
                my *code $ds;
                foreach my string $a in ($aih.keyIterator()) {
                    $ds = MimeDataTypes.$a.serialize;
                    if ($ds) {
                        $rv.body = $ds($rv.body);
                        $rv.hdr += ("Content-Type": $a);
                        break;
                    }
                }

                # if still not encoded and the client accepts anything, encode with the first possible serialization method
                if (!$ds && $aih."*/*") {
                    foreach my string $k in (MimeDataTypes.keyIterator()) {
                        $ds = MimeDataTypes.$k.serialize;
                        if ($ds) {
                            $rv.body = $ds($rv.body);
                            $rv.hdr += ("Content-Type": $k);
                            break;
                        }
                    }
                    if (!$ds) {
                        $.responseSerializationError($cx, $aih, $rv);
                        # http://www.w3.org/Protocols/rfc2616/rfc2616-sec14.html: If an Accept header field is present, and if the server cannot send a response which is acceptable according to the combined Accept field value, then the server SHOULD send a 406 (not acceptable) response.
                        return RestHandler::makeResponse(406, "cannot serialize response; you claim to accept only: %y; types supported: %y; discarding response: %y", $aih.keys(), MimeDataTypes.keys(), $rv.body);
                    }
                }
            }

            $.logDebug("response serialization: %d %s (%d bytes)", $rv.code, $rv.hdr."Content-Type", $rv.body.size());

            #$.logDebug("rv: %N", $rv);

            return $rv;
        }

        #! default implementation is empty
        removeRootPath(reference $path) {
        }
        
        #! default implementation is empty
        requestDeserializationError(hash $hdr, hash $cx, string $body) {
        }

        #! default implementation is empty
        responseSerializationError(hash $cx, *hash $aih, hash $rv) {
        }

        #! default implementation is empty
        logInfo(string $fmt) {
            delete $argv;
        }

        #! default implementation is empty
        logError(string $fmt) {
            delete $argv;
        }

        #! default implementation is empty
        logDebug(string $fmt) {
            delete $argv;
        }

        #! adds a REST class to the handler
        addClass(AbstractRestClass $cls) {
            $.mx.lock();
            on_exit $.mx.unlock();

            my string $name = $cls.name();
            if ($.ch{$name})
                throw "RETSHANDLER-ERROR", sprintf("class %y has already been registered with this handler", $name);
            $.ch{$name} = $cls;
        }

        #! creates a hash for an HTTP response with the response code and a literal response message body
        static hash makeResponse(int $code, any $body, *hash $hdr) {
            return (
                "code": $code,
                "body": $body,
                "hdr": $hdr,
                );
        }
    }
}
