<?xml version="1.0" encoding="UTF-8" ?>

<chapter id="Introduction">
  <title>Introduction</title>

  <sect1 id="Qore_Introduction">
    <title>Introduction to the Qore Programming Language</title>

    <para>The Qore programming language is a powerful, high-performance, thread-capable, object-oriented, database-integrated weakly-typed language with procedural and object-oriented features designed for anything from quick scripting to complex multithreaded, network-aware application development.  By design, it is particularly suited to the rapid implementation of sophisticated interfaces in an enterprise environment.</para>

    <para>It features extensive database and XML integration into the syntax, functions, data structures, and operators of the language, enabling the development of sophisticated programs using the Qore Programming Language.</para>

    <para>Flexible character set encoding support is also built-in to Qore strings, and automatic character set encoding conversions are supported, enabling correct behavior for interfacing systems with different character set encoding requirements (see <link linkend='Qore_Strings_and_Character_Set_Encoding'>Qore Strings and Character Set Encoding</link>).</para>

    <para>Qore includes the following design points:</para>

    <itemizedlist mark='bullet'>
      <listitem>
	<para>Database Integration and DBI Layer</para>

	<para>Retrieving, comparing, and manipulating data in a consistent manner from heterogenous database types is made possible by Qore's built-in database integration. Qore was designed with a database independent interfacing (DBI) layer, providing a standard interface for Qore programs to access any database supported by a Qore DBI driver (see the <link linkend='Qore::SQL::Datasource_Class'>Datasource Class</link>). Currently <link linkend="oracle_Module">Oracle</link> and <link linkend="mysql_Module">MySQL</link> drivers are available for Qore.</para>

      </listitem>
    </itemizedlist>

    <itemizedlist mark='bullet'>
      <listitem>
	<para>XML and JSON Integration</para>
	
	<para>Qore uses the libxml2 library to provide fast and efficient XML functionality. Qore's XML integration enables serialization from Qore data structures to XML strings and deserialization from XML strings to Qore data structures, making it trivial to work with data in XML format (see <link linkend="XML_Integration">XML Integration</link>).  Qore provides <link linkend="JSON_Functions">JSON</link> and JSON-RPC integration as well.</para>
      </listitem>
    </itemizedlist>

    <itemizedlist mark='bullet'>
      <listitem>
	<para>Thread Safety and SMP Scalability</para>

	<para>All elements of Qore are thread-safe, and the language in general has been designed with SMP scalability in mind.  The internal design and implementation of Qore favors multithreaded performance over single-threaded performance, so multithreaded Qore programs can count on an efficient and stable execution platform, and do not have to limit themselves to a subset of Qore's functionality (see <link linkend='Threading'>Threading</link>).</para>
      </listitem>
    </itemizedlist>


    <itemizedlist mark='bullet'>
      <listitem>
	<para>Function and Class Library</para>
	
	<para>Qore features growing builtin function and class libraries covering areas such as: POSIX-compliant command-line parsing (ex: <link linkend='Qore::GetOpt_Class'>GetOpt Class</link>), XML serialization/deserialization (<link linkend="XML_Functions">XML Functions</link>), <link linkend="Cryptographic_Functions">strong encryption</link> and <link linkend="Digest_Functions">digest calculation</link>, thread synchronization (ex: <link linkend='Qore::Thread::Queue_Class'>Queue Class</link>, <link linkend='Qore::Thread::Mutex_Class'>Mutex Class</link>, <link linkend='Qore::Thread::Condition_Class'>Condition Class</link>, etc), working with files (<link linkend="Qore_File_Class">File class</link>), socket and HTTP communication (<link linkend='Qore_Socket_Class'>Socket Class</link>, <link linkend='HTTPClient_Class'>HTTPClient Class</link>, <link linkend='XmlRpcClient_Class'>XmlRpcClient Class</link>,  <link linkend='JsonRpcClient_Class'>JsonRpcClient Class</link>, including optional TLS/SSL encryption), database communication with transaction management (<link linkend="Qore::SQL::Datasource_Class">Datasource Class</link>), communication with FTP and FTPS servers (<link linkend="Qore_FtpClient_Class">FtpClient Class</link>), support for dynamic embedded application logic (<link linkend="Qore_Program_Class">Program Class</link>), as well as <link linkend="tibrv_Module">TIBCO Rendezvous</link>, <link linkend="tibae_Module">TIBCO Adapters</link>, <link linkend="Tuxedo_Module">Tuxedo</link> integration, and more.</para>
      </listitem>
    </itemizedlist>

    <itemizedlist mark='bullet'>
      <listitem>
	<para>Intuitive Syntax</para>

	<para>The Qore syntax is intuitive, allowing new programmers to rapidly come up to speed in the language and be productive quicker than with comparable languages. The language features some of the best features from C++ (ex: <link linkend="Class_Inheritance">multiple inheritance</link>, <link linkend="Exception_Handling">exception handling</link>), Java (ex: the <link linkend="Private_and_Synchronized_Methods"><command>synchronized</command></link> keyword, the <link linkend="Instanceof_Operator"><command>instanceof</command></link> operator, object implementation), and Perl (ex: the <link linkend="foreach_Statements"><command>foreach</command> statement</link>, <link linkend="Splice_Operator"><command>splice</command></link>, <link linkend="Push_Operator"><command>push</command></link>, <link linkend="Pop_Operator"><command>pop</command></link>, <link linkend="Chomp_Operator"><command>chomp</command></link> operators, etc), and with enhancements unique to Qore.  Due to the simple yet powerful syntax, Qore code is clear, self-documenting, and easy to maintain, even for programs written by others.</para>

	<para>Qore's intelligent <link linkend="Operators">operators</link> are designed to produce the expected results for the programmer even when data types are mixed, a feature meant to further flatten the learning curve for new programmers.</para>
      </listitem>
    </itemizedlist>

    <para>Simple or complex interfaces involving data extraction and manipulation from multiple Oracle and MySQL databases and/or multiple applications connected with a TIBCO bus can be developed quickly and easily with Qore, particularly in comparison with Java, Perl, or C/C++. Furthermore, solutions based on Qore are transparent and easily maintainable, bringing advantages for the developer and end-user alike.</para>

    <para>Additionally, Qore is thoroughly tested with valgrind on Linux and dbx on Solaris for memory leaks and memory errors.  While it is possible that there are bugs in some less tested code paths, every effort is made to eliminate all bugs before each new release, particularly memory bugs and race conditions, in order to ensure that Qore releases are of the highest possible quality.</para>

</sect1>

<sect1 id="Document_Conventions">
<title>Document Conventions</title>

<para>Examples of Qore code are given in the following font:</para>

<programlisting>
#!/usr/bin/qore
#
# this is an example of Qore code
</programlisting>

<para>keywords are given in bold:</para>

<!-- 
<para># "if" is a key word</para>
<para><command>if</command> ($a == 1) print("yes\n");</para>
-->
<programlisting>
# "if" is a key word
<command>if</command> ($a == 1) print("yes\n");
</programlisting>

<para>placeholders are given in italics:</para>

<!-- 
<para><command>if</command> ( <replaceable>expression</replaceable> ) 
<replaceable>statement</replaceable></para>
-->
<programlisting>
<command>if</command> ( <replaceable>expression</replaceable> ) 
    <replaceable>statement</replaceable>
</programlisting>

<para>where expressions and statements are 
defined in this document. The text above indicates that any valid expression and 
any valid statement may be used in the positions indicated.</para>

<para>Optional text is given in square brackets "[" and "]" as follows:</para>

<para><code><command>sub</command> name([<replaceable>$variable1</replaceable>,<replaceable> $variable2</replaceable>, ...])</code></para>

<para>indicating that an arbitrarily long 
list of variable names separated by commas (or nothing at all) may appear in 
subroutine (function) declarations.</para>

</sect1>

</chapter>

