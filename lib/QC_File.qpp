/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  QC_File.qpp

  Qore Programming Language

  Copyright 2003 - 2011 David Nichols

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.
  
  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <qore/Qore.h>
#include <qore/intern/QC_File.h>
#include <qore/intern/QC_Queue.h>
#ifdef HAVE_TERMIOS_H
#include <qore/intern/QC_TermIOS.h>
#endif

#ifndef TCSANOW
#define Q_TCSANOW 0
#else
#define Q_TCSANOW TCSANOW
#endif

static int check_terminal_io(QoreObject *self, const char *m, ExceptionSink *xsink) {
   // check for no-terminal-io at runtime with system objecs
   if (self->isSystemObject() && (getProgram()->getParseOptions64() & PO_NO_TERMINAL_IO)) {
      xsink->raiseException("ILLEGAL-EXPRESSION", "File::%s() cannot be called with a system constant object when 'no-terminal-io' is set", m);
      return -1;
   }
   return 0;
}

static void FILE_system_constructor(QoreObject *self, int fd, va_list args) {
   //printd(5, "FILE_system_constructor() self=%08p, descriptor=%d\n", self, fd);
   File *f = new File(QCS_DEFAULT);
   f->makeSpecial(fd);
   self->setPrivate(CID_FILE, f);
}

#ifdef HAVE_STRUCT_FLOCK
static int lock_intern(struct flock &fl, const QoreListNode *args, ExceptionSink *xsink) {
   fl.l_type = (short)HARD_QORE_INT(args, 0);
   fl.l_start = (off_t)HARD_QORE_INT(args, 1);
   fl.l_len = (off_t)HARD_QORE_INT(args, 2);
   if (fl.l_len < 0) {
      xsink->raiseException("FILE-LOCK-ERROR", "length of locked area cannot be negative (value passed=%d)", fl.l_len);
      return -1;
   }
   fl.l_whence = (short)HARD_QORE_INT(args, 3);
   return 0;
}
#else
static int file_lock_error(const char *f, ExceptionSink *xsink) {
   xsink->raiseException("MISSING-FEATURE-ERROR", "this platform does not support UNIX-style file locking with fnctl(), therefore the File::%s() method is not available; for maximum portability, check Option::HAVE_FILE_LOCKING before calling this method", f);
   return 0;
}
#ifndef F_RDLCK
#define F_RDLCK -1
#endif
#endif

AbstractQoreNode *missing_method_error(const char *meth, const char *feat, ExceptionSink *xsink) {
   xsink->raiseException("MISSING-FEATURE-ERROR", "the %s() method is not available on this build; for maximum portability, check Option::HAVE_%s before calling this method", meth, feat);
   return 0;
}

/** @defgroup file_open_constants File Open Constants
    These are the possible values that can be or'ed together when calling File::open() or File::open2()
*/
//@{ 
//! Mask for access modes (O_RDONLY|O_WRONLY|O_RDWR)
const O_ACCMODE = O_ACCMODE;
//! Open the file in append mode (append on each write)
const O_APPEND = O_APPEND;
//! Create the file if it doesn't exist
const O_CREAT = O_CREAT;
//! Open the file read-only
const O_RDONLY = O_RDONLY;
//! Open the file write-only
const O_WRONLY = O_WRONLY;
//! Open for reading and writing
const O_RDWR = O_RDWR;
//! Truncate the size to zero
const O_TRUNC = O_TRUNC;
//! Raise an error if used with O_CREAT and the file exists
const O_EXCL = O_EXCL;

// the following constants were defined earlier but are system-specific; they are included in the build
// in case anyone is using them on the platforms where they are supported
#ifdef O_NOCTTY
const O_NOCTTY = O_NOCTTY;
#endif
#ifdef O_NONBLOCK
const O_NONBLOCK = O_NONBLOCK;
#endif
#ifdef O_NDELAY
const O_NDELAY = O_NDELAY;
#endif
#ifdef O_SYNC
const O_SYNC = O_SYNC;
#endif
#ifdef O_DIRECT
const O_DIRECT = O_DIRECT;
#endif
#ifdef O_LARGEFILE
const O_LARGEFILE = O_LARGEFILE;
#endif
#ifdef O_DIRECTORY
const O_DIRECTORY = O_DIRECTORY;
#endif
#ifdef O_NOFOLLOW
const O_NOFOLLOW = O_NOFOLLOW;
#endif
#ifdef O_ATOMICLOOKUP
const O_ATOMICLOOKUP = O_ATOMICLOOKUP;
#endif
//@}

/** @defgroup file_stat_constants File Stat Constants
    These are values that can be and'ed with the \c "mode" element of a file's status as returned by File::hstat(), hstat(), etc, or with element 2 of the status list as returned from File::stat(), stat(), etc.
*/
//@{ 
//! File type bitmask
const S_IFMT = S_IFMT;

//! Bit signifying if the file is a character special (device) file
const S_IFCHR = S_IFCHR;

//! Bit signifying if the entry is a directory
const S_IFDIR = S_IFDIR;

//! Bitmask signifying if the file is a block special (device) file
const S_IFBLK = S_IFBLK;

//! Bit signifying if the file is a regular file
const S_IFREG = S_IFREG;

#ifndef S_IFLNK
#define S_IFLNK 0
#endif

//! Bitmask signifying if the file is a symbolic link; equal to 0 on native Windows ports
const S_IFLNK = S_IFLNK;

#ifndef S_IFSOCK
#define S_IFSOCK 0
#endif

//! Bitmask signifying if the file is a socket file; equal to 0 on native Windows ports
const S_IFSOCK = S_IFSOCK;

#ifndef S_IFWHT
#define S_IFWHT S_IFREG
#endif

//! Bitmask signifying if the file is a whiteout file; equal to 0 on native Windows ports
const S_IFWHT = S_IFWHT;

//! Bitmask giving the RWX mask for the owner
const S_IRWXU = S_IRWXU;

//! Bit signifying if the file's owner has read permissions
const S_IRUSR = S_IRUSR;

//! Bit signifying if the file's owner has write permissions
const S_IWUSR = S_IWUSR;

//! Bit signifying if the file's owner has execute permissions
const S_IXUSR = S_IXUSR;

#ifndef S_IRWXG
#define S_IRWXG 0;
#endif

//! Bitmask giving the RWX mask for the group; equal to 0 on native Windows ports
const S_IRWXG = S_IRWXG;

#ifndef S_IRGRP
#define S_IRGRP 0;
#endif

//! Bit signifying if the file's group has read permissions; equal to 0 on native Windows ports
const S_IRGRP = S_IRGRP;

#ifndef S_IWGRP
#define S_IWGRP 0;
#endif

//! Bit signifying if the file's group has write permissions; equal to 0 on native Windows ports
const S_IWGRP = S_IWGRP;

#ifndef S_IXGRP
#define S_IXGRP 0;
#endif

//! Bit signifying if the file's group has execute permissions; equal to 0 on native Windows ports
const S_IXGRP = S_IXGRP;

#ifndef S_IRWXO
#define S_IRWXO 0;
#endif

//! Bitmask giving the RWX mask for other; equal to 0 on native Windows ports
const S_IRWXO = S_IRWXO;

#ifndef S_IROTH
#define S_IROTH 0;
#endif

//! Bit signifying if other has read permissions; equal to 0 on native Windows ports
const S_IROTH = S_IROTH;

#ifndef S_IWOTH
#define S_IWOTH 0;
#endif

//! Bit signifying if other has write permissions; equal to 0 on native Windows ports
const S_IWOTH = S_IWOTH;

#ifndef S_IXOTH
#define S_IXOTH 0;
#endif

//! Bit signifying if other has execute permissions; equal to 0 on native Windows ports
const S_IXOTH = S_IXOTH;

#ifndef S_ISUID
#define S_ISUID 0
#endif

//! Bit signifying set user id on execution; equal to 0 on native Windows ports
const S_ISUID = S_ISUID;

#ifndef S_ISGID
#define S_ISGID 0
#endif

//! Bit signifying set group id on execution; equal to 0 on native Windows ports
const S_ISGID = S_ISGID;

#ifndef S_ISVTX
#define S_ISVTX 0
#endif

//! Bit signifying restricted deletes for directories; equal to 0 on native Windows ports
const S_ISVTX = S_ISVTX;
//@}

/** @defgroup file_locking_constants File Locking Constants
    These are the possible values for the File::lock() or File::lockBlocking() methods.

    @note These contants are set to 0 on platforms where HAVE_FILE_LOCKING is \c False (such as native Windows ports)
*/
//@{ 
#ifndef HAVE_STRUCT_FLOCK
#define F_RDLCK 0
#define F_WRLCK 0
#define F_UNLCK 0
#endif

//! Use for read-only locking
const F_RDLCK = F_RDLCK;
//! Use for exclusive write locking
const F_WRLCK = F_WRLCK;
//! Use for unlocking a lock
const F_UNLCK = F_UNLCK;
//@}

/** @defgroup file_seek_constants File Seek Constants
    These are the possible values for the \c whence parameter of the File::lock() and File::lockBlocking() methods
 */
//@{
//! Indicates that the offset is from the start of the file
const SEEK_SET = SEEK_SET;
//! Indicates that the offset is from the current position in the file
const SEEK_CUR = SEEK_CUR;
//! Indicates that the offset is from the end of the file
const SEEK_END = SEEK_END;
//@}

//! The File class allows %Qore programs to read, write, and create files
/** @note This class is not available with the @ref PO_NO_FILESYSTEM parse option

    File objects are created and/or opened with a specific character encoding, meaning that any string read from the file will be tagged with the file's character encoding, and any string data written to the file will be transparently converted to that character encoding before being written (if necessary). If no character encoding is specified, then the default %Qore @ref character_encoding "character encoding" is assumed for the file.

    This class supports posting events to a @ref Qore::Thread::Queue "Queue". See @ref event_handling for more information.

    The events raised by this object are listed in the following table:

    @anchor file_events
    <b>File Events</b>
    |!Name|!Description
    |@ref EVENT_DATA_READ|Raised when data is read from the file
    |@ref EVENT_DATA_WRITTEN|Raised when data is written to the file
    |@ref EVENT_CHANNEL_CLOSED|Raised when the file is closed
    |@ref EVENT_DELETED|Raised when the object being monitored is deleted
    |@ref EVENT_OPEN_FILE|Raised right before an attempt to open a file is made
    |@ref EVENT_FILE_OPENED|Raised when the file has been successfully opened
 */
qclass File [system_constructor=FILE_system_constructor; arg=File* f; dom=FILESYSTEM];

//! Creates the File object
/** It accepts one optional argument that will set the default character encoding for the file (only affects reading and writing string data).  To open the file, call File::open() or File::open2().

    @par Example
    @code
my File $f();
$f.open2("/tmp/my-file.txt");
@endcode

    @param encoding The character encoding for the file. Any strings written to the file will be converted to this character encoding if necessary; if this argument is not given then the file will receive the default encoding

    @see File::open(), File::open2()
 */
File::constructor(*string encoding) {
   const QoreEncoding *qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   self->setPrivate(CID_FILE, new File(qe));
}

//! Closes the file if it is open and destroys the file object
/** Closes the file if it is open and destroys the file object
 */
File::destructor() [doconly=true] {
   // this code should never be output - this function is only here for documentation
   assert(false);
}

//! Creates a new file object with the same character encoding specification as the original, otherwise no other information is copied
/** @par Example
    @code my File $f1 = $f.copy(); @endcode
 */
File::copy() {
   self->setPrivate(CID_FILE, new File(f->getEncoding()));
}

//! Opens a file in a particular mode, returns an error code on failure
/** Opens the file in the mode given; if the file was previously open, it is closed first. Aditionally, the file permissions can be given if the file is to be created, and optionally the file's default character encoding can be specified.

    Note that if no encoding is specified, the file will be tagged with the default character encoding for the process. Any string data written to the file will be converted to the file's encoding, and any string data read from the file will be automatically tagged with the file's encoding.

    @par Example
    @code
# open a file for writing, truncate data if already exists, create the file if doesn't exist
# set 0644 permissions, and convert all string data to ISO-8859-1 encoding
if ($f.open($fn, O_CREAT | O_TRUNC | O_WRONLY, 0644, "ISO-8859-1"))
    printf("%s: %s\n", $fn, strerror(errno()));
    @endcode

    @par Events
    @ref EVENT_OPEN_FILE, @ref EVENT_FILE_OPENED

    @param path the path to the file
    @param flags flags that determine the way the file is accessed, see @ref file_open_constants for more information; if this argument is not given, \c O_RDONLY will be used as the default value.
    @param mode permission bits for when the file is to be created (default: 0666)
    @param encoding the name of the default character encoding for this file; if this argument is not given, the file will be tagged with the @ref default_encoding "default character encoding" of the process

    @return 0 = no error, -1 = see errno() and strerror() for the error message

    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @see File::open2() for a version of this method that throws an exception when errors occur opening the file
 */
int File::open(string path, softint flags = O_RDONLY, softint mode = 0666, *string encoding) {
   if (check_terminal_io(self, "open", xsink))
      return 0;

   const QoreEncoding *qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   return f->open(path->getBuffer(), flags, mode, qe);
}

//! Opens a file in a particular mode; throws an exception on failure
/** Opens the file in the mode given; if the file was previously open, it is closed first. Aditionally, the file permissions can be given if the file is to be created, and optionally the file's default character encoding can be specified.

    Note that if no encoding is specified, the file will be tagged with the default character encoding for the process. Any string data written to the file will be converted to the file's encoding, and any string data read from the file will be automatically tagged with the file's encoding.

    If an error occurs, a \c FILE-OPEN2-ERROR exception is thrown. For a version of this method that returns an error code, see File::open().

    @par Example
    @code
# open a file for writing, truncate data if already exists, create the file if doesn't exist
# set 0644 permissions, and convert all string data to ISO-8859-1 encoding
try {
    $f.open2($fn, O_CREAT | O_TRUNC | O_WRONLY, 0644, "ISO-8859-1");
}
catch (hash $ex) {
    printf("%s: %s: %s\n", $fn, $ex.err, $ex.desc);
}
@endcode

    @par Events
    @ref EVENT_OPEN_FILE, @ref EVENT_FILE_OPENED

    @param path the path to the file
    @param flags flags that determine the way the file is accessed, see @ref file_open_constants for more information; if this argument is not given, \c O_RDONLY will be used as the default value.
    @param mode permission bits for when the file is to be created (default: 0666)
    @param encoding the name of the default character encoding for this file; if this argument is not given, the file will be tagged with the default character encoding for the process

    @return 0 = no error, -1 = see errno() and strerror() for the error message

    @throw FILE-OPEN2-ERROR an error occured opening the file
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @see File::open2() for a version of this method that throws an exception when errors occur opening the file
 */
nothing File::open2(string path, softint flags = O_RDONLY, softint mode = 0666, *string encoding) {
   if (check_terminal_io(self, "open2", xsink))
      return 0;

   const QoreEncoding *qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   f->open2(xsink, path->getBuffer(), flags, mode, qe);
}

//! Closes the file object
/** @par Example
    @code
 if ($f.close())
    printf("error closing file: %s\n", strerror(errno()));
@endcode

    @par Events
    @ref EVENT_CHANNEL_CLOSED

    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @return 0 for success, -1 for an error (see errno() and strerror() for the error information)
 */
int File::close() {
   if (check_terminal_io(self, "close", xsink))
      return 0;

   return f->close();
}

//! Flushes the file's buffer to disk
/** @par Example
    @code
if ($f.sync())
    printf("error in File::sync(): %s\n", strerror(errno()));
@endcode

    @return 0 for success, -1 for error (see errno() and strerror() for the error information)

    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
int File::sync() {
   if (check_terminal_io(self, "sync", xsink))
      return 0;

   return f->sync();
}

//! Reads a certain number of bytes from the file within an optional timeout period and returns a string of the data read or NOTHING if no data can be read
/** Reads a certain amount of string data from the file; the size argument is required. To read binary data, use the File::readBinary() method.

    Note that the amount of data read from the file may be less than the size given, for example if the file does not contain enough data to fulfill the request. In this case, only the data available in the file is returned.

    An optional timeout period in milliseconds can be passed as well (or a @ref relative_dates "relative date/time value" may be passed instead of an integer to make the timeout units clear; ex: 25ms). If a timeout value is passed and the data cannot be read within the timeout period, then a \c FILE-READ-TIMEOUT exception is thrown. If no timeout value is passed or a negative value is given, then the call will never timeout until either the requested amount of data has been read from the file or an end-of-file condition has been reached.

    @par Example
    @code my *string $data = $f.read(-1); # read an entire text file into a variable @endcode

    @par Events
    @ref EVENT_DATA_READ

    @param size the number of bytes to read of the file, -1 will read the entire file
    @param timeout_ms a timeout period with a resolution of milliseconds (a @ref relative_dates "relative date/time value"; integer arguments will be assumed to be milliseconds); if not given or negative the call will never time out and will only return when the data has been read

    @return the data read from the file, returned as a string tagged with the File's character encoding.  \c NOTHING is returned if end-of-file is encountered, however, if data has been read before EOF, the data read will be returned and \c NOTHING (signifying EOF) will be returned on the next call to this method.

    @throw FILE-READ-PARAMETER-ERROR zero size argument passed
    @throw FILE-READ-ERROR file is not open; timeout limit exceeded
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @see File::readBinary()
 */
*string File::read(softint size, timeout timeout_ms = -1) {
   if (check_terminal_io(self, "read", xsink))
      return 0;

   if (!size) {
      xsink->raiseException("FILE-READ-PARAMETER-ERROR", "expecting non-zero size as first parameter of File::read()");
      return 0;
   }

   return f->read((qore_offset_t)size, timeout_ms, xsink);
}

//! Reads a 1-byte unsigned integer from the file in binary format or NOTHING if no data can be read 
/** @par Example
    @code my *int $i = $f.readu1(); @endcode

    @par Events
    @ref EVENT_DATA_READ

    @return a 1-byte unsigned integer as read from the file in binary format or NOTHING if no data can be read

    @throw FILE-READ-ERROR file is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
*int File::readu1() {
   if (check_terminal_io(self, "readu1", xsink))
      return 0;

   unsigned char c;
   if (f->readu1(&c, xsink))
      return 0;
   return new QoreBigIntNode(c);
}

//! Reads a 2-byte (16 bit) unsigned integer from the file in binary big-endian format or NOTHING if no data can be read
/** @par Example
    @code my *int $i = $f.readu2(); @endcode

    @par Events
    @ref EVENT_DATA_READ

    @return a 2-byte unsigned integer as read from the file in binary big-endian format or NOTHING if no data can be read

    @throw FILE-READ-ERROR file is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
*int File::readu2() {
   if (check_terminal_io(self, "readu2", xsink))
      return 0;

   unsigned short s;
   if (f->readu2(&s, xsink))
      return 0;
   return new QoreBigIntNode(s);
}

//! Reads a 4-byte (32 bit) unsigned integer from the file in big-endian format or NOTHING if no data can be read
/** @par Example
    @code my *int $i = $f.readu4(); @endcode

    @par Events
    @ref EVENT_DATA_READ

    @return a 4-byte unsigned integer as read from the file in binary big-endian format or NOTHING if no data can be read

    @throw FILE-READ-ERROR file is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
*int File::readu4() {
   if (check_terminal_io(self, "readu4", xsink))
      return 0;

   unsigned int i;
   if (f->readu4(&i, xsink))
      return 0;
   return new QoreBigIntNode(i);
}

//! Reads a 2-byte (16 bit) unsigned integer from the file in binary little-endian format or NOTHING if no data can be read
/** @par Example
    @code my *int $i = $f.readu2LSB(); @endcode

    @par Events
    @ref EVENT_DATA_READ

    @return a 2-byte unsigned integer as read from the file in binary little-endian format or NOTHING if no data can be read

    @throw FILE-READ-ERROR file is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
*int File::readu2LSB() {
   if (check_terminal_io(self, "readu2LSB", xsink))
      return 0;

   unsigned short s;
   if (f->readu2LSB(&s, xsink))
      return 0;
   
   return new QoreBigIntNode(s);
}

//! Reads a 4-byte (32 bit) unsigned integer from the file in binary little-endian format or NOTHING if no data can be read
/** @par Example
    @code my *int $i = $f.readu4LSB(); @endcode

    @par Events
    @ref EVENT_DATA_READ

    @return a 4-byte unsigned integer as read from the file in binary little-endian format or NOTHING if no data can be read

    @throw FILE-READ-ERROR file is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
*int File::readu4LSB() {
   if (check_terminal_io(self, "readu4LSB", xsink))
      return 0;

   unsigned int i;
   if (f->readu4LSB(&i, xsink))
      return 0;
   
   return new QoreBigIntNode(i);
}

//! Reads a 1-byte signed integer from the file in binary format or NOTHING if no data can be read 
/** @par Example
    @code my *int $i = $f.readi1(); @endcode

    @par Events
    @ref EVENT_DATA_READ

    @return a 1-byte signed integer as read from the file in binary format or NOTHING if no data can be read

    @throw FILE-READ-ERROR file is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
*int File::readi1() {
   if (check_terminal_io(self, "readi1", xsink))
      return 0;

   char c;
   if (f->readi1(&c, xsink))
      return 0;
   return new QoreBigIntNode(c);
}

//! Reads a 2-byte (16 bit) signed integer from the file in binary big-endian format or NOTHING if no data can be read
/** @par Example
    @code my *int $i = $f.readi2(); @endcode

    @par Events
    @ref EVENT_DATA_READ

    @return a 2-byte signed integer as read from the file in binary big-endian format or NOTHING if no data can be read

    @throw FILE-READ-ERROR file is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
*int File::readi2() {
   if (check_terminal_io(self, "readi2", xsink))
      return 0;

   short s;
   if (f->readi2(&s, xsink))
      return 0;
   return new QoreBigIntNode(s);
}

//! Reads a 4-byte (32 bit) signed integer from the file in binary big-endian format or NOTHING if no data can be read
/** @par Example
    @code my *int $i = $f.readi4(); @endcode

    @par Events
    @ref EVENT_DATA_READ

    @return a 4-byte signed integer as read from the file in binary big-endian format or NOTHING if no data can be read

    @throw FILE-READ-ERROR file is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
*int File::readi4() {
   if (check_terminal_io(self, "readi4", xsink))
      return 0;

   int i;
   if (f->readi4(&i, xsink))
      return 0;
   return new QoreBigIntNode(i);
}

//! Reads an 8-byte (64 bit) signed integer from the file in binary big-endian format or NOTHING if no data can be read
/** @par Example
    @code my *int $i = $f.readi8(); @endcode

    @par Events
    @ref EVENT_DATA_READ

    @return a 8-byte signed integer as read from the file in binary big-endian format or NOTHING if no data can be read

    @throw FILE-READ-ERROR file is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
*int File::readi8() {
   if (check_terminal_io(self, "readi8", xsink))
      return 0;

   int64 i;
   if (f->readi8(&i, xsink))
      return 0;
   
   return new QoreBigIntNode(i);
}

//! Reads a 2-byte (16 bit) signed integer from the file in binary little-endian format or NOTHING if no data can be read
/** @par Example
    @code my *int $i = $f.readi2LSB(); @endcode

    @par Events
    @ref EVENT_DATA_READ

    @return a 2-byte signed integer as read from the file in binary little-endian format or NOTHING if no data can be read

    @throw FILE-READ-ERROR file is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
*int File::readi2LSB() {
   if (check_terminal_io(self, "readi2LSB", xsink))
      return 0;

   short s;
   if (f->readi2LSB(&s, xsink))
      return 0;

   return new QoreBigIntNode(s);
}

//! Reads a 4-byte (32 bit) signed integer from the file in binary little-endian format or NOTHING if no data can be read
/** @par Example
    @code my *int $i = $f.readi4LSB(); @endcode

    @par Events
    @ref EVENT_DATA_READ

    @return a 4-byte signed integer as read from the file in binary little-endian format or NOTHING if no data can be read

    @throw FILE-READ-ERROR file is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
*int File::readi4LSB() {
   if (check_terminal_io(self, "readi4LSB", xsink))
      return 0;

   int i;
   if (f->readi4LSB(&i, xsink))
      return 0;
   return new QoreBigIntNode(i);
}

//! Reads an 8-byte (64 bit) signed integer from the file in binary little-endian format or NOTHING if no data can be read
/** @par Example
    @code my *int $i = $f.readi8LSB(); @endcode

    @par Events
    @ref EVENT_DATA_READ

    @return an 8-byte signed integer as read from the file in binary little-endian format or NOTHING if no data can be read

    @throw FILE-READ-ERROR file is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
*int File::readi8LSB() {
   if (check_terminal_io(self, "readi8LSB", xsink))
      return 0;

   int64 i;
   if (f->readi8LSB(&i, xsink))
      return 0;   
   return new QoreBigIntNode(i);
}

//! Reads a certain number of bytes from the file within an optional timeout period and returns a binary object of the data read or NOTHING if no data can be read
/** Reads a certain amount of string data from the file; the size argument is required. To read string data, use the File::read() method.

    Note that the amount of data read from the file may be less than the size given, for example if the file does not contain enough data to fulfill the request. In this case, only the data available in the file is returned.

    An optional timeout period in milliseconds can be passed as well (or a @ref relative_dates "relative date/time value" may be passed instead of an integer to make the timeout units clear; ex: 25ms). If a timeout value is passed and the data cannot be read within the timeout period, then a \c FILE-READ-TIMEOUT exception is thrown. If no timeout value is passed or a negative value is given, then the call will never timeout until either the requested amount of data has been read from the file or an end-of-file condition has been reached.

    @par Events
    @ref EVENT_DATA_READ

    @par Example
    @code my *binary $data = $f.readBinary(-1); # read an entire file into a variable @endcode

    @param size the number of bytes to read of the file, -1 will read the entire file
    @param timeout_ms a timeout period with a resolution of milliseconds (a @ref relative_dates "relative date/time value"; integer arguments will be assumed to be milliseconds); if not given or negative the call will never time out and will only return when the data has been read

    @return the data read from the file, returned as a binary object.  \c NOTHING is returned if end-of-file is encountered, however, if data has been read before EOF, the data read will be returned and \c NOTHING (signifying EOF) will be returned on the next call to this method.

    @throw FILE-READ-BINARY-PARAMETER-ERROR zero size argument passed
    @throw FILE-READ-ERROR file is not open; timeout limit exceeded
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @see File::read()
 */
*binary File::readBinary(softint size, timeout timeout_ms = -1) {
   if (check_terminal_io(self, "readBinary", xsink))
      return 0;

   if (!size) {
      xsink->raiseException("FILE-READ-BINARY-PARAMETER-ERROR", "expecting size as first parameter of File::readBinary()");
      return 0;
   }

   return f->readBinary((qore_offset_t)size, timeout_ms, xsink);
}

//! Writes binary data to a file
/** @par Example
    @code
if ($f.write($data))
    printf("File::write() error: %s\n", strerror(errno()));
@endcode

    @par Events
    @ref EVENT_DATA_WRITTEN

    @param data the data to be written to the file

    @return the number of bytes written or -1 for error; if -1 is returned, the error can be checked with the errno() function

    @throw FILE-WRITE-ERROR File is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
int File::write(binary data) {
   if (check_terminal_io(self, "write", xsink))
      return 0;

   return f->write(data, xsink);
}

//! Writes string data to a file; string data is converted to the File's character encoding if necessary before writing
/** @par Example
    @code
if ($f.write($data))
    printf("File::write() error: %s\n", strerror(errno()));
@endcode

    @par Events
    @ref EVENT_DATA_WRITTEN

    @param data the data to be written to the file; string data is converted to the File's character encoding if necessary before writing

    @return the number of bytes written or -1 for error; if -1 is returned, the error can be checked with the errno() function

    @throw FILE-WRITE-ERROR File is not open
    @throw ENCODING-CONVERSION-ERROR error converting from the string's encoding to the File's encoding
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @note this variant of this method is equivalent to File::print()
 */
int File::write(string data) {
   if (check_terminal_io(self, "write", xsink))
      return 0;

   return f->write(data, xsink);
}

//! Writes string data to a file; string data is converted to the File's character encoding if necessary before writing
/** @par Example
    @code
if ($f.print($data))
    printf("File::print() error: %s\n", strerror(errno()));
@endcode

    @par Events
    @ref EVENT_DATA_WRITTEN

    @param data the data to be written to the file; string data is converted to the File's character encoding if necessary before writing

    @return the number of bytes written or -1 for error; if -1 is returned, the error can be checked with the errno() function

    @throw FILE-WRITE-ERROR File is not open
    @throw ENCODING-CONVERSION-ERROR error converting from the string's encoding to the File's encoding
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @note this method is equivalent to File::write(string)
 */
int File::print(string data) {
   if (check_terminal_io(self, "write", xsink))
      return 0;

   return f->write(data, xsink);
}

//! Writes a 1-byte integer to the file
/** @par Example
    @code
if ($f.writei1($val))
    printf("eror writing to file: %s\n", strerror(errno()));
@endcode

    @par Events
    @ref EVENT_DATA_WRITTEN

    @param c the integer to write; only the least-significant 8 bits will be written to the file

    @return 0 for success, -1 for error

    @throw FILE-WRITE-ERROR File is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
int File::writei1(int c) {
   if (check_terminal_io(self, "writei1", xsink))
      return 0;

   return f->writei1(c, xsink);
}

//! Writes a 2-byte (16 bit) integer to the file in binary big-endian format
/** @par Example
    @code
if ($f.writei2($val))
    printf("eror writing to file: %s\n", strerror(errno()));
@endcode

    @par Events
    @ref EVENT_DATA_WRITTEN

    @param s the integer to write in binary big-endian format; only the least-significant 16 bits of the integer will be written to the file

    @return 0 for success, -1 for error

    @throw FILE-WRITE-ERROR File is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
int File::writei2(int s) {
   if (check_terminal_io(self, "writei2", xsink))
      return 0;

   return f->writei2(s, xsink);
}

//! Writes a 4-byte (32 bit) integer to the file in binary big-endian format
/** @par Example
    @code
if ($f.writei4($val))
    printf("eror writing to file: %s\n", strerror(errno()));
@endcode

    @par Events
    @ref EVENT_DATA_WRITTEN

    @param i the integer to write in binary big-endian format; only the least-significant 32 bits of the integer will be written to the file

    @return 0 for success, -1 for error

    @throw FILE-WRITE-ERROR File is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
int File::writei4(int i) {
   if (check_terminal_io(self, "writei4", xsink))
      return 0;

   return f->writei4(i, xsink);
}

//! Writes an 8-byte (64 bit) integer to the file in binary big-endian format
/** @par Example
    @code
if ($f.writei8($val))
    printf("eror writing to file: %s\n", strerror(errno()));
@endcode

    @par Events
    @ref EVENT_DATA_WRITTEN

    @param i the integer to write in binary big-endian format; only the least-significant 64 bits of the integer will be written to the file

    @return 0 for success, -1 for error

    @throw FILE-WRITE-ERROR File is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
int File::writei8(int i) {
   if (check_terminal_io(self, "writei8", xsink))
      return 0;

   return f->writei8(i, xsink);
}

//! Writes a 2-byte (16 bit) integer to the file in binary little-endian format
/** @par Example
    @code
if ($f.writei2LSB($val))
    printf("eror writing to file: %s\n", strerror(errno()));
@endcode

    @par Events
    @ref EVENT_DATA_WRITTEN

    @param s the integer to write in binary little-endian format; only the least-significant 16 bits of the integer will be written to the file

    @return 0 for success, -1 for error

    @throw FILE-WRITE-ERROR File is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
int File::writei2LSB(int s) {
   if (check_terminal_io(self, "writei2LSB", xsink))
      return 0;

   return f->writei2LSB(s, xsink);
}

//! Writes a 4-byte (32 bit) integer to the file in binary little-endian format
/** @par Example
    @code
if ($f.writei4LSB($val))
    printf("eror writing to file: %s\n", strerror(errno()));
@endcode

    @par Events
    @ref EVENT_DATA_WRITTEN

    @param i the integer to write in binary little-endian format; only the least-significant 32 bits of the integer will be written to the file

    @return 0 for success, -1 for error

    @throw FILE-WRITE-ERROR File is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
int File::writei4LSB(int i) {
   if (check_terminal_io(self, "writei4LSB", xsink))
      return 0;

   return f->writei4LSB(i, xsink);
}

//! Writes an 8-byte (64 bit) integer to the file in binary little-endian format
/** @par Example
    @code
if ($f.writei8LSB($val))
    printf("eror writing to file: %s\n", strerror(errno()));
@endcode

    @par Events
    @ref EVENT_DATA_WRITTEN

    @param i the integer to write in binary little-endian format; only the least-significant 64 bits of the integer will be written to the file

    @return 0 for success, -1 for error

    @throw FILE-WRITE-ERROR File is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
int File::writei8LSB(int i) {
   if (check_terminal_io(self, "writei8LSB", xsink))
      return 0;

   return f->writei8LSB(i, xsink);
}

//! Writes a formatted string with soft field widths to the file
/** This method will allow arguments to overrun field width specifiers in the format string.

    @par Example
    @code $f.printf("%5s\n", "hello there"); # outputs "hello there\n", exceeding field width @endcode

    @par Events
    @ref EVENT_DATA_WRITTEN

    @param fmt the format string; see @ref string_formatting for more information about the format string

    @return the number of bytes written of -1 if an error occurred (in which case check errno() for the error)

    @throw FILE-WRITE-ERROR File is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @see File::f_printf() for a similar method that enforces field widths
 */
int File::printf(string[doc] fmt, ...) {
   if (check_terminal_io(self, "printf", xsink))
      return 0;

   QoreStringNodeHolder str(q_sprintf(args, 0, 0, xsink));
   if (!str)
      return 0;

   return f->write(*str, xsink);
}

//! This method variant does nothing except return a constant 0; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** @return a constant 0
 */
int File::printf() [flags=QC_RUNTIME_NOOP] {
   return 0;
}

//! Writes a formatted string with soft field widths to a file, where the second argument is the formatting argument list
/** This method will allow arguments to overrun field width specifiers in the format string.

    @par Example
    @code $f.vprintf("%5s: %d\n", ("hello there", 2)); # outputs "hello there: 2\n", exceeding field width @endcode

    @par Events
    @ref EVENT_DATA_WRITTEN

    @param fmt the format string; see @ref string_formatting for more information about the format string
    @param fmt_args the single argument or list of arguments that will be used as the argument list or the format string. If a single argument is passed instead of a list, it will be used as the first argument as if a list were passed

    @return the number of bytes written of -1 if an error occurred (in which case check errno() for the error)

    @throw FILE-WRITE-ERROR File is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @see File::f_vprintf() for a similar method that enforces field widths
 */
int File::vprintf(string[doc] fmt, any[doc] fmt_args) {
   if (check_terminal_io(self, "vprintf", xsink))
      return 0;

   QoreStringNodeHolder str(q_vsprintf(args, 0, 0, xsink));
   if (!str)
      return 0;

   return f->write(*str, xsink);
}

//! This method variant does nothing except return a constant 0; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** @return a constant 0
 */
int File::vprintf() [flags=QC_RUNTIME_NOOP] {
   return 0;
}

//! Writes a formatted string with hard field widths to the file
/** This method does not allow arguments to overrun field width specifiers in the format string.

    @par Example
    @code $f.f_printf("%5s\n", "hello there"); # outputs "hello\n", enforcing the field width @endcode

    @par Events
    @ref EVENT_DATA_WRITTEN

    @param fmt the format string; see @ref string_formatting for more information about the format string

    @return the number of bytes written of -1 if an error occurred (in which case check errno() for the error)

    @throw FILE-WRITE-ERROR File is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @see File::printf() for a similar method that does not enforce field widths
 */
int File::f_printf(string[doc] fmt, ...) {
   if (check_terminal_io(self, "f_printf", xsink))
      return 0;

   QoreStringNodeHolder str(q_sprintf(args, 1, 0, xsink));
   if (!str)
      return 0;

   return f->write(*str, xsink);
}

//! This method variant does nothing except return a constant 0; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** @return a constant 0
 */
int File::f_printf() [flags=QC_RUNTIME_NOOP] {
   return 0;
}

//! Writes a formatted string with hard field widths to a file, where the second argument is the formatting argument list
/** This method will not allow arguments to overrun field width specifiers in the format string.

    @par Example
    @code $f.f_vprintf("%5s: %d\n", ("hello there", 2)); # outputs "hello: 2\n", enforcing the field width @endcode

    @par Events
    @ref EVENT_DATA_WRITTEN

    @param fmt the format string; see @ref string_formatting for more information about the format string
    @param fmt_args the single argument or list of arguments that will be used as the argument list or the format string. If a single argument is passed instead of a list, it will be used as the first argument as if a list were passed

    @return the number of bytes written of -1 if an error occurred (in which case check errno() for the error)

    @throw FILE-WRITE-ERROR File is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @see File::vprintf() for a similar method that does not enforce field widths
 */
int File::f_vprintf(string[doc] fmt, any[doc] fmt_args) {
   if (check_terminal_io(self, "f_vprintf", xsink))
      return 0;

   QoreStringNodeHolder str(q_vsprintf(args, 1, 0, xsink));
   if (!str)
      return 0;

   return f->write(*str, xsink);
}

//! This method variant does nothing except return a constant 0; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** @return a constant 0
 */
int File::f_vprintf() [flags=QC_RUNTIME_NOOP] {
   return 0;
}

//! Reads until an EOL marker is found and returns the string read or NOTHING if no data can be read
/** Any string returned wiill be tagged with the File's character encoding.

    @par Example
    @code
while (exists (my *string $line = $f.readLine())) {
    # remove EOL marker
    chomp $line;
    # print out the line just read
    printf("%s\n", $line);
}
@endcode

    @par Events
    @ref EVENT_DATA_READ

    @return The line read from the file. NOTHING is returned if end-of-file is encountered, however, if data has been read before EOF, the data read will be returned and NOTHING (signifying EOF) will be returned on the next call to this method.  Any string returned wiill be tagged with the File's character encoding.

    @throw FILE-READLINE-ERROR File is not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
*string File::readLine() {
   if (check_terminal_io(self, "readLine", xsink))
      return 0;

   return f->readLine(xsink);
}

//! Sets the character encoding for the file; if called with no argument, the default encoding is set
/** @par Example
    @code $f.setEncoding("ISO-8859-1"); @endcode

    @param encoding the character encoding for the file; if called with no argument, the default encoding is set

    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
nothing File::setEncoding(*string encoding) {
   if (check_terminal_io(self, "setEncoding", xsink))
      return 0;

   const QoreEncoding *qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   f->setEncoding(qe);
}

//! Sets the character encoding for the file; if called with no argument, the default encoding is set
/** A method synonym for Socket::setEncoding(), kept for backwards-compatibility
    @param encoding the character encoding for the file; if called with no argument, the default encoding is set

    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
nothing File::setCharset(*string encoding) {
   if (check_terminal_io(self, "setCharset", xsink))
      return 0;

   const QoreEncoding *qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   f->setEncoding(qe);
}

//! Returns the character encoding for the file
/** @par Example
    @code my string $encoding = $f.getEncoding(); @endcode

    @return the character encoding for the file
 */
string File::getEncoding() {
   return new QoreStringNode(f->getEncoding()->getCode());
}

//! Returns the character encoding for the file
/** A method synonym for Socket::getEncoding(), kept for backwards-compatibility

    @par Example
    @code my string $encoding = $f.getCharset(); @endcode

    @return the character encoding for the file
 */
string File::getCharset() {
   return new QoreStringNode(f->getEncoding()->getCode());
}

//! Sets the current file position (in bytes from the beginning of the file)
/** @par Example
    @code $f.setPos(0); # go to the beginning of the file @endcode

    @param pos the position in the file as offset from position 0

    @return the new offset in the file, -1 for error

    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
int File::setPos(int pos = 0) {
   if (check_terminal_io(self, "setPos", xsink))
      return 0;

   return f->setPos(pos);
}

//! Returns the current file position as an integer giving the offset in bytes from the beginning of the file (starting from zero)
/** @par Example
    @code my int $pos = $f.getPos(); @endcode

    @return the current file position as an integer giving the offset in bytes from the beginning of the file (starting from zero)

    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
int File::getPos() {
   if (check_terminal_io(self, "getPos", xsink))
      return 0;

   return f->getPos();
}

//! Reads one character from the file and returns it as a string; returns NOTHING if no data can be read from the file
/** Multi-byte characters are also read; use File::readu1() or File::readi1() to read a single byte from a file regardless of the File's character encoding. 

    @par Example
    @code my *string $str = $f.getchar(); @endcode

    @return the single character read from the file or NOTHING if no data can be read from the file

    @throw FILE-READ-ERROR file is not open
    @throw FILE-GETCHAR-ERROR invalid multi-byte character read or EOF received while reading a multi-byte character
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
*string File::getchar() {
   if (check_terminal_io(self, "getchar", xsink))
      return 0;

   return f->getchar(xsink);
}

//! Attempts to lock the file according to the arguments passed, does not block
/** Locks or unlocks a portion of the file or the entire file, for reading or writing, non-blocking. The file must be opened in the appropriate mode before this call or the call will fail with an exception.

    @par Platform Availability
    @ref HAVE_FILE_LOCKING

    @par Example
    @code
# lock the entire file exclusively
$f.lock(F_WRLCK);

# lock a section of the file for reading, start byte 512, 2K range
$f.lock(F_RDLCK, 512, 2048);

# release all locks
$f.lock(F_UNLCK);
@endcode

    @param type Type of lock (or unlock); see @ref file_locking_constants
    @param start Start byte for lock, 0 is the default (start of file)
    @param len Length in bytes for range to lock, 0 is the default (rest of file)
    @param whence Indicates how the relative offset of the file should be calculated for the lock; see @ref file_seek_constants

    @return 0 for success, \c EACCES if the lock would block (only in the case that the lock would block is no exception thrown and \c EACCES returned)

    @throw FILE-LOCK-ERROR File is not open, lock length is negative, or the fcntl operation failed
    @throw MISSING-FEATURE-ERROR this exception is thrown when the method is not available on the runtime platform; for maximum portability, check the constant @ref HAVE_FILE_LOCKING before calling this function.
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @see File::lockBlocking() for a blocking version of this method
 */
int File::lock(softint[doc] type = F_RDLCK, softint[doc] start = 0, softint[doc] len = 0, softint[doc] whence = SEEK_SET) {
#ifdef HAVE_STRUCT_FLOCK
   if (check_terminal_io(self, "lock", xsink))
      return 0;

   struct flock fl;
   if (lock_intern(fl, args, xsink))
      return 0;
   return f->lock(fl, xsink);
#else
   return file_lock_error("lock", xsink);
#endif
}

//! Attempts to lock the file according to the arguments passed, blocking
/** Locks or unlocks a portion of the file or the entire file, for reading or writing, blocking. The file must be opened in the appropriate mode before this call or the call will fail with an exception.

    @par Platform Availability
    @ref HAVE_FILE_LOCKING

    @par Example
    @code
# lock the entire file exclusively
$f.lockBlocking(F_WRLCK);

# lock a section of the file for reading, start byte 512, 2K range
$f.lockBlocking(F_RDLCK, 512, 2048);

# release all locks
$f.lockBlocking(F_UNLCK);
@endcode

    @param type Type of lock (or unlock); see @ref file_locking_constants
    @param start Start byte for lock, 0 is the default (start of file)
    @param len Length in bytes for range to lock, 0 is the default (rest of file)
    @param whence Indicates how the relative offset of the file should be calculated for the lock; see @ref file_seek_constants

    @throw FILE-LOCK-ERROR File is not open, lock length is negative, or the fcntl operation failed
    @throw MISSING-FEATURE-ERROR this exception is thrown when the method is not available on the runtime platform; for maximum portability, check the constant @ref HAVE_FILE_LOCKING before calling this function.
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @see File::lockBlocking() for a blocking version of this method
 */
nothing File::lockBlocking(softint[doc] type = F_RDLCK, softint[doc] start = 0, softint[doc] len = 0, softint[doc] whence = SEEK_SET) {
#ifdef HAVE_STRUCT_FLOCK
   if (check_terminal_io(self, "lockBlocking", xsink))
      return 0;

   struct flock fl;
   if (lock_intern(fl, args, xsink))
      return 0;

   f->lockBlocking(fl, xsink);
   return 0;
#else
   return file_lock_error("lockBlocking", xsink);
#endif
}

//! Returns a hash of lock information
/** @par Platform Availability
    @ref HAVE_FILE_LOCKING

    @par Example
    @code my hash $hash = $f.getLockInfo(); @endcode

    @return a hash with the following keys: 
    - \c start: starting byte of the lock
    - \c len: the length in bytes of the locked region
    - \c pid: the PID of the process holding the lock
    - \c type: see @ref file_locking_constants; if no lock is set on the file, the key type has the value \c F_UNLCK.
    - \c whence: always returned as \c SEEK_SET when the call is successful

    @throw FILE-LOCK-ERROR File is not open or the fcntl operation failed
    @throw MISSING-FEATURE-ERROR this exception is thrown when the method is not available on the runtime platform; for maximum portability, check the constant @ref HAVE_FILE_LOCKING before calling this function.
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
hash File::getLockInfo() {
#ifdef HAVE_STRUCT_FLOCK
   if (check_terminal_io(self, "getLockInfo", xsink))
      return 0;

   struct flock fl;
   if (f->getLockInfo(fl, xsink))
      return 0;

   QoreHashNode *h = new QoreHashNode;
   h->setKeyValue("start", new QoreBigIntNode(fl.l_start), xsink);
   h->setKeyValue("len", new QoreBigIntNode(fl.l_len), xsink);
   h->setKeyValue("pid", new QoreBigIntNode(fl.l_pid), xsink);
   h->setKeyValue("type", new QoreBigIntNode(fl.l_type), xsink);
   h->setKeyValue("whence", new QoreBigIntNode(fl.l_whence), xsink);

   return h;
#else
   return file_lock_error("getLockInfo", xsink);
#endif
}

//! Changes the user and group owners of the file on the filesystem (if the current user has sufficient permission to do so)
/** @par Platform Availability
    @ref HAVE_UNIX_FILEMGT

    @par Example
    @code $f.chown(0, 0); @endcode

    @param uid The user id of the user to change to; -1 means do not change uid
    @param gid The group id of the user to change to; -1 means do not change gid

    @throw FILE-CHOWN-ERROR File is not open or the chown operation failed
    @throw MISSING-FEATURE-ERROR this method is not supported on this platform; check \c Option::HAVE_UNIX_FILEMGT before calling this method to avoid this exception
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
nothing File::chown(softint uid, softint gid = -1) {
#ifdef HAVE_CHOWN
   if (check_terminal_io(self, "chown", xsink))
      return 0;

   f->chown( (uid_t)uid, (gid_t)gid, xsink);
   return 0;
#else
   return missing_method_error("File::chown", "UNIX_FILEMGT", xsink);
#endif
}

//! Returns True if there is data available for reading from the file within the timeout period
/** With a timeout of zero (the default if no timeout value is passed), this method can be used for non-blocking polling the file for data. Like all Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" may be passed instead of an integer to make the timeout units clear (ex: 25ms).

    @param timeout_ms An optional timeout in milliseconds (1/1000 second)

    @return \c True if data becomes available for reading from the file within the timeout period, \c False if not

    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
bool File::isDataAvailable(timeout timeout_ms = 0) {
   if (check_terminal_io(self, "isDataAvailable", xsink))
      return 0;

   return f->isDataAvailable(timeout_ms, xsink);
}

//! Saves the current terminal attributes for the file in the TermIOS object passed; changes the object passed as an argument to reflect the terminal attributes as set for the File
/** Do not pass a reference to the TermIOS object; pass the object itself as an argument.

    @par Platform Availability
    @ref HAVE_TERMIOS

    @par Example
    @code
my TermIOS $termios();
stdin.getTerminalAttributes($termios);
@endcode

    @param termios The method writes the current terminal attributes for the file to the object passed

    @throw FILE-OPERATION-ERROR the File is not open
    @throw TERMIOS-GET-ERROR error reading terminal attributes from the file descriptor
    @throw MISSING-FEATURE-ERROR this method is not supported on this platform; check \c Option::HAVE_TERMIOS before calling this method to avoid this exception
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
nothing File::getTerminalAttributes(TermIOS[QoreTermIOS] termios) {
#ifdef HAVE_TERMIOS_H
   if (check_terminal_io(self, "getTerminalAttributes", xsink))
      return 0;

   ReferenceHolder<QoreTermIOS> holder(termios, xsink);
   f->getTerminalAttributes(termios, xsink);
   return 0;
#else
   return missing_method_error("File::getTerminalAttributes", "TERMIOS", xsink);
#endif
}

//! Sets the current terminal attributes for the File from the TermIOS object passed; does not change the object passed
/** @par Platform Availability
    @ref HAVE_TERMIOS

    @par Example
    @code
my TermIOS $termios();
stdin.getTerminalAttributes($termios);
my TermIOS $orig = $termios.copy();
on_exit
    stdin.setTerminalAttributes(TCSADRAIN, $orig);

my int $lflag = $termios.getLFlag();
$lflag &= ~ICANON;
$lflag &= ~ECHO;
$lflag &= ~ISIG;
$termios.setLFlag($lflag);
$termios.setCC(VMIN, 1);
$termios.setCC(VTIME, 0);
stdin.setTerminalAttributes(TCSADRAIN, $termios);
@endcode

    @param action a binary or'ed value of the following actions: 
    - \c TCSANOW: the change occurs immediately
    - \c TCSADRAIN: the change occurs after all output written to fildes has been transmitted to the terminal
    - \c TCSAFLUSH: the change occurs after all output written to the File has been transmitted to the terminal
    - \c TCSASOFT: the values of the \c c_cflag, \c c_ispeed, and \c c_ospeed fields are ignored
    @param termios the TermIOS to use

    @throw FILE-OPERATION-ERROR the File is not open
    @throw TERMIOS-SET-ERROR error setting terminal attributes on the file descriptor
    @throw MISSING-FEATURE-ERROR this method is not supported on this platform; check \c Option::HAVE_TERMIOS before calling this method to avoid this exception
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
nothing File::setTerminalAttributes(softint action = TCSANOW, TermIOS[QoreTermIOS] termios) {
#ifdef HAVE_TERMIOS_H
   if (check_terminal_io(self, "setTerminalAttributes", xsink))
      return 0;

   ReferenceHolder<QoreTermIOS> holder(termios, xsink);
   f->setTerminalAttributes(action, termios, xsink);
   return 0;
#else
   return missing_method_error("File::setTerminalAttributes", "TERMIOS", xsink);
#endif
}

//! Sets a @ref Qore::Thread::Queue "Queue" object to receive @ref file_events "file events"
/** @par Example
    @code $f.setEventQueue($queue); @endcode

    @param queue the @ref Qore::Thread::Queue "Queue" object to receive @ref file_events "file events"

    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @see @ref event_handling for more information
 */
nothing File::setEventQueue(Qore::Thread::Queue[Queue] queue) {
   if (check_terminal_io(self, "setEventQueue", xsink))
      return 0;

   // pass reference from QoreObject::getReferencedPrivateData() to function
   f->setEventQueue(queue, xsink);
   return 0;
}

//! Removes any @ref Qore::Thread::Queue "Queue" object from the File object so that @ref file_events "file events" are no longer added to the @ref Qore::Thread::Queue "Queue"
/** @par Example
    @code $f.setEventQueue(); @endcode

    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @see @ref event_handling for more information
 */
nothing File::setEventQueue() {
   if (check_terminal_io(self, "setEventQueue", xsink))
      return 0;

   f->setEventQueue(0, xsink);
   return 0;
}

//! Returns a @ref stat_list about the file's status or throws an exception if any errors occur
/** If any errors occur, a \c FILE-STAT-ERROR exception is thrown.

    @par Example
    @code my int $mode = $file.stat()[2]; @endcode

    @return a @ref stat_list "list of file status values" for the current file (must be open).

    @throw FILE-STAT-ERROR stat() call failed or file not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @see @ref file_stat_constants
 */
list File::stat() {
   if (check_terminal_io(self, "stat", xsink))
      return 0;

   return f->stat(xsink);
}

//! Returns a @ref stat_hash about the file's status or throws an exception if any errors occur
/** If any errors occur, a \c FILE-HSTAT-ERROR exception is thrown

    @par Example
    @code my hash $h = $file.hstat(); @endcode

    @return a @ref stat_hash about the file's status

    @throw FILE-HSTAT-ERROR stat() call failed or file not open
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set

    @see @ref file_stat_constants
 */
hash File::hstat() {
   if (check_terminal_io(self, "hstat", xsink))
      return 0;

   return f->hstat(xsink);
}

//! Returns a @ref filesystem_status_hash about the file's filesystem status or throws an exception if any errors occur
/** If any errors occur, a \c FILE-STATVFS-ERROR exception is thrown

    @par Platform Availability
    @ref HAVE_STATVFS

    @par Example
    @code my hash $h = $file.statvfs(); @endcode

    @return a @ref filesystem_status_hash about the filesystem where the file resides

    @throw FILE-STATVFS-ERROR statvfs() call failed or file is not open
    @throw MISSING-FEATURE-ERROR this method is not supported on this platform; check \c Option::HAVE_STATVFS before calling this method to avoid this exception
    @throw ILLEGAL-EXPRESSION this exception is only thown if called with a system constant object (\c stdio, \c stdin, \c stdout) when @ref no-terminal-io is set
 */
hash File::statvfs() {
#ifdef HAVE_SYS_STATVFS_H
   if (check_terminal_io(self, "statvfs", xsink))
      return 0;

   return f->statvfs(xsink);
#else
   return missing_method_error("File::statvfs", "STATVFS", xsink);
#endif
}

//! Returns a @ref stat_list about the file's status (follows symbolic links) or throws an exception if any errors occur
/** This method will follow symbolic links and return information about the target.
    If any errors occur, a \c FILE-STAT-ERROR exception is thrown

    @par Restrictions
    Not available with @ref PO_NO_FILESYSTEM

    @par Example
    @code my int $mode = File::stat($path)[2]; @endcode

    @param path the file to stat()

    @return a @ref stat_list "list of file status values" for the given file

    @throw FILE-STAT-ERROR stat() call failed

    @see @ref file_stat_constants
 */
static list File::stat(string path) [dom=QDOM_FILESYSTEM] {
   struct stat sbuf;
   if (stat(path->getBuffer(), &sbuf)) {
      xsink->raiseErrnoException("FILE-STAT-ERROR", errno, "stat() command failed");
      return 0;
   }

   return stat_to_list(sbuf);
}

//! Returns a @ref stat_list about the given path's status (does not follow symbolic links) or throws an exception if any errors occur
/** Does not follow symbolic links, but rather returns filesystem information for symbolic links.
    If any errors occur, a \c FILE-LSTAT-ERROR exception is thrown

    @par Restrictions
    Not available with @ref PO_NO_FILESYSTEM

    @par Example
    @code my int $mode = File::lstat($path)[2]; @endcode

    @param path the file to stat()

    @return a @ref stat_list "list of file status values" for the given file

    @throw FILE-LSTAT-ERROR stat() call failed

    @see lstat() for a similar function that does not throw exceptions when errors occur, but rather returns @ref nothing
    @see @ref file_stat_constants
 */
static list File::lstat(string path) {
   struct stat sbuf;
#ifdef HAVE_LSTAT
   if (lstat(path->getBuffer(), &sbuf))
#else
   if (stat(path->getBuffer(), &sbuf))
#endif
   {
      xsink->raiseErrnoException("FILE-LSTAT-ERROR", errno, "lstat() command failed");
      return 0;
   }

   return stat_to_list(sbuf);
}

//! Returns a @ref stat_hash about the file's status (follows symbolic links) or throws an exception if any errors occur
/** This method will follow symbolic links and return information about the target.
    If any errors occur, a \c FILE-HSTAT-ERROR exception is thrown

    @par Restrictions
    Not available with @ref PO_NO_FILESYSTEM

    @par Example
    @code my hash $h = File::hstat($path); @endcode

    @param path the file to stat()
    @return a @ref stat_hash about the file's status

    @throw FILE-HSTAT-ERROR stat() call failed

    @see hstat() for a normal function returns @ref nothing instead of throwing an exception when errors occur
    @see @ref file_stat_constants
 */
static hash File::hstat(string path) {
   struct stat sbuf;
   if (stat(path->getBuffer(), &sbuf)) {
      xsink->raiseErrnoException("FILE-HSTAT-ERROR", errno, "stat() command failed");
      return 0;
   }

   return stat_to_hash(sbuf);
}

//! Returns a @ref stat_hash about the file's status (does not follow symbolic links) or throws an exception if any errors occur
/** Does not follow symbolic links, but rather returns filesystem information for symbolic links.
    If any errors occur, a \c FILE-HSTAT-ERROR exception is thrown

    @par Restrictions
    Not available with @ref PO_NO_FILESYSTEM

    @par Example
    @code my hash $h = File::hstat($path); @endcode

    @param path the file to stat()
    @return a @ref stat_hash about the file's status

    @throw FILE-HSTAT-ERROR stat() call failed

    @see hstat() for a normal function returns @ref nothing instead of throwing an exception when errors occur
    @see @ref file_stat_constants
 */
static hash File::hlstat(string path) {
   struct stat sbuf;
#ifdef HAVE_LSTAT
   if (lstat(path->getBuffer(), &sbuf))
#else
   if (stat(path->getBuffer(), &sbuf))
#endif
   {
      xsink->raiseErrnoException("FILE-HLSTAT-ERROR", errno, "lstat() command failed");
      return 0;
   }

   return stat_to_hash(sbuf);
}

//! Returns a @ref filesystem_status_hash about filesystem status of the given path; throws an exception if any errors occur
/** If any errors occur, a \c FILE-STATVFS-ERROR exception is thrown

    @par Restrictions
    Not available with @ref PO_NO_FILESYSTEM

    @par Platform Availability
    @ref HAVE_STATVFS

    @par Example
    @code my hash $h = File::statvfs($path); @endcode

    @param path the path to the filesystem to check
    @return a @ref filesystem_status_hash about the filesystem where the file resides

    @throw FILE-STATVFS-ERROR statvfs() call failed
    @throw MISSING-FEATURE-ERROR this method is not supported on this platform; check \c Option::HAVE_STATVFS before calling this method to avoid this exception
 */
static hash File::statvfs(string path) {
#ifdef HAVE_SYS_STATVFS_H
   struct statvfs vfs;
   if (statvfs(path->getBuffer(), &vfs)) {
      xsink->raiseErrnoException("FILE-STATVFS-ERROR", errno, "statvfs() call failed");
      return 0;
   }

   return statvfs_to_hash(vfs);
#else
   return file_lock_error("statvfs", xsink);
#endif
}
