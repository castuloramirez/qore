/* -*- mode: c++; indent-tabs-mode: nil -*- */
/** @file QC_RangeIterator.qpp RangeIterator class definition */
/*
  Qore Programming Language

  Copyright 2003 - 2013 Qore Technologies s.r.o.

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <qore/Qore.h>
#include <qore/intern/RangeIterator.h>

//! This class defines a range-like iterator to be used to iterate numerical sequences
/** The main purpose is to provide resource friendly iterator to generate
    numerical rows (sequences) with ascending and descending ordering.

    The RangeIterator class provides an iterator for loop statements with functionality
    similar to @ref range(). Unlike range() RangeIterator objects
    do not generate real @ref list "lists" but calculate iteration values on demand.

    This results in memory-friendly handling for large numerical sequences compared to
    generating a list in memory and iterating that list (as with @ref Qore::range()).

   @par Example:
   @code
my RangeIterator $r(2);
for my int $i in ($r)
    printf("i=%d\n", $i);
# i=0
# i=1
# i=2
   @endcode

   @see range()
   @see xrange()

   @since %Qore 0.8.6
 */
qclass RangeIterator [arg=RangeIterator* i; ns=Qore; vparent=AbstractIterator];

//! creates the numerical sequence iterator with the initial arguments
/** @param start an initial value
    @param stop a final value
    @param step is the interval. Default = 1

    @par Example:
    @code
my RangeIterator $i(5, 10, 2);
    @endcode

    @see xrange()
 */
RangeIterator::constructor(int start, int stop, int step=1) {
   self->setPrivate(CID_RANGEITERATOR, new RangeIterator(start, stop, step, xsink));
}

//! Creates a copy of the RangeIterator object, iterating the same object as the original and in the same position
/** @par Example:
    @code
my RangeIterator $ni = $i.copy();
    @endcode
 */
RangeIterator::copy() {
   self->setPrivate(CID_RANGEITERATOR, new RangeIterator(*i));
}

//! This method returns @ref Qore::True "True" while there are more numbers to iterate and @ref Qore::False "False" when the range has been completed iterated
/** The iterator object should not be used after this method returns @ref Qore::False "False".

    @return @ref Qore::True "True" and @ref Qore::False "False" alternately unless it has no value iterate.

    @par Example:
    @code
while ($i.next()) {
    printf("value: %y\n", $i.getValue());
}
    @endcode

    @throw ITERATOR-THREAD-ERROR this exception is thrown if this method is called from any thread other than the thread that created the object
 */
bool RangeIterator::next() {
   if (i->check(xsink))
       return false;
   return i->next();
}

//! returns the current value or throws an \c INVALID-ITERATOR exception if the iterator is invalid
/** @return the current value or throws an \c INVALID-ITERATOR exception if the iterator is invalid

    @par Example:
    @code
while ($i.next()) {
    printf("+ %y\n", $i.getValue());
}
    @endcode

    @throw INVALID-ITERATOR the iterator is not pointing at a valid element
    @throw ITERATOR-THREAD-ERROR this exception is thrown if this method is called from any thread other than the thread that created the object
 */
any RangeIterator::getValue() [flags=RET_VALUE_ONLY] {
   if (i->check(xsink))
       return 0;
   return i->getValue(xsink);
}

//! Reset the iterator instance to its initial state (start, stop, and step).
/** Reset the iterator instance to its initial state (start, stop, and step).

   @par Example
   @code
# raw RangeIterator object usage
my RangeIterator $r(2);
foreach my int $i in ($r) {
    printf("i=%d\n", $i);
    if ($i == 1)
        break;
}
# i=0
# i=1

# show the reset feature; start iterating all over again
$r.reset();
foreach my int $i in ($r)
    printf("reused i=%d\n", $i);
# reused i=0
# reused i=1
# reused i=2
   @endcode

    @throw ITERATOR-THREAD-ERROR this exception is thrown if this method is called from any thread other than the thread that created the object
 */
RangeIterator::reset() {
   if (i->check(xsink))
       return 0;
   i->reset();
}

/** @defgroup range_functions RangeIterator helper functions
    RangeIterator helper functions allow to use RangeItartor
    in easier usage in loop statements.

    @par Example
    @code
foreach my int $i in(xrange(5))
    printf("i=%d\n", $i);
# resulting in:
# i=0
# i=1
# i=2
# i=3
# i=4
# i=5
	@endcode
 */
//@{
//! Returns an RangeIterator containing an arithmetic progression of integers.
/**
    @par Example:
    @code
xrange(2, 5); # 2, 3, 4, 5
xrange(2, -2); # 2, 1, 0, -1, -2
xrange(1, 10, 5); # 1, 6
xrange(0, 10, 5); # 0, 5, 10
xrange(-10, 10, 5); # -10, -5, 0, 5, 10
xrange(10, -10, 5); # 10, 5, 0, -5, -10
    @endcode

    @param start the initial value
    @param stop the final value
    @param step the step; the default is 1; must be greater than 0; the function throws a \c RANGE-ERROR exception when this argument is < 1

    @retval Returns an RangeIterator containing an arithmetic progression of integers.

    @throw RANGEITERATOR-ERROR this exception is thrown if \c step < 1

    @see range

    @note the main difference between range() and xrange() is that range returns a real list and xrange() returns an RangeIterator

    @since %Qore 0.8.6
*/
RangeIterator xrange(int start, int stop, int step = 1) [flags=RET_VALUE_ONLY] {
   return new QoreObject(QC_RANGEITERATOR, 0, new RangeIterator(start, stop, step, xsink));
}

//! Returns an RangeIterator containing an arithmetic progression of integers with start = 0 and step = 1.
/**
    This is an overloaded version of xrange(int, int, int) meaning \c xrange(0, \c stop, 1)

    @par Example:
    @code
xrange(1); # 0, 1
xrange(-3); # 0, -1, -2, -3
    @endcode

    @param stop the final value

    @retval Returns an RangeIterator containing an arithmetic progression of integers with start = 0 and step = 1.

    @see range

    @note the main difference between range() and xrange() is that range() returns a real list and xrange() returns an RangeIterator

    @since %Qore 0.8.6
 */
RangeIterator xrange(int stop) [flags=CONSTANT] {
   return new QoreObject(QC_RANGEITERATOR, 0, new RangeIterator(0, stop, 1, xsink));
}
//@}
