/* -*- mode: c++; indent-tabs-mode: nil -*- */
/** @file QC_ThreadPool.qpp ThreadPool class definition */
/*
  Qore Programming Language

  Copyright 2003 - 2013 David Nichols

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <qore/Qore.h>
#include <qore/intern/ThreadPool.h>

static void tpt_start_thread(ExceptionSink* xsink, ThreadPoolThread* tpt) {
   tpt->worker(xsink);
}

ThreadPoolThread::ThreadPoolThread(ThreadPool& n_tp, ExceptionSink* xsink) : tp(n_tp), task(0), stopCond(0), stopflag(false), stopped(false) {
   id = q_start_thread(xsink, (q_thread_t)tpt_start_thread, this);
   if (id > 0)
      tp.ref();
}

void ThreadPoolThread::worker(ExceptionSink* xsink) {
   SafeLocker sl(m);
      
   while (!stopflag) {
      if (!task) {
         //printd(5, "ThreadPoolThread::worker() id %d about to wait stopflag: %d task: %p\n", id, stopflag, task);
         c.wait(m);
         if (stopflag && !task)
            break;
      }
      
      assert(task);
      
      sl.unlock();
      discard(task->run(xsink), xsink);
      sl.lock();
      task->del(xsink);
      task = 0;
      
      if (stopflag || tp.done(this))
         break;
   }

   //printd(5, "ThreadPoolThread::worker() stopping id %d: %s\n", id, stopCond ? "wait" : "after detach");

   if (stopCond) {
      stopped = true;
      stopCond->signal();
   }
   else {
      sl.unlock();
      finalize(xsink);
   }
}

void ThreadPoolThread::finalize(ExceptionSink* xsink) {
   tp.deref(xsink);
   delete this;
}

static void tp_start_thread(ExceptionSink* xsink, ThreadPool* tp) {
   tp->worker(xsink);
}

ThreadPool::ThreadPool(ExceptionSink* xsink, int n_max, int n_minidle, int n_maxidle, int n_release_ms) : 
   max(n_max), minidle(n_minidle), maxidle(n_maxidle), release_ms(n_release_ms), quit(false), waiting(false), stopflag(false), stopped(false), confirm(false) {
   if (max < 0)
      max = 0;
   if (minidle < 0)
      minidle = 0;
   if (maxidle <= 0)
      maxidle = minidle;
   if (q_start_thread(xsink, (q_thread_t)tp_start_thread, this) == -1) {
      assert(*xsink);
      stopped = true;
   }
}

void ThreadPool::worker(ExceptionSink* xsink) {
   SafeLocker sl(m);

   if (minidle)
      for (int i = 0; i < minidle; ++i) {
         if (addIdleWorker(xsink)) {
            xsink->handleExceptions();
            break;
         }
      }

   while (!stopflag) {
      if (q.empty()) {
         if (release_ms && fh.size() > minidle) {
            if (cond.wait(m, release_ms) && q.empty()) {
               // timeout occurred: terminate an idle thread
               ThreadPoolThread* tpt = fh.front();
               //printd(5, "ThreadPool::worker() this: %p release_ms: %d timeout - stopping idle thread %p (minidle: %d maxidle: %d fh.size(): %ld)\n", this, release_ms, tpt, minidle, maxidle, fh.size());
               fh.pop_front();
               tpt->stop();
               continue;
            }
         }
         else
            cond.wait(m);
      }

      if (stopflag)
         break;

      while (!q.empty()) {
         ThreadPoolThread* tpt = getThreadUnlocked(xsink);
         if (!tpt) {
            xsink->handleExceptions();
            break;
         }
         tpt->submit(q.front());
         q.pop_front();
      }

      while (fh.size() < minidle && (!max || (fh.size() + ah.size() < max))) {
         if (addIdleWorker(xsink)) {
            xsink->handleExceptions();
            break;
         }
      }
   }

   // idle threads can be terminated with stop() in all cases
   for (tplist_t::iterator i = fh.begin(), e = fh.end(); i != e; ++i)
      (*i)->stop();

   // terminate all worker threads
   if (confirm) {
      for (tplist_t::iterator i = ah.begin(), e = ah.end(); i != e; ++i)
         (*i)->stopWait();

      sl.unlock();

      for (tplist_t::iterator i = ah.begin(), e = ah.end(); i != e; ++i)
         (*i)->stopConfirm(xsink);

      sl.lock();
   }
   else {
      for (tplist_t::iterator i = ah.begin(), e = ah.end(); i != e; ++i)
         (*i)->stop();
   }

#ifdef DEBUG
   ah.clear();
   fh.clear();
#endif

   stopped = true;
   stopCond.broadcast();

   sl.unlock();

   // cancel tasks if any
   for (taskq_t::iterator i = q.begin(), e = q.end(); i != e; ++i) {
      (*i)->cancel(xsink);
      delete *i;
   }

#ifdef DEBUG
   q.clear();;
#endif
}

//! This class defines a thread pool for executing tasks in a pool of threads that can grow or shrink dynamically
/** The ThreadPool can also allocate idle threads in advance for quickly executing tasks submitted through @ref Qore::Thread::ThreadPool::submit() "ThreadPool::submit()".

    A worker thread is started while the ThreadPool is running that waits for tasks in an internal task queue and allocates the tasks
    to child threads.   If an idle thread is available, the task is submitted to that thread immediately, otherwise, if the ThreadPool
    is not already at maximum capacity (the \a max argument to @ref Qore::Thread::ThreadPool::constructor() "ThreadPool::constructor()"), a new thread is started
    and the task is allocated to the new thread.  Otherwise, the task will block until a thread becomes free, at which time the task
    is allocated to the newly-freed child thread.

    When a child thread has no more tasks to execute, it will either be returned to the pool to wait in an idle state if possible, or it
    will terminate.  Threads are returned to the idle pool if there are fewer than \a maxidle threads in the idle pool already or if
    there are more tasks in the queue than idle threads.

    ThreadPools downscale over time when demand is lower according to the \a delay_ms argument to @ref Qore::Thread::ThreadPool::constructor() "ThreadPool::constructor()"; when there more than \a minidle threads in the idle pool, then for each time period defined by \a delay_ms, a single thread in the idle pool is released until the number of threads in the idle pool reaches \a minidle. 

    Therefore the \a minidle argument defines the "ground state" of the ThreadPool (how many idle threads are waiting for tasks), and the \a delay_ms argument defines the period in which the ThreadPool returns to its ground state after demand for threads results in a condition where there are temporarily more than \a minidle threads in the idle pool

    If the ThreadPool is stopped when tasks are still in the queue, then any cancelation @ref closure "closure" or
    @ref call_reference "call reference" for the task is executed; see @ref  @ref Qore::Thread::ThreadPool::submit() "ThreadPool::submit()" for more information.

    @par Example:
    @code
my ThreadPool $tp(10, 2, 4);
    @endcode

    @since %Qore 0.8.8
 */
qclass ThreadPool [dom=THREAD_CLASS; arg=ThreadPool* tp; ns=Qore::Thread];

//! creates the pool with the given parameters; idle threads are started immediately if necessary
/** @par Example:
    @code
my ThreadPool $tp(10, 2, 4);
    @endcode

    When task threads complete, the thread is returned to the pool if there are less than \a minidle threads in the idle list or there are more tasks in the queue than the number of idle threads.

    @param max the maximum number of threads in the pool
    @param minidle the minimum number of free idle threads to keep ready
    @param maxidle the maximum number of idle threads to keep ready    
    @param release_ms this value gives the delay in terminating single idle threads when \a maxidle > \a minidle and there are more than \a minidle threads in the idle pool; for example, if \a release_ms = \c 10s then when there are more than \a minidle threads in the idle pool, every 10 seconds an idle thread is terminated until there are \a minidle threads in the pool.  Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.)
    
    @throw THREADPOOL-ERROR minidle > max, maxidle > max or minidle > maxidle, or release_ms < 0
 */
ThreadPool::constructor(int max = 0, int minidle = 0, int maxidle = 0, timeout release_ms = 5s) {
   if (max > 0) {
      if (minidle > max) {
         xsink->raiseException("THREADPOOL-ERROR", "cannot create a ThreadPool object with minidle (%d) > max (%d)", minidle, max);
         return;
      }
      if (maxidle > max) {
         xsink->raiseException("THREADPOOL-ERROR", "cannot create a ThreadPool object with maxidle (%d) > max (%d)", maxidle, max);
         return;
      }
   }
   if (maxidle > 0) {
      if (minidle > maxidle) {
         xsink->raiseException("THREADPOOL-ERROR", "cannot create a ThreadPool object with minidle (%d) > maxidle (%d)", minidle, maxidle);
         return;
      }
   }
   if (release_ms < 0) {
      xsink->raiseException("THREADPOOL-ERROR", "cannot create a ThreadPool object with release_ms < 0 (value passed: %d)", release_ms);
      return;
   }

   ReferenceHolder<ThreadPool> tp(new ThreadPool(xsink, max, minidle, maxidle, release_ms), xsink);
   if (*xsink)
      return;

   self->setPrivate(CID_THREADPOOL, tp.release());
}

//! destroys the pool; any task threads are detached; to wait for all task threads to complete, call ThreadPool::stopWait() first
/** @par Example:
    @code
delete $tp;
    @endcode
 */
ThreadPool::destructor() {
   tp->stop();
   tp->deref();
}

//! stops the thread pool and returns immediately; after this method has been executed once no more tasks can be submitted to the ThreadPool
/** @par Example:
    @code
$tp.stop();
    @endcode

    This method detaches all child threads immediately, stops the ThreadPool, and returns immediately.

    @note if any task threads are still running; they are detached from the ThreadPool and terminate independently from the ThreadPool

    @see ThreadPool::stopWait()
 */
ThreadPool::stop() {
   tp->stop();
}

//! stops the thread pool and does not return until all child threads have also been stopped; after this method has been executed once no more tasks can be submitted to the ThreadPool
/** @par Example:
    @code
$tp.stopWait();
    @endcode

    This method does not return until the ThreadPool has been stopped and all child threads have also been stopped.

    @see ThreadPool::stop()
 */
ThreadPool::stopWait() {
   tp->stopWait(xsink);
}

//! submit a task to the pool
/** @par Example:
    @code
$tp.submit(sub () { call_function($arg); });
    @endcode

    @param task the @ref closure "closure" or @ref call_reference "call reference" to execute
    @param cancel an optional  @ref closure "closure" or @ref call_reference "call reference" to execute if the ThreadPool is stopped before the task can be executed; note that cancelation code is run serially for each task in order of submission in the ThreadPool's worker thread after the ThreadPool has been shut down
 */
ThreadPool::submit(code task, *code cancel) {
   tp->submit(task->refRefSelf(), cancel ? cancel->refRefSelf() : 0, xsink);
}

//! returns a description of the ThreadPool
/** @par Example:
    @code
my string $desc = $tp.toString();
    @endcode

    @return a description of the ThreadPool
 */
string ThreadPool::toString() [flags=CONSTANT] {
   QoreStringNode* str = new QoreStringNode;
   tp->toString(*str);
   return str;
}
