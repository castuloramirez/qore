# -*- mode: qore; indent-tabs-mode: nil -*-
# @file OracleSqlUtil.qm Qore user module for working with Oracle SQL data

/*  OracleSqlUtil.qm Copyright 2013 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.8 or better
%requires qore >= 0.8.8

# requires the SqlUtil module
%requires SqlUtil >= 1.0

# requires the Util module
%requires Util >= 1.0

# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module OracleSqlUtil {
    version = "1.0";
    desc = "user module for working with Oracle SQL data";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
}

/*  Version History
    * 2013-xx-xx v1.0: David Nichols <david@qore.org>
      + the initial version of the OracleSqlUtil module
*/

/** @mainpage OracleSqlUtil Module

    The %OracleSqlUtil module provides a high level API for working with Oracle database objects.

    Usually this module is loaded on demand from the SqlUtil module, however to use this module
    directly, use \c "%requires OracleSqlUtil" in your code.
    
    All the public symbols in the module are defined in the OracleSqlUtil namespace
*/

#! the OracleSqlUtil namespace contains all the objects in the OracleSqlUtil module
public namespace OracleSqlUtil {
    public OracleTable sub get_table(AbstractDatasource nds, string nname, *hash opts) {
	return new OracleTable(nds, nname, opts);
    }

    public OracleDatabase sub get_database(AbstractDatasource nds, *hash opts) {
	return new OracleDatabase(nds, opts);
    }

    public class OracleColumn inherits AbstractColumn {
        public {
            #! the column uses character semantics
            bool char_used;
            #! byte size of the column
            int byte_size;
        }

        constructor(string n, string nt, *string qt, int sz, bool nul, *string dv, *string cm, bool is_char = False, bool cu = False, int bs) : AbstractColumn(n, nt, qt, sz, nul, dv, cm) {
            # only set "char_used" if we are dealing with a char column
            char_used = is_char && cu;
            byte_size = bs;
        }

        #! returns the string describing the native type that can be used in SQL (for example to add the colunn to a table or when creating the table)
        string getNativeTypeString() {
            if (char_used)
                return sprintf("%s(%d char)", native_type, size);
            return AbstractColumn::getNativeTypeString();
        }

        #! returns a list of sql strings that can be used to add the column to an existing table
        /** @par Example:
            @code
my list $l = $col.getCreateSql($t);
            @endcode

            @param t the AbstractTable object to modify
         */
        list getCreateSql(AbstractTable t) {
	    list l += sprintf("alter table %s add %s", t.getSqlName(), getCreateSql());	    
	    if (comment)
		l += sprintf("comment on column %s.%s is %s", t.getSqlName(), name, t.getSqlValue(comment));
            return l;
        }

        #! returns a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $col.getModifySql($t, $newcol);
            @endcode

            The column names are assumed to be equal

            @param t the AbstractTable object to modify
            @param c the new column definition
         */
        list getModifySql(AbstractTable t, AbstractColumn col) {
            list l = ();
            OracleColumn c = col;

            bool modified;
            string sql = sprintf("alter table %s modify %s", t.getSqlName(), name);

            # get new native type declaration string
            string nts = c.getNativeTypeString();
            if (getNativeTypeString() != nts) {
                sql += sprintf(" %s", nts);
                modified = True;
            }

            if (def_val != c.def_val) {
                sql += sprintf(" default %s", exists c.def_val ? c.def_val : "null");
                modified = True;
            }

            if (nullable != c.nullable) {
                sql += sprintf(" %snull", c.nullable ? "" : "not ");
                modified = True;
            }
            if (modified)
                l += sql;

            # to remove a comment we set it to the empty string ('')
            # http://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_4009.htm
            if (c.comment != comment)
		l += sprintf("comment on column %s.%s is %s", t.getSqlName(), name, c.comment ? t.getSqlValue(c.comment) : "''");
            return l;
        }

        #! returns a string that can be used to rename the column
        /** @par Example:
            @code
my string $str = $col.getRenameSql($t, "new_name");
            @endcode

            @param t the AbstractTable object to modify
            @param new_name the new name for the column

            @return a string that can be used to rename the column
        */
        string getRenameSql(AbstractTable t, string new_name) {
            return sprintf("alter table %s rename column %s to %s", t.getSqlName(), name, new_name);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equalImpl(AbstractColumn c) {
            return char_used == cast<OracleColumn>(c).char_used;
        }
    }

    public class OracleNumberColumn inherits OracleColumn, NumericColumnInfo {
        constructor(string n, string nt, *string qt, int sz, bool nul, *string dv, *string cm, bool cu = False, int bs, int n_scale = 0) :
            OracleColumn(n, nt, qt, sz, nul, dv, cm, False, cu, bs), NumericColumnInfo(n_scale) {
        }

        string getNativeTypeString() {
            return NumericColumnInfo::getNativeTypeString(native_type, size);
        }
    }

    public class OracleIndex inherits AbstractIndex {
        public {
            #! the native type of the index (if supported)
            string native_type;

            #! the tablespace name of the index (if supported)
            *string tablespace;
        }

        #! creates the object from the arguments
        constructor(string n, bool u, hash c, string nt, *string t) : AbstractIndex(n, u, c) {
            native_type = nt;
            tablespace = t;
        }

        #! returns a string that can be used to create the index in the database
        string getCreateSql(string table_name, *hash opt) {
            string sql = sprintf("create %sindex %s on %s (%s)", unique ? "unique " : "", name, table_name, (foldl $1 + ", " + $2, columns.keyIterator()));

            *string ts = opt.index_tablespace ? opt.index_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            if (opt.compute_statistics)
                sql += " compute statistics";

            return sql;
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current index, @ref Qore::False "False" if not
        bool equalImpl(AbstractIndex ix) {
            return True;
        }

        #! returns a string that can be used to rename the index in the database
        string getRenameSql(string table_name, string new_name) {
            return sprintf("alter index %s rename to %s", name, new_name);
        }
    }

    public class OracleForeignConstraint inherits AbstractForeignConstraint {
        public {
            #! @ref Qore::True "True" if the constraint is enabled, @ref Qore::False "False" if not
            bool enabled;
        }

        constructor(string n, Columns c, ForeignConstraintTarget t, bool e) : AbstractForeignConstraint(n, c, t) {
            enabled = e;
        }

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s foreign key (%s) references %s (%s)", table_name, name, (foldl $1 + ", " + $2, columns.keys()), target.table, (foldl $1 + ", " + $2, target.columns.keys()));
        }

        string getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }

        #! returns a string that can be used to temporarily disable the constraint from the database
        string getDisableSql(string table_name) {
            return sprintf("alter table %s disable constraint %s", table_name, name);
        }

        #! returns a string that can be used to enable the constraint in the database
        string getEnableSql(string table_name, *hash opt) {
            return sprintf("alter table %s enable constraint %s", table_name, name);
        }
    }

    public class OracleCheckConstraint inherits AbstractCheckConstraint {
        public {
            #! @ref Qore::True "True" if the constraint is enabled, @ref Qore::False "False" if not
            bool enabled;
        }

        constructor(string n, string n_src, bool e = True) : AbstractCheckConstraint(n, n_src) {
            enabled = e;
        }        

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s check (%s)", table_name, name, src);
        }

        string getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }

        #! returns a string that can be used to temporarily disable the constraint from the database
        string getDisableSql(string table_name) {
            return sprintf("alter table %s disable constraint %s", table_name, name);
        }

        #! returns a string that can be used to enable the constraint in the database
        string getEnableSql(string table_name, *hash opt) {
            return sprintf("alter table %s enable constraint %s", table_name, name);
        }
    }

    public class OracleUniqueConstraint inherits AbstractUniqueConstraint {
        public {
            #! @ref Qore::True "True" if the constraint is enabled, @ref Qore::False "False" if not
            bool enabled;

            #! any tablespace for the unique key index
            *string tablespace;

            #! index the constraint is based on
            *string index;
        }

        constructor(string n, hash n_cols, bool e = True, *string ts) : AbstractUniqueConstraint(n, n_cols) {
            enabled = e;
            tablespace = ts;
        }

        #! returns the OracleColumn value of the given key if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code
my any $v = $c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        OracleColumn memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        bool setIndexBase(string ix) {
            if (index && index != ix)
                return False;
            index = ix;
            delete tablespace;
            return True;
        }

        string getCreateSql(string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s unique (%s)", table_name, name, (foldl $1 + ", " + $2, keyIterator()));
            *string ix = opts.index ? opts.index : index;
            if (ix)
                sql += sprintf(" using index %s", ix);
            else {
                *string ts = opts.index_tablespace ? opts.index_tablespace : tablespace;
                if (ts) {
                    sql += sprintf(" using index tablespace %s", ts);
                    if (opts.compute_statistics)
                        sql += " compute statistics";
                }
            }

            return sql;
        }

        string getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }

        #! returns a string that can be used to temporarily disable the constraint from the database
        string getDisableSql(string table_name) {
            return sprintf("alter table %s disable constraint %s", table_name, name);
        }

        #! returns a string that can be used to enable the constraint in the database
        string getEnableSql(string table_name, *hash opt) {
            return sprintf("alter table %s enable constraint %s", table_name, name);
        }
    }

    public class OraclePrimaryKey inherits AbstractPrimaryKey {
        public {
            #! any tablespace for the primary key index
            *string tablespace;

            #! index the constraint is based on
            *string index;
        }

        constructor(string n, *hash c, *string ts) : AbstractPrimaryKey(n, c) {
            tablespace = ts;
        }

        #! returns the OracleColumn value of the given key if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code
my any $v = $c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        OracleColumn memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        bool setIndexBase(string ix) {
            if (index && index != ix)
                return False;
            index = ix;
            delete tablespace;
            return True;
        }

        string getCreateSql(string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s primary key (%s)", table_name, name, (foldl $1 + ", " + $2, keyIterator()));
            *string ix = opts.index ? opts.index : index;
            if (ix)
                sql += sprintf(" using index %s", ix);
            else {
                *string ts = opts.index_tablespace ? opts.index_tablespace : tablespace;
                if (ts) {
                    sql += sprintf(" using index tablespace %s", ts);
                    if (opts.compute_statistics)
                        sql += " compute statistics";
                }
            }

            return sql;
        }

        string getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }

        #! returns a string that can be used to temporarily disable the constraint from the database
        string getDisableSql(string table_name) {
            return sprintf("alter table %s disable constraint %s", table_name, name);
        }

        #! returns a string that can be used to enable the constraint in the database
        string getEnableSql(string table_name, *hash opt) {
            return sprintf("alter table %s enable constraint %s", table_name, name);
        }
    }

    #! class for Oracle sequences
    public class OracleSequence inherits AbstractSequence {
        #! creates the object from the arguments
        constructor(string n_name, number n_start = 1, number n_increment = 1, *softnumber n_end) : AbstractSequence(n_name, n_start, n_increment, n_end) {
        }

        #! returns a string that can be used to create the sequence in the database
        string getCreateSql(*hash opt) {
            string sql = sprintf("create sequence %s start with %d increment by %d ", name, start, increment);
            sql += max ? sprintf("maxvalue %d", max) : "nomaxvalue";
            return sql;
        }

        #! returns a string that can be used to rename the sequence in the database
        string getRenameSql(string new_name) {
            return sprintf("rename %s to %s", name, new_name);
        }
    }

    public class OracleTrigger inherits AbstractTrigger {
        public {
            #! @ref Qore::True "True" if the trigger is enabled, @ref Qore::False "False" if not
            bool enabled;
        }

        constructor(string n, string n_src, bool en = True) : AbstractTrigger(n, n_src) {
            enabled = en;
        }

        softlist getCreateSql(string table_name, *hash opt) {
            return sprintf("create%s trigger %s %s", opt.replace ? " or replace" : "", name, src);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equalImpl(AbstractFunctionBase t) {
            return enabled == cast<OracleTrigger>(t).enabled;
        }

        #! returns a string that can be used to rename the trigger in the database
	softlist getRenameSql(string table_name, string new_name) {
	    return sprintf("alter trigger %s rename to %s", name, new_name);
	}
    }

    public class OracleCodeBase inherits AbstractFunction {
        #! creates the object from the arguments passed
        /** @param n the name of the object
            @param n_type the type of object
            @param n_src the source of the object
         */
        constructor(string n, string n_type, string n_src) : AbstractFunction(n, n_type, n_src) {
        }

        #! returns a string that can be used to create the object in the database
        softlist getCreateSql(*hash opt) {
            return sprintf("create%s %s %s", opt.replace ? " or replace" : "", type, src);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equalImpl(AbstractFunctionBase t) {
            return True;
        }

        #! returns a string that can be used to rename the object in the database
	list getRenameSql(string new_name) {
            list l = ();
            l += getDropSql();
            l += getCreateSql();
            return l;
	}
    }

    public class OracleType inherits OracleCodeBase {
        constructor(string n_name, string n_src) : OracleCodeBase(n_name, "type", n_src) {
        }
    }

    public class OracleFunction inherits OracleCodeBase {
        #! creates the object from the arguments passed
        /** @param n the name of the function
            @param n_src the source of the function
         */
        constructor(string n, string n_src) : OracleCodeBase(n, "function", n_src) {
        }
    }

    public class OracleProcedure inherits OracleCodeBase {
        #! creates the object from the arguments passed
        /** @param n the name of the function
            @param n_src the source of the function
         */
        constructor(string n, string n_src) : OracleCodeBase(n, "procedure", n_src) {
        }
    }

    public class OraclePackage inherits OracleCodeBase {
        private {
            #! package body source
            *string body_src;
        }

        #! creates the object from the arguments passed
        /** @param n the name of the package
            @param n_src the source of the package declaration
            @param n_body_src the package body source
         */
        constructor(string n, string n_src, *string n_body_src) : OracleCodeBase(n, "package", n_src) {
            body_src = n_body_src;
        }

        #! returns a string that can be used to create the package in the database
        list getCreateSql(*hash opt) {
            list l = ();
            # package declaration
            l += sprintf("create%s package %s", opt.replace ? " or replace" : "", src);
            # package body
            if (body_src)
                l += sprintf("create%s package body %s", opt.replace ? " or replace" : "", body_src);
            return l;
        }
    }

    public class OracleMaterializedView inherits OracleCodeBase {
        public {
            bool logging;
            bool use_index;
            *string tablespace;
        }

        #! creates the object from the arguments passed
        /** @param n the name of the materialized view
            @param n_src the source of the materialized view
            @param n_tablespace the optional data tablespace used by the materialized view
            @param n_logging if the materialized view should use logging
            @param n_use_index if the materialized view should use an index
         */
        constructor(string n, string n_src, bool n_logging = True, bool n_use_index = True, *string n_tablespace) : OracleCodeBase(n, "materialized view", n_src) {
            logging = n_logging;
            use_index = n_use_index;
            tablespace = n_tablespace;
        }

        #! returns a string that can be used to create the object in the database
        softlist getCreateSql(*hash opt) {
            string sql = sprintf("create %s %s", type, name);

            *string ts = opt.data_tablespace ? opt.data_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            sql += logging ? " logging" : " nologging";
            sql += use_index ? " using index" : " using no index";

            sql += " as " + src;

            return sql;
        }

        bool equalImpl(AbstractFunctionBase t) {
            OracleMaterializedView mv = cast<OracleMaterializedView>(t);
            return mv.logging == logging && mv.use_index == use_index;
        }
    }

    public class OracleDatabase inherits AbstractDatabase {
        public {
            #! oracle-specific generic creation options
            const OracleCreationOptions = AbstractDatabase::CreationOptions + (
                "compute_statistics": Type::Boolean,
                );

            #! oracle-specific schema description / alignment options
            const OracleAlignSchemaOptions = AbstractDatabase::CreationOptions + OracleCreationOptions;

            #! oracle-specific schema description keys
            const OracleSchemaDescriptionOptions = AbstractDatabase::SchemaDescriptionOptions + (
                "types": Type::Hash,
                "type_map": Type::Hash,

                "packages": Type::Hash,
                "package_map": Type::Hash,

                "materialized_views": Type::Hash,
                "materialized_view_map": Type::Hash,

                #"synonyms": Type::Hash,
                #"synonym_map": Type::Hash,
                );

            #! oracle-specific package description options
            const OraclePackageDescriptionOptions = (
                "src": Type::String,
                "body": Type::String,
                );

            #! oracle-specific materialized view description options
            const OracleMaterializedViewDescriptionOptions = (
                "logging": Type::Boolean,
                "use_index": Type::Boolean,
                "tablespace": Type::String,
                "src": Type::String,
                );
        }

        constructor(AbstractDatasource nds, *hash opts) : AbstractDatabase(nds, opts) {
        }

        private OracleSequence makeSequenceImpl(string name, number start = 1, number increment = 1, *softnumber end, *hash opts) {
            return new OracleSequence(name, start, increment, end);
        }

        private *AbstractSequence getSequenceImpl(string name) {
            *hash row = ds.selectRow("select * from user_sequences where sequence_name = %v", name.upr());
            if (!row)
                return;
            return new OracleSequence(name, row.min_value, row.increment_by, row.max_value == 10000000000000000000000000000n ? NOTHING : row.max_value);
        }

        private OracleFunction makeFunctionImpl(string name, string src, *hash opts) {
            checkSource("function", name, \src);

            return new OracleFunction(name, src);
        }

        private OracleProcedure makeProcedureImpl(string name, string src, *hash opts) {
            checkSource("procedure", name, \src);

            return new OracleProcedure(name, src);
        }

        OraclePackage makePackage(string name, string src, string body, *hash opts) {
            checkSource("package", name, \src);

            return new OraclePackage(name, src, body);
        }

        OraclePackage makePackageFromDescription(string name, hash ph, *hash opts) {
            validateOptionsIntern("PACKAGE-DESCRIPTION-ERROR", OraclePackageDescriptionOptions, \ph);
            if (!ph.src)
                throw "PACKAGE-DESCRIPTION-ERROR", sprintf("package %y: description hash has no 'src' key (keys: %y)", name, ph.keys());

            checkSource("package", name, \ph.src);
            if (ph.body)
                checkSource("package", name, \ph.body);

            return new OraclePackage(name, ph.src, ph.body);
        }

        OracleType makeType(string name, string src, *hash opts) {
            return new OracleType(name, sprintf("%s as %s", name, src));
        }

        OracleMaterializedView makeMaterializedView(string name, string src, bool logging = True, bool use_index = True, *string tablespace, *hash opts) {
            return new OracleMaterializedView(name, src, logging, use_index, tablespace);
        }

        OracleMaterializedView makeMaterializedViewFromDescription(string name, hash mvh, *hash opts) {
            validateOptionsIntern("MATERIALIZEDVIEW-DESCRIPTION-ERROR", OracleMaterializedViewDescriptionOptions, \mvh);
            if (!mvh.src)
                throw "MATERIALIZEDVIEW-DESCRIPTION-ERROR", sprintf("materialized view %y: description hash has no 'src' key (keys: %y)", name, mvh.keys());

            return new OracleMaterializedView(name, mvh.src, mvh.logging, mvh.use_index, mvh.tablespace);
        }

        private list getDropSchemaSqlImpl(hash schema_hash, *hash opt) {
            list l = ();

            if (opt.start) {
                # drop materialized views
                list tl = dropSqlUnlocked("materialized_view", schema_hash, \getMaterializedView(), \makeMaterializedViewFromDescription(), opt, Type::Hash);
                if (tl) l += tl;

                # drop packages
                tl = dropSqlUnlocked("package", schema_hash, \getPackage(), \makePackageFromDescription(), opt, Type::Hash);
                if (tl) l += tl;

                return l;
            }
            
            # drop types
            list tl = dropSqlUnlocked("type", schema_hash, \getType(), \makeType(), opt, Type::String);
            if (tl) l += tl;

            return l;
        }

        private list getAlignSqlImpl(hash schema_hash, *hash opt) {
            list l = ();

            if (opt.start) {
                # create types
                list tl = alignCodeUnlocked("type", schema_hash, \getType(), \makeType(), opt, Type::String);
                if (tl) l += tl;

                return l;
            }
            
            # create packages
            list tl = alignCodeUnlocked("package", schema_hash, \getPackage(), \makePackageFromDescription(), opt, Type::Hash);
            if (tl) l += tl;

            # create materialized views
            tl = alignCodeUnlocked("materialized_view", schema_hash, \getMaterializedView(), \makeMaterializedViewFromDescription(), opt, Type::Hash);
            if (tl) l += tl;

            return l;
        }

        private *OracleFunction getFunctionImpl(string name) {
            *string src = getSource("FUNCTION", name);
            if (!src)
                return;

            return new OracleFunction(name, src);
        }

        private *OracleProcedure getProcedureImpl(string name) {
            *string src = getSource("PROCEDURE", name);
            if (!src)
                return;

            return new OracleProcedure(name, src);
        }

        *OraclePackage getPackage(string name) {
            *string src = getSource("PACKAGE", name);
            if (!src)
                return;

            *string body_src = getSource("PACKAGE BODY", name);
            return new OraclePackage(name, src, body_src);
        }

        *OracleType getType(string name) {
            *string src = getSource("TYPE", name);
            if (!src)
                return;

            return new OracleType(name, src);
        }

        *OracleMaterializedView getMaterializedView(string name) {
            *hash row = ds.selectRow("select * from user_mviews mv, user_tables t where mview_name = %v and mview_name = table_name", name.upr());
            if (!row)
                return;

            if (!native_case)
                map row.$1 = row.$1.lwr(), ("tablespace_name");

            return new OracleMaterializedView(name, row.query, row.logging == "YES", row.use_no_index == "N", row.tablespace_name);
        }

        private *string getSource(string type, string name) {
            *list l = ds.select("select text from user_source where type = %v and name = %v order by line", type, name.upr()).text;
            if (!l)
                return;
            string src = foldl $1 + $2, l;

            if (!regex(src, "^" + type + "( |\n)", RE_Caseless))
                throw "SOURCE-ERROR", sprintf("source to %s %y does not begin with the type name: %y", type, name, src.substr(0, 50));

            # remove the type name from the beginning of the string
            splice src, 0, type.size() + 1;

            checkSource(type, name, \src);
            return src;
        }
        
        private checkSource(string type, string name, reference src) {
            # remove whitespace from the beginning and end of the string
            trim src;

            # ensure the name of the object is at the beginning of the string
            if (!regex(src, "^" + name, RE_Caseless))
                throw "SOURCE-ERROR", sprintf("source to %s %y does not begin with the %s name: %y", type, name, type, src.substr(0, 50));
        }

        #! returns a list of string synonym names in the database
        list listSynonyms() {
            return getListIntern("SYNONYM");
        }
        
        #! returns an iterator listing the string synonym names in the database
        ListIterator synonymIterator() {
            return listSynonyms().iterator();            
        }

        list listTypes() {
            return getListIntern("TYPE");
        }

        #! returns an iterator listing the string type names in the database
        ListIterator typeIterator() {
            return listTypes().iterator();            
        }

        private list listTablesImpl() {
            return getListIntern(ds.select("select table_name from user_tables").table_name);
        }

        private list listFunctionsImpl() {
            return getListIntern("FUNCTION");
        }

        private list listProceduresImpl() {
            return getListIntern("PROCEDURE");
        }

        private list listSequencesImpl() {
            return getListIntern("SEQUENCE");
        }

        private list listViewsImpl() {
            return getListIntern("VIEW");
        }

        private list getListIntern(string type) {
            return getListIntern(ds.select("select object_name from user_objects where object_type = %v", type).object_name);
        }

        private list getListIntern(list l) {
            return native_case ? l : (map $1.lwr(), l);
        }

        private string getCreateSqlImpl(list l) {
            return OracleDatabase::getCreateSql(l);
        }

        static string getCreateSql(list l) {
            return !l ? "" : foldl $1 + "\n" + $2, (map sprintf("%s%s", $1, $1 =~ /(;|\$)$/ ? "" : ";"), l);
        }

        #! returns driver-specific options to the base abstract class
        private hash getCreationOptions() {
            return OracleCreationOptions;
        }

        #! returns driver-specific options to the base abstract class
        private hash getAlignSchemaOptions() {
            return OracleAlignSchemaOptions;
        }

        #! returns driver-specific options to the base abstract class
        private hash getSchemaDescriptionOptions() {
            return OracleSchemaDescriptionOptions;
        }
    }

    public class OracleTable inherits AbstractTable {
        public {
            const OraTypeMap = (
                "number": ("qore": Type::Number, "size": SZ_NUM, "size_range": (1, 38), "scale_range": (-84, 127)),
                "varchar2": ("qore": Type::String, "size": SZ_MAND, "size_range": (1, 4000), "is_char": True),
                "char": ("qore": Type::String, "size": SZ_MAND, "size_range": (1, 4000), "is_char": True),
                "date": ("qore": Type::Date,),
		"timestamp": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 9)),
		"timestamp with time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 9)),
		"timestamp with local time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 9)),
                "timestamp(0)": ("qore": Type::Date,),
                "timestamp(1)": ("qore": Type::Date,),
                "timestamp(2)": ("qore": Type::Date,),
                "timestamp(3)": ("qore": Type::Date,),
                "timestamp(4)": ("qore": Type::Date,),
                "timestamp(5)": ("qore": Type::Date,),
                "timestamp(6)": ("qore": Type::Date,),
                "timestamp(7)": ("qore": Type::Date,),
                "timestamp(8)": ("qore": Type::Date,),
                "timestamp(9)": ("qore": Type::Date,),
                "timestamp(0) with time zone": ("qore": Type::Date,),
                "timestamp(1) with time zone": ("qore": Type::Date,),
                "timestamp(2) with time zone": ("qore": Type::Date,),
                "timestamp(3) with time zone": ("qore": Type::Date,),
                "timestamp(4) with time zone": ("qore": Type::Date,),
                "timestamp(5) with time zone": ("qore": Type::Date,),
                "timestamp(6) with time zone": ("qore": Type::Date,),
                "timestamp(7) with time zone": ("qore": Type::Date,),
                "timestamp(8) with time zone": ("qore": Type::Date,),
                "timestamp(9) with time zone": ("qore": Type::Date,),
                "timestamp(0) with local time zone": ("qore": Type::Date,),
                "timestamp(1) with local time zone": ("qore": Type::Date,),
                "timestamp(2) with local time zone": ("qore": Type::Date,),
                "timestamp(3) with local time zone": ("qore": Type::Date,),
                "timestamp(4) with local time zone": ("qore": Type::Date,),
                "timestamp(5) with local time zone": ("qore": Type::Date,),
                "timestamp(6) with local time zone": ("qore": Type::Date,),
                "timestamp(7) with local time zone": ("qore": Type::Date,),
                "timestamp(8) with local time zone": ("qore": Type::Date,),
                "timestamp(9) with local time zone": ("qore": Type::Date,),
                "interval year(0) to month": ("qore": Type::Date,),
                "interval year(1) to month": ("qore": Type::Date,),
                "interval year(2) to month": ("qore": Type::Date,),
                "interval year(3) to month": ("qore": Type::Date,),
                "interval year(4) to month": ("qore": Type::Date,),
                "interval year(5) to month": ("qore": Type::Date,),
                "interval year(6) to month": ("qore": Type::Date,),
                "interval year(7) to month": ("qore": Type::Date,),
                "interval year(8) to month": ("qore": Type::Date,),
                "interval year(9) to month": ("qore": Type::Date,),
                "interval day(0) to second(0)": ("qore": Type::Date,),
                "interval day(0) to second(1)": ("qore": Type::Date,),
                "interval day(0) to second(2)": ("qore": Type::Date,),
                "interval day(0) to second(3)": ("qore": Type::Date,),
                "interval day(0) to second(4)": ("qore": Type::Date,),
                "interval day(0) to second(5)": ("qore": Type::Date,),
                "interval day(0) to second(6)": ("qore": Type::Date,),
                "interval day(0) to second(7)": ("qore": Type::Date,),
                "interval day(0) to second(8)": ("qore": Type::Date,),
                "interval day(0) to second(9)": ("qore": Type::Date,),
                "interval day(1) to second(0)": ("qore": Type::Date,),
                "interval day(1) to second(1)": ("qore": Type::Date,),
                "interval day(1) to second(2)": ("qore": Type::Date,),
                "interval day(1) to second(3)": ("qore": Type::Date,),
                "interval day(1) to second(4)": ("qore": Type::Date,),
                "interval day(1) to second(5)": ("qore": Type::Date,),
                "interval day(1) to second(6)": ("qore": Type::Date,),
                "interval day(1) to second(7)": ("qore": Type::Date,),
                "interval day(1) to second(8)": ("qore": Type::Date,),
                "interval day(1) to second(9)": ("qore": Type::Date,),
                "interval day(2) to second(0)": ("qore": Type::Date,),
                "interval day(2) to second(1)": ("qore": Type::Date,),
                "interval day(2) to second(2)": ("qore": Type::Date,),
                "interval day(2) to second(3)": ("qore": Type::Date,),
                "interval day(2) to second(4)": ("qore": Type::Date,),
                "interval day(2) to second(5)": ("qore": Type::Date,),
                "interval day(2) to second(6)": ("qore": Type::Date,),
                "interval day(2) to second(7)": ("qore": Type::Date,),
                "interval day(2) to second(8)": ("qore": Type::Date,),
                "interval day(2) to second(9)": ("qore": Type::Date,),
                "clob": ("qore": Type::String,),
                "blob": ("qore": Type::Binary,),
                "long": ("qore": Type::Binary,),
                "raw": ("qore": Type::Binary, "size": SZ_MAND, "size_range": (1, 2000)),
                "bfile": ("qore": Type::Binary,),
                "binary_float": ("qore": Type::Float,),
                "binary_double": ("qore": Type::Float,),
                "rowid": ("qore": Type::String,),
                "urowid": ("qore": Type::String, "size": SZ_OPT, "size_range": (1, 4000)),
                );

            const QoreTypeMap = (
                "integer": "number",
                "float": "number",
                "number": "number",
                "string": "varchar2",
                "date": "timestamp(6)",
                "binary": "blob",
                SqlUtil::CHAR: "char",
                SqlUtil::CLOB: "clob",
                SqlUtil::BLOB: "blob",
                );

            const OraColumnOptions = AbstractTable::ColumnOptions + (
                "character_semantics": Type::Boolean,
                );

            const OracleIndexOptions = AbstractTable::IndexOptions + (
                "compute_statistics": Type::Boolean,
                );

            const OracleConstraintOptions = OracleIndexOptions + (
                "index": Type::String,
                );

            #! Oracle table creation options
            const OracleTableCreationOptions = AbstractTable::TableCreationOptions + OracleConstraintOptions;

            const OracleAlignTableOptions = AbstractTable::AlignTableOptions + OracleTableCreationOptions;
        }

        private {
	    # schema name
            string schema;

	    # tablespace name
            string tablespace;

	    # is the table read only?
            bool readonly;
	    
	    # table comment
            *string comment;

            #! does the current oracle driver support long values?
            bool has_long;
        }

        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
            # see if there is a schema in the name
            *string sstr = (nname =~ x/^(\w+)\.\w+/)[0];
            if (sstr) {
                schema = sstr;
                splice nname, 0, schema.size() + 1;
                name = nname;
            }
            else
		schema = ds.getUserName();

            # the oracle driver >= 3.0 supports selecting from LONG columns
            has_long = compare_version("3.0", getModuleHash().oracle.version) >= 0;
        }

        private bool checkExistenceImpl() {
            try {
                setTableInfoIntern();
            }
            catch (hash ex) {
                if (ex.err == "TABLE-ERROR")
                    return False;
                rethrow;
            }
            return True;
        }

	private setTableInfoIntern() {
	    hash row = (schema.lwr() == ds.getUserName().lwr()) ? setTable() : setSchemaTable();

            tablespace = row.tablespace_name;
            readonly = row.read_only == "YES";
            if (!native_case)
                tablespace = tablespace.lwr();

            # get any comment
            any cm = ds.selectRow("select * from all_tab_comments where owner = %v and table_name = %v", schema.upr(), name.upr()).comments;
            comment = cm ? cm : NOTHING;

	    inDb = True;
	}

        string getSqlName() {
            return sprintf("%s.%s", schema, name);
        }

        private hash setSchemaTable() {
            # get the table information if possible
            *hash row = ds.selectRow("select * from all_tables where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (!row)
                throw "TABLE-ERROR", sprintf("table %y.%y does not exist or is not accessible to this user (%s)", schema, name, getDBString());
            return row;
        }

        private hash setTable() {
            # see if the current user has the table
            *hash row = ds.selectRow("select * from user_tables where table_name = %v", name.upr());
            if (row) {
                schema = getUserSchema();
                return row;
            }

            bool pub = False;
            # see if there is a user synonym with this name
            row = ds.selectRow("select * from user_synonyms where synonym_name = %v", name.upr());
            if (!row) {
                # see if there is a public synonym with this name
                row = ds.selectRow("select * from all_synonyms where owner = 'PUBLIC' and synonym_name = %v", name.upr());
                if (!row)
                    throw "TABLE-ERROR", sprintf("table %y or synonym %y does not exist or is not accessible to this user (%s)", name, name, getDBString());
                pub = True;
            }
            
            # update the table name if necessary
            string orig_name = name;
            if (name.upr() != row.table_name) {
                name = row.table_name;
                if (!native_case)
                    name = name.lwr();
            }
            
            schema = row.table_owner;
            if (!native_case)
                schema = schema.lwr();
            
            # get the table information if possible
            row = ds.selectRow("select * from all_tables where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (!row)
                throw "TABLE-ERROR", sprintf("%y is a %ssynonym pointing to table %y.%y which does not exist or is not accessible to this user (%s)", orig_name, pub ? "public " : "", schema, name, getDBString());
            return row;
        }

        private string getUserSchema() {
            string rv = ds.getUserName();
            if (native_case)
                rv = rv.upr();
            return rv;
        }

        private string getDBString() {
            return sprintf("%s@%s", ds.getUserName(), ds.getDBName());
        }

        string getSchemaName() {
            return schema;
        }

        *string getTablespaceName() {
            return tablespace;
        }

        *string getComment() {
            return comment;
        }

        bool readOnly() {
            return readonly;
        }

        private hash getColumnOptions() {
            return OraColumnOptions;
        }

        private Columns describeImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            # get column descriptions
            *hash qh = ds.select("select col.column_name, data_type, data_length, data_precision, data_scale, nullable, data_default, char_length, char_used, comments from all_tab_columns col, all_col_comments com where col.owner = %v and col.table_name = %v and com.owner = col.owner and com.table_name = col.table_name and com.column_name = col.column_name order by column_id", schema.upr(), name.upr());
            if (!qh.column_name)
                throw "TABLE-ERROR", sprintf("cannot retrieve table information for table %y in %y", name, dsdesc);

            hash rv;
            foreach hash row in (qh.contextIterator()) {
                *hash th = OraTypeMap.(row.data_type.lwr());
                int size = row.data_type == "NUMBER" && row.data_precision ? row.data_precision : row.data_length;
                switch (row.data_type) {
                    case "ROWID":
                    case "UROWID":
                    case "DATE":
                    case "BINARY_FLOAT":
                    case "BINARY_DOUBLE":
                    case =~ /^TIMESTAMP/:
                    case =~ /^INTERVAL/:
                    case "BFILE":
                    case "BLOB":
                    case "CLOB": size = 0; break;
                }
                if (!native_case) {
                    row.column_name = row.column_name.lwr();
                    row.data_type = row.data_type.lwr();
                }
                trim row.data_default;

                OracleColumn c;
                if (row.data_precision) 
                    c = new OracleNumberColumn(row.column_name, row.data_type, th.qore, row.data_precision, row.nullable == "Y", row.data_default ? row.data_default : NOTHING, row.comments ? row.comments : NOTHING, row.char_used == "C", row.data_length, row.data_scale);
                else
                    c = new OracleColumn(row.column_name, row.data_type, th.qore, size, row.nullable == "Y", row.data_default ? row.data_default : NOTHING, row.comments ? row.comments : NOTHING, th.is_char, row.char_used == "C", row.data_length);

                rv.(row.column_name) = c;
            }

            return new Columns(rv);
        }

        private *OraclePrimaryKey getPrimaryKeyImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            hash rv;

            # get primary key description
            *hash qh = ds.select("select cons.constraint_name, cols.column_name, cols.position, cons.status, cons.owner from all_constraints cons, all_cons_columns cols where cols.owner = %v and cols.table_name = %v and cons.constraint_type = 'P' and cons.owner = %v and cons.constraint_name = cols.constraint_name order by cols.position", schema.upr(), name.upr(), schema.upr());
            if (!qh.constraint_name)
                return;

            foreach string col in (qh.column_name) {
                string cn = native_case ? col : col.lwr();
                rv{cn} = columns{cn};
            }

            string pkname = qh.constraint_name[0];
            if (!native_case)
                pkname = pkname.lwr();
            return new OraclePrimaryKey(pkname, rv);
        }

        private Indexes getIndexesImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            hash rv;

            # get index description
            *hash qh = ds.select("select index_name, index_type, uniqueness, tablespace_name from all_indexes where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (qh.index_name) {
                hash ih;

                # get column info for all indexes in 1 query
                *hash iqh = ds.select("select c.index_name, c.column_name, e.column_expression from all_ind_columns c left join all_ind_expressions e on (c.table_owner = e.index_owner and c.index_name = e.index_name and c.table_name = e.table_name) where c.table_owner = %v and c.table_name = %v order by c.index_name, c.column_position", schema.upr(), name.upr());
                foreach hash row in (iqh.contextIterator()) {
                    if (!native_case)
                        map row.$1 = row.$1.lwr(), ("index_name", "column_name", "column_expression"), row.$1;
                    # process function indexes
                    if (row.column_expression) {
                        row.column_expression =~ s/"//g;
                        ih{row.index_name}{row.column_expression} = hash();
                    }
                    else
                        ih{row.index_name}{row.column_name} = columns{row.column_name};
                }
                
                foreach hash row in (qh.contextIterator()) {
                    if (!native_case) {
                        row.index_name = row.index_name.lwr();
                        row.tablespace_name = row.tablespace_name.lwr();
                    }
                    # skip system indexes
                    if (!ih{row.index_name})
                        continue;
                    rv.(row.index_name) = new OracleIndex(row.index_name, row.uniqueness == "UNIQUE", ih{row.index_name}, row.index_type, row.tablespace_name);
                }

            }

            return new Indexes(rv);
        }

        private ForeignConstraints getForeignConstraintsImpl(*hash opts) {
	    if (!tablespace)
		setTableInfoIntern();

            hash ch;

            # get foreign referential constraints
            *hash qh = ds.select("select constraint_name, status from user_constraints where owner = %v and table_name = %v and constraint_type = 'R'", schema.upr(), name.upr());
            if (qh.status) {
                hash rv;
                foreach hash row in (qh.contextIterator()) {
                    if (!native_case)
                        row.constraint_name = row.constraint_name.lwr();
                    rv.(row.constraint_name) = (
                        "enabled": row.status == "ENABLED",
                        );
                }
                qh = ds.select("select c.constraint_name, status, cols1.column_name source_column, cols1.position, cols2.table_name target_table, cols2.column_name target_column from all_constraints c, all_cons_columns cols1, all_cons_columns cols2 where c.owner = %v and c.table_name = %v and c.constraint_name = cols1.constraint_name and constraint_type = 'R' and c.r_constraint_name = cols2.constraint_name and cols1.position = cols2.position and cols1.owner = c.owner and cols2.owner = c.owner order by cols1.position", schema.upr(), name.upr());
                foreach hash row in (qh.contextIterator()) {
                    if (!native_case) {
                        row.constraint_name = row.constraint_name.lwr();
                        row.source_column = row.source_column.lwr();
                        row.target_column = row.target_column.lwr();
                        row.target_table = row.target_table.lwr();
                    }
                    reference c = \rv.(row.constraint_name);
                    c.columns.(row.source_column) = columns{row.source_column};
                    c.target.table = row.target_table;
                    c.target.columns.(row.target_column) = True;
                }

                foreach hash c in (rv.pairIterator()) {
                    # get a description of the target table's columns
                    Columns targ_columns = getReferencedTableColumnsUnlocked(c.value.target.table, \opts.table_cache);
                    ForeignConstraintTarget fct(c.value.target.table, targ_columns.subset(c.value.target.columns.keys()));
                    ch.(c.key) = new OracleForeignConstraint(c.key, new Columns(c.value.columns), fct, c.value.enabled);
                }
            }

            return new ForeignConstraints(ch);
        }

        private Constraints getConstraintsImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            # if we cannot select "long" values then skip this: all_constraints.search_condition is a LONG for example
            if (!has_long)
                return new Constraints();

            # get only user check constraints
            *hash qh = ds.select("select constraint_name, search_condition, status from all_constraints where owner = %v and table_name = %v and constraint_type = 'C' and generated != 'GENERATED NAME'", schema.upr(), name.upr());
            hash rv;
            foreach hash row in (qh.contextIterator()) {
                if (!native_case)
                    row.constraint_name = row.constraint_name.lwr();
                rv.(row.constraint_name) = new OracleCheckConstraint(row.constraint_name, row.search_condition, row.status == "ENABLED");
            }
            
            Constraints c(rv);

            # now get unique constraints
            qh = ds.select("select c.constraint_name, status, cols.column_name, cols.position, status from all_constraints c, all_cons_columns cols where c.owner = %v and c.table_name = %v and c.constraint_name = cols.constraint_name and constraint_type = 'U' and cols.owner = c.owner and generated != 'GENERATED NAME' order by cols.position", schema.upr(), name.upr());
            delete rv;
            foreach hash row in (qh.contextIterator()) {
                if (!native_case)
                    map row.$1 = row.$1.lwr(), ("constraint_name", "column_name");
                reference ch = \rv.(row.constraint_name);
                if (!ch)
                    ch = new OracleUniqueConstraint(row.constraint_name, hash(), row.status == "ENABLED");
                ch.add(row.column_name, columns{row.column_name});
            }
            
            # add unique constraints to constraint hash
            map c.add($1.key, $1.value), rv.pairIterator();

            return c;
        }

        private Triggers getTriggersImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            hash rv;

            # get trigger description
            *hash qh = ds.select("select * from all_triggers where owner = %v and table_name = %v", schema.upr(), name.upr());
            foreach hash row in (qh.contextIterator()) {
                if (!native_case)
                    map row.$1 = row.$1.lwr(), ("trigger_name", "trigger_type", "triggering_event", "referencing_names");
                #printf("%y: %s\n", row.trigger_name, row.description);

                # replace newlines with spaces
                row.description =~ s/\n/ /g;
                trim row.description;

                # remove trigger name from description line
                splice row.description, 0, row.trigger_name.size() + 1;
                rv{row.trigger_name} = new OracleTrigger(row.trigger_name, row.description + "\n" + row.trigger_body, row.status == "ENABLED");
            }

            return new Triggers(rv);
        }

        string getCreateTableSqlImpl(*hash opt) {
            string sql = sprintf("create table %s (\n", name);

            sql += foldl $1 + ",\n" + $2, (map "  " + $1.getCreateSql(), columns.iterator());
            sql += "\n)";

            *string ts = opt.data_tablespace ? opt.data_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            return sql;
        }

        private *list getCreateIndexesSqlImpl(*hash opt) {
            return map $1.getCreateSql(name, opt), indexes.iterator();
        }

        private *string getCreatePrimaryKeySqlImpl(*hash opt) {
            return primaryKey.getCreateSql(name, opt);
        }
        
        private *list getCreateForeignConstraintsSqlImpl(*hash opt) {
            return map $1.getCreateSql(name, opt), foreignConstraints.iterator();
        }

        private *list getCreateConstraintsSqlImpl(*hash opt) {
            return map $1.getCreateSql(name, opt), constraints.iterator();
        }

        private *list getCreateMiscSqlImpl(*hash opt, bool cache) {
	    if (cache)
		getColumnsUnlocked();
            return map AbstractDatabase::doCallback(opt, sprintf("comment on column %s.%s is '%s'", name, $1.name, $1.comment), "adding comment to column %s.%s", name, $1.name), columns.iterator(), $1.comment;
        }

        private *list getCreateTriggersSqlImpl(*hash opt) {
            list l = ();
            map l += $1.getCreateSql(name, opt), triggers.iterator();
            return l;
        }

        private string getCreateSqlImpl(list l) {
            return OracleDatabase::getCreateSql(l);
        }

        private string getRenameSqlImpl(string new_name) {
            return sprintf("alter table %s rename to %s", getSqlName(), new_name);
        }

        private AbstractColumn addColumnImpl(string cname, hash opt, bool nullable = True) {
            if (opt.precision)
                return new OracleNumberColumn(cname, opt.native_type, opt.qore_type, opt.precision, nullable, opt.default_value, opt.comment, opt.character_semantics, 0, opt.scale);
            return new OracleColumn(cname, opt.native_type, opt.qore_type, opt.size, nullable, opt.default_value, opt.comment, opt.local_def.is_char, opt.character_semantics, 0);
        }

        private AbstractPrimaryKey addPrimaryKeyImpl(string cname, hash ch, *hash opt) {
            return new OraclePrimaryKey(cname, ch, opt.index_tablespace);
        }

        private AbstractIndex addIndexImpl(string iname, bool enabled, hash ch, *hash opt) {
            return new OracleIndex(iname, enabled, ch, "normal", opt.index_tablespace);
        }

        private AbstractForeignConstraint addForeignConstraintImpl(string cname, hash ch, string table, hash tch, *hash opt) {
            ForeignConstraintTarget fct(table, new Columns(tch));
            return new OracleForeignConstraint(cname, new Columns(ch), fct, True);
        }

        private AbstractCheckConstraint addCheckConstraintImpl(string cname, string src, *hash opt) {
            return new OracleCheckConstraint(cname, src);
        }

        private AbstractUniqueConstraint addUniqueConstraintImpl(string cname, hash ch, *hash opt) {
            return new OracleUniqueConstraint(cname, ch, True, opt.index_tablespace);
        }

        private AbstractTrigger addTriggerImpl(string tname, string src, *hash opt) {
            return new OracleTrigger(tname, src);
        }

        private bool tryInsertImpl(string sql, hash row) {
            try {
                ds.vexec(sql, row.values());
            }
            catch (hash ex) {
                if (ex.desc =~ /ORA-00001/)
                    return False;
                rethrow;
            }
            return True;
        }

        private *list getAlignSqlImpl(AbstractTable t, *hash opt) {
        }

        private hash getQoreTypeMapImpl() {
            return QoreTypeMap;
        }

        private hash getTypeMapImpl() {
            return OraTypeMap;
        }

        private hash getIndexOptions() {
            return OracleIndexOptions;
        }

        private hash getConstraintOptions() {
            return OracleConstraintOptions;
        }

        private hash getTableCreationOptions() {
            return OracleTableCreationOptions;
        }

        private hash getAlignTableOptions() {
            return OracleAlignTableOptions;
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument; returns NOTHING if the type cannot be converted to an SQL string
        private *string getSqlValueImpl(any v) {
            switch (v.typeCode()) {
                case NT_FLOAT:
                case NT_INT: return v.toStr();

                case NT_NUMBER: return string(v);

                # double any single quotes in strings
                case NT_STRING: v =~ s/'/''/g; return "'" + v + "'";

                case NT_NULL:
                case NT_NOTHING: return "null";

                case NT_BOOLEAN: return v ? "1" : "0";

                case NT_DATE: return sprintf("to_date('%s', 'YYYYMMDDHH24MISS')", v.format("YYYYMMDDHHmmSS"));
            }
        }

        private bool emptyImpl() {
            return True;
        }

        private setupTableImpl(hash desc, *hash opt) {
        }
    }
}
