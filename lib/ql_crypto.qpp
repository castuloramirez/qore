/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  ql_crypto.qpp
  
  Qore Programming Language

  Copyright 2003 - 2011 David Nichols

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <qore/Qore.h>
#include <qore/intern/ql_crypto.h>

#include <openssl/evp.h>
#include <openssl/des.h>

#include <stdio.h>
#include <stdlib.h>

#define QCRYPTO_DECRYPT 0
#define QCRYPTO_ENCRYPT 1

// NOTE: the trailing null ('\0') is not included when encrypting strings or calculating digests

// default initialization vector
static unsigned char def_iv[] = { 0, 0, 0, 0, 0, 0, 0, 0 };

#define MD2_ERR "MD2-DIGEST-ERROR"
#define MD4_ERR "MD4-DIGEST-ERROR"
#define MD5_ERR "MD5-DIGEST-ERROR"
#define SHA_ERR "SHA-DIGEST-ERROR"
#define SHA1_ERR "SHA1-DIGEST-ERROR"
static const char SHA224_ERR[] = "SHA224-DIGEST-ERROR";
static const char SHA256_ERR[] = "SHA256-DIGEST-ERROR";
static const char SHA384_ERR[] = "SHA384-DIGEST-ERROR";
static const char SHA512_ERR[] = "SHA512-DIGEST-ERROR";
#define DSS_ERR "DSS-DIGEST-ERROR"
#define DSS1_ERR "DSS1-DIGEST-ERROR"
static const char MDC2_ERR[] = "MDC2-DIGEST-ERROR";
#define RIPEMD160_ERR "RIPEMD160-DIGEST-ERROR"

class BaseHelper {
protected:
   unsigned char *input;
   int input_len;

   DLLLOCAL void setInput(const AbstractQoreNode *pt) {
      if (pt->getType() == NT_STRING) {
	 const QoreStringNode *str = reinterpret_cast<const QoreStringNode *>(pt);
	 input = (unsigned char *)str->getBuffer();
	 input_len = str->strlen();
	 return;
      }

      const BinaryNode *b = reinterpret_cast<const BinaryNode *>(pt);
      input = (unsigned char *)b->getPtr();
      input_len = b->size();
   }
};

class DigestHelper : public BaseHelper {
private:
   unsigned char md_value[EVP_MAX_MD_SIZE];
   unsigned int md_len;

public:
   DLLLOCAL DigestHelper(const QoreListNode *params) {
      setInput(get_param(params, 0));
   }

   DLLLOCAL int doDigest(const char *err, const EVP_MD *md, ExceptionSink *xsink) {
      EVP_MD_CTX mdctx;
      EVP_MD_CTX_init(&mdctx);
	 
      EVP_DigestInit_ex(&mdctx, md, 0);

      if (!EVP_DigestUpdate(&mdctx, input, input_len) || !EVP_DigestFinal_ex(&mdctx, md_value, &md_len)) {
	 EVP_MD_CTX_cleanup(&mdctx);
	 xsink->raiseException(err, "error calculating digest");
	 return -1;
      }

      EVP_MD_CTX_cleanup(&mdctx);
      return 0;
   }

   DLLLOCAL QoreStringNode *getString() const {
      QoreStringNode *str = new QoreStringNode();
      for (unsigned i = 0; i < md_len; i++)
	 str->sprintf("%02x", md_value[i]);

      return str;
   }

   DLLLOCAL BinaryNode *getBinary() const {
      BinaryNode *b = new BinaryNode();
      b->append(md_value, md_len);
      return b;
   }      
};

class CryptoHelper : public BaseHelper {
private:
   unsigned char *iv, *output;
   int output_len;
   const QoreEncoding* qe;

   DLLLOCAL const char *getOrdinal(int n) {
      assert(n > 0 && n <= 3);
      return n == 1 ? "first" : (n == 2 ? "second" : "third");
   }

   DLLLOCAL void setKey(const QoreListNode *args, int n) {
      assert(n > 0 && n <= 3);
      const AbstractQoreNode *pt = get_param(args, n);
      if (pt->getType() == NT_STRING) {
	 const QoreStringNode *str = reinterpret_cast<const QoreStringNode *>(pt);
	 key[n - 1] = (unsigned char *)str->getBuffer();
	 keylen[n - 1] = str->strlen();
	 return;
      }
	 
      const BinaryNode *b = reinterpret_cast<const BinaryNode *>(pt);
      key[n - 1] = (unsigned char *)b->getPtr();
      keylen[n - 1] = b->size();
   }

   DLLLOCAL void setEncoding(const QoreListNode* args, int n) {
      const QoreStringNode* encoding = test_string_param(args, n);
      qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   }

   // set the initialization vector (used with hard typing)
   DLLLOCAL int setIV(const char *err, const AbstractQoreNode *pt, ExceptionSink *xsink) {
      assert(pt);
      if (pt->getType() == NT_STRING) {
	 const QoreStringNode *str = reinterpret_cast<const QoreStringNode *>(pt);
	 if (str->strlen() < 8) {
	    xsink->raiseException(err, "the input vector must be at least 8 bytes long (%d bytes passed)", str->strlen());
	    return -1;
	 }
	 iv = (unsigned char *)str->getBuffer();
	 return 0;
      }
      
      assert(pt->getType() == NT_BINARY);
      const BinaryNode *b = reinterpret_cast<const BinaryNode *>(pt);
      if (b->size() < 8) {
	 xsink->raiseException(err, "the input vector must be at least 8 bytes long (%d bytes passed)", b->size());
	 return -1;
      }
      iv = (unsigned char *)b->getPtr();
      return 0;
   }

public:
   unsigned char *key[3];
   int keylen[3];

   DLLLOCAL CryptoHelper() : iv(0), output(0), output_len(0), qe(QCS_DEFAULT) {
   }

   DLLLOCAL ~CryptoHelper() {
      if (output)
	 free(output);
   }

   DLLLOCAL BinaryNode *getBinary() {
      BinaryNode *b = new BinaryNode(output, output_len);
      output = 0;
      return b;
   }

   DLLLOCAL QoreStringNode *getString(const QoreEncoding *enc = QCS_DEFAULT) {
      // create the string
      QoreStringNode *str = new QoreStringNode((char *)output, output_len, output_len, enc);
      // add trailing '\0'
      str->terminate(output_len);

      output = 0;
      return str;
   }

   DLLLOCAL int setSingleKey(const char *err, const QoreListNode *params, ExceptionSink *xsink, bool has_encoding = false) {
      if (setIV(err, get_param(params, 2), xsink))
	 return -1;

      setInput(get_param(params, 0));
      setKey(params, 1);
      if (has_encoding)
	 setEncoding(params, 2);
      return 0;
   }

   DLLLOCAL int doCipher(const EVP_CIPHER *type, const char *cipher, int do_crypt, ExceptionSink *xsink) {
      const char *err = (do_crypt ? "ENCRYPT-ERROR" : "DECRYPT-ERROR");

      EVP_CIPHER_CTX ctx;
      EVP_CIPHER_CTX_init(&ctx);
      EVP_CipherInit_ex(&ctx, type, 0, 0, 0, do_crypt);
      if (key[0]) {
	 if (keylen[0] > EVP_MAX_KEY_LENGTH)
	    keylen[0] = EVP_MAX_KEY_LENGTH;

	 if (!EVP_CIPHER_CTX_set_key_length(&ctx, keylen[0]) || !EVP_CipherInit_ex(&ctx, 0, 0, key[0], iv, -1)) {
	    xsink->raiseException(err, "error setting %s key length=%d", cipher, keylen[0]);
	    EVP_CIPHER_CTX_cleanup(&ctx);
	    return -1;
	 }
      }

      // we allocate 1 byte more than we need in case we return as a string so we can terminate it
      output = (unsigned char *)malloc(sizeof(char) * (input_len + (EVP_MAX_BLOCK_LENGTH * 2)));

      if (!EVP_CipherUpdate(&ctx, output, &output_len, input, input_len)) {
	 xsink->raiseException(err, "error %scrypting %s block", do_crypt ? "en" : "de", cipher);
	 EVP_CIPHER_CTX_cleanup(&ctx);
	 return -1;
      }

      int tmplen;
      // Buffer passed to EVP_EncryptFinal() must be after data just encrypted to avoid overwriting it.
      if (!EVP_CipherFinal_ex(&ctx, output + output_len, &tmplen)) {
	 xsink->raiseException(err, "error %scrypting final %s block", do_crypt ? "en" : "de", cipher);
	 EVP_CIPHER_CTX_cleanup(&ctx);
	 return -1;
      }

      EVP_CIPHER_CTX_cleanup(&ctx);
      output_len += tmplen;
      //printd(5, "cipher_intern() %s: in=%08p (%d) out=%08p (%d)\n", cipher, buf, len, cbuf, *size);
      return 0;
   }

   DLLLOCAL int checkKeyLen(const char *err, int n, int len, ExceptionSink *xsink) {
      if (keylen[n] < len) {
	 xsink->raiseException(err, "key length is not %d bytes long (%d bytes)", len, keylen[n]);
	 return -1;
      }
      keylen[n] = len;
      return 0;
   }

/*
   DLLLOCAL int setDESKey(int n, ExceptionSink *xsink) {
      // force odd parity 
      //DES_set_odd_parity((DES_cblock *)key[n]);
      // populate the schedule structure
      //DES_set_key_unchecked((DES_cblock *)key[n], schedule);
      //key[n] = (unsigned char *)schedule;
      return 0;
   }
*/
};

static void missing_openssl_feature(const char *f, ExceptionSink *xsink) {
   xsink->raiseException("MISSING-FEATURE-ERROR", "the openssl library version that qore was compiled with did not support the %s algorithm; for maximum portability, check Option::HAVE_%s before calling this function", f, f);
}

//! @qppinit: SimpleRefHolder<BinaryNode> DefaultIV(new BinaryNode); DefaultIV->append(def_iv, 8);
//! @qppval: Qore::DefaultIV=DefaultIV->refSelf()

/** @defgroup cryptographic_constants Crytographic Contants
    Cryptographic constants
 */
//@{
//! The default initialization vector is simply a 8-byte string of nulls
const DefaultIV = <0000000000000000>;
//@}

/** @defgroup cryptographic_functions Crytographic Functions
    Cryptographic functions
 */
//@{
//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://www.counterpane.com/blowfish.html">blowfish algorithm</a>
/** @param data the data to be encrypted
    @param key a variable-length key (recommended 16 bytes or more)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example
    @code
my binary $bin = blowfish_encrypt_cbc($data, $key);
    @endcode

    @throw BLOWFISH-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary blowfish_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("BLOWFISH-ENCRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_bf_cbc(), "blowfish", QCRYPTO_ENCRYPT, xsink))
      return 0;

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://www.counterpane.com/blowfish.html">blowfish algorithm</a> and returns a binary object of the decrypted data
/** @param data the data to be decrypted
    @param key a variable-length key (recommended 16 bytes or more)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example
    @code
my binary $bin = blowfish_decrypt_cbc($data, $key);
    @endcode

    @throw BLOWFISH-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary blowfish_decrypt_cbc(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("BLOWFISH-DECRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_bf_cbc(), "blowfish", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://www.counterpane.com/blowfish.html">blowfish algorithm</a> and returns a string of the decrypted data
/** @param data the data to be decrypted
    @param key a variable-length key (recommended 16 bytes or more)
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example
    @code
my string $str = blowfish_decrypt_cbc_to_string($data, $key, NOTHING, "iso-8859-1");
    @endcode

    @throw BLOWFISH-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string blowfish_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) {
   CryptoHelper ch;

   if (ch.setSingleKey("BLOWFISH-DECRYPT-PARAM-ERROR", args, xsink, true)
       || ch.doCipher(EVP_bf_cbc(), "blowfish", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getString();
}

//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a> using an 8-byte key
/** @param data the data to be encrypted
    @param key the encryption key must be at least 8 bytes long (only the first 8 bytes will be used)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example
    @code
my binary $bin = des_encrypt_cbc($data, $key);
    @endcode

    @throw DES-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary des_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-ENCRYPT-PARAM-ERROR", args, xsink) 
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 8, xsink)
       || ch.doCipher(EVP_des_cbc(), "DES", QCRYPTO_ENCRYPT, xsink))
	    return 0;

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a> using an 8-byte key
/** @param data the data to be decrypted
    @param key the decryption key must be at least 8 bytes long (only the first 8 bytes will be used)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example
    @code
my binary $bin = des_decrypt_cbc($data, $key);
    @endcode

    @throw DES-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary des_decrypt_cbc(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-DECRYPT-PARAM-ERROR", args, xsink) 
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 8, xsink)
       || ch.doCipher(EVP_des_cbc(), "DES", QCRYPTO_DECRYPT, xsink))
	    return 0;

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a> using an 8-byte key
/** @param data the data to be decrypted
    @param key the decryption key must be at least 8 bytes long (only the first 8 bytes will be used)
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example
    @code
my string $bin = des_decrypt_cbc_to_string($data, $key, NOTHING, "iso-8859-1");
    @endcode

    @throw DES-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string des_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-DECRYPT-PARAM-ERROR", args, xsink, true) 
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 8, xsink)
       || ch.doCipher(EVP_des_cbc(), "DES", QCRYPTO_DECRYPT, xsink))
	    return 0;

   return ch.getString();
}

//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the two-key triple DES algorithm using two eight-byte keys (set by a single 16-byte key argument)
/** @param data the data to be encrypted
    @param key the encryption key must be at least 16 bytes long (only the first 16 bytes will be used for the two 8-byte keys)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example
    @code
my binary $bin = des_ede_encrypt_cbc($data, $key);
    @endcode

    @throw DES-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary des_ede_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-ENCRYPT-PARAM-ERROR", args, xsink) 
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 16, xsink)
       || ch.doCipher(EVP_des_ede_cbc(), "DES", QCRYPTO_ENCRYPT, xsink))
      return 0;

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the two-key triple DES algorithm using two eight-byte keys (set by a single 16-byte key argument)
/** @param data the data to be decrypted
    @param key the decryption key must be at least 16 bytes long (only the first 16 bytes will be used for the two 8-byte keys)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example
    @code
my binary $bin = des_ede_decrypt_cbc($data, $key);
    @endcode

    @throw DES-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary des_ede_decrypt_cbc(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-DECRYPT-PARAM-ERROR", args, xsink) 
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 16, xsink)
       || ch.doCipher(EVP_des_ede_cbc(), "DES", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the two-key triple DES algorithm using two eight-byte keys (set by a single 16-byte key argument)
/** @param data the data to be decrypted
    @param key the decryption key must be at least 16 bytes long (only the first 16 bytes will be used for the two 8-byte keys)
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example
    @code
my string $bin = des_ede_decrypt_cbc_to_string($data, $key, NOTHING, "iso-8859-1");
    @endcode

    @throw DES-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string des_ede_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-DECRYPT-PARAM-ERROR", args, xsink, true) 
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 16, xsink)
       || ch.doCipher(EVP_des_ede_cbc(), "DES", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getString();
}

//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the three-key triple <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a> using three 8-byte keys (set by a single 24-byte key argument) and an optional 8-byte initialization vector
/** @param data the data to be encrypted
    @param key the encryption key must be at least 24 bytes long (only the first 24 bytes will be used for the three 8-byte keys)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example
    @code
my binary $bin = des_ede3_encrypt_cbc($data, $key);
    @endcode

    @throw DES-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary des_ede3_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-ENCRYPT-PARAM-ERROR", args, xsink) 
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 24, xsink)
       || ch.doCipher(EVP_des_ede3_cbc(), "DES", QCRYPTO_ENCRYPT, xsink))
      return 0;

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the three-key triple <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a> using three 8-byte keys (set by a single 24-byte key argument) and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key the decryption key must be at least 24 bytes long (only the first 24 bytes will be used for the three 8-byte keys)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example
    @code
my binary $bin = des_ede3_decrypt_cbc($data, $key);
    @endcode

    @throw DES-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary des_ede3_decrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-DECRYPT-PARAM-ERROR", args, xsink) 
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 24, xsink)
       || ch.doCipher(EVP_des_ede3_cbc(), "DES", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the three-key triple <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a> using three 8-byte keys (set by a single 24-byte key argument) and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key the decryption key must be at least 24 bytes long (only the first 24 bytes will be used for the three 8-byte keys)
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example
    @code
my string $bin = des_ede3_decrypt_cbc_to_string($data, $key, NOTHING, "iso-8859-1");
    @endcode

    @throw DES-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DES-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string des_ede3_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) {
   CryptoHelper ch;

   if (ch.setSingleKey("DES-DECRYPT-PARAM-ERROR", args, xsink, true) 
       || ch.checkKeyLen("DES-KEY-ERROR", 0, 24, xsink)
       || ch.doCipher(EVP_des_ede3_cbc(), "DES", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getString();
}

//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://www.rsasecurity.com/">DESX algorithm</a> using a 24-byte key and an optional 8-byte initialization vector
/** @param data the data to be encrypted
    @param key the encryption key must be at least 24 bytes long (only the first 24 bytes will be used)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example
    @code
my binary $bin = desx_encrypt_cbc($data, $key);
    @endcode

    @throw DESX-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DESX-KEY-ERROR invalid key (too short)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary desx_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("DESX-ENCRYPT-PARAM-ERROR", args, xsink) 
       || ch.checkKeyLen("DESX-KEY-ERROR", 0, 24, xsink)
       || ch.doCipher(EVP_desx_cbc(), "DESX", QCRYPTO_ENCRYPT, xsink))
      return 0;

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://www.rsasecurity.com/">DESX algorithm</a> using a 24-byte key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key the decryption key must be at least 24 bytes long (only the first 24 bytes will be used)
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example
    @code
my binary $bin = desx_decrypt_cbc($data, $key);
    @endcode

    @throw DESX-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DESX-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary desx_decrypt_cbc(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("DESX-DECRYPT-PARAM-ERROR", args, xsink) 
       || ch.checkKeyLen("DESX-KEY-ERROR", 0, 24, xsink)
       || ch.doCipher(EVP_desx_cbc(), "DESX", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://www.rsasecurity.com/">DESX algorithm</a> using a 24-byte key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key the decryption key must be at least 24 bytes long (only the first 24 bytes will be used)
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a binary object of the decrypted data

    @par Example
    @code
my string $str = desx_decrypt_cbc_to_string($data, $key, NOTHING, "iso-8859-1");
    @endcode

    @throw DESX-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DESX-KEY-ERROR invalid key (too short)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string desx_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) {
   CryptoHelper ch;

   if (ch.setSingleKey("DESX-DECRYPT-PARAM-ERROR", args, xsink, true)
       || ch.checkKeyLen("DESX-KEY-ERROR", 0, 24, xsink)
       || ch.doCipher(EVP_desx_cbc(), "DESX", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getString();
}

//! Encrypts data using the Alleged <a href="http://en.wikipedia.org/wiki/RC4">RC4 cipher algorithm</a>, which should be compatible with RSA's RC4(tm) algorithm using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be encrypted
    @param key a variable-width encryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example
    @code
my binary $bin = rc4_encrypt($data, $key);
    @endcode

    @throw RC4-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary rc4_encrypt(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("RC4-ENCRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_rc4(), "rc4", QCRYPTO_ENCRYPT, xsink))
      return 0;

   return ch.getBinary();
}

//! Decrypts data using the Alleged <a href="http://en.wikipedia.org/wiki/RC4">RC4 cipher algorithm</a>, which should be compatible with RSA's RC4(tm) algorithm using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example
    @code
my binary $bin = rc4_decrypt($data, $key);
    @endcode

    @throw RC4-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary rc4_decrypt(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("RC4-DECRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_rc4(), "rc4", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getBinary();
}

//! Decrypts data using the Alleged <a href="http://en.wikipedia.org/wiki/RC4">RC4 cipher algorithm</a>, which should be compatible with RSA's RC4(tm) algorithm using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example
    @code
my string $str = rc4_decrypt_to_string($encrypted_data, $key, NOTHING, "iso-8859-1");
    @endcode

    @throw RC4-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string rc4_decrypt_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) {
   CryptoHelper ch;

   if (ch.setSingleKey("RC4-DECRYPT-PARAM-ERROR", args, xsink, true)
       || ch.doCipher(EVP_rc4(), "rc4", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getString();
}

//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://en.wikipedia.org/wiki/RC2">RC2(tm) algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be encrypted
    @param key a variable-width encryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example
    @code
my binary $bin = rc2_encrypt_cbc($data, $key);
    @endcode

    @throw RC2-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary rc2_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("RC2-ENCRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_rc2_cbc(), "rc2", QCRYPTO_ENCRYPT, xsink))
      return 0;

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://en.wikipedia.org/wiki/RC2">RC2(tm) algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example
    @code
my binary $bin = rc2_decrypt_cbc($data, $key);
    @endcode

    @throw RC2-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary rc2_decrypt_cbc(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("RC2-DECRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_rc2_cbc(), "rc2", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://en.wikipedia.org/wiki/RC2">RC2(tm) algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example
    @code
my string $str = rc2_decrypt_cbc_to_string($data, $key);
    @endcode

    @throw RC2-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string rc2_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) {
   CryptoHelper ch;

   if (ch.setSingleKey("RC2-DECRYPT-PARAM-ERROR", args, xsink, true)
       || ch.doCipher(EVP_rc2_cbc(), "rc2", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getString();
}

//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://en.wikipedia.org/wiki/CAST5">CAST5 algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be encrypted
    @param key a variable-width encryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example
    @code
my binary $bin = cast5_encrypt_cbc($data, $key);
    @endcode

    @throw CAST5-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary cast5_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("CAST5-ENCRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_cast5_cbc(), "CAST5", QCRYPTO_ENCRYPT, xsink))
      return 0;

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://en.wikipedia.org/wiki/CAST5">CAST5 algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example
    @code
my binary $bin = cast5_decrypt_cbc($data, $key);
    @endcode

    @throw CAST5-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary cast5_decrypt_cbc(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
   CryptoHelper ch;

   if (ch.setSingleKey("CAST5-DECRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_cast5_cbc(), "CAST5", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getBinary();
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for the <a href="http://en.wikipedia.org/wiki/CAST5">CAST5 algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example
    @code
my string $bin = cast5_decrypt_cbc_to_string($data, $key, NOTHING, "iso-8859-1");
    @endcode

    @throw CAST5-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string cast5_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) {
   CryptoHelper ch;

   if (ch.setSingleKey("CAST5-DECRYPT-PARAM-ERROR", args, xsink, true)
       || ch.doCipher(EVP_cast5_cbc(), "CAST5", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getString();
}

//! Encrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://en.wikipedia.org/wiki/RC5">RC2(tm) algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @par Availability
    @ref Qore::HAVE_RC5

    @param data the data to be encrypted
    @param key a variable-width encryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the encrypted data

    @par Example
    @code
my binary $bin = rc2_encrypt_cbc($data, $key);
    @endcode

    @throw RC5-ENCRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw ENCRYPT-ERROR processing error encrypting the data (should not normally happen)
 */
binary rc5_encrypt_cbc(data[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
#ifndef OPENSSL_NO_RC5
   CryptoHelper ch;

   if (ch.setSingleKey("RC5-ENCRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_rc5_32_12_16_cbc(), "rc5", QCRYPTO_ENCRYPT, xsink))
      return 0;

   return ch.getBinary();
#else
   missing_openssl_feature("RC5", xsink);
   return 0;
#endif
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://en.wikipedia.org/wiki/RC5">RC2(tm) algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @par Availability
    @ref Qore::HAVE_RC5

    @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present

    @return a binary object of the decrypted data

    @par Example
    @code
my binary $bin = rc2_decrypt_cbc($data, $key);
    @endcode

    @throw RC5-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)
 */
binary rc5_decrypt_cbc(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV) {
#ifndef OPENSSL_NO_RC5
   CryptoHelper ch;

   if (ch.setSingleKey("RC5-DECRYPT-PARAM-ERROR", args, xsink)
       || ch.doCipher(EVP_rc5_32_12_16_cbc(), "rc5", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getBinary();
#else
   missing_openssl_feature("RC5", xsink);
   return 0;
#endif
}

//! Decrypts data using the <a href="http://en.wikipedia.org/wiki/Cipher_block_chaining#Cipher-block_chaining_.28CBC.29">Cipher Block Chaining</a> function for RSA's <a href="http://en.wikipedia.org/wiki/RC5">RC2(tm) algorithm</a> using a variable-length key and an optional 8-byte initialization vector
/** @par Availability
    @ref Qore::HAVE_RC5

    @param data the data to be decrypted
    @param key a variable-width decryption key
    @param iv the initialization vector must be at least 8 bytes long if present
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed

    @return a string of the decrypted data

    @par Example
    @code
my string $str = rc2_decrypt_cbc_to_string($data, $key, NOTHING, "iso-8859-1");
    @endcode

    @throw RC5-DECRYPT-PARAM-ERROR invalid initialization vector (less than 8 bytes)
    @throw DECRYPT-ERROR processing error decrypting the data (for example invalid data)

    @since %Qore 0.8.4 added the encoding parameter to specify the output encoding of the string
 */
string rc5_decrypt_cbc_to_string(binary[doc] data, data[doc] key, data[doc] iv = Qore::DefaultIV, *string[doc] encoding) {
#ifndef OPENSSL_NO_RC5
   CryptoHelper ch;

   if (ch.setSingleKey("RC5-DECRYPT-PARAM-ERROR", args, xsink, true)
       || ch.doCipher(EVP_rc5_32_12_16_cbc(), "rc5", QCRYPTO_DECRYPT, xsink))
      return 0;

   return ch.getString();
#else
   missing_openssl_feature("RC5", xsink);
   return 0;
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MD2_(cryptography)">MD2 message digest</a> of the supplied argument as a hex string
/** 
    @par Availability
    @ref Qore::HAVE_MD2

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "a9046c73e00331af68917d3804f70655")

    @par Example
    @code
my string $str = MD2("hello"); # returns "a9046c73e00331af68917d3804f70655"
    @endcode

    @throw MD2-DIGEST-ERROR error calculating digest (should not normally happen)

    @see MD2_bin()
 */
string MD2(data[doc] data) {
#if !defined(OPENSSL_NO_MD2) && !defined(NO_MD2)
   DigestHelper dh(args);
   if (dh.doDigest(MD2_ERR, EVP_md2(), xsink))
      return 0;

   return dh.getString();
#else
   missing_openssl_feature("MD2", xsink);
   return 0;
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MD4">MD4 message digest</a> of the supplied argument as a hex string
/** 
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "866437cb7a794bce2b727acc0362ee27")

    @par Example
    @code
my string $str = MD4("hello"); # returns "866437cb7a794bce2b727acc0362ee27"
    @endcode

    @throw MD4-DIGEST-ERROR error calculating digest (should not normally happen)

    @see MD4_bin()
 */
string MD4(data[doc] data) {
   DigestHelper dh(args);
   if (dh.doDigest(MD4_ERR, EVP_md4(), xsink))
      return 0;

   return dh.getString();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MD5">MD5 message digest</a> of the supplied argument as a hex string
/** 
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "5d41402abc4b2a76b9719d911017c592")

    @par Example
    @code
my string $str = MD5("hello"); # returns "5d41402abc4b2a76b9719d911017c592"
    @endcode

    @throw MD5-DIGEST-ERROR error calculating digest (should not normally happen)

    @see MD5_bin()
 */
string MD5(data[doc] data) {
   DigestHelper dh(args);
   if (dh.doDigest(MD5_ERR, EVP_md5(), xsink))
      return 0;

   return dh.getString();
}

//! Returns the SHA (outdated SHA-0) message digest of the supplied argument as a hex string
/** This hash algorithm was withdrawn after publishing and is considered to have serious flaws.

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "ac62a630ca850b4ea07eda664eaecf9480843152")

    @par Example
    @code
my string $str = SHA("hello"); returns "ac62a630ca850b4ea07eda664eaecf9480843152"
    @endcode

    @throw SHA-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA_bin()
 */
string SHA(data[doc] data) {
   DigestHelper dh(args);
   if (dh.doDigest(SHA_ERR, EVP_sha(), xsink))
      return 0;

   return dh.getString();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/SHA-1">SHA1</a> message digest of the supplied argument as a hex string
/** 
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d")

    @par Example
    @code
my string $str = SHA1("hello"); # "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d"
    @endcode

    @throw SHA1-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA1_bin()
 */
string SHA1(data[doc] data) {
   DigestHelper dh(args);
   if (dh.doDigest(SHA1_ERR, EVP_sha1(), xsink))
      return 0;

   return dh.getString();
}

//! Returns the SHA-224 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a hex string
/** 
    @par Availability
    @ref Qore::HAVE_SHA224

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "ea09ae9cc6768c50fcee903ed054556e5bfc8347907f12598aa24193")

    @par Example
    @code
my string $str = SHA224("hello"); # returns "ea09ae9cc6768c50fcee903ed054556e5bfc8347907f12598aa24193"
    @endcode

    @throw SHA224-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA224_bin()
 */
string SHA224(data[doc] data) {
#if !defined(OPENSSL_NO_SHA256) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA224_ERR, EVP_sha224(), xsink))
      return 0;

   return dh.getString();
#else
   missing_openssl_feature("SHA224", xsink);
   return 0;
#endif
}

//! Returns the SHA-256 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a hex string
/** 
    @par Availability
    @ref Qore::HAVE_SHA256

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824")

    @par Example
    @code
my string $str = SHA256("hello"); # returns "2cf24dba5fb0a30e26e83b2ac5b9e29e1b161e5c1fa7425e73043362938b9824"
    @endcode

    @throw SHA256-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA256_bin()
 */
string SHA256(data[doc] data) {
#if !defined(OPENSSL_NO_SHA256) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA256_ERR, EVP_sha256(), xsink))
      return 0;

   return dh.getString();
#else
   missing_openssl_feature("SHA256", xsink);
   return 0;
#endif
}

//! Returns the SHA-384 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a hex string
/** 
    @par Availability
    @ref Qore::HAVE_SHA384

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "59e1748777448c69de6b800d7a33bbfb9ff1b463e44354c3553bcdb9c666fa90125a3c79f90397bdf5f6a13de828684f")

    @par Example
    @code
my string $str = SHA384("hello"); # returns "59e1748777448c69de6b800d7a33bbfb9ff1b463e44354c3553bcdb9c666fa90125a3c79f90397bdf5f6a13de828684f"
    @endcode

    @throw SHA384-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA384_bin()
 */
string SHA384(data[doc] data) {
#if !defined(OPENSSL_NO_SHA512) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA384_ERR, EVP_sha384(), xsink))
      return 0;

   return dh.getString();
#else
   missing_openssl_feature("SHA384", xsink);
   return 0;
#endif
}

//! Returns the SHA-512 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a hex string
/** 
    @par Availability
    @ref Qore::HAVE_SHA512

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "9b71d224bd62f3785d96d46ad3ea3d73319bfbc2890caadae2dff72519673ca72323c3d99ba5c11d7c7acc6e14b8c5da0c4663475c2e5c3adef46f73bcdec043")

    @par Example
    @code
my string $str = SHA512("hello"); # returns "9b71d224bd62f3785d96d46ad3ea3d73319bfbc2890caadae2dff72519673ca72323c3d99ba5c11d7c7acc6e14b8c5da0c4663475c2e5c3adef46f73bcdec043"
    @endcode

    @throw SHA512-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA512_bin()
 */
string SHA512(data[doc] data) {
#if !defined(OPENSSL_NO_SHA512) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA512_ERR, EVP_sha512(), xsink))
      return 0;

   return dh.getString();
#else
   missing_openssl_feature("SHA512", xsink);
   return 0;
#endif
}

//! Returns the DSS message digest (based on SHA-0 and <a href="http://en.wikipedia.org/wiki/Digital_Signature_Algorithm">DSA</a>) of the supplied argument as a hex string
/** 
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d")

    @par Example
    @code
my string $str = DSS("hello"); # returns "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d"
    @endcode

    @throw DSS-DIGEST-ERROR error calculating digest (should not normally happen)

    @see DSS_bin()

    @note this digest algorithm is considered outdated and is included for backwards-compatibility
 */
string DSS(data[doc] data) {
   DigestHelper dh(args);
   if (dh.doDigest(DSS_ERR, EVP_dss(), xsink))
      return 0;

   return dh.getString();
}

//! Returns the DSS1 message digest (based on <a href="http://en.wikipedia.org/wiki/SHA-1">SHA1</a> and <a href="http://en.wikipedia.org/wiki/Digital_Signature_Algorithm">DSA</a>) of the supplied argument as a hex string
/** 
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d")

    @par Example
    @code
my string $str = DSS1("hello"); # returns "aaf4c61ddcc5e8a2dabede0f3b482cd9aea9434d"
    @endcode

    @throw DSS1-DIGEST-ERROR error calculating digest (should not normally happen)

    @see DSS1_bin()

    @note this digest algorithm is considered outdated and is included for backwards-compatibility
 */
string DSS1(data[doc] data) {
   DigestHelper dh(args);
   if (dh.doDigest(DSS1_ERR, EVP_dss1(), xsink))
      return 0;

   return dh.getString();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MDC2">MDC2 message digest</a> of the supplied argument as a hex string
/** 
    @par Availability
    @ref Qore::HAVE_MDC2

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "4517036cf97b2407d6fe22aa5ab878a3")

    @par Example
    @code
my string $str = MDC2("hello"); # returns "4517036cf97b2407d6fe22aa5ab878a3"
    @endcode

    @throw MDC2-DIGEST-ERROR error calculating digest (should not normally happen)

    @see MDC2_bin()
 */
string MDC2(data[doc] data) {
#ifndef OPENSSL_NO_MDC2
   DigestHelper dh(args);
   if (dh.doDigest(MDC2_ERR, EVP_mdc2(), xsink))
      return 0;

   return dh.getString();
#else
   xsink->raiseException("MDC2-ERROR", "the openssl library version that qore was compiled with did not support the MDC2 algorithm; for maximum portability, check Option::HAVE_MDC2 before calling this function");
   return 0;
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/RIPEMD">RIPEMD message digest</a> of the supplied argument as a hex string
/** 
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a hex string of the digest (ex: \c "108f07b8382412612c048d07d13f814118445acd")

    @par Example
    @code
my string $str = RIPEMD160("hello"); # returns "108f07b8382412612c048d07d13f814118445acd"
    @endcode

    @throw RIPEMD160-DIGEST-ERROR error calculating digest (should not normally happen)

    @see RIPEMD160_bin()
 */
string RIPEMD160(data[doc] data) {
   DigestHelper dh(args);
   if (dh.doDigest(RIPEMD160_ERR, EVP_ripemd160(), xsink))
      return 0;

   return dh.getString();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MD2_(cryptography)">MD2 message digest</a> of the supplied argument as binary object
/** 
    @par Availability
    @ref Qore::HAVE_MD2

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example
    @code
my binary $bin = MD2_bin("hello");
    @endcode

    @throw MD2-DIGEST-ERROR error calculating digest (should not normally happen)

    @see MD2()
 */
binary MD2_bin(data[doc] data) {
#if !defined(OPENSSL_NO_MD2) && !defined(NO_MD2)
   DigestHelper dh(args);
   if (dh.doDigest(MD2_ERR, EVP_md2(), xsink))
      return 0;
   
   return dh.getBinary();
#else
   missing_openssl_feature("MD2", xsink);
   return 0;
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MD4">MD4 message digest</a> of the supplied argument as a binary object
/** 
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example
    @code
my binary $bin = MD4_bin("hello");
    @endcode

    @throw MD4-DIGEST-ERROR error calculating digest (should not normally happen)

    @see MD4()
 */
binary MD4_bin(data[doc] data) {
   DigestHelper dh(args);
   if (dh.doDigest(MD4_ERR, EVP_md4(), xsink))
      return 0;
   
   return dh.getBinary();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MD5">MD5 message digest</a> of the supplied argument as a binary object
/** 
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example
    @code
my binary $bin = MD5_bin("hello");
    @endcode

    @throw MD5-DIGEST-ERROR error calculating digest (should not normally happen)

    @see MD5()
 */
binary MD5_bin(data[doc] data) {
   DigestHelper dh(args);
   if (dh.doDigest(MD5_ERR, EVP_md5(), xsink))
      return 0;
   
   return dh.getBinary();
}

//! Returns the SHA (outdated SHA-0) message digest of the supplied argument as a binary object
/** This hash algorithm was withdrawn after publishing and is considered to have serious flaws.

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example
    @code
my binary $bin = SHA_bin("hello");
    @endcode

    @throw SHA-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA()
 */
binary SHA_bin(data[doc] data) {
   DigestHelper dh(args);
   if (dh.doDigest(SHA_ERR, EVP_sha(), xsink))
      return 0;
   
   return dh.getBinary();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/SHA-1">SHA1</a> message digest of the supplied argument as a binary object
/** 
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example
    @code
my binary $bin = SHA1_bin("hello");
    @endcode

    @throw SHA1-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA1()
 */
binary SHA1_bin(data[doc] data) {
   DigestHelper dh(args);
   if (dh.doDigest(SHA1_ERR, EVP_sha1(), xsink))
      return 0;
   
   return dh.getBinary();
}

//! Returns the SHA-224 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a binary object
/** 
    @par Availability
    @ref Qore::HAVE_SSH224

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example
    @code
my binary $bin = SHA224_bin("hello");
    @endcode

    @throw SHA224-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA224()
 */
binary SHA224_bin(data[doc] data) {
#if !defined(OPENSSL_NO_SHA256) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA224_ERR, EVP_sha224(), xsink))
      return 0;
   
   return dh.getBinary();
#else
   missing_openssl_feature("SHA224", xsink);
   return 0;
#endif
}

//! Returns the SHA-256 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a binary object
/** 
    @par Availability
    @ref Qore::HAVE_SSH256

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example
    @code
my binary $bin = SHA256_bin("hello");
    @endcode

    @throw SHA256-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA256()
 */
binary SHA256_bin(data[doc] data) {
#if !defined(OPENSSL_NO_SHA256) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA256_ERR, EVP_sha256(), xsink))
      return 0;
   
   return dh.getBinary();
#else
   missing_openssl_feature("SHA256", xsink);
   return 0;
#endif
}

//! Returns the SHA-384 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a binary object
/** 
    @par Availability
    @ref Qore::HAVE_SSH384

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example
    @code
my binary $bin = SHA384_bin("hello");
    @endcode

    @throw SHA384-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA384()
 */
binary SHA384_bin(data[doc] data) {
#if !defined(OPENSSL_NO_SHA512) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA384_ERR, EVP_sha384(), xsink))
      return 0;
   
   return dh.getBinary();
#else
   missing_openssl_feature("SHA384", xsink);
   return 0;
#endif
}

//! Returns the SHA-512 message digest (a variant of <a href="http://en.wikipedia.org/wiki/SHA-2">SHA-2</a>) of the supplied argument as a binary object
/** 
    @par Availability
    @ref Qore::HAVE_SSH512

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example
    @code
my binary $bin = SHA512_bin("hello");
    @endcode

    @throw SHA512-DIGEST-ERROR error calculating digest (should not normally happen)

    @see SHA512()
 */
binary SHA512_bin(data[doc] data) {
#if !defined(OPENSSL_NO_SHA512) && defined(HAVE_OPENSSL_SHA512)
   DigestHelper dh(args);
   if (dh.doDigest(SHA512_ERR, EVP_sha512(), xsink))
      return 0;
   
   return dh.getBinary();
#else
   missing_openssl_feature("SHA512", xsink);
   return 0;
#endif
}

//! Returns the DSS message digest (based on SHA-0 and <a href="http://en.wikipedia.org/wiki/Digital_Signature_Algorithm">DSA</a>) of the supplied argument as a binary object
/** 
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example
    @code
my binary $bin = DSS_bin("hello");
    @endcode

    @throw DSS-DIGEST-ERROR error calculating digest (should not normally happen)

    @see DSS()

    @note this digest algorithm is considered outdated and is included for backwards-compatibility
 */
binary DSS_bin(data[doc] data) {
   DigestHelper dh(args);
   if (dh.doDigest(DSS_ERR, EVP_dss(), xsink))
      return 0;
   
   return dh.getBinary();
}

//! Returns the DSS1 message digest (based on SHA-0 and <a href="http://en.wikipedia.org/wiki/Digital_Signature_Algorithm">DSA</a>) of the supplied argument as a binary object
/** 
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example
    @code
my binary $bin = DSS1_bin("hello");
    @endcode

    @throw DSS1-DIGEST-ERROR error calculating digest (should not normally happen)

    @see DSS1()

    @note this digest algorithm is considered outdated and is included for backwards-compatibility
 */
binary DSS1_bin(data[doc] data) {
   DigestHelper dh(args);
   if (dh.doDigest(DSS1_ERR, EVP_dss1(), xsink))
      return 0;
   
   return dh.getBinary();
}

//! Returns the <a href="http://en.wikipedia.org/wiki/MDC2">MDC2 message digest</a> of the supplied argument as a binary object
/** 
    @par Availability
    @ref Qore::HAVE_MDC2

    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example
    @code
my binary $bin = MDC2_bin("hello");
    @endcode

    @throw MDC2-DIGEST-ERROR error calculating digest (should not normally happen)

    @see MDC2_bin()
 */
binary MDC2_bin(data[doc] data) {
#ifndef OPENSSL_NO_MDC2
   DigestHelper dh(args);
   if (dh.doDigest(MDC2_ERR, EVP_mdc2(), xsink))
      return 0;
   
   return dh.getBinary();
#else
   missing_openssl_feature("MDC2", xsink);
   return 0;
#endif
}

//! Returns the <a href="http://en.wikipedia.org/wiki/RIPEMD">RIPEMD message digest</a> of the supplied argument as a binary object
/** 
    @param data the data to process and produce a digest for; the trailing null character is not included in the digest when processing string arguments

    @return a binary object of the digest

    @par Example
    @code
my binary $bin = RIPEMD160_bin("hello");
    @endcode

    @throw RIPEMD160-DIGEST-ERROR error calculating digest (should not normally happen)

    @see RIPEMD160()
 */
binary RIPEMD160_binary(data[doc] data) {
   DigestHelper dh(args);
   if (dh.doDigest(RIPEMD160_ERR, EVP_ripemd160(), xsink))
      return 0;
   
   return dh.getBinary();
}

//! Returns a binary object of a random key for the <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a>
/** @return a binary object of a random key for the <a href="http://www.itl.nist.gov/fipspubs/fip46-2.htm">DES algorithm</a>

    @par Example
    @code
my binary $bin = des_random_key();
    @endcode
 */
binary des_random_key() [flags=QC_CONSTANT] {
   DES_cblock *db = (DES_cblock *)malloc(sizeof(DES_cblock));
   DES_random_key(db);
   return new BinaryNode(db, sizeof(DES_cblock));
}
//@}
