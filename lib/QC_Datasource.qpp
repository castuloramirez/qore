/* -*- mode: c++; indent-tabs-mode: nil -*- */
/* @file QC_Datasource.qpp Datasource class definition

  Qore Programming Language

  Copyright 2003 - 2011 David Nichols

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.
  
  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.
  
  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <qore/Qore.h>
#include <qore/intern/QC_Datasource.h>

static const char *DSC_ERR = "DATASOURCE-CONSTRUCTOR-ERROR";

//! This class provides the %Qore interface to databases
/** This class provides the main direct interface to DBI drivers (along with the SQLStatement and DatasourcePool classes).

    The Datasource class will attempt to load any DBI driver that is not currently loaded in the constructor. For connection pooling support, see the DatasourcePool class.

    Datasource objects will implicitly call Datasource::open() if no connection has yet been established and a method is called requiring a connection to the database server. Therefore any method that requires communication with the database server can also throw any exception that the open method can throw.

    Most %Qore DBI drivers allow "select" queries to be executed through the Datasource::exec() method, and allow SQL commands (procedure calls, etc) to be executed through the Datasource::select() method, and some DBI drivers do not (depends on the underlying DB API). At any rate, the transaction lock is set when auto-commit is disabled and when the Datasource::exec() or Datasource::beginTransaction() methods are executed as documented above. Therefore executing a transaction relevant command through the Datasource::select() method while auto-commit mode is disabled and a transaction has not yet started will not result in the transaction lock being allocated to the current thread and therefore could cause transaction errors when sharing the Datasource object between multiple threads.

    Only databases with an existing %Qore DBI driver can be accessed through the Datasource class.

    All %Qore DBI drivers set new connections to use transaction isolation level \c "read committed".

    The Datasource class provides consistent, high-level, per-connection locking on requests at a level above the DBI drivers to ensure that the communication between clients and servers is properly serialized.

    Datasource objects also have a default character encoding; all requests to the server will be made in this encoding, and all responses will be returned in the given encoding.  If no encoding is specifically given to the Datasource object, the Datasource object will use the @ref default_encoding.

    <b>Datasource Binding By Value and By Placeholder</b>

    All Datasource methods accepting SQL strings to execute understand a special syntax used in the query string to bind %Qore data by value and to specify placeholders for output variables (for example, when executing a stored procedure or database function). Placeholder binding is DBI driver specific, but binding by value is supported with the same syntax in all drivers. Additionally, the \c %d numeric specifier is supported equally in all %Qore DBI drivers.

    <b>Datasource Format Specifiers</b>
    |!Format Specification|!Description
    |\c %d|If any value other than @ref nothing or @ref null is given, then the value is converted to an integer and this value is substituted in the string at this position; if the value is @ref nothing or @ref null, then a literal \c "null" is substituted instead.
    |\c %s|The argument is converted to a string and the string is inserted literally without any conversion or escape sequences in the string; this is useful for table or schema prefixes, etc
    |\c %v|The argument is bound by value according to the DBI driver's implementation.

    To bind %Qore data values directly in a binary format in an SQL command, use <tt>%v</tt> in the command string, and include the value as an argument after the string. Binding by value allows the DBI driver to take care of formatting the data properly for use in the query with the database server. When binding by value, strings do not need to be quoted, date/time values do not need special formatting, binary objects (with BLOB columns, for example) can be used directly in queries, etc.

    Here is an example:
    @code
my int $rows = $db.exec("insert into table (varchar_col, timestamp_col, blob_col, numeric_col) values (%v, %v, %v, %d)", $string, now(), $binary, 100);
    @endcode

    To insert a numeric value or a literal \c "null" in a query, use \c %d in the command string, and include the value as an argument after the string. If the value is @ref nothing or @ref null, a literal \c "null" will be written to the string; otherwise the argument is converted to a floating-point value or integer if necessary and written to the string. This is useful for working with \c DECIMAL (\c NUMERIC, \c NUMBER) types in a database-independent way; for example PostgreSQL servers do not do type conversions to \c DECIMAL types when a string, integer, or float is bound by value, therefore to ensure that integral decimal values can be used in a database-independent way (with \c "null" substitution when no value is bound), a valid approach is to use the \c %d code in the command string instead of \c %v.  However please note that \c %v is normally preferred to keep the statement cache a managable size, in the previous example using the int() or float() functions to convert string values before binding with \c %v may be better.

    For binding placeholders for output variables, write a unique name in the string and prefix it with a colon (ex: \c ":code"). In this case the method will return a hash of the output variables using the placeholder names as keys, but without the colon prefix. By default, a string type will be bound to the position. To bind other variable types to placeholder positions, include the type constant (see @ref sql_type_constants) as an argument after the command string. For BLOBs, use Binary, for CLOBs, use the string "clob" (constants will be provided in a future release). Not all DBI drivers require placeholder buffer specifications; see the documentation for the DBI driver in question for more information and examples regarding placeholder buffer specifications.

    <b>Datasource Transaction Locks</b>
    Datasource objects have an internal transaction lock which will be grabbed when the Datasource::exec(), Datasource::vexec() Datasource::execRaw(), or Datasource::beginTransaction() methods are executed and autocommit is not enabled. This enables a single datasource to be safely used for transaction management by several threads simultaneously. Note that an exception in a Datasource method that would acquire the lock (such as the Datasource::exec() method) when it's not already held, will have the effect that the transaction lock is not acquired.

    Any thread attempting to do transaction-relevant actions on a Datasource with auto-commit disabled while a transaction is in progress by another thread will block until the thread currently executing a transaction executes the Datasource::commit() or Datasource::rollback() methods (or the Datasource is deleted, reset, or closed, in which case the lock is released and an exception is raised as well).

    There is a timeout associated with the transaction lock; if a thread waits for the transaction lock for more than the timeout period, then an exception will be raised in the waiting thread. The timeout value can be read and changed with the Datasource::getTransactionLockTimeout() and Datasource::setTransactionLockTimeout() methods, respectively. The default transaction lock timeout value is 120 seconds.

    Note that the SQLStatement class also grabs the transaction lock when executing if it is created using a Datasource object in the constructor; for more information see the SQLStatement class.

    @note This class is not available with the @ref PO_NO_DATABASE parse option
 */
qclass Datasource [dom=DATABASE; arg=ManagedDatasource* ds; ns=SQL];

//! Creates the Datasource object; attempts to load a DBI driver if the driver is not already present in %Qore
/** @param driver The name of the DBI driver for the Datasource. See @ref sql_constants for builtin constants for DBI drivers shipped with %Qore, or see the DBI driver documentation to use an add-on driver (this string should be the name of the driver to be loaded)
    @param user The user name for the new connection. Also see Datasource::setUserName() for a method that allows this parameter to be set after the constructor.
    @param pass The password for the new connection. Also see Datasource::setPassword() for a method that allows this parameter to be set after the constructor.
    @param db The database name for the new connection. Also see Datasource::setDBName() for a method that allows this parameter to be set after the constructor.
    @param encoding The database-specific name of the @character_encoding "character encoding" to use for the new connection. Also see Datasource::setDBCharset() for a method that allows this parameter to be set after the constructor. If no value is passed for this parameter, then the database character encoding corresponding to the @ref default_encoding "default character encoding" will be used instead.
    @param host The host name for the new connection. Also see Datasource::setHostName() for a method that allows this parameter to be set after the constructor.
    @param port The port number for the new connection. Also see Datasource::setPort() for a method that allows this parameter to be set after the constructor.

    @par Example
    @code
my Datasource $db(DSPGSQL, "user", "pass", "database", "utf8", "localhost", 5432);
    @endcode

    @throw DATASOURCE-UNSUPPORTED-DATABASE DBI driver cannot be loaded
    @throw DATASOURCE-CONSTRUCTOR-ERROR port value is \<= 0
 */
Datasource::constructor(string driver, *string user, *string pass, *string db, *string encoding, *string host, int port) {
   DBIDriver *db_driver = DBI.find(driver->getBuffer(), xsink);
   if (!db_driver) {
      if (!*xsink)
	 xsink->raiseException("DATASOURCE-UNSUPPORTED-DATABASE", "DBI driver '%s' cannot be loaded", driver->getBuffer());
      return;
   }

   ReferenceHolder<ManagedDatasource> ds(new ManagedDatasource(db_driver), xsink);

   if (user && !user->empty())
      ds->setPendingUsername(user->getBuffer());

   if (pass && !pass->empty())
      ds->setPendingPassword(pass->getBuffer());

   if (db && !db->empty())
      ds->setPendingDBName(db->getBuffer());

   if (encoding && !encoding->empty())
      ds->setPendingDBEncoding(encoding->getBuffer());
   
   if (host && !host->empty())
      ds->setPendingHostName(host->getBuffer());
   
   if (port) {
      if (port < 0) {
	 xsink->raiseException(DSC_ERR, "port value must be zero (meaning use the default port) or positive (value given: %d)", port);
	 return;
      }
      ds->setPendingPort(port);
   }

   self->setPrivate(CID_DATASOURCE, ds.release());
}

//! Creates a Datasource object from a hash argument giving parameters for the constructor
/** @param opts a hash giving parameters for the new datasource with the following possible keys (the \c "type" key is mandatory):
    - \c type: (@ref string_or_nothing_type "*string") The name of the database driver to use; this key is mandatory; if not present, an exception will be raised. See @ref sql_constants for builtin constants for DBI drivers shipped with Qore, or see the DBI driver documentation to use an add-on driver (this string should be the name of the driver to be loaded)
    - \c user: (@ref string_or_nothing_type "*string") The user name for the new connection. Also see Datasource::setUserName() for a method that allows this parameter to be set after the constructor.
    - \c pass: (@ref string_or_nothing_type "*string") The password for the new connection. Also see Datasource::setPassword() for a method that allows this parameter to be set after the constructor.
    - \c db: (@ref string_or_nothing_type "*string") The database name for the new connection. Also see Datasource::setDBName() for a method that allows this parameter to be set after the constructor.
    - \c charset: (@ref string_or_nothing_type "*string") The database-specific name of the character encoding to use for the new connection. Also see Datasource::setDBCharset() for a method that allows this parameter to be set after the constructor. If no value is passed for this parameter, then the database character encoding corresponding to the default character encoding for the Qore process will be used instead.
    - \c host: (@ref string_or_nothing_type "*string") The host name for the new connection. Also see Datasource::setHostName() for a method that allows this parameter to be set after the constructor.
    - \c port: (@ref softint_type "softint") The port number for the new connection. Also see Datasource::setPort() for a method that allows this parameter to be set after the constructor. If this key is present and is 0 then an exception will be raised.

    @par Example
    @code
my Datasource $db(("type": DSPGSQL, "user": "username", "pass": "password", "db": "database", "charset": "utf8", "host": "localhost", "port": 5432);
    @endcode

    @throw DATASOURCE-UNSUPPORTED-DATABASE DBI driver cannot be loaded
    @throw DATASOURCE-CONSTRUCTOR-ERROR missing or invalid \c "driver" key, other key name not assigned to a string; port value is \<= 0
 */
Datasource::constructor(hash opts) {   
   const char *str = check_hash_key(opts, "type", DSC_ERR, xsink);
   if (*xsink) return;
   
   if (!str) {
      xsink->raiseException(DSC_ERR, "expecting a string value with the 'type' key giving the driver name");
      return;
   }
   
   DBIDriver *db_driver = DBI.find(str, xsink);
   if (!db_driver) {
      if (!*xsink)
         xsink->raiseException("DATASOURCE-UNSUPPORTED-DATABASE", "DBI driver '%s' cannot be loaded", str);
      return;
   }
   
   ReferenceHolder<ManagedDatasource> ds(new ManagedDatasource(db_driver), xsink);

   str = check_hash_key(opts, "user", DSC_ERR, xsink);
   if (*xsink) return;
   if (str) ds->setPendingUsername(str);

   str = check_hash_key(opts, "pass", DSC_ERR, xsink);
   if (*xsink) return;
   if (str) ds->setPendingPassword(str);

   str = check_hash_key(opts, "db", DSC_ERR, xsink);
   if (*xsink) return;
   if (str) ds->setPendingDBName(str);

   str = check_hash_key(opts, "charset", DSC_ERR, xsink);
   if (*xsink) return;
   if (str) ds->setPendingDBEncoding(str);

   str = check_hash_key(opts, "host", DSC_ERR, xsink);
   if (*xsink) return;
   if (str) ds->setPendingHostName(str);

   bool found;
   int port = (int)opts->getKeyAsBigInt("port", found);
   if (port) {
      if (port < 0) {
	 xsink->raiseException(DSC_ERR, "port value must be zero (meaning use the default port) or positive (value given: %d)", port);
	 return;
      }

      ds->setPendingPort(port);
   }

   self->setPrivate(CID_DATASOURCE, ds.release());
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
Datasource::destructor() {
   ds->destructor(xsink);
   ds->deref(xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
Datasource::copy() {
   self->setPrivate(CID_DATASOURCE, ds->copy());
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
nothing Datasource::open() {
   ds->open(xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
nothing Datasource::close() {
   ds->close(xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
nothing Datasource::commit() {
   ds->commit(xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
nothing Datasource::rollback() {
   ds->rollback(xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
nothing Datasource::setAutoCommit(bool ac = True) {
   ds->setAutoCommit(ac, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
bool Datasource::getAutoCommit() [flags=QC_CONSTANT] {
   return ds->getAutoCommit();
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
any Datasource::exec(string sql, ...) {
   ReferenceHolder<QoreListNode> argl((args->size() > 1 ? args->copyListFrom(1) : 0), xsink);
   return ds->exec(sql, *argl, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
any Datasource::vexec(string sql, *softlist vargs) {
   return ds->exec(sql, vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
any Datasource::execRaw(string sql) {
   return ds->execRaw(sql, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
any Datasource::select(string sql, ...) {
   ReferenceHolder<QoreListNode> argl((args->size() > 1 ? args->copyListFrom(1) : 0), xsink);
   return ds->select(sql, *argl, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
any Datasource::selectRow(string sql, ...) {
   ReferenceHolder<QoreListNode> argl((args->size() > 1 ? args->copyListFrom(1) : 0), xsink);
   return ds->selectRow(sql, *argl, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
any Datasource::selectRows(string sql, ...) {
   ReferenceHolder<QoreListNode> argl((args->size() > 1 ? args->copyListFrom(1) : 0), xsink);
   return ds->selectRows(sql, *argl, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
any Datasource::vselect(string sql, *softlist vargs) {
   return ds->select(sql, vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
any Datasource::vselectRow(string sql, *softlist vargs) {
   return ds->selectRow(sql, vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
any Datasource::vselectRows(string sql, *softlist vargs) {
   return ds->selectRows(sql, vargs, xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
nothing Datasource::beginTransaction() {
   ds->beginTransaction(xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
nothing Datasource::reset() {
   ds->reset(xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
int Datasource::getCapabilities() [flags=QC_CONSTANT] {
   return ds->getCapabilities();
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
list Datasource::getCapabilityList() [flags=QC_CONSTANT] {
   return ds->getCapabilityList();
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
nothing Datasource::setUserName(string user) {
   ds->setPendingUsername(user->getBuffer());
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
nothing Datasource::setPassword(string pass) {
   ds->setPendingPassword(pass->getBuffer());
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
nothing Datasource::setDBName(string db) {
   ds->setPendingDBName(db->getBuffer());
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
nothing Datasource::setDBCharset(string encoding) {
   ds->setPendingDBEncoding(encoding->getBuffer());
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
nothing Datasource::setDBEncoding(string encoding) {
   ds->setPendingDBEncoding(encoding->getBuffer());
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
nothing Datasource::setHostName(string host) {
   ds->setPendingHostName(host->getBuffer());
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
nothing Datasource::setPort(int port) {
   ds->setPendingPort((int)port);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
*string Datasource::getUserName() [flags=QC_CONSTANT] {
   return ds->getPendingUsername();
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
*string Datasource::getPassword() [flags=QC_CONSTANT] {
   return ds->getPendingPassword();
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
*string Datasource::getDBName() [flags=QC_CONSTANT] {
   return ds->getPendingDBName();
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
string Datasource::getDBCharset() [flags=QC_CONSTANT] {
   return ds->getPendingDBEncoding();
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
string Datasource::getDBEncoding() [flags=QC_CONSTANT] {
   return ds->getPendingDBEncoding();
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
string Datasource::getOSCharset() [flags=QC_CONSTANT] {
   const QoreEncoding *enc = ds->getQoreEncoding();
   return new QoreStringNode(enc ? enc->getCode() : "(unknown)");
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
*string Datasource::getOSEncoding() [flags=QC_CONSTANT] {
   const QoreEncoding *enc = ds->getQoreEncoding();
   return enc ? new QoreStringNode(enc->getCode()) : 0;
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
*string Datasource::getHostName() [flags=QC_CONSTANT] {
   return ds->getPendingHostName();
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
*int Datasource::getPort() [flags=QC_CONSTANT] {
   int port = ds->getPort();
   return port ? new QoreBigIntNode(port) : 0;
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
nothing Datasource::setTransactionLockTimeout(timeout timeout_ms = 0) {
   ds->setTransactionLockTimeout((int)timeout_ms);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
int Datasource::getTransactionLockTimeout() [flags=QC_CONSTANT] {
   return ds->getTransactionLockTimeout();
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
string Datasource::getDriverName() [flags=QC_CONSTANT] {
   return new QoreStringNode(ds->getDriver()->getName());
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
any Datasource::getServerVersion() {
   return ds->getServerVersion(xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
any Datasource::getClientVersion() {
   return ds->getClientVersion(xsink);
}

//! 
/** 
    @par Example
    @code
    @endcode
 */
bool Datasource::inTransaction() [flags=QC_CONSTANT] {
   return ds->isInTransaction();
}
