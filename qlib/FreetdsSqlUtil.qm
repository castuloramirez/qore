# -*- mode: qore; indent-tabs-mode: nil -*-
# @file FreetdsSqlUtil.qm Qore user module for working with PostgreSQL SQL data

/*  FreetdsSqlUtil.qm Copyright (C) 2015 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum qore version
%requires qore >= 0.8.12

# requires the SqlUtil module
%requires SqlUtil >= 1.2

# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module FreetdsSqlUtil {
    version = "1.1";
    desc = "user module for working with FreeTDS SQL data";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

# version history is included below in the docs

/** @mainpage FreetdsSqlUtil Module

    @tableofcontents

    @section freetdssqlutilintro FreetdsSqlUtil Module Introduction

    The %FreetdsSqlUtil module provides a high level API for working with database objects through the freetds driver.

    Usually this module is loaded on demand from the SqlUtil module, however to use this module
    directly, use \c "%requires FreetdsSqlUtil" in your code.

    All the public symbols in the module are defined in the FreetdsSqlUtil namespace

    @note This module requires the <a href="https://github.com/qorelanguage/module-sybase">freetds</a> binary module for communication with MS SQL Server and Sybase databases

    @section freetds_schema_management Schema Management with the FreeTDS Driver

    @subsection freetds_type_mapping Type Mapping

    Column types are mapped from %Qore types as follows:

    <b>FreeTDS Column Type Mappings</b>
    |!Generic Type Name|!FreeTDS Type Used
    |\c float|\c float
    |\c integer|\c bigint
    |\c number|\c numeric
    |\c string|\c varchar
    |\c date|\c datetime
    |\c binary|\c varbinary
    |\c bool|\c tinyint
    |@ref SqlUtil::BLOB|\c varbinary
    |@ref SqlUtil::CHAR|\c char
    |@ref SqlUtil::CLOB|\c text
    |@ref SqlUtil::NUMERIC|\c numeric
    |@ref SqlUtil::VARCHAR|\c varchar

    To use other types, use the \c "native_type" @ref SqlUtil::AbstractTable::ColumnDescOptions "column description option" with the
    native FreeTDS type name instead (under the \c "driver" and \c "freetds" keys for schemas supporting multiple databases).

    @subsection freetdssqlutilv10 FreetdsSqlUtil v1.0
    - initial release
*/

#! the FreetdsSqlUtil namespace contains all the objects in the FreetdsSqlUtil module
public namespace FreetdsSqlUtil {
    #! returns a FreetdsTable object corresponding to the arguments
    public FreetdsTable sub get_table(AbstractDatasource nds, string nname, *hash opts) {
        return new FreetdsTable(nds, nname, opts);
    }

    #! returns a FreetdsDatabase object corresponding to the arguments
    public FreetdsDatabase sub get_database(AbstractDatasource nds, *hash opts) {
	return new FreetdsDatabase(nds, opts);
    }

    sub parse_schema_name(string nname, reference schema, reference name) {
        *string sstr = (nname =~ x/^(\w+)\.\w+/)[0];
        if (sstr) {
            schema = sstr;
            splice nname, 0, schema.size() + 1;
            name = nname;
        }
        else {
            schema = "dbo";
            name = nname;
        }
    }

    #! represents a FreeTDS-specific index
    public class FreetdsIndex inherits SqlUtil::AbstractIndex {
	public {
            #! the tablespace (filegroup) name of the index
            *string filegroup;
        }

        #! creates the object from the arguments
        constructor(string n_name, bool n_unique, hash n_cols, *string n_filegroup) : AbstractIndex(n_name, n_unique, n_cols) {
            filegroup = n_filegroup;
        }

        #! returns a string that can be used to create the index in the database
        string getCreateSql(string table_name, *hash opt) {
            string sql = sprintf("create %sindex %s on %s (%s)", unique ? "unique " : "", name, table_name, (foldl $1 + ", " + $2, columns.keyIterator()));

            *string ts = opt.index_filegroup ? opt.index_filegroup : filegroup;
            if (ts)
                sql += sprintf(" on %s", ts);
            return sql;
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current index, @ref Qore::False "False" if not
        private bool equalImpl(AbstractIndex ix) {
            return True;
        }

        #! returns a string that can be used to rename the index in the database
        string getRenameSql(string table_name, string new_name) {
            return sprintf("exec sp_rename '%s.%s', '%s', 'INDEX'", table_name, name, new_name);
        }
    }

    #! represents a FreeTDS-specific foreign constraint
    public class FreetdsForeignConstraint inherits SqlUtil::AbstractForeignConstraint {
        #! creates the constraint from the supplied arguments
        constructor(string n, Columns c, ForeignConstraintTarget t) : AbstractForeignConstraint(n, c, t) {
        }

        #! returns a string that can be used to create the constraint in the database
        string getCreateSql(string table_name, *hash opt) {
            return getCreateSql(name, table_name, opt);
        }

        softlist getRenameSql(string table_name, string new_name) {
            # the following is only valid with FreeTDS 9.2+
            #return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
            list l += getDropSql(table_name);
            l += getCreateSql(new_name, table_name);
            return l;
        }

        #! returns a string that can be used to create the constraint in the database
        string getCreateSql(string name, string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s foreign key (%s) references %s (%s)", table_name, name, (foldl $1 + ", " + $2, h.keys()), target.table, (foldl $1 + ", " + $2, target.columns.keys()));
        }
    }

    #! represents a FreeTDS-specific check constraint
    public class FreetdsCheckConstraint inherits SqlUtil::AbstractCheckConstraint {
        #! creates the constraint from the supplied arguments
        constructor(string n, string n_src) : AbstractCheckConstraint(n, n_src) {
        }

        #! returns a string that can be used to create the constraint in the database
        string getCreateSql(string table_name, *hash opt) {
            return getCreateSql(name, table_name, opt);
        }

        list getRenameSql(string table_name, string new_name) {
            # the following is only valid with FreeTDS 9.2+
            #return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
            list l += getDropSql(table_name);
            l += getCreateSql(new_name, table_name);
            return l;
        }

        #! returns a string that can be used to create the constraint in the database
        string getCreateSql(string name, string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s check (%s)", table_name, name, src);
        }
    }

    #! represents a FreeTDS-specific column
    public class FreetdsColumn inherits SqlUtil::AbstractColumn {
        public {
            #! byte size of the column
            int byte_size;
        }

        #! creates the column from the supplied arguments
        constructor(string n, string nt, *string qt, int sz, bool nul, *string dv, softint bs) : AbstractColumn(n, nt, qt, sz, nul, dv) {
            byte_size = bs;
        }

        #! returns a string giving the native type of the column
        string getNativeTypeString() {
            string sql = native_type;
            if (size)
                sql += sprintf("(%d)", size);
            return sql;
        }

        #! returns a list of sql strings that can be used to add the column to an existing table
        /** @par Example:
            @code
my list $l = $col.getAddColumnSql($t);
            @endcode

            @param t the SqlUtil::AbstractTable object to modify
         */
        list getAddColumnSql(AbstractTable t) {
	    list l += sprintf("alter table %s add %s", t.getSqlName(), AbstractColumn::getCreateSql(t));
            return l;
        }

        #! returns a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $col.getModifySql($t, $newcol);
            @endcode

            The column names are assumed to be equal.

            @param t the SqlUtil::AbstractTable object to modify
            @param col the new column definition

            @return a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
         */
        list getModifySqlImpl(AbstractTable t, AbstractColumn col, *hash opt) {
            list l = ();
            FreetdsColumn c = col;

            # get new native type declaration string
            string nts = c.getNativeTypeString();
            if (getNativeTypeString() != nts) {
                #printf("ME: %s\nDB: %s\n", nts, getNativeTypeString());
                if (def_val !== c.def_val)
                    l += sprintf("alter table %s drop constraint dv_%s", t.getSqlName(), name);

                l += sprintf("alter table %s alter %s type %s", t.getSqlName(), name, nts);

                if (def_val !== c.def_val && exists c.def_val && c.def_val !== NULL)
                    l += sprintf("alter table %s add constraint dv_%s default %s for column %s", t.getSqlName(), name, c.def_val, name);
            }
            else if (def_val !== c.def_val) {
                #printf("L: %N\nXXXXXXXXXXXXXXX\nR: %N\n\n", self, c);
                if (exists c.def_val && c.def_val !== NULL)
                    l += sprintf("alter table %s add constraint dv_%s default %s for column %s", t.getSqlName(), name, c.def_val, name);
                else
                    l += sprintf("alter table %s drop constraint dv_%s", t.getSqlName(), name);
            }
            if (nullable != c.nullable) {
                l += sprintf("alter table %s alter column %s %snull", t.getSqlName(), name, c.nullable ? "" : "not ");
            }

            return l;
        }

        #! returns a string that can be used to rename the column
        /** @par Example:
            @code
my string $str = $col.getRenameSql($t, "new_name");
            @endcode

            @param t the SqlUtil::AbstractTable object to modify
            @param new_name the new name for the column

            @return a string that can be used to rename the column
        */
        string getRenameSql(AbstractTable t, string new_name) {
            return sprintf("sp_rename '%s.%s', '%s', 'COLUMNS'", t.getSqlName(), name, new_name);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        private bool equalImpl(AbstractColumn c) {
            return True;
        }
    }

    #! represents a FreeTDS-specific numeric column
    public class FreetdsNumericColumn inherits FreetdsColumn, SqlUtil::NumericColumnInfo {
        #! creates the column from the supplied arguments
        constructor(string n, string nt, *string qt, int sz, bool nul, *string dv, softint bs, softint n_scale) : FreetdsColumn(n, nt, qt, sz, nul, dv, bs), NumericColumnInfo(n_scale) {
        }

        #! returns a string giving the native type of the column
        string getNativeTypeString() {
            return NumericColumnInfo::getNativeTypeString(native_type, size);
        }
    }

    #! common base class for unique constraints
    public class FreetdsUniqueConstraintCommon inherits SqlUtil::AbstractUniqueConstraint {
        private {
            #! any filegroup for the unique key index
            *string filegroup;
        }

        #! creates the constraint with an optional filegroup name
        constructor(*string ts) {
            filegroup = ts;
        }

        #! returns the filegroup name used for this constraint, if known
        *string getTablespace() {
            return filegroup;
        }

        #! sets or clears the filegroup name
        setTablespace(*string ts) {
            filegroup = ts;
        }

        #! sets the supporting index name
        bool setIndexBase(string ix) {
            if (index && index != ix)
                return False;
            index = ix;
            delete filegroup;
            return True;
        }

        #! clears any index base for the constraint
        clearIndex() {
            delete index;
        }

        #! returns an iterator for keys iterating a list of string key names
        abstract AbstractIterator keyIterator();
    }

    #! class modeling a unique constraint
    public class FreetdsUniqueConstraint inherits SqlUtil::AbstractUniqueConstraint, FreetdsUniqueConstraintCommon {
        private {
            #! @ref Qore::True "True" if the constraint is enabled, @ref Qore::False "False" if not
            bool enabled;
        }

        #! creates the object with the given attributes
        /** @param n name of the constraint
            @param n_cols column hash
            @param e the enabled status of the constraint
            @param ts optional filegroup name
        */
        constructor(string n, hash n_cols, bool e = True, *string ts) : AbstractUniqueConstraint(n, n_cols), FreetdsUniqueConstraintCommon(ts) {
            enabled = e;
        }

        #! returns the FreetdsColumn value of the given key if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code
my any $v = $c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        FreetdsColumn memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        #! returns a string that can be used to create the constraint
        string getCreateSql(string table_name, *hash opts) {
            return getCreateSql(name, table_name, opts);
        }

        list getRenameSql(string table_name, string new_name) {
            # the following is only valid with FreeTDS 9.2+
            #return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
            list l += getDropSql(table_name);
            l += getCreateSql(new_name, table_name);
            return l;
        }

        #! returns a string that can be used to rename the constraint
        string getCreateSql(string name, string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s unique ", table_name, name);
            return sql;
        }

        #! returns @ref Qore::True "True" if the constraint is enabled, @ref Qore::False "False" if not
        bool isEnabled() {
            return enabled;
        }
    }

    #! represents a FreeTDS-specific primary key constraint
    public class FreetdsPrimaryKey inherits SqlUtil::AbstractPrimaryKey, FreetdsUniqueConstraintCommon {
        #! creates an empty primary key object
        constructor() {
        }

        #! creates the object with the given attributes
        /** @param n name of the constraint
            @param c column hash
            @param ts optional filegroup name
        */
        constructor(string n, *hash c, *string ts) : AbstractPrimaryKey(n, c), FreetdsUniqueConstraintCommon(ts) {
        }

        #! returns the FreetdsColumn value of the given key if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code
my any $v = $c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class

            @see @ref memberGate_methods
        */
        FreetdsColumn memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        #! returns a string that can be used to create the constraint
        string getCreateSql(string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s primary key", table_name, name);
            return sql;
        }

        #! returns a string that can be used to rename the constraint
        softlist getRenameSql(string table_name, string new_name) {
            return sprintf("sp_rename '%s.%s', '%s', 'OBJECT'", table_name, name, new_name);
        }
    }

    #! class for FreeTDS sequences
    public class FreetdsSequence inherits SqlUtil::AbstractSequence {
        #! creates the object from the arguments
        constructor(string n_name, number n_start = 1, number n_increment = 1, *softnumber n_end) : AbstractSequence(n_name, n_start, n_increment, n_end) {
        }

        #! returns a string that can be used to create the sequence in the database
        string getCreateSql(*hash opt) {
            string sql = sprintf("create sequence %s start with %d increment by %d ", name, start, increment);
            sql += max ? sprintf("maxvalue %d", max) : "no maxvalue";
            return sql;
        }

        #! returns a string that can be used to rename the sequence in the database
        string getRenameSql(string new_name) {
            # no idea if this will work
            return sprintf("sp_rename '%s', '%s', 'OBJECT'", name, new_name);
        }
    }

    #! represents a FreeTDS view
    public class FreetdsView inherits SqlUtil::AbstractView {
        #! creates the object from the arguments
        constructor(string n_name, string n_src, *string n_schemaname) : AbstractView(n_name, n_src) {
            schema = n_schemaname;
            updatable = False;
        }

        #! returns a string that can be used to create the view in the database
        string getCreateSql(*hash opt) {
            # TODO/FIXME: more freetds options - what's allows in "opt"?
            return sprintf("create %s%sview %s as %s",
                           opt.replace ? "or replace " : "",
                           opt.temp ? "temp " : "",
                           name,
                           src
                          );
        }

        #! returns a string that can be used to rename the view in the database
        softlist getRenameSql(string new_name) {
            # no idea if this will work
            return sprintf("sp_rename '%s', '%s', 'OBJECT'", name, new_name);
        }
    }

    #! represents a FreeTDS-specific trigger
    public class FreetdsTrigger inherits SqlUtil::AbstractTrigger {
        #! creates the object and sets its name and the trigger source
        constructor(string n, string n_src) : AbstractTrigger(n, n_src) {
        }

        #! returns a string that can be used to create the trigger in the database
        softlist getCreateSql(string table_name, *hash opt) {
            return sprintf("create trigger %s %s", name, src);
        }

        #! returns a string that can be used to drop the trigger from the database
        softlist getDropSql(string table_name) {
            return sprintf("drop trigger %s", name);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        private bool equalImpl(AbstractFunctionBase t) {
            return True;
        }

        #! returns a string that can be used to rename the trigger in the database
	softlist getRenameSql(string table_name, string new_name) {
            # no idea if this will work
            return sprintf("sp_rename '%s', '%s', 'OBJECT'", name, new_name);
	}
    }

    #! represents a FreeTDS-specific function
    public class FreetdsFunction inherits SqlUtil::AbstractFunction {
        public {
            *string args;
        }

        constructor(string n, string n_src, *string a) : AbstractFunction(n, "function", n_src) {
            args = a;
        }

        #! returns a string that can be used to create the function in the database
        softlist getCreateSql(*hash opt) {
            return sprintf("create function %s %s", name, src);
        }

        #! returns a string that can be used to drop the function from the database
        string getDropSql() {
            return sprintf("drop function %s", name);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        private bool equalImpl(AbstractFunctionBase t) {
            return True;
        }

        #! returns a string that can be used to rename the function in the database
	softlist getRenameSql(string new_name) {
            # no idea if this will work
            return sprintf("sp_rename '%s', '%s', 'OBJECT'", name, new_name);
	}

        #! sets the new name of the function
        setName(string new_name) {
            name = new_name;
        }
    }

    #! provides the FreeTDS-specific implementation of the AbstractDatabase interface
    public class FreetdsDatabase inherits SqlUtil::AbstractDatabase {
        public {
            #! FreeTDS-specific schema description keys
            const FreetdsSchemaDescriptionOptions = AbstractDatabase::SchemaDescriptionOptions;

            const FreeTDS_TempSavepoint = "qore_freetds_tmp_savepoint";

            #! Options for reclaimSpace()
            const FreetdsReclaimSpaceOptions = ReclaimSpaceOptions;
        }

        constructor(AbstractDatasource nds, *hash opts) : AbstractDatabase(nds, opts) {
        }

        private list featuresImpl() {
            return (DB_SEQUENCES, DB_TABLES, DB_VIEWS);
        }

        private FreetdsSequence makeSequenceImpl(string name, number start = 1, number increment = 1, *softnumber end, *hash opts) {
            return new FreetdsSequence(name, start, increment, end);
        }

        private *AbstractSequence getSequenceImpl(string name) {
            throw "UNIMPLEMENTED", "unimplemented";
        }

        private *AbstractView getViewImpl(string name) {
            string schema;
            parse_schema_name(name, \schema, \name);

            *hash row = ds.selectRow("select * from information_schema.views where tabke_chema = %v and table_name = %v", schema, name);
            if (!row)
                return;

            return new FreetdsView(name, row.view_definition, row.table_schema);
        }

        private FreetdsFunction makeFunctionImpl(string name, string src, *hash opts) {
            throw "UNIMPLEMENTED", "unimplemented";
        }

        private FreetdsFunction makeProcedureImpl(string name, string src, *hash opts) {
            return makeFunctionImpl(name, src, opts);
        }

        private *AbstractFunction getFunctionImpl(string name) {
            throw "UNIMPLEMENTED", "unimplemented";
        }

        private AbstractFunction getProcedureImpl(string name) {
            return getFunctionImpl(name);
        }

        private list getDropSchemaSqlImpl(hash schema_hash, *hash opt) {
            return ();
        }

        private list getAlignSqlImpl(hash schema_hash, *hash opt) {
            return ();
        }

        #! returns a list of string table names in the database
        private softlist listTablesImpl() {
            return ds.select("select table_name from information_schema.tables").table_name;
        }

        #! returns a list of string function names in the database
        /** The function names will include arguments in parentheses after the names

            @return a list of string function names in the database
        */
        private list listFunctionsImpl() {
            return ds.select("select routine_name from information_schema.routines").routine_name;
        }

        #! since FreeTDS only supports functions, this method is identical to listFunctionsImpl()
        /** @see listFunctionsImpl()
        */
        private list listProceduresImpl() {
            return listFunctionsImpl();
        }

        private list listSequencesImpl() {
            throw "UNIMPLEMENTED", "unimplemented";
        }

        private list listViewsImpl() {
            return ds.select("select table_name from information_schema.views").table_name;
        }

        #! returns a string that can be used to create the schema in the database
        private string getCreateSqlImpl(list l) {
            return FreetdsDatabase::getCreateSql(l);
        }

        #! returns a string that can be used to create the schema in the database
        static string getCreateSql(list l) {
            return !l ? "" : foldl $1 + "\n" + $2, (map sprintf("%s%s", $1, $1 =~ /(;|\$)$/ ? "" : ";"), l);
        }

        #! returns driver-specific options to the base abstract class
        private hash getSchemaDescriptionOptions() {
            return FreetdsSchemaDescriptionOptions;
        }

        #! returns driver-specific options to the base abstract class
        private hash getReclaimSpaceOptions() {
            return FreetdsReclaimSpaceOptions;
        }

        #! returns the next value in the given sequence
        private softint getNextSequenceValueImpl(string name) {
            return ds.selectRow("select next value for %v as nextval", name).nextval;
        }

        #! returns the last value issued for the given sequence in the current session
        private softint getCurrentSequenceValueImpl(string name) {
            return ds.selectRow("select current_value from sys.sequences where name = %v", name).current_value;
        }

        #! returns @ref Qore::True "True" if the database supports sequences
        private bool supportsSequencesImpl() {
            return True;
        }

        #! returns @ref Qore::True "True" if the database supports named types
        private bool supportsTypesImpl() {
            return True;
        }

        #! returns @ref Qore::True "True" if the database supports packages
        private bool supportsPackagesImpl() {
            return False;
        }

        #! rebuild index implementation. See @ref SqlUtil::AbstractDatabase::rebuildIndex()
        private bool rebuildIndexImpl(string name, *hash options) {
            ds.select("alter index %v on %v reorganize", name, options.table_name);
            return True;
        }

        #! compute statistics implementation. See @ref SqlUtil::AbstractDatabase::computeStatistics()
        private computeStatisticsImpl(*hash options) {
            if (options.tables)
                map ds.select("update statistics %v", $1), options.tables;
            else # otherwise update all statistics in the DB
                ds.select("exec sp_updatestats");
        }

        #! reclaim space implementation. See @ref SqlUtil::AbstractDatabase::reclaimSpace()
        private reclaimSpaceImpl(*hash options) {
            ds.select("dbcc shrinkdatabase");
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        private any tryExecArgsImpl(string sql, *softlist args) {
            return FreetdsDatabase::tryExecArgs(ds, sql, args);
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        private any tryExecRawImpl(string sql, *softlist args) {
            return FreetdsDatabase::tryExecRaw(ds, sql);
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        static any tryExecArgs(AbstractDatasource ds, string sql, *softlist args) {
            ds.exec("save tran " + FreeTDS_TempSavepoint);

            any rv;
            try {
                rv = ds.vexec(sql, args);
            }
            catch (hash ex) {
                ds.exec("rollback transaction " + FreeTDS_TempSavepoint);
                rethrow;
            }
            return rv;
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        static any tryExecRaw(AbstractDatasource ds, string sql) {
            ds.exec("save tran " + FREETDS_TempSavepoint);

            any rv;
            try {
                rv = ds.execRaw(sql);
            }
            catch (hash ex) {
                ds.exec("rollback transaction " + FREETDS_TempSavepoint);
                rethrow;
            }
            return rv;
        }
    }

    #! provides the FreeTDS-specific implementation of the SqlUtil::AbstractTable interface
    public class FreetdsTable inherits SqlUtil::AbstractTable {
        public {
            #! maps postgresql type names to type configurations
            const FreetdsTypeMap = (
                "numeric": ("qore": Type::Number, "size": SZ_NUM,),
                "decimal": ("qore": Type::Number, "size": SZ_NUM,),
                "tinyint": ("qore": Type::Int,),
                "smallint": ("qore": Type::Int,),
                "int": ("qore": Type::Int,),
                "bigint": ("qore": Type::Int,),
                "float": ("qore": Type::Float,),
                "real": ("qore": Type::Float,),
                "money": ("qore": Type::Number,),
                "smallmoney": ("qore": Type::Number,),
                "datetime": ("qore": Type::Date,),
                "smalldatetime": ("qore": Type::Date,),
                "date": ("qore": Type::Date,),
                "time": ("qore": Type::Date,),
                "char": ("qore": Type::String, "size": SZ_MAND,),
                "character varying": ("qore": Type::String, "size": SZ_MAND,),
                "varchar": ("qore": Type::String, "size": SZ_MAND,),
                "unichar": ("qore": Type::String, "size": SZ_MAND,),
                "univarchar": ("qore": Type::String, "size": SZ_MAND,),
                "text": ("qore": Type::String,),
                "unitext": ("qore": Type::String,),
                "binary": ("qore": Type::Binary,),
                "varbinary": ("qore": Type::Binary,),
                "image": ("qore": Type::Binary,),
                );

            #! maps qore type names to postgresql type names
            const QoreTypeMap = (
                "integer": "bigint",
                "float": "float",
                "number": "numeric",
                "string": "varchar",
                "date": "datetime",
                "binary": "varbinary",
                "bool": "tinyint",
                SqlUtil::CHAR: "char",
                SqlUtil::CLOB: "text",
                SqlUtil::BLOB: "varbinary",
                );

            #! equal to @ref SqlUtil::AbstractTable::TableDescriptionHashOptions
            const FreetdsTableDescriptionHashOptions = AbstractTable::TableDescriptionHashOptions;

            const FreetdsColumnDescOptions = AbstractTable::ColumnDescOptions;

            const FreetdsIndexOptions = AbstractTable::IndexOptions;

            const FreetdsConstraintOptions = AbstractTable::ConstraintOptions + FreetdsIndexOptions;

            const FreetdsTableCreationOptions = AbstractTable::TableCreationOptions + FreetdsConstraintOptions;

            const FreetdsAlignTableOptions = AbstractTable::AlignTableOptions + FreetdsTableCreationOptions;

            #! column operator specializations for FreeTDS
            const FreetdsCopMap = DefaultCopMap + (
                COP_OVER: (
                    "argcolumn": True,
                    "argoptional": True,
                    "code": string sub (*string cve, *string arg) {
                        string sql = cve + " over (";
                        if (arg)
                            sql += sprintf("partition by %s", arg);
                        sql += ")";
                        return sql;
                    },
                ),
                COP_YEAR: (
                    "code": string sub (string arg1, any arg) {
                        return sprintf("substring(convert(varchar, dt, 120), 1, 4)", arg1);
                    }
                ),
                COP_YEAR_MONTH: (
                    "code": string sub (string arg1, any arg) {
                        return sprintf("substring(convert(varchar, dt, 120), 1, 7)", arg1);
                    }
                ),
                COP_YEAR_DAY: (
                    "code": string sub (string arg1, any arg) {
                        return sprintf("substring(convert(varchar, dt, 120), 1, 10)", arg1);
                    }
                ),
                COP_YEAR_HOUR: (
                    "code": string sub (string arg1, any arg) {
                        return sprintf("substring(convert(varchar, dt, 120), 1, 13)", arg1);
                    }
                ),
                COP_SEQ: (
                    "code": string sub (string arg1, string arg) {
                        return sprintf("next value for %s", arg);
                    }
                ),
                );

            #! a hash of default value operator descriptions for FreeTDS
            const FreetdsIopMap = DefaultIopMap + (
                IOP_SEQ: (
                    "arg": Type::String,
                    "placeholder": "next value for %v",
                ),
                );
        }

        private {
            #! filegroup name for the table, if known
            *string filegroup;

            #! schema name for the table
            string schema;

            #! contains any trigger functions supporting triggers on the table
            Functions triggerFunctions;
        }

        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
            # see if there is a schema in the name
            parse_schema_name(nname, \schema, \name);
        }

        #! returns the schema name
        string getSchemaName() {
            return schema;
        }

        #! returns the data filegroup name for the table or @ref nothing if none is known
        *string getTablespaceName() {
            return filegroup;
        }

        #! returns @ref Qore::False "False" because the freetds driver does not support array binds / bulk DML operations
        bool hasArrayBind() {
            return False;
        }

        #! returns the name of the table to be used in SQL (with a possible qualifiers for schema, etc)
        string getSqlName() {
            return schema + "." + name;
        }

        private hash getTableCreationOptions() {
            return FreetdsTableCreationOptions;
        }

        private hash getTableDescriptionHashOptions() {
            return FreetdsTableDescriptionHashOptions;
        }

        private hash getColumnDescOptions() {
            return FreetdsColumnDescOptions;
        }

        private hash getIndexOptions() {
            return FreetdsIndexOptions;
        }

        private hash getConstraintOptions() {
            return FreetdsConstraintOptions;
        }

        private hash getAlignTableOptions() {
            return FreetdsAlignTableOptions;
        }

        #! returns the column operator map for this object
        private hash getColumnOperatorMap() {
            return FreetdsCopMap;
        }

        #! returns the insert operator map for this object
        private hash getInsertOperatorMap() {
            return FreetdsIopMap;
        }

        private bool checkExistenceImpl() {
            *hash qh = ds.selectRow("select * from information_schema.tables where table_schema = %v and table_name = %v", schema, name);
            if (qh)
                return inDb = True;
            return False;
        }

        private Columns describeImpl() {
            # get column descriptions
            *hash qh = ds.select("select * from information_schema.columns where table_schema = %v and table_name = %v",
                                 schema, name);
            if (!qh.column_name)
                throw "TABLE-ERROR", sprintf("cannot retrieve table information for table %y in %y", name, dsdesc);

            hash rv;
            foreach hash row in (qh.contextIterator()) {
                *hash th = FreetdsTypeMap.(row.data_type);
                softint size = row.character_maximum_length ? row.character_maximum_length : row.numeric_precision;
                if (!size)
                    size = row.datetime_precision;
                switch (th.qore) {
                    case Type::Int:
                    case Type::Float: {
                        size = 0;
                        break;
                    }
                }

                FreetdsColumn c;
                *string defval = row.column_default;
                # normalize default value expressions
                if (defval =~ /::bpchar$/)
                    defval =~ s/::bpchar$//;
                if (row.numeric_precision)
                    c = new FreetdsNumericColumn(row.column_name, row.data_type, th.qore, row.numeric_precision, row.is_nullable == "YES", defval, 0, row.numeric_scale);
                else
                    c = new FreetdsColumn(row.column_name, row.data_type, th.qore, exists size ? size : 0, row.is_nullable == "YES", defval, row.character_octet_length);

                rv.(row.column_name) = c;
            }

            return new Columns(rv);
        }

        private FreetdsPrimaryKey getPrimaryKeyImpl() {
            *hash pkh = ds.selectRow("select * from information_schema.table_constraints where table_schema = %v and table_name = %v and constraint_type = 'PRIMARY KEY'", schema, name);
            if (!pkh.constraint_name)
                return new FreetdsPrimaryKey();

            # get primary key description
            *hash qh = ds.select("select * from information_schema.key_column_usage where table_schema = %v and table_name = %v and constraint_name = %v order by ordinal_position", schema, name, pkh.constraint_name);
            if (!qh.constraint_name)
                return new FreetdsPrimaryKey();

            #printf("FreetdsTable::getPrimaryKeyImpl(): %s: %N\n", getName(), qh);
            hash rv = map {col: columns{col}}, qh.column_name;

            return new FreetdsPrimaryKey(pkh.constraint_name, rv);
        }

        private Indexes getIndexesImpl() {
            hash rv;

            # get index descriptions
            *hash qh = ds.select("select i.name as index_name, i.is_primary_key from sys.indexes i, sys.tables t, sys.schemas s where t.type_desc = 'USER_TABLE' and i.object_id = t.object_id and t.schema_id = s.schema_id and t.name = %v and s.name = %v", schema, name);

            if (qh.index_name) {
                hash ih;
                foreach hash row in (qh.contextIterator()) {
                    if (!ih.(row.index_name)) {
                        ih.(row.index_name) = (
                            "unique": row.indisunique,
                            "filegroup": row.filegroup,
                            "primary": row.indisprimary,
                        );
                    }
                    # send "blank" column for function index
                    if (row.column_name =~ /\(.*\)/ || !columns.hasKey(row.column_name))
                        ih.(row.index_name).columns{row.column_name} = {};
                    else
                        ih.(row.index_name).columns{row.column_name} = columns{row.column_name};
                }

                foreach hash i in (ih.pairIterator()) {
                    # check primary key index and add filegroup to primary key definition
                    if (i.primary && !primaryKey.empty()) {
                        FreetdsPrimaryKey pk = cast<FreetdsPrimaryKey>(primaryKey);
                        if (i.value.filegroup && !pk.filegroup)
                            pk.filegroup = i.value.filegroup;
                        continue;
                    }
                    # check unique indexes to make sure they are not matched with a unique constraint
                    if (i.value.unique && constraints.hasKey(i.key) && (constraints{i.key} instanceof AbstractUniqueConstraint)) {
                        FreetdsUniqueConstraint uk = cast<FreetdsUniqueConstraint>(constraints{i.key});
                        if (uk.matchKeys(i.value.columns)) {
                            # set filegroup in constraint
                            if (i.value.filegroup && !uk.getFilegroup())
                                uk.setFilegroup(i.value.filegroup);
                            continue;
                        }
                    }
                    rv.(i.key) = new FreetdsIndex(i.key, i.value.unique, i.value.columns, i.value.filegroup ? i.value.filegroup : NOTHING);
                }
            }

            return new Indexes(rv);
        }

        private ForeignConstraints getForeignConstraintsImpl(*hash opts) {
            hash rv;
            # get foreign referential constraints
            *hash qh = ds.select("select constraint_name, att2.attname source_column, cl.relname target_table, att.attname target_column from (select con1.conname constraint_name, generate_subscripts(con1.conkey, 1) AS rn, unnest(con1.conkey) parent, unnest(con1.confkey) child, con1.confrelid, con1.conrelid from pg_class cl join pg_namespace ns on cl.relnamespace = ns.oid join pg_constraint con1 on con1.conrelid = cl.oid where cl.relname = %v and ns.nspname = %v and con1.contype = 'f' order by conname, rn) con join pg_attribute att on att.attrelid = con.confrelid and att.attnum = con.child join pg_class cl on cl.oid = con.confrelid join pg_attribute att2 on att2.attrelid = con.conrelid and att2.attnum = con.parent order by att.attnum", name, schema);
            if (qh.constraint_name) {
                hash ch;
                foreach hash row in (qh.contextIterator()) {
                    reference c = \ch.(row.constraint_name);
                    c.columns.(row.source_column) = columns{row.source_column};
                    c.target.table = row.target_table;
                    c.target.columns.(row.target_column) = True;
                }

                foreach hash c in (ch.pairIterator()) {
                    # get a description of the target table's columns
                    Columns targ_columns = getReferencedTableColumnsUnlocked(c.value.target.table, opts.table_cache);
                    ForeignConstraintTarget fct(c.value.target.table, targ_columns.subset(c.value.target.columns.keys()));
                    rv.(c.key) = new FreetdsForeignConstraint(c.key, new Columns(c.value.columns), fct);
                }
            }

            return new ForeignConstraints(rv);
        }

        private Constraints getConstraintsImpl() {
            # get check constraints
            *hash qh = ds.select("select c.conname as constraint_name, case when c.condeferrable = 'f' then 0 else 1 end as is_deferrable, case when c.condeferred = 'f' then 0 else 1 end as is_deferred, t.relname as table_name, array_to_string(c.conkey, ' ') as constraint_key, case confupdtype when 'a' then 'NO ACTION' when 'r' then 'RESTRICT' when 'c' then 'CASCADE' when 'n' then 'SET NULL' when 'd' then 'SET DEFAULT' end as on_update, case confdeltype when 'a' then 'NO ACTION' when 'r' then 'RESTRICT' when 'c' then 'CASCADE' when 'n' then 'SET NULL' when 'd' then 'SET DEFAULT' end as on_delete, case confmatchtype when 'u' then 'UNSPECIFIED' when 'f' then 'FULL' when 'p' then 'PARTIAL' end as match_type, t2.relname as references_table, array_to_string(c.confkey, ' ') as fk_constraint_key, consrc from pg_constraint c left join pg_class t on c.conrelid  = t.oid left join pg_class t2 on c.confrelid = t2.oid join pg_catalog.pg_namespace n on n.oid = t.relnamespace where c.contype = 'c' and n.nspname = %v and t.relname = %v", schema, name);
            hash rv;
            foreach hash row in (qh.contextIterator())
                rv.(row.constraint_name) = new FreetdsCheckConstraint(row.constraint_name, row.consrc);

            Constraints c = new Constraints(rv);

            # get unique constraints
            qh = ds.select("select tc.constraint_name, kcu.column_name from information_schema.table_constraints tc join information_schema.key_column_usage kcu on (tc.table_schema = kcu.table_schema and tc.table_name = kcu.table_name and tc.constraint_name = kcu.constraint_name) where constraint_type = 'UNIQUE' and tc.table_schema = %v and tc.table_name = %v order by ordinal_position", schema, name);
            delete rv;
            foreach hash row in (qh.contextIterator()) {
                reference ch = \rv.(row.constraint_name);
                if (!ch)
                    ch = new FreetdsUniqueConstraint(row.constraint_name, {}, row.status == "ENABLED");
                ch.add(row.column_name, columns{row.column_name});
            }

            # add unique constraints to constraint hash
            map c.add($1.key, $1.value), rv.pairIterator();

            return c;
        }

        private Triggers getTriggersImpl() {
            hash rv;

            # get trigger description
            *hash qh = ds.select("select * from information_schema.triggers where event_object_schema = %v and event_object_table = %v", schema, name);

            # list of trigger functions
            list fl = ();
            # map trigger function name -> trigger name
            hash tfh;
            foreach hash row in (qh.contextIterator()) {
                *string f = (row.action_statement =~ x/EXECUTE PROCEDURE (\w+)\(\)$/)[0];
                if (f) {
                    fl += f;
                    tfh{f} = row.trigger_name;
                }

                if (!native_case)
                    map row.$1 = row.$1.lwr(), ("event_manipulation", "action_statement", "action_timing", "action_orientation");
                if (rv{row.trigger_name}) {
                    # add event to trigger
                    *string px = (rv{row.trigger_name}.src =~ x/(.+) on/i)[0];
                    if (!px)
                        throw "FREETDS-TRIGGER-ERROR", sprintf("cannot find beginning of trigger source: %s", rv{row.trigger_name}.src);
                    splice rv{row.trigger_name}.src, px.size(), 0, " or " + row.event_manipulation;
                    continue;
                }

                string src = sprintf("%s %s on %s for each %s %s", row.action_timing, row.event_manipulation, name, row.action_orientation, row.action_statement);
                rv{row.trigger_name} = new FreetdsTrigger(row.trigger_name, src);
            }

            if (fl) {
                hash fh;
                # also get trigger functions
                qh = ds.select("select p.proname, t1.typname return_type, a.rolname procedure_owner, l.lanname lang, prosrc body, pg_catalog.pg_get_functiondef(proname::regproc) hdr, pg_catalog.pg_get_function_arguments(proname::regproc) args, case provolatile when 'i' then 'IMMUTABLE' when 's' then 'STABLE' when 'v' then 'VOLATILE' end stability from pg_proc p left join pg_type t1 on p.prorettype = t1.oid left join pg_authid a on p.proowner = a.oid left join pg_language l on p.prolang = l.oid where proname in (%s)", (foldl $1 + "," + $2, (map sprintf("'%s'", $1), fl)));

                # create trigger function map
                map fh{$1.proname + "()"} = FreetdsDatabase::processFunction($1 + ("trigger_name": tfh{$1.proname}), native_case), qh.contextIterator();

                triggerFunctions = new Functions(fh);
            }

            #printf("gTI triggerFunctions: %N\n", triggerFunctions);

            return new Triggers(rv);
        }

        #! returns a string that can be used to create the table in the database
        private string getCreateTableSqlImpl(*hash opt) {
            string sql = sprintf("create table %s (\n", name);

            sql += foldl $1 + ",\n" + $2, (map "  " + $1.getCreateSql(self), columns.iterator());
            sql += "\n)";

            *string ts = opt.tablespace ? opt.tablespace : filegroup;
            if (ts)
                sql += sprintf(" on %s", ts);

            return sql;
        }

        private *list getCreateMiscSqlImpl(*hash opt, bool cache) {
            if (cache) {
                getColumnsUnlocked();
                getTriggersUnlocked();
            }

            list l = map AbstractDatabase::doCallback(opt, sprintf("comment on column %s.%s is '%s'", name, $1.name, $1.comment), AbstractDatabase::AC_Add, "column comment", $1.name, name), columns.iterator(), $1.comment;

            if (!opt.omit_trigger_functions && !triggerFunctions.empty()) {
                map l += AbstractDatabase::doCallback(opt, $1.getCreateSql(opt), AbstractDatabase::AC_Create, "trigger function", $1.name, name), triggerFunctions.iterator();
            }

            #printf("gCMSI triggerFunctions: %N\n", triggerFunctions);
            return l;
        }

        private *list getAlignSqlImpl(AbstractTable table, *hash opt) {
            FreetdsTable t = cast<FreetdsTable>(table);

            list l = ();
            # check for trigger functions in the template that are not present or different in the current table
            foreach AbstractFunction f in (t.triggerFunctions.iterator()) {
                if (!triggerFunctions.hasKey(f.name)) {
                    # create trigger function
                    l += AbstractDatabase::doCallback(opt, f.getCreateSql(opt), AbstractDatabase::AC_Create, "trigger function", f.name, name);
                }
                else if (!f.equal(triggerFunctions{f.name})) {
                    # replace current trigger function
                    l += AbstractDatabase::doCallback(opt, f.getCreateSql(opt + ("replace": True)), AbstractDatabase::AC_Recreate, "trigger function", f.name, name);
                }
            }

            # check for trigger functions not in the template and drop them
            foreach FreetdsTriggerFunction f in (triggerFunctions.iterator()) {
                if (!t.triggerFunctions.hasKey(f.name)) {
                    if (triggers{f.trigger}) {
                        l += AbstractDatabase::doCallback(opt, triggers{f.trigger}.getDropSql(name), AbstractDatabase::AC_Drop, "trigger", f.trigger, name);
                        triggers.take(f.trigger);
                    }
                    l += AbstractDatabase::doCallback(opt, f.getDropSql(), AbstractDatabase::AC_Drop, "trigger function", f.name, name);
                }
            }

            return l ? l : NOTHING;
        }

        #! returns a string that can be used to create the table in the database
        private string getCreateSqlImpl(list l) {
            return FreetdsDatabase::getCreateSql(l);
        }

        private string getRenameSqlImpl(string new_name) {
            return sprintf("alter table %s rename to %s", getSqlName(), new_name);
        }

        private AbstractColumn addColumnImpl(string cname, hash opt, bool nullable = True) {
            if (opt.precision)
                return new FreetdsNumericColumn(cname, opt.native_type, opt.qore_type, opt.precision, nullable, opt.default_value, opt.comment, 0, opt.scale);
            return new FreetdsColumn(cname, opt.native_type, opt.qore_type, opt.size, nullable, opt.default_value, opt.comment, 0);
        }

        private AbstractPrimaryKey addPrimaryKeyImpl(string cname, hash ch, *hash opt) {
            return new FreetdsPrimaryKey(cname, ch, opt.index_filegroup);
        }

        private AbstractIndex addIndexImpl(string iname, bool enabled, hash ch, *hash opt) {
            return new FreetdsIndex(iname, enabled, ch, opt.index_filegroup);
        }

        private AbstractForeignConstraint addForeignConstraintImpl(string cname, hash ch, string table, hash tch, *hash opt) {
            ForeignConstraintTarget fct(table, new Columns(tch));
            return new FreetdsForeignConstraint(cname, new Columns(ch), fct);
        }

        private AbstractCheckConstraint addCheckConstraintImpl(string cname, string src, *hash opt) {
            return new FreetdsCheckConstraint(cname, src);
        }

        private AbstractUniqueConstraint addUniqueConstraintImpl(string cname, hash ch, *hash opt) {
            return new FreetdsUniqueConstraint(cname, ch, True, opt.index_filegroup);
        }

        private AbstractTrigger addTriggerImpl(string tname, string src, *hash opt) {
            return new FreetdsTrigger(tname, src);
        }

        private bool tryInsertImpl(string sql, hash row) {
            ds.exec("begin");
            ds.exec("savepoint " + FreetdsDatabase::FREETDS_TempSavepoint);

            try {
                ds.vexec(sql, row.values());
                ds.exec("release savepoint " + FreetdsDatabase::FREETDS_TempSavepoint);
            }
            catch (hash ex) {
                if (ex.desc =~ /duplicate key value/) {
                    ds.exec("rollback to savepoint " + FreetdsDatabase::FREETDS_TempSavepoint);
                    return False;
                }
                rethrow;
            }
            return True;
        }

        private hash getQoreTypeMapImpl() {
            return QoreTypeMap;
        }

        private hash getTypeMapImpl() {
            return FreetdsTypeMap;
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument; returns NOTHING if the type cannot be converted to an SQL string
        private *string getSqlValueImpl(any v) {
            switch (v.typeCode()) {
                case NT_FLOAT:
                case NT_INT: return v.toString();

                case NT_NUMBER: return string(v);

                # double any single quotes in strings
                case NT_STRING: v =~ s/'/''/g; return "'" + v + "'";

                case NT_NULL:
                case NT_NOTHING: return "null";

                case NT_BOOLEAN: return v ? "true" : "false";

                case NT_DATE: return v.format("'YYYY-MM-DD HH:mm:SS.us'");
            }
        }

        private bool emptyImpl() {
            return triggerFunctions.empty();
        }

        #! clears FreeTDS-specific table information
        private clearImpl() {
            delete triggerFunctions;
        }

        private softlist getDropSqlImpl() {
            getTriggers();
            list l = ();
            l += sprintf("drop table %s", getSqlName());
            map l += $1.getDropSql(), triggerFunctions.iterator();
            return l;
        }

        private setupTableImpl(hash desc, *hash opt) {
            # add trigger functions to table
            AbstractDatabase::checkDriverOptions(\desc.functions, ds.getDriverName());

            foreach string fn in (desc.functions.keyIterator()) {
                if (desc.functions{fn}.typeCode() != NT_STRING)
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to function key %y is not a string giving the function source code, got type %y instead (%y)", name, fn, desc.functions{fn}.type(), desc.functions{fn});

                string src = desc.functions{fn};
                addTriggerFunctionUnlocked(fn, src, fn);
            }
        }

        #! returns @ref Qore::True "True" if the database links constraints to indexes (ie dropping the constraint drops the index, etc)
        private bool constraintsLinkedToIndexesImpl() {
            return True;
        }

        #! returns @ref Qore::True "True" if the database automatically creates a unique constraint when a unique index is created (ex: mysql)
        private bool uniqueIndexCreatesConstraintImpl() {
            return False;
        }

        #! returns @ref Qore::True "True" if the database support filegroups
        private bool supportsTablespacesImpl() {
            return True;
        }

        #! processes a string for use in SQL select statements when there is a "limit" argument, but no "orderby" or "offset" arguments
        private doSelectLimitOnlyUnlockedImpl(reference sql, reference args, *hash qh) {
           sql += " limit %v";
           args += qh.limit;
        }

        #! processes a string for use in SQL select statements when there is an "order by" and "offset" argument
        private doSelectOrderByWithOffsetSqlUnlockedImpl(reference sql, reference args, *hash qh, *hash jch, *hash ch) {
            doSelectOrderBySqlUnlocked(\sql, \args, qh, jch, ch);
            if (qh.limit) {
                sql += " limit %v";
                args += qh.limit;
            }

            if (qh.offset) {
                sql += " offset %v";
                args += qh.offset;
            }
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        private any tryExecArgsImpl(string sql, *softlist args) {
            return FreetdsDatabase::tryExecArgs(ds, sql, args);
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        private any tryExecRawImpl(string sql, *softlist args) {
            return FreetdsDatabase::tryExecRaw(ds, sql);
        }

        #! db-specific copy actions
        private copyImpl(AbstractTable old) {
            if (triggerFunctions)
                triggerFunctions = triggerFunctions.copy();
        }

        private *hash doReturningImpl(hash opt, reference sql, list args) {
            list l = ();
            foreach softstring k in (opt.returning) {
                *FreetdsColumn c = columns{k};
                if (!c)
                    throw "COLUMN-ERROR", sprintf("%s.%s is not a valid column for the \"returning\" clause (valid columns: %y)", name, k, columns.keys());
                l += k;
                args += c.qore_type ?* Type::String;
            }
            sql += sprintf(" returning %s", (foldl $1 + "," + $2, l));

            *hash h = execData(opt, sql, args);
            return h ? map {$1.key: $1.value[0]}, h.pairIterator() : h;
        }
    }
}
