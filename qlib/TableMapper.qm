# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file TableMapper.qm provides mapping functionality to a Table target 

/*  TableMapper.qm Copyright 2014 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.11 or better
%requires qore >= 0.8.11

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

# requires the Mapper module
%requires Mapper
# requires the SqlUtil module
%requires SqlUtil

module TableMapper {
    version = "1.1";
    desc = "user module providing data mapping infrastructure to an SQL Table target";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage TableMapper Module

    @tableofcontents

    @section tablemapperintro TableMapper Module Introduction

    Classes provided by this module:
    - @ref TableMapper::InboundTableMapper "InboundTableMapper": extends the @ref Mapper::Mapper class; assumes an SQL table target
    - @ref TableMapper::InboundTableMapperIterator "InboundTableMapperIterator": provides a specialization of the @ref Mapper::AbstractMapperIterator class; assumes an SQL table target; automatically inserts mapped data into the target table based on the mapper provided

    @section tablemapperexamples TableMapper Examples

    The following is an example map hash with comments:
    @code
const DataMap = (
    # output column: "id" mapper from the "Id" element of any "^attributes^" hash in the input record
    "id": "^attributes^.Id",
    # output column: "name": maps from an input field with the same name (no translations are made)
    "name": True,
    # output column: "explicit_count": maps from the input "Count" field
    "explicit_count": "Count",
    # output column: "implicit_count": runs the given code on the input record and retuns the result, the code returns the number of "Products" sub-records
    "implicit_count": int sub (any $ignored, hash $rec) { return $rec.Products.size(); },
    # output column: "order_date": converts the "OrderDate" string input field to a date in the specified format
    "order_date": ("name": "OrderDate", "date_format": "DD.MM.YYYY HH:mm:SS.us"),
    # output column: order_type: given as a constant value
    "order_type": ("constant": "NEW"),
);
    @endcode

    If this map is applied in the following way:
    @code
my Table $table($ds, "order_table");
my InboundTableMapper $map($table, DataMap);
{
    on_success $map.commit();
    on_error $map.rollback();
    # apply the map and insert the mapped for for each input record
    map $map.insertRowNoCommit($1), $input;
}
printf("%d record%s inserted\n", $map.getCount(), $map.getCount() == 1 ? "" : "s");
    @endcode

    This will insert all the mapped input data into data into the \c ORDER_TABLE
    table and then print out the number of rows inserted.
    
    @section tablemapperrelnotes Release Notes

    @subsection tablemapperv1_1 TableMapper v1.1
    - added table name to error messages

    @subsection tablemapperv1_0 TableMapper v1.0
    - Initial release.
*/

#! the TableMapper namespace contains all the definitions in the TableMapper module
public namespace TableMapper {
    #! provides an inbound data mapper to a Table target
    public class InboundTableMapper inherits Mapper::Mapper {
        # no public members
        public {
        }

        private {
            #! the target table object
            SqlUtil::AbstractTable $.table;

            #! the target Database object in case sequence value need to be acquired
            SqlUtil::AbstractDatabase $.db;
        }

        #! builds the object based on a hash providing field mappings, data constraints, and optionally custom mapping logic
        /** The target table is also scanned using @ref sqlutilintro "SqlUtil" and column definitions are used to update the target record specification, also if there are any columns with NOT NULL constraints and no default value, mapping, or constant value, then a MAP-ERROR exception is thrown

            @par Example:
            @code
const DbMapper = (
    "id": ("sequence": "seq_inventory_example"),
    "store_code": "StoreCode",
    "product_code": "ProductCode",
    "product_desc": "ProductDescription",
    "ordered": "Ordered",
    "available": "Available",
    "in_transit": "InTransit",
    "status": ("constant": "01"),
    "total": int sub (any $x, hash $rec) { return $rec.Available.toInt() + $rec.Ordered.toInt() + $rec.InTransit.toInt(); },
    );

my InboundTableMapper $map($table, DbMapper);
            @endcode

            @param table the target table object
            @param map a hash providing field mappings; each hash key is the name in lower case of the output column in the target table; each value is either @ref Qore::True "True" (meaning no translations are done; the data is copied 1:1) or a hash describing the mapping; see @ref mapperkeys for detailed documnentation for this option
            @param opts an optional hash of options for the mapper; see @ref mapperoptions for a description of valid mapper options

            @throw MAP-ERROR the map hash has a logical error (ex: \c "trunc" key given without \c "maxlen", invalid map key)
        */
        constructor(SqlUtil::Table $table, hash $map, *hash $opts) {
            $.table = $table.getTable();
            $.setup($map, $opts);

            # check map for logical errors
            $.checkMap();            
        }

        #! builds the object based on a hash providing field mappings, data constraints, and optionally custom mapping logic
        /** The target table is also scanned using @ref sqlutilintro "SqlUtil" and column definitions are used to update the target record specification, also if there are any columns with NOT NULL constraints and no default value, mapping, or constant value, then a MAP-ERROR exception is thrown

            @par Example:
            @code
const DbMapper = (
    "id": ("sequence": "seq_inventory_example"),
    "store_code": "StoreCode",
    "product_code": "ProductCode",
    "product_desc": "ProductDescription",
    "ordered": "Ordered",
    "available": "Available",
    "in_transit": "InTransit",
    "status": ("constant": "01"),
    "total": int sub (any $x, hash $rec) { return $rec.Available.toInt() + $rec.Ordered.toInt() + $rec.InTransit.toInt(); },
    );

my InboundTableMapper $map($table, DbMapper);
            @endcode

            @param table the target table object
            @param map a hash providing field mappings; each hash key is the name of the output field; each value is either @ref Qore::True "True" (meaning no translations are done; the data is copied 1:1) or a hash describing the mapping; see @ref mapperkeys for detailed documnentation for this option
            @param opts an optional hash of options for the mapper; see @ref mapperoptions for a description of valid mapper options

            @throw MAP-ERROR the map hash has a logical error (ex: \c "trunc" key given without \c "maxlen", invalid map key)
        */
        constructor(SqlUtil::AbstractTable $table, hash $map, *hash $opts) {
            $.table = $table;
            $.setup($map, $opts);

            # check map for logical errors
            $.checkMap();            
        }

        #! verifies the input map in the constructor
        private checkMap() {
            my Columns $cols = $.table.describe();

            # ensure there are no unknown mappings
            foreach my string $k in ($.map.keyIterator()) {
                if (!$cols.hasKey($k))
                    $.error("mapper specifies column '%s' that does not exist in the target table '%s'", $.getFieldName($k), $.table.getSqlName());                
            }

            # update output field definitions from real table description
            foreach my AbstractColumn $col in ($cols.iterator()) {
                my string $cn = $col.name.lwr();
                my reference $ch = \$.map.$cn;
                my int $t = $ch.typeCode();

                my bool $mand;
                if (!$col.nullable && !exists $col.def_val)
                    $mand = True;

                # only add column descriptions where mappings are missing if there is a NOT NULL constraint and no default value
                if (!exists $ch && !$mand)
                    continue;

                if ($t != NT_HASH) {
                    if ($t == NT_NOTHING && $mand && !exists $.crec.$cn)
                        $.error("output column '%s.%s' has a NOT NULL constraint and no default value, and the mapper object has no mapping or constant value; please provide a mapping or constant value for this column", $.table.getSqlName(), $.getFieldName($cn));
                    $.convertToHash($t, $cn, \$ch);
                }

                switch ($col.qore_type) {
                    case "string": $ch += ("maxlen": $col.size, "trunc": $.trunc_all); break;
                    case "number": $ch.type = "number"; break;
                    case "integer": $ch.type = "integer"; break;
                    case "date": $ch.type = "date"; break;
                    default: throw "TABLE-ERROR", sprintf("column '%s.%s' has unknown native type %y", $.table.getSqlName(), $cn, $col.native_type);
                }
                if ($mand)
                    $ch.mand = True;
            }

            map $.checkMapField($1, \$.map.$1, ("cols": $cols)), $.map.keyIterator();
        }

        #! performs type handling
        private mapFieldType(string $key, hash $m, reference $v, hash $rec) {
            if ($m.sequence)
                $v = $.db.getNextSequenceValue($m.sequence);
            Mapper::$.mapFieldType($key, $m, \$v, $rec);
        }

        #! returns @ref Qore::True "True" if the field has a mapping, @ref Qore::False "False" if not
        private bool hasMapping(hash $fh) {
            return $fh.name || $fh.struct || $fh.code || $fh.sequence;
        }

        #! perform per-field pre-processing on the passed map in the constructor
        /** @param k the field name
            @param fh a reference to the field's value in the map
        */
        private checkMapField(string $k, reference $fh, hash $th) {
            if ($fh.sequence) {
                if ($fh.sequence.typeCode() != NT_STRING)
                    $.error("column '%s.%s' has a sequence key assigned to type '%s' (%y)", $.table.getSqlName(), $.getFieldName($k), $fh.sequence.type(), $fh.sequence);
                if (!$.db)
                    $.db = AbstractDatabase::getDatabase($.table.getDatasource());

                if ($fh.type) {
                    if ($fh.type != "number" && $fh.type != "integer")
                        $.error("column '%s.%s' has a 'sequence' key, but the type is '%s'", $.table.getSqlName(), $.getFieldName($k), $fh.type);
                }
                else
                    $fh.type = "number";
            }

            Mapper::$.checkMapField($k, \$fh);
        }

        #! returns a list of valid field keys for this class (can be overridden in subclasses)
        /** @return a list of valid field keys for this class (can be overridden in subclasses)
        */
        hash validKeys() {
            return Mapper::ValidKeys + (
                "sequence": True,
                );
        }

        #! returns a list of valid constructor options for this class (can be overridden in subclasses)
        /** @return a list of valid constructor options for this class (can be overridden in subclasses)
        */
        hash optionKeys() {
            return OptionKeys + (
                "table": True,
                );
        }

        #! inserts a row into the target table based on a mapped input record; does not commit the transaction
        /** @param $rec the input record

            @return a hash of the row values inserted (row name: value)

            @throw MISSING-INPUT a field marked mandatory is missing
            @throw STRING-TOO-LONG a field value exceeds the maximum value and the 'trunc' key is not set
            @throw INVALID-NUMBER the field is marked as numeric but the input value contains non-numeric data        
        */
        hash insertRowNoCommit(hash $rec) {
            my hash $h = $.mapData($rec + $.crec);
            $.table.insertNoCommit($h);
            return $h;
        }

        #! inserts a row into the target table based on a mapped input record; commits the transaction
        /** @param $rec the input record

            @return a hash of the row values inserted (column: value), not including the extra values

            @throw MISSING-INPUT a field marked mandatory is missing
            @throw STRING-TOO-LONG a field value exceeds the maximum value and the 'trunc' key is not set
            @throw INVALID-NUMBER the field is marked as numeric but the input value contains non-numeric data        
        */
        hash insertRow(hash $rec) {
            on_success $.table.commit();
            on_error $.table.rollback();

            return $.insertRowNoCommit($rec);
        }

        #! commits the transaction
        nothing commit() {
            $.table.commit();
        }

        #! rolls back the transaction
        nothing rollback() {
            $.table.rollback();
        }

        #! returns the table name
        string getTableName() {
            return $.table.getSqlName();
        }

        #! returns the underlying SqlUtil::AbstractTable object
        SqlUtil::AbstractTable getTable() {
            return $.table;
        }
    }

    #! provides a hash iterator based on a @ref TableMapper::InboundTableMapper "InboundTableMapper" object and an iterator input source; for each iteration the iterted row is inserted into the @ref SqlUtil::Table "Table" target
    public class InboundTableMapperIterator inherits Mapper::AbstractMapperIterator {
        public {
        }

        private {
            #! data mapper
            TableMapper::InboundTableMapper $.map;

            #! row commit limit (<= 0 for no commits)
            int $.commit_limit;

            #! row count for commit
            int $.cnt = 0;

            #! a copy of the last hash value mapped
            hash $.val;
        }

        #! creates the iterator from the arguments passed
        /** The target table is also scanned using @ref sqlutilintro "SqlUtil" and column definitions are used to update the target record specification, also if there are any columns with NOT NULL constraints and no default value, mapping, or constant value, then a MAP-ERROR exception is thrown

            @par Example:
            @code
const DbMapper = (
    "id": ("sequence": "seq_inventory_example"),
    "store_code": "StoreCode",
    "product_code": "ProductCode",
    "product_desc": "ProductDescription",
    "ordered": "Ordered",
    "available": "Available",
    "in_transit": "InTransit",
    "status": ("constant": "01"),
    "total": int sub (any $x, hash $rec) { return $rec.Available.toInt() + $rec.Ordered.toInt() + $rec.InTransit.toInt(); },
    );

my InboundTableMapperIterator $i($input, $table, DbMapper);
            @endcode

            @param i input iterator; @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()" must return a hash
            @param table the target table object
            @param map a hash providing field mappings; each hash key is the name of the output column in lower case in the target table; each value is either @ref Qore::True "True" (meaning no translations are done; the data is copied 1:1) or a hash describing the mapping; see @ref mapperkeys for detailed documnentation for this option
            @param opts an optional hash of options for the mapper; see @ref mapperoptions for a description of valid mapper options
            @param commit_limit row count before a commit is made; if <= 0 then no commits are made by this object, otherwise a commit is made for each \a commit_limit rows processed by this object, commits are made in calls to @ref next()

            @note by default \a commit_limit is 0 meaning that this object will make no commits; in this case the transaction will
            have to be commited explicitly externally
        */
        constructor(Qore::AbstractIterator $i, SqlUtil::Table $table, hash $map, *hash $opts, int $commit_limit = 0) : Mapper::AbstractMapperIterator($i) {
            $.map = new TableMapper::InboundTableMapper($table, $map, $opts);
            $.commit_limit = $commit_limit > 0 ? $.commit_limit : 0;
        }

        #! creates the iterator from the arguments passed
        /** The target table is also scanned using @ref sqlutilintro "SqlUtil" and column definitions are used to update the target record specification, also if there are any columns with NOT NULL constraints and no default value, mapping, or constant value, then a MAP-ERROR exception is thrown

            @par Example:
            @code
const DbMapper = (
    "id": ("sequence": "seq_inventory_example"),
    "store_code": "StoreCode",
    "product_code": "ProductCode",
    "product_desc": "ProductDescription",
    "ordered": "Ordered",
    "available": "Available",
    "in_transit": "InTransit",
    "status": ("constant": "01"),
    "total": int sub (any $x, hash $rec) { return $rec.Available.toInt() + $rec.Ordered.toInt() + $rec.InTransit.toInt(); },
    );

my InboundTableMapperIterator $i($input, $table, DbMapper);
            @endcode

            @param i input iterator; @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()" must return a hash
            @param table the target table object
            @param map a hash providing field mappings; each hash key is the name of the output column in lower case in the target table; each value is either @ref Qore::True "True" (meaning no translations are done; the data is copied 1:1) or a hash describing the mapping; see @ref mapperkeys for detailed documnentation for this option
            @param opts an optional hash of options for the mapper; see @ref mapperoptions for a description of valid mapper options
            @param commit_limit row count before a commit is made; if <= 0 then no commits are made by this object, otherwise a commit is made for each \a commit_limit rows processed by this object, commits are made in calls to @ref next()

            @note by default \a commit_limit is 0 meaning that this object will make no commits; in this case the transaction will
            have to be commited explicitly externally
        */
        constructor(Qore::AbstractIterator $i, SqlUtil::AbstractTable $table, hash $map, *hash $opts, int $commit_limit = 0) : Mapper::AbstractMapperIterator($i) {
            $.map = new TableMapper::InboundTableMapper($table, $map, $opts);
            $.commit_limit = $commit_limit > 0 ? $.commit_limit : 0;
        }

        #! creates the iterator from the arguments passed
        /** The target table is also scanned using @ref sqlutilintro "SqlUtil" and column definitions are used to update the target record specification, also if there are any columns with NOT NULL constraints and no default value, mapping, or constant value, then a MAP-ERROR exception is thrown

            @par Example:
            @code
const DbMapper = (
    "id": ("sequence": "seq_inventory_example"),
    "store_code": "StoreCode",
    "product_code": "ProductCode",
    "product_desc": "ProductDescription",
    "ordered": "Ordered",
    "available": "Available",
    "in_transit": "InTransit",
    "total": int sub (any $x, hash $rec) { return $rec.Available.toInt() + $rec.Ordered.toInt() + $rec.InTransit.toInt(); },
    );

my InboundTableMapper $map($table, DbMapper);
my InboundTableMapperIterator $i($input, $map);
            @endcode

            @param i input iterator; @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()" must return a hash
            @param map the mapper to transform the data
            @param commit_limit row count before a commit is made; if <= 0 then no commits are made by this object, otherwise a commit is made for each \a commit_limit rows processed by this object, commits are made in calls to @ref next()
        */
        constructor(Qore::AbstractIterator $i, TableMapper::InboundTableMapper $map, int $commit_limit = 0) : Mapper::AbstractMapperIterator($i) {
            $.map = $map;
            $.commit_limit = $commit_limit > 0 ? $.commit_limit : 0;
        }

        #! returns the current row transformed with the mapper
        hash getValue() {
            if ($.val)
                return $.val;
            return $.val = $.map.mapData($.i.getValue());
        }

        #! Moves the current position of the input iterator to the next element; returns @ref Qore::False "False" if there are no more elements otherwise inserts the row in the target table and returns @ref Qore::True "True"
        /** if \a commit_limit is > 0 then @ref TableMapper::InboundTableMapper::commit() is called for every \a commit_limit rows according to the internal row count

            @return @ref Qore::False "False" if there are no more elements, in this case if there is an uncommitted transaction according to the internal row count, then @ref TableMapper::InboundTableMapper::commit() is called as well
        */
        bool next() {
            delete $.val;
            my bool $rv = $.i.next();

            if ($rv)
                $.map.getTable().insertNoCommit($.getValue());

            # commit transaction if necessary
            if ($.commit_limit && (($rv && (++$.cnt == $.commit_limit)) || (!$rv && $.cnt))) {
                $.map.commit();
                $.cnt = 0;
            }

            return $rv;
        }

        #! returns the \a commit_limit value set in the constructor()
        int commitLimit() {
            return $.commit_limit;
        }

        #! commits the transaction
        nothing commit() {
            $.map.commit();
        }

        #! rolls back the transaction
        nothing rollback() {
            $.map.rollback();
        }

        #! returns the table name
        string getTableName() {
            return $.map.getTableName();
        }

        #! returns the internal record count
        /** @see resetCount()
        */
        int getCount() {
            return $.map.getCount();
        }

        #! resets the internal record count
        /** @see getCount()
        */
        resetCount() {
            $.map.resetCount();
        }
    }
}
