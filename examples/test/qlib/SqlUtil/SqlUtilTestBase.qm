#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%enable-all-warnings
%require-types
%strict-args

module SqlUtilTestBase {
    version = "0.1";
    desc = "SqlUtil test base module";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

%requires ../../../../qlib/QUnit.qm
%requires ../../../../qlib/SqlUtil.qm
%requires ../../../../qlib/BulkSqlUtil.qm
%requires ../../../../qlib/Schema.qm

public class SqlUtilTestSchema inherits AbstractSchema {
    constructor(AbstractDatasource ds, *string dts, *string its) : AbstractSchema(ds, dts, its) {
    }

    log(string fmt) {
        delete argv;
    }

    logpf(string fmt) {
        delete argv;
    }

    logProgress(string fmt) {
        delete argv;
    }
}

public class SqlTestBase inherits QUnit::Test {
    private {
        AbstractSchema schema;
        AbstractTable table;

        const MyOpts = Opts + (
            "connstr": "c,conn=s",
            );

        const OptionColumn = 22;

        hash expect_data;

        list insert_data;
        list upsert_data;
    }

    constructor(string testName, string testVer, any args, *hash mopts) : Test(testName, testVer, \args, mopts) {
        addTestCase("Insert", \insertTest());
        addTestCase("Select", \selectTest());
        addTestCase("Update", \updateTest());
        addTestCase("Upsert", \upsertTest());
        addTestCase("BulkInsert", \bulkInsertTest());
        addTestCase("BulkUpsert", \bulkUpsertTest());
        addTestCase("Column Operators", \columnOperatorTest());
    }

    globalTearDown() {
        # drop the test schema
        if (schema)
            schema.drop(False, m_options.verbose);
    }

    insertTest() {
        if (!table)
            testSkip("no DB connection");

        on_success table.commit();
        on_error table.rollback();

        foreach hash data in (insert_data)
            assertEq(NOTHING, table.insertNoCommit(data));
    }

    selectTest() {
        if (!table)
            testSkip("no DB connection");

        on_success table.commit();
        on_error table.rollback();

        *list rows = table.selectRows();
        assertEq (2, rows.size());

        foreach hash e in (expect_data.pairIterator()) {
            # printf("* %s\n", e.key);
            # printf("  I: %s: %N\n", insert_data[0]{e.key}.type(), insert_data[0]{e.key});
            # printf("  R: %s: %N\n", rows[0]{e.key}.type(), rows[0]{e.key});
            if (e.value === NOTHING)
                continue; # skipping assertion
            assertEq (e.value, rows[0]{e.key}, "checking data in column " + e.key);
        }
    }

    updateTest() {
        if (!table)
            testSkip("no DB connection");

        on_success table.commit();
        on_error table.rollback();

        map assertEq(1, table.updateNoCommit($1 - "id", ("id": $1.id))), insert_data;
    }

    upsertTest() {
        if (!table)
            testSkip("no DB connection");

        on_success table.commit();
        on_error table.rollback();

        code upsert = table.getUpsertClosure(upsert_data[0]);
        assertEq(AbstractTable::UR_Verified, upsert(upsert_data[0]));
        # upsert can return UR_Verified even when rows are upserted when there is an optimized upsert implementation used in the driver-specific SqlUtil module
        assertEq(True, inlist(upsert(upsert_data[1]), (AbstractTable::UR_Inserted, AbstractTable::UR_Verified)));
    }

    bulkInsertTest() {
        if (!table)
            testSkip("no DB connection");

        on_success table.commit();
        on_error table.rollback();

        table.delNoCommit();

        BulkInsertOperation insert(table);
        on_success insert.flush();
        on_error insert.discard();

        foreach hash data in (insert_data)
            assertEq(NOTHING, insert.queueData(data));
    }

    bulkUpsertTest() {
        if (!table)
            testSkip("no DB connection");

        on_success table.commit();
        on_error table.rollback();

        table.delNoCommit();

        BulkUpsertOperation insert(table);
        on_success insert.flush();
        on_error insert.discard();

        foreach hash data in (upsert_data)
            assertEq(NOTHING, insert.queueData(data));
    }

    columnOperatorTest() {
        if (!table)
            testSkip("no DB connection");

        on_success table.commit();
        on_error table.rollback();

        hash soh = ("columns": (
                cop_as (cop_value (0), "cop_value"), # triggers bug #511 (GitHub)
                cop_as (cop_lower (cop_value ("Ahoj")), "cop_lower"),
                cop_as (cop_upper (cop_value ("Ahoj")), "cop_upper"),
                cop_as (cop_prepend ("id", "abc"), "cop_prepend"),
                cop_as (cop_append ("id", "abc"), "cop_append"),
                cop_as (cop_minus ("id", "id"), "cop_minus"),
                cop_as (cop_plus ("id", "id"), "cop_plus"),
                cop_as (cop_divide ("id", "id"), "cop_divide"),
                cop_as (cop_multiply ("id", "id"), "cop_multiply"),
                # cop_as (cop_minus ("id", cop_value(2)), "cop_minus"),
                # cop_as (cop_plus ("id", cop_value(2)), "cop_plus"),
                # cop_as (cop_divide ("id", cop_value(2)), "cop_divide"),
                # cop_as (cop_multiply ("id", cop_value(2)), "cop_multiply"),
                ),
                "where": ("id": 2)
                );

        *hash row = table.selectRow (soh);

        hash expect = (
                "cop_value": 0,
                "cop_lower": "ahoj",
                "cop_upper": "AHOJ",
                "cop_prepend": "abc2",
                "cop_append": "2abc",
                "cop_minus": 0,
                "cop_plus": 4,
                "cop_divide": 1,
                "cop_multiply": 4,
                );

        foreach hash e in (expect.pairIterator())
            assertEq (e.value, row{e.key}, "checking column operator " + e.key);

        soh = ("columns": (
                cop_as ("char_f", "pivot"),
                cop_as (cop_min ("id"), "cop_min"),
                cop_as (cop_max ("id"), "cop_max"),
                cop_as (cop_avg ("id"), "cop_avg"),
                cop_as (cop_sum ("id"), "cop_sum"),
                cop_as (cop_count ("char_f"), "cop_count"),
                cop_as (cop_count (cop_distinct ("char_f")), "cop_distinct"),
                ),
                "groupby": ("char_f")
                );

        row = table.selectRow (soh);

        expect = (
                "cop_min": 1,
                "cop_max": 22,
                "cop_avg": 1.5n,
                "cop_sum": 3,
                "cop_count": 2,
                "cop_distinct": 1,
                );

        foreach hash e in (expect.pairIterator())
            assertEq (e.value, row{e.key}, "checking column operator " + e.key);
    }

    static string getColumnName(string n) {
        n =~ s/ //g;
        return n + "_f";
    }

    init_test_data (hash custom_columns) {
        hash row;

        foreach hash h in (custom_columns.pairIterator()) {
            string cn = getColumnName(h.key);
            row{cn} = h.value.bind ?? h.value.value ?? h.value;

            if (h.value.typeCode() == NT_HASH && h.value.hasKey('expect'))
                expect_data{cn} = h.value.expect;
            else
                expect_data{cn} = h.value.bind.'^value^' ?? h.value.value ?? h.value;
        }
        insert_data = (("id": 1,) + row, ("id": 2,) + row,);
        upsert_data = (("id": 2,) + row, ("id": 3,) + row,);
    }
}
