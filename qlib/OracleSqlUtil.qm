# -*- mode: qore; indent-tabs-mode: nil -*-
# @file OracleSqlUtil.qm Qore user module for working with Oracle SQL data

/*  OracleSqlUtil.qm Copyright 2013 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.8 or better
%requires qore >= 0.8.8

# requires the SqlUtil module
%requires SqlUtil >= 1.0

# requires the Util module
%requires Util >= 1.0

# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings
%disable-warning non-existent-method-call

module OracleSqlUtil {
    version = "1.0";
    desc = "user module for working with Oracle SQL data";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
}

/*  Version History
    * 2013-xx-xx v1.0: David Nichols <david@qore.org>
      + the initial version of the OracleSqlUtil module
*/

/** @mainpage OracleSqlUtil Module

    The %OracleSqlUtil module provides a high level API for working with Oracle database objects.

    Usually this module is loaded on demand from the SqlUtil module, however to use this module
    directly, use \c "%requires OracleSqlUtil" in your code.
    
    All the public symbols in the module are defined in the OracleSqlUtil namespace
*/

#! the OracleSqlUtil namespace contains all the objects in the OracleSqlUtil module
public namespace OracleSqlUtil {
    public OracleTable sub get_table(AbstractDatasource nds, string nname, *hash opts) {
	return new OracleTable(nds, nname, opts);
    }

    public class OracleColumn inherits AbstractColumn {
        public {
            #! the column uses character semantics
            bool char_used;
            #! any comments on the column
            *string comment;
            #! byte size of the column
            int byte_size;
        }

        constructor(string n, string nt, *string qt, int sz, int cs, softint prec, softint sc, bool nul, *string dv, bool cu, *string cm, int bs) : AbstractColumn(n, nt, qt, sz, cs, prec, sc, nul, dv) {
            char_used = cu;
            comment = cm;
            byte_size = bs;
        }

        #! returns a list of sql strings that can be used to add the column to an existing table
        /** @par Example:
            @code
my list $l = $col.getCreateSql($t);
            @endcode

            @param t the AbstractTable object to modify
         */
        list getCreateSql(AbstractTable t) {
	    list l += sprintf("alter table %s add %s", t.getSqlName(), getCreateSql());	    
	    if (comment)
		l += sprintf("comment on column %s.%s is %s", t.getSqlName(), name, t.getSqlValue(comment));
            return l;
        }

        #! returns a list of sql strings that can be used to modify the column to the new definition
        /** @par Example:
            @code
my list $l = $col.getModifySql($t, $newcol);
            @endcode

            The column names are assumed to be equal.

            @param t the AbstractTable object to modify
            @param c the new column definition
         */
        list getModifySql(AbstractTable t, AbstractColumn col) {
            list l = ();
            OracleColumn c = col;

            string sql = sprintf("alter table %s modify %s", t.getSqlName(), name);
            
            if (native_type != c.native_type
                || size != c.size
                || scale != c.scale
                )
                sql += sprintf(" %s", c.getNativeTypeString());

            if (def_val != c.def_val)
                sql += sprintf(" default %s", exists c.def_val ? c.def_val : "null");

            if (nullable != c.nullable) {
                sql += sprintf("%snull", c.nullable ? "" : "not ");
            }
            l += sql;

            # to remove a comment we set it to the empty string ('')
            if (c.comment != comment)
		l += sprintf("comment on column %s.%s is %s", t.getSqlName(), name, c.comment ? t.getSqlValue(c.comment) : "''");
            return l;
        }
    }

    public class OracleIndex inherits AbstractIndex {
        public {
            #! the native type of the index (if supported)
            string native_type;

            #! the tablespace name of the index (if supported)
            *string tablespace;
        }

        constructor(string n, bool u, hash c, string nt, *string t) : AbstractIndex(n, u, c) {
            native_type = nt;
            tablespace = t;
        }

        string getCreateSql(string table_name, *hash opt) {
            string sql = sprintf("create %sindex %s on %s (%s)", unique ? "unique " : "", name, table_name, (foldl $1 + ", " + $2, columns.keyIterator()));

            *string ts = opt.index_tablespace ? opt.index_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            if (opt.compute_statistics)
                sql += " compute statistics";

            return sql;
        }
    }

    public class OracleForeignConstraint inherits AbstractForeignConstraint {
        public {
            #! @ref Qore::True if the constraint is enabled, @ref Qore::False if not
            bool enabled;
        }

        constructor(string n, Columns c, ForeignConstraintTarget t, bool e) : AbstractForeignConstraint(n, c, t) {
            enabled = e;
        }

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s foreign key (%s) references %s (%s)", table_name, name, (foldl $1 + ", " + $2, columns.keys()), target.table, (foldl $1 + ", " + $2, target.columns.keys()));
        }
    }

    public class OracleCheckConstraint inherits AbstractCheckConstraint {
        public {
            #! @ref Qore::True if the constraint is enabled, @ref Qore::False if not
            bool enabled;
        }

        constructor(string n, string n_src, bool e = True) : AbstractCheckConstraint(n, n_src) {
            enabled = e;
        }        

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s check (%s)", table_name, name, src);
        }
    }

    public class OraclePrimaryKey inherits AbstractPrimaryKey {
        public {
            #! any tablespace for the primary key index
            *string tablespace;
        }

        constructor(string n, *hash c, *string ts) : AbstractPrimaryKey(n, c) {
            tablespace = ts;
        }

        string getCreateSql(string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s primary key (%s)", table_name, name, (foldl $1 + ", " + $2, keyIterator()));
            *string ts = opts.index_tablespace ? opts.index_tablespace : tablespace;
            if (ts) {
                sql += sprintf(" using index tablespace %s", ts);
                if (opts.compute_statistics)
                    sql += " compute statistics";
            }

            return sql;
        }
    }

    public class OracleTrigger inherits AbstractTrigger {
        public {
            #! @ref Qore::True if the trigger is enabled, @ref Qore::False if not
            bool enabled;
        }

        constructor(string n, string n_src, bool en = True) : AbstractTrigger(n, n_src) {
            enabled = en;
        }

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("create trigger %s %s", name, src);
        }
    }

    public class OracleTable inherits AbstractTable {
        public {
            const OraTypeMap = (
                "number": ("qore": Type::Number, "size": SZ_NUM, "size_range": (1, 38), "scale_range": (-84, 127)),
                "varchar2": ("qore": Type::String, "size": SZ_MAND, "size_range": (1, 4000)),
                "char": ("qore": Type::String, "size": SZ_MAND, "size_range": (1, 4000)),
                "date": ("qore": Type::Date,),
		"timestamp": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 9)),
		"timestamp with time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 9)),
		"timestamp with local time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 9)),
                "timestamp(0)": ("qore": Type::Date,),
                "timestamp(1)": ("qore": Type::Date,),
                "timestamp(2)": ("qore": Type::Date,),
                "timestamp(3)": ("qore": Type::Date,),
                "timestamp(4)": ("qore": Type::Date,),
                "timestamp(5)": ("qore": Type::Date,),
                "timestamp(6)": ("qore": Type::Date,),
                "timestamp(7)": ("qore": Type::Date,),
                "timestamp(8)": ("qore": Type::Date,),
                "timestamp(9)": ("qore": Type::Date,),
                "timestamp(0) with time zone": ("qore": Type::Date,),
                "timestamp(1) with time zone": ("qore": Type::Date,),
                "timestamp(2) with time zone": ("qore": Type::Date,),
                "timestamp(3) with time zone": ("qore": Type::Date,),
                "timestamp(4) with time zone": ("qore": Type::Date,),
                "timestamp(5) with time zone": ("qore": Type::Date,),
                "timestamp(6) with time zone": ("qore": Type::Date,),
                "timestamp(7) with time zone": ("qore": Type::Date,),
                "timestamp(8) with time zone": ("qore": Type::Date,),
                "timestamp(9) with time zone": ("qore": Type::Date,),
                "timestamp(0) with local time zone": ("qore": Type::Date,),
                "timestamp(1) with local time zone": ("qore": Type::Date,),
                "timestamp(2) with local time zone": ("qore": Type::Date,),
                "timestamp(3) with local time zone": ("qore": Type::Date,),
                "timestamp(4) with local time zone": ("qore": Type::Date,),
                "timestamp(5) with local time zone": ("qore": Type::Date,),
                "timestamp(6) with local time zone": ("qore": Type::Date,),
                "timestamp(7) with local time zone": ("qore": Type::Date,),
                "timestamp(8) with local time zone": ("qore": Type::Date,),
                "timestamp(9) with local time zone": ("qore": Type::Date,),
                "interval year(0) to month": ("qore": Type::Date,),
                "interval year(1) to month": ("qore": Type::Date,),
                "interval year(2) to month": ("qore": Type::Date,),
                "interval year(3) to month": ("qore": Type::Date,),
                "interval year(4) to month": ("qore": Type::Date,),
                "interval year(5) to month": ("qore": Type::Date,),
                "interval year(6) to month": ("qore": Type::Date,),
                "interval year(7) to month": ("qore": Type::Date,),
                "interval year(8) to month": ("qore": Type::Date,),
                "interval year(9) to month": ("qore": Type::Date,),
                "interval day(0) to second(0)": ("qore": Type::Date,),
                "interval day(0) to second(1)": ("qore": Type::Date,),
                "interval day(0) to second(2)": ("qore": Type::Date,),
                "interval day(0) to second(3)": ("qore": Type::Date,),
                "interval day(0) to second(4)": ("qore": Type::Date,),
                "interval day(0) to second(5)": ("qore": Type::Date,),
                "interval day(0) to second(6)": ("qore": Type::Date,),
                "interval day(0) to second(7)": ("qore": Type::Date,),
                "interval day(0) to second(8)": ("qore": Type::Date,),
                "interval day(0) to second(9)": ("qore": Type::Date,),
                "interval day(1) to second(0)": ("qore": Type::Date,),
                "interval day(1) to second(1)": ("qore": Type::Date,),
                "interval day(1) to second(2)": ("qore": Type::Date,),
                "interval day(1) to second(3)": ("qore": Type::Date,),
                "interval day(1) to second(4)": ("qore": Type::Date,),
                "interval day(1) to second(5)": ("qore": Type::Date,),
                "interval day(1) to second(6)": ("qore": Type::Date,),
                "interval day(1) to second(7)": ("qore": Type::Date,),
                "interval day(1) to second(8)": ("qore": Type::Date,),
                "interval day(1) to second(9)": ("qore": Type::Date,),
                "interval day(2) to second(0)": ("qore": Type::Date,),
                "interval day(2) to second(1)": ("qore": Type::Date,),
                "interval day(2) to second(2)": ("qore": Type::Date,),
                "interval day(2) to second(3)": ("qore": Type::Date,),
                "interval day(2) to second(4)": ("qore": Type::Date,),
                "interval day(2) to second(5)": ("qore": Type::Date,),
                "interval day(2) to second(6)": ("qore": Type::Date,),
                "interval day(2) to second(7)": ("qore": Type::Date,),
                "interval day(2) to second(8)": ("qore": Type::Date,),
                "interval day(2) to second(9)": ("qore": Type::Date,),
                "clob": ("qore": Type::String,),
                "blob": ("qore": Type::Binary,),
                "long": ("qore": Type::Binary,),
                "raw": ("qore": Type::Binary, "size": SZ_MAND, "size_range": (1, 2000)),
                "bfile": ("qore": Type::Binary,),
                "binary_float": ("qore": Type::Float,),
                "binary_double": ("qore": Type::Float,),
                "rowid": ("qore": Type::String,),
                "urowid": ("qore": Type::String, "size": SZ_OPT, "size_range": (1, 4000)),
                );

            const QoreTypeMap = (
                "integer": "number",
                "float": "number",
                "number": "number",
                "string": "varchar2",
                "date": "timestamp(6)",
                "binary": "blob",
                );

            const OraColumnOptions = AbstractTable::ColumnOptions + (
                "comment": Type::String,
                );

            const OracleIndexOptions = AbstractTable::IndexOptions + (
                "compute_statistics": Type::Boolean,
                );

            const OraclePrimaryKeyOptions = OracleIndexOptions;

            #! Oracle table creation options
            const OracleTableCreationOptions = AbstractTable::TableCreationOptions + OracleIndexOptions;
        }

        private {
	    # schema name
            string schema;

	    # tablespace name
            string tablespace;

	    # is the table read only?
            bool readonly;
	    
	    # table comment
            *string comment;

            #! does the current oracle driver support long values?
            bool has_long;
        }

        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
            # see if there is a schema in the name
            *string sstr = (nname =~ x/^(\w+)\.\w+/)[0];
            if (sstr) {
                schema = sstr;
                splice nname, 0, schema.size() + 1;
                name = nname;
            }
            else
		schema = ds.getUserName();

            # the oracle driver >= 3.0 supports selecting from LONG columns
            has_long = compare_version("3.0", getModuleHash().oracle.version) >= 0;
        }

	private setTableInfoIntern() {
	    hash row = (schema.lwr() == ds.getUserName().lwr()) ? setTable() : setSchemaTable();

            tablespace = row.tablespace_name;
            readonly = row.read_only == "YES";
            if (!native_case)
                tablespace = tablespace.lwr();

            # get any comment
            any cm = ds.selectRow("select * from all_tab_comments where owner = %v and table_name = %v", schema.upr(), name.upr()).comments;
            comment = cm ? cm : NOTHING;

	    inDb = True;
	}

        string getSqlName() {
            return sprintf("%s.%s", schema, name);
        }

        private hash setSchemaTable() {
            # get the table information if possible
            *hash row = ds.selectRow("select * from all_tables where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (!row)
                throw "TABLE-ERROR", sprintf("table %y.%y does not exist or is not accessible to this user (%s)", schema, name, getDBString());
            return row;
        }

        private hash setTable() {
            # see if the current user has the table
            *hash row = ds.selectRow("select * from user_tables where table_name = %v", name.upr());
            if (row) {
                schema = getUserSchema();
                return row;
            }

            bool pub = False;
            # see if there is a user synonym with this name
            row = ds.selectRow("select * from user_synonyms where synonym_name = %v", name.upr());
            if (!row) {
                # see if there is a public synonym with this name
                row = ds.selectRow("select * from all_synonyms where owner = 'PUBLIC' and synonym_name = %v", name.upr());
                if (!row)
                    throw "TABLE-ERROR", sprintf("table %y or synonym %y does not exist or is not accessible to this user (%s)", name, name, getDBString());
                pub = True;
            }
            
            # update the table name if necessary
            string orig_name = name;
            if (name.upr() != row.table_name) {
                name = row.table_name;
                if (!native_case)
                    name = name.lwr();
            }
            
            schema = row.table_owner;
            if (!native_case)
                schema = schema.lwr();
            
            # get the table information if possible
            row = ds.selectRow("select * from all_tables where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (!row)
                throw "TABLE-ERROR", sprintf("%y is a %ssynonym pointing to table %y.%y which does not exist or is not accessible to this user (%s)", orig_name, pub ? "public " : "", schema, name, getDBString());
            return row;
        }

        private string getUserSchema() {
            string rv = ds.getUserName();
            if (native_case)
                rv = rv.upr();
            return rv;
        }

        private string getDBString() {
            return sprintf("%s@%s", ds.getUserName(), ds.getDBName());
        }

        string getSchemaName() {
            return schema;
        }

        *string getTablespaceName() {
            return tablespace;
        }

        *string getComment() {
            return comment;
        }

        bool readOnly() {
            return readonly;
        }

        private hash getColumnOptions() {
            return OraColumnOptions;
        }

        private Columns describeImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            # get column descriptions
            *hash qh = ds.select("select col.column_name, data_type, data_length, data_precision, data_scale, nullable, data_default, char_length, char_used, comments from all_tab_columns col, all_col_comments com where col.owner = %v and col.table_name = %v and com.owner = col.owner and com.table_name = col.table_name and com.column_name = col.column_name order by column_id", schema.upr(), name.upr());
            if (!qh.column_name)
                throw "TABLE-ERROR", sprintf("cannot retrieve table information for table %y in %y", name, dsdesc);

            hash rv;
            foreach hash row in (qh.contextIterator()) {
                *hash th = OraTypeMap.(row.data_type.lwr());
                int size = row.data_type == "NUMBER" && row.data_precision ? row.data_precision : row.data_length;
                switch (row.data_type) {
                    case "ROWID":
                    case "UROWID":
                    case "DATE":
                    case "BINARY_FLOAT":
                    case "BINARY_DOUBLE":
                    case =~ /^TIMESTAMP/:
                    case =~ /^INTERVAL/:
                    case "BFILE":
                    case "BLOB":
                    case "CLOB": size = 0; break;
                }
                if (!native_case) {
                    row.column_name = row.column_name.lwr();
                    row.data_type = row.data_type.lwr();
                }
                trim row.data_default;
                rv.(row.column_name) = new OracleColumn(row.column_name, row.data_type, th.qore, size, row.char_length, row.data_precision, row.data_scale, row.nullable == "Y", row.data_default ? row.data_default : NOTHING, row.char_used == "C", row.comments ? row.comments : NOTHING, row.data_length);
            }

            return new Columns(rv);
        }

        private *OraclePrimaryKey getPrimaryKeyImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            hash rv;

            # get primary key description
            *hash qh = ds.select("select cons.constraint_name, cols.column_name, cols.position, cons.status, cons.owner from all_constraints cons, all_cons_columns cols where cols.owner = %v and cols.table_name = %v and cons.constraint_type = 'P' and cons.owner = %v and cons.constraint_name = cols.constraint_name order by cols.position", schema.upr(), name.upr(), schema.upr());
            if (!qh.constraint_name)
                return;

            foreach string col in (qh.column_name) {
                string cn = native_case ? col : col.lwr();
                rv{cn} = columns{cn};
            }

            string pkname = qh.constraint_name[0];
            if (!native_case)
                pkname = pkname.lwr();
            return new OraclePrimaryKey(pkname, rv);
        }

        private Indexes getIndexesImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            hash rv;

            # get index description
            *hash qh = ds.select("select index_name, index_type, uniqueness, tablespace_name from all_indexes where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (qh.index_name) {
                hash ih;
                # get column info for all indexes in 1 query
                *hash iqh = ds.select("select * from all_ind_columns where table_owner = %v and table_name = %v order by index_name, column_position", schema.upr(), name.upr());
                foreach hash row in (iqh.contextIterator()) {
                    if (!native_case) {  
                        row.index_name = row.index_name.lwr();
                        row.column_name = row.column_name.lwr();
                    }
                    ih{row.index_name}{row.column_name} = columns{row.column_name};
                }
                
                foreach hash row in (qh.contextIterator()) {
                    if (!native_case) {
                        row.index_name = row.index_name.lwr();
                        row.tablespace_name = row.tablespace_name.lwr();
                    }
                    # skip system indexes
                    if (!ih{row.index_name})
                        continue;
                    rv.(row.index_name) = new OracleIndex(row.index_name, row.uniqueness == "UNIQUE", ih{row.index_name}, row.index_type, row.tablespace_name);
                }

            }

            return new Indexes(rv);
        }

        private ForeignConstraints getForeignConstraintsImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            hash ch;

            # get foreign referential constraints
            *hash qh = ds.select("select constraint_name, status from user_constraints where owner = %v and table_name = %v and constraint_type = 'R'", schema.upr(), name.upr());
            if (qh.status) {
                hash rv;
                foreach hash row in (qh.contextIterator()) {
                    if (!native_case)
                        row.constraint_name = row.constraint_name.lwr();
                    rv.(row.constraint_name) = (
                        "enabled": row.status == "ENABLED",
                        );
                }
                qh = ds.select("select c.constraint_name, status, cols1.column_name source_column, cols1.position, cols2.table_name target_table, cols2.column_name target_column from all_constraints c, all_cons_columns cols1, all_cons_columns cols2 where c.owner = %v and c.table_name = %v and c.constraint_name = cols1.constraint_name and constraint_type = 'R' and c.r_constraint_name = cols2.constraint_name and cols1.position = cols2.position and cols1.owner = %v and cols2.owner = %v order by cols1.position", schema.upr(), name.upr(), schema.upr(), schema.upr());
                foreach hash row in (qh.contextIterator()) {
                    if (!native_case) {
                        row.constraint_name = row.constraint_name.lwr();
                        row.source_column = row.source_column.lwr();
                        row.target_column = row.source_column.lwr();
                        row.target_table = row.target_table.lwr();
                    }
                    reference c = \rv.(row.constraint_name);
                    c.columns.(row.source_column) = columns{row.source_column};
                    c.target.table = row.target_table;
                    c.target.columns.(row.target_column) = True;
                }

                # temporary foreign table buffer hash
                hash fth;
                foreach hash c in (rv.pairIterator()) {
                    # get a description of the target table for the target column descriptions
                    if (!fth{c.value.target.table})
                        fth{c.value.target.table} = new OracleTable(ds, c.value.target.table, opts);
                    ForeignConstraintTarget fct(c.value.target.table, fth{c.value.target.table}.describe().subset(c.value.target.columns.keys()));
                    ch.(c.key) = new OracleForeignConstraint(c.key, new Columns(c.value.columns), fct, c.value.enabled);
                }
            }

            return new ForeignConstraints(ch);
        }

        private Constraints getConstraintsImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            # if we cannot select "long" values then skip this: all_constraints.search_condition is a LONG for example
            if (!has_long)
                return new Constraints();

            # get only user constraints
            *hash qh = ds.select("select constraint_name, search_condition, status from all_constraints where owner = %v and table_name = %v and constraint_type = 'C' and generated != 'GENERATED NAME'", schema.upr(), name.upr());
            hash rv;
            foreach hash row in (qh.contextIterator()) {
                if (!native_case)
                    row.constraint_name = row.constraint_name.lwr();
                rv.(row.constraint_name) = new OracleCheckConstraint(row.constraint_name, row.search_condition, row.status == "ENABLED");
            }
            return new Constraints(rv);
        }

        private Triggers getTriggersImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            hash rv;

            # get trigger description
            *hash qh = ds.select("select * from all_triggers where owner = %v and table_name = %v", schema.upr(), name.upr());
            foreach hash row in (qh.contextIterator()) {
                if (!native_case)
                    map row.$1 = row.$1.lwr(), ("trigger_name", "trigger_type", "triggering_event", "referencing_names", "description");
                #printf("%y: %s\n", row.trigger_name, row.description);

                # replace newlines with spaces
                row.description =~ s/\n/ /g;
                trim row.description;

                # remove trigger name from description line
                splice row.description, 0, row.trigger_name.size() + 1;
                rv{row.trigger_name} = new OracleTrigger(row.trigger_name, row.description + "\n" + row.trigger_body, row.status == "ENABLED");
            }
            
            return new Triggers(rv);
        }

        string getCreateTableSqlImpl(*hash opt) {
            string sql = sprintf("create table %s (\n", name);

            sql += foldl $1 + ",\n" + $2, (map "  " + $1.getCreateSql(), columns.iterator());
            sql += "\n)";

            *string ts = opt.data_tablespace ? opt.data_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            return sql;
        }

        *list getCreateIndexesSqlImpl(*hash opt) {
            return map $1.getCreateSql(name, opt), indexes.iterator();
        }

        *string getCreatePrimaryKeySqlImpl(*hash opt) {
            return primaryKey.getCreateSql(name, opt);
        }

        *list getCreateForeignConstraintsSqlImpl(*hash opt) {
            return map $1.getCreateSql(name, opt), foreignConstraints.iterator();
        }

        *list getCreateConstraintsSqlImpl(*hash opt) {
            return map $1.getCreateSql(name, opt), constraints.iterator();
        }

        *list getCreateMiscSqlImpl(*hash opt, bool cache) {
	    if (cache)
		getColumnsUnlocked();
            return map sprintf("comment on column %s.%s is '%s'", name, $1.name, $1.comment), columns.iterator(), $1.comment;
        }

        *list getCreateTriggersSqlImpl(*hash opt) {
            return map $1.getCreateSql(name, opt), triggers.iterator();
        }

        string getCreateSqlStringImpl(list l) {
            string str;
            map str += sprintf("%s%s\n", $1, $1 =~ /;$/ ? "\n/" : ";"), l;
            return str;
        }

        private AbstractColumn addColumnImpl(string cname, hash opt, bool nullable = True) {
            bool char_used = False;
            int char_size = 0;

            OracleColumn c(cname, opt.native_type, opt.qore_type, opt.size, char_size, opt.precision, opt.scale, nullable, opt.default_value, char_used, opt.comment, 0);
            return c;
        }

        private AbstractPrimaryKey addPrimaryKeyImpl(string cname, hash ch, *hash opt) {
            return new OraclePrimaryKey(cname, ch, opt.index_tablespace);
        }

        private AbstractIndex addIndexImpl(string iname, bool enabled, hash ch, *hash opt) {
            return new OracleIndex(iname, enabled, ch, opt.index_tablespace);
        }

        private AbstractForeignConstraint addForeignConstraintImpl(string cname, hash ch, string table, hash tch, *hash opt) {
            ForeignConstraintTarget fct(table, new Columns(tch));
            return new OracleForeignConstraint(cname, new Columns(ch), fct, True);
        }

        private AbstractCheckConstraint addCheckConstraintImpl(string cname, string src, *hash opt) {
            return new OracleCheckConstraint(cname, src);
        }

        private AbstractTrigger addTriggerImpl(string tname, string src, *hash opt) {
            return new OracleTrigger(tname, src);
        }

        private hash getQoreTypeMapImpl() {
            return QoreTypeMap;
        }

        private hash getTypeMapImpl() {
            return OraTypeMap;
        }

        private hash getIndexOptions() {
            return OracleIndexOptions;
        }

        private hash getPrimaryKeyOptions() {
            return OraclePrimaryKeyOptions;
        }

        private hash getTableCreationOptions() {
            return OracleTableCreationOptions;
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument; returns NOTHING if the type cannot be converted to an SQL string
        private *string getSqlValueImpl(any v) {
            switch (v.typeCode()) {
                case NT_FLOAT:
                case NT_INT: return v.toStr();

                case NT_NUMBER: return string(v);

                # double any single quotes in strings
                case NT_STRING: v =~ s/'/''/g; return "'" + v + "'";

                case NT_NULL:
                case NT_NOTHING: return "null";

                case NT_BOOLEAN: return v ? "1" : "0";

                case NT_DATE: return sprintf("to_date('%s', 'YYYYMMDDHH24MISS')", v.format("YYYYMMDDHHmmSS"));
            }
        }
    }
}
