# -*- mode: qore; indent-tabs-mode: nil -*-
# @file FsUtil.qm Qore user module providing file system related functionality

/*  FsUtil.qm Copyright 2017 - 2018 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 0.8.13

%requires Util

# assume local var scope, do not use "$" for vars, members, and method calls
%new-style
%strict-args
%require-types
%enable-all-warnings

module FsUtil {
    version = "1.0";
    desc = "user module providing file system related functionality";
    author = "Tomas Heger";
    url = "http://qore.org";
    license = "MIT";
    init    = sub () { init(); };
}

/* see release notes below for version history
*/

/** @mainpage FsUtil Module

    @tableofcontents

    @section fsutilintro Introduction to the FsUtil Module

    The %FsUtil module provides functionality for file system operations.

    To use this module, use \c "%requires FsUtil" in your code.

    All the public symbols in the module are defined in the FsUtil namespace

    Currently the module provides the following multiplatform functions:
    @ref FsUtil::basename_ext()
    @ref FsUtil::join_paths()
    @ref FsUtil::make_tmp_dir()

    Also classes for platform specific operations are available:
    @ref FsUtil::PosixPathHandler
    @ref FsUtil::WinPathHandler


    @section fsutil_relnotes Release Notes

    @subsection fsutil_v1_0 Version 1.0
    - initial version of module
*/

namespace Init {

    sub init() {
        #! handler for the current platform
        our FsUtil::PathHandler local_handler;
        if (Platform.Windows)
            local_handler = new FsUtil::WinPathHandler();
        else if (Platform.Unix)
            local_handler = new FsUtil::PosixPathHandler();
        else
            throw "UNKNOWN-PLATFORM-ERROR",
                  sprintf("Unknown platform: %s.\n", PlatformOS);
    }
}

#! the FsUtil namespace contains all the objects in the FsUtil module
public namespace FsUtil {

    #! generic path handler implementing functionality common for both platforms
    class PathHandler {
        public {
            #! path delimiters - to be set by platform specific path handlers
            list Delimiters;
        }


        public string join_paths(list paths) {
            if (!paths) {
                # NOTHING or an empty list
                throw "MISSING-PARAMETER-ERROR", "No paths to join";
            }

            if (paths.size() == 1) {
                # nothing to join, return the only path part given
                return paths[0];
            }

            return self.join_paths(paths[0], paths[1..]);
        }

        # to be implemented by platform-specific classes
        public abstract string join_paths(string path1, softlist paths);
    }

    #! path handler implementing Windows specific functionality
    public class WinPathHandler inherits PathHandler {

        #! creates the object and sets the delimiter
        constructor() {
            # both slashes can be used as path delimiters on Windows
            Delimiters = ("\\", "/");
        }

        #! separates and returns the drive and the rest of the path
        /** @param path the path to be processed

            @return list of two items - drive and the rest of the path, either
            can be empty and concatenation of both parts always gives the
            original path back.
        */
        public list split_drive(string path) {
            if (regex(path, '^[a-zA-Z]:'))
                return (path.substr(0,2), path.substr(2));
            return ("", path);
        }

        #! Returns path resulting from joining the given paths
        /** @param path1 the first part of the path
            @param paths the other parts of the path

            @return all paths joined into one valid path (i.e. delimiters are added/removed as needed) except for cases
            when one of the paths (in the list) is an absolute path or if each path is on different drive - in such
            cases that path is considered a new start of the resulting path. The resulting path is not normalized
            (i.e. "/path/to/../../file.txt" is a correct result of join("/path/to", "../../file.txt");).
            Since the second parameter is a softlist, this variant also works for joining two string paths.
        */
        public string join_paths(string path1, softlist paths) {
            string result = path1;

            foreach string path2 in (paths) {
                if (path2 == "") {
                    continue;
                }

                # extract drive (if present)
                list result_split = split_drive(result);
                list path2_split = split_drive(path2);

                if (result == "" ||
                    absolute_path_windows(path2) ||
                    (path2_split[0] != "" && toupper(result_split[0]) != toupper(path2_split[0]))) {
                    # if the first path is empty or
                    # if the second path is absolute or
                    # if both paths contain drive and the drives differ,
                    # then use path2 only
                    result = path2;
                    continue;
                }

                # otherwise let's join both parts and return
                if (result_split[1] != "" && !inlist(result[-1], self.Delimiters)) {
                    result += self.Delimiters[0];
                }
                result = result + path2_split[1];
            }

            return result;
        }
    }

    #! path handler implementing POSIX specific functionality
    public class PosixPathHandler inherits PathHandler {

        #! creates the object and sets the delimiter
        constructor() {
            Delimiters = ("/",);
        }

        #! Returns path resulting from joining the given paths
        /** @param path1 the first part of the path
            @param paths the other parts of the path

            @return @return all paths joined into one valid path (i.e. delimiters are added/removed as needed) except
            for cases when one of the paths (in the list) is an absolute path - in such cases that path is considered
            a new start of the resulting path. The resulting path is not normalized (i.e. "/path/to/../../file.txt" is
            a correct result of join("/path/to", "../../file.txt");).
            Since the second parameter is a softlist, this variant also works for joining two string paths.
        */
        public string join_paths(string path1, softlist paths) {
            string result = path1;

            foreach string path2 in (paths) {
                if (path2 == "") {
                    continue;
                }

                # if the second path is absolute, use path2 only
                if (absolute_path_unix(path2)) {
                    result = path2;
                    continue;
                }

                if (result != "" && result[-1] != self.Delimiters[0]) {
                    result += self.Delimiters[0];
                }
                result = result + path2;
            }

            return result;
        }
    }

    #! this function returns the segment of given path after the last delimiter
    /** @param path      the path to be processed
        @param extension the extension to cut from basename

        @return everything after the last delimiter except for the extension if present

        @throws EXTENSION-NOT-FOUND if the extension is not a part of the path

        Delimiters for the current platform are used.
    */
    public string sub basename_ext(string path, *string extension) {
        string bn = basename(path);

        if (!extension) {
            return bn;
        }

        if (!string_ends_with(bn, extension)) {
            throw "EXTENSION-NOT-FOUND", sprintf("Extension '%s' not found in basename '%s'.", extension, bn);
        }

        # return everything without the extension
        int ext_start = bn.length() - extension.length();
        return bn[..ext_start - 1];

    }

    #! Returns path resulting from joining the given paths
    /** @param path1 the first part of the path
        @param paths the other parts of the path

        @return all paths joined into one valid path (i.e. delimiters are added/removed as needed) except for cases when
        one of the paths (in the list) is an absolute path or if each path is on different drive (Windows only) - in
        such cases that path is considered a new start of the resulting path. The resulting path is not normalized
        (i.e. "/path/to/../../file.txt" is a correct result of join("/path/to", "../../file.txt");).
        Since the second parameter is a softlist, this variant also works for joining two string paths.
    */
    public string sub join_paths(string path1, softlist paths) {
        return local_handler.join_paths(path1, paths);
    }

    #! Returns path resulting from joining the given paths
    /** @param paths the parts of the path to be joined into one

        @return all paths joined into one valid path (i.e. delimiters are added/removed as needed) except for cases when
        one of the paths is an absolute path or if each path is on different drive (Windows only) - in such cases that
        path is considered a new start of the resulting path. The resulting path is not normalized
        (i.e. "/path/to/../../file.txt" is a correct result of join("/path/to", "../../file.txt");).

        @throws MISSING-PARAMETER-ERROR if the list is empty
    */
    public string sub join_paths(list paths) {
        return local_handler.join_paths(paths);
    }

    const TMP_MAX_ATTEMPTS = 10000;

    #! Creates a unique temporary directory and returns its absolute path
    /** @param prefix prefix to be used in the newly created directory name
        @param suffix suffix to be used in the newly created directory name
        @param path path to a dir in which the caller wants to create the new directory; if not provided, standard temp
                    location will be used

        @return absolute path to the newly created directory

        @throws DIR-WRITE-ERROR The directory couldn't be created.

        The directory is created in a secure way and is readable and writable only by the current user.
        The caller is responsible for removing the temporary directory once it's needed no more.

    */
    public string sub make_tmp_dir(*string prefix, *string suffix, *string path) {
        if (exists path) {
            if (!is_writable(path)) {
                throw "DIR-WRITE-ERROR", sprintf("'%s' is not a writable directory.", path);
            }
        } else {
            # get standard tmp location (and check that it's writable)
            path = tmp_location();
        }

        for (int i = 0; i < TMP_MAX_ATTEMPTS; i++) {
            string tmp_dir = prefix + get_random_string() + suffix;
            string tmp_path = join_paths(path, tmp_dir);

            if (mkdir(tmp_path, 0700) == 0) {
                # success
                return tmp_path;
            } else {
                # unable to create the file
                int err = errno();
                if (err == Err::EEXIST) {
                    # directory already exists -> let's try again with another name
                    continue;
                } else {
                    # another (unexpected) error
                    throw "DIR-WRITE-ERROR", sprintf("Directory '%s' couldn't be created: %s", tmp_path, strerror(err));
                }
            }
        }

        # even after TMP_MAX_ATTEMPTS we didn't succeed in finding a unique name
        throw "DIR-WRITE-ERROR", "Impossible to find a unique name.";
    }

    #! Creates and opens a unique temporary file and returns its absolute path as well as its File object
    /** @param prefix prefix to be used in the newly created file name
        @param suffix suffix to be used in the newly created file name
        @param path path to a dir in which the caller wants to create the new file; if not provided, standard temp
                    location will be used

        @return hash with absolute path to the newly created file and its File object
                (keys "path" and "file" recpectively)

        @throws FILE-WRITE-ERROR The file couldn't be created.

        The file is created in a secure way and is readable and writable only by the current user.
        The caller is responsible for removing the temporary file once it's needed no more.

    */
    public hash sub make_tmp_file(*string prefix, *string suffix, *string path) {
        if (exists path) {
            if (!is_writable(path)) {
                throw "FILE-WRITE-ERROR", sprintf("'%s' is not a writable directory.", path);
            }
        } else {
            # get standard tmp location (and check that it's writable)
            path = tmp_location();
        }

        # O_CREAT and O_EXCL are important to ensure that we only open a new file
        int flags = O_CREAT | O_EXCL | O_RDWR;
        File tmp_file = new File();

        for (int i = 0; i < TMP_MAX_ATTEMPTS; i++) {
            string tmp_fn = prefix + get_random_string() + suffix;
            string tmp_path = join_paths(path, tmp_fn);

            if (tmp_file.open(tmp_path, flags, 0600) == 0) {
                # success
                return {"path": tmp_path,
                        "file": tmp_file};
            } else {
                # unable to create the file
                int err = errno();
                if (err == Err::EEXIST) {
                    # file already exists -> let's try again with another name
                    continue;
                } else {
                    # another (unexpected) error
                    throw "FILE-WRITE-ERROR", sprintf("File '%s' couldn't be created: %s", tmp_path, strerror(err));
                }
            }
        }

        # even after TMP_MAX_ATTEMPTS we didn't succeed in finding a unique name
        throw "FILE-WRITE-ERROR", "Impossible to find a unique name.";
    }

    #! Removes the filesystem tree specified by path
    /** @param path path to a filesystem tree root which should be removed
        @param dir_only flag specifying whether the tree should be removed only if path leads to a directory
                        (default: True)

        @throws NOT-A-DIRECTORY If path doesn't point to a directory and dir_only is True -> can't remove it

        By default this function will only remove a directory (i.e. path can't point to a regular file, symlink, etc.)
        which can be overriden by dir_only flag. This doesn't hold true for the path's contents though of course.
        Therefore if path leads to a directory, it's contents will be removed regardless of dir_only flag.
        This function doesn't follow symlinks.

    */
    public sub rmtree(string path, bool dir_only=True) {
        if (!is_dir(path)) {
            if (dir_only) {
                throw "NOT-A-DIRECTORY", sprintf("Can't remove '%s': not a directory.", path);
            }

            # remove the file or symlink specified by path
            unlink(path);
            return;
        }

        # now we know path is a directory
        Dir dir();
        dir.chdir(path);

        # remove the directory's contents
        foreach string name in (dir.list()) {
            string sub_path = join_paths(path, name);
            if (is_dir(sub_path)) {
                rmtree(sub_path);
            } else {
                unlink(sub_path);
            }
        }

        # directory specified by path should be empty now
        rmdir(path);
    }

    #! Checks whether two stat hashes point to the same file or not
    /** @param stat1 first stat hash
        @param stat2 second stat hash
        @param ignore_errors flag indicating that errors should be ignored (True by default)

        @return True if the two stat hashes point to the same file, False otherwise.

        @throws STAT-HASH-ERROR If parameters don't both contain stat hashes.

        Device and inode IDs are compared.
        If a stat hash does not exist and ignore_errors is True, then the function returns False. This is for
        convenience of the caller who thus may just call a stat function to a path and pass the result to this function
        without taking care of possible NOTHINGs. In that case the paths can probably be considered not pointing to
        the same file.
    */
    public bool sub same_file_stat(*hash stat1, *hash stat2, bool ignore_errors=True) {

        # handle special cases
        if (ignore_errors) {
            if (!exists stat1 || !exists stat2) {
                return False;
            }
        } else {
            if (!exists stat1 || !exists stat1.dev || !exists stat1.inode ||
                !exists stat2 || !exists stat2.dev || !exists stat2.inode) {
                # not a stat hash
                throw "STAT-HASH-ERROR", "Parameters aren't stat hashes.";
            }
        }

        # the usual case
        return (stat1.inode == stat2.inode &&
                stat1.dev == stat2.dev);
    }

    #! Checks whether two paths point to the same file or not
    /** @param path1 first path
        @param path2 second path
        @param follow_symlinks flag indicating whether symlinks should be followed (True by default)
        @param ignore_errors flag indicating that errors should be ignored (True by default)

        @return True if the two paths point to the same file, False otherwise.

        @throws FILE-STAT-ERROR If stat call for a path fails unless errors are ignored.

        Stat is retrieved for each of the paths and device and inode IDs are compared. By default if one of the paths is
        a symlink pointing to the other, this function will return True but this can be changed using
        the follow_symlinks parameter.
        If stat can't be retrieved for a path and ignore_errors is True, then the function returns False. This is
        because the most common error here is that one of the paths doesn't exist (or both). In that case the paths
        indeed don't point to the same file.
    */
    public bool sub same_file(string path1, string path2, bool follow_symlinks=True, bool ignore_errors=True) {
        hash stat1;
        hash stat2;

        try {
            if (follow_symlinks) {
                stat1 = hstat(path1);
                stat2 = hstat(path2);
            } else {
                stat1 = hlstat(path1);
                stat2 = hlstat(path2);
            }
        } catch (hash ex) {
            if (ignore_errors) {
                return False;
            }

            throw "FILE-STAT-ERROR", sprintf("Couldn't stat path: %s", strerror());
        }

        return (stat1.inode == stat2.inode &&
                stat1.dev == stat2.dev);
    }


    }

} # FsUtil namespace
