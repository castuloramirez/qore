<?xml version="1.0" encoding="UTF-8" ?>

<chapter id="Qore_Language_Description">
  <title>Qore Language Description</title>

  <sect1 id="Language_Overview">
    <title>Language Overview</title>

    <para>A Qore program is composed of a series of declarations, statements, subroutine definitions, and/or class definitions. Non-block statements are terminated by a semi-colon ";". Block statements are grouped by using curly brackets ("{" and "}"), as in C, C++, Java, and Perl.</para>
    
    <para>Programmers familiar with C, C++, Java, and/or Perl should find the standard Qore syntax intuitive and should be productive fairly quickly with the language. However Qore has unique features that differentiate it from other languages, and these features must be mastered in order to leverage the full power of Qore.</para>
    
    <para>Qore programs/scripts are free form. Formatting does not affect the execution of the program; formatting is at the discretion of the programmer and should be used to enhance readability and clarity of the source code.</para>
    
    <para>Qore is a weakly typed language. That means that variables can hold values of any type and subroutines can return any value type (or none at all, see <link linkend='Variables'>Variables</link>). Furthermore list elements can be of any type (they do not have to be uniform), and multidimensional lists can have a different number of elements in each list. The same type flexibility holds true of hashes, objects, and all combinations of container types.</para>
    
    <para>Qore can be used a a traditional subroutine-based scripting language or as a pure object-oriented language, where the application is defined as a class. Aside from traditional local and global variables, constants, and subroutines, Qore also supports nested namespaces, classes, multiple inheritance, overriding base class constructor arguments, and private members and methods.</para>
    
    <para>All elements of Qore are designed to work together seamlessly: <link linkend="Qore::SQL::Datasource_Class">database access</link>, <link linkend="XML_Integration">XML transformations</link>, <link linkend="Qore_Socket_Class">socket communication</link>, <link linkend="Qore_Program_Class">embedding logic</link> in subprograms, <link linkend="Regular_Expressions">regular expressions</link>, <link linkend="Operators">operators</link>, <link linkend="Function_Library">functions</link>, and all other elements are thread-safe and built on an execution engine that was designed for SMP scalability.</para>

    <para>Qore automatically converts data types when necessary when evaluating operators. The goal is to provide the expected result for the programmer without requiring the programmer to explicitly convert data types. Please see <link linkend='Operators'>Operators</link> for more information.</para>

    <para>Qore supports <link linkend="signal_handling">signal handling</link> by dispatching Qore-language signal handlers in a safe manner, asynchronously to the actual receipt of the signal.</para>

    <para>UNIX operating systems allow an executable script to specify their interpreter. This is done by setting the first line in the program to a special string indicating the location of the Qore binary. For the purposes of this document, the location for the Qore binary is assumed to be <code>/usr/bin/qore</code>. The first line of Qore scripts in this case should look as follows:</para>

    <programlisting>#!/usr/bin/qore</programlisting>

    <para>If another installation directory is used (such as <code>/usr/local/bin</code>), then the correct path must be reflected in the first line of the Qore script.</para>

    <para>Qore convention dictates that Qore script file names end with <code>.q</code>.</para>
  </sect1>

  <sect1 id="Environment_Variables">
    <title>Environment Variables</title>

    <para>This section will outline the environment variables that are used by Qore.</para>

    <table frame='all'><title>Qore Environment Variables</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>

      <thead>
	<row>
	  <entry><para>Environment Variable</para></entry>
	  <entry><para>Description</para></entry>
	</row>
      </thead>
  
      <tbody>
	<row>
	  <entry><para><code>QORE_AUTO_MODULE_DIR</code></para></entry>
	  <entry><para>This environment variable should contain a colon-separated list of directories which will be searched for Qore modules when Qore starts. If any modules are found, they are loaded automatically before any parsing starts.</para></entry>
	</row>
	<row>
	  <entry><para><code>QORE_MODULE_DIR</code></para></entry>
	  <entry><para>This environment variable should contain a colon-separated list of directories which will be searched when modules are loaded with the <code>%requires</code> parse directive</para></entry>
	</row>
	<row>
	  <entry><para><code>QORE_INCLUDE_DIR</code></para></entry>
	  <entry><para>This variable should be a colon-separated list 
	  of directories where the Qore binary should look for include 
	  files</para></entry>
	</row>
	<row>
	  <entry><para><code>QORE_CHARSET</code></para></entry>
	  <entry><para>If this variable is set, then the default character set name for the process will be the value of this variable.  This variable takes precedence over the <code>LANG</code> variable, but can be overridden by the command line using option <code>--charset</code> (see <link linkend='Qore_Strings_and_Character_Set_Encoding'>Qore Strings and Character Set Encoding</link> for more information on this option)</para></entry>
	</row>
	<row>
	  <entry><para><code>LANG</code></para></entry>
	  <entry><para>If this variable is set and includes a character set specification, then, if the <code>QORE_CHARSET</code> variable is not set (and no character set was specified on the command line), this character set will be the default for the process.</para></entry>
	</row>
      </tbody>
      
    </tgroup>
    </table>
    
  </sect1>
  
  <sect1 id="Qore_Modules">
    <title>Qore Modules</title>
    <para>Qore modules allow the Qore language to be extended at run-time.  Qore modules must conform to the Qore Module API and have the file extension <command><code>*.qmod</code></command>.</para>
    <para>Modules shipping with Qore include <link linkend="oracle_Module"><code>oracle</code></link>, <link linkend="mysql_Module"><code>mysql</code></link>, <link linkend="pgsql_Module"><code>pgsql</code></link>, <link linkend="sybase_Module"><code>sybase</code></link>, <link linkend="mssql_Module"><code>mssql</code></link>, <link linkend="ncurses_Module"><code>ncurses</code></link>, <link linkend="tibrv_Module"><code>tibrv</code></link>, <link linkend="tibae_Module"><code>tibae</code></link>, and <link linkend="Tuxedo_Module"><code>tuxedo</code></link>.</para>
    <para>To load a module at parse time (normally required for most modules), use the <link linkend="requires_directive"><code>%requires</code></link> parse directive. If the named feature is not already present in Qore, Qore looks for a module with this name in the directories listed in the <code>QORE_MODULE_DIR</code> environment variable.</para>
    <para>Use the <link linkend="load_module">load_module()</link> function to load Qore modules at run-time; however, note that any module providing parse support (classes, constants, functions, etc) must be loaded at parse time using the <link linkend="requires_directive"><code>%requires</code></link> directive.</para>
    <para>Also note that DBI drivers are loaded on demand by the <link linkend="Qore::SQL::Datasource_Class">Datasource class</link>.</para>
  </sect1>
  
  <sect1 id="Include_Files">
    <title>Include Files</title>
  
    <para>A Qore program can include other program code to be used and executed in the current program by using the <code>%include</code> directive. The <code>%include</code> directive must be the first text on the line, and the file name to include must follow. All text on the line after the <code>%include</code> directive will be used for the file name to include. The file name should not be quoted.</para>
    
    <para>Here is an example:</para>
    
    <programlisting>#!/usr/bin/qore
%include /usr/qore/lib/functions.lib</programlisting>
    
    <para>After this, any variable, subroutine, namespace, constant, or object declared in the above file can be used by the Qore program.</para>
    
    <para>The <code>QORE_INCLUDE_DIR</code> environment variable determines the search path for include files.</para>
    
  </sect1>
  <sect1 id="Identifiers">
    <title>Identifiers</title>

    <para>Qore identifiers must start with an alphabetic character, and then may contain any number of alphabetic, numeric, or "_" characters.  There is no length limit on Qore identifiers.</para>
    
    <para>All Qore identifiers are case-sensitive, therefore the identifier <code>hello_there</code> is not the same as <code>Hello_There</code> or <code>HELLO_THERE</code>.</para>

    <para>The following are examples of valid Qore identifiers:</para>

    <table frame='all'><title>Examples of Valid Qore Identifiers</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>

      <thead>
	<row>
	  <entry><para>Identifier</para></entry>
	  <entry><para>Description</para></entry>
	</row>
      </thead>
      
      <tbody>
	<row>
	  <entry><para><code>i</code></para></entry>
	  <entry><para>Simple one-character identifier</para></entry>
	</row>
	<row>
	  <entry><para><code>foo21</code></para></entry>
	  <entry><para>Identifier with number</para></entry>
	</row>
	<row>
	  <entry><para><code>this_is_a_long_identifier</code></para></entry>
	  <entry><para>Long identifier with underline characters</para></entry>
	</row>
	<row>
	  <entry><para><code>Total_318</code></para></entry>
	  <entry><para>Identifier with underline and number</para></entry>
	</row>
	<row>
	  <entry><para><code>AVeryBigNumber</code></para></entry>
	  <entry><para>Mixed case identifier name</para></entry>
	</row>
	<row>
	  <entry><para><code>CAPS</code></para></entry>
	  <entry><para>Identifier in all capital letters</para></entry>
	</row>
	
      </tbody>
    </tgroup>
    </table>  
    
    <para>The following are invalid identifiers:</para>
    
    <table frame='all'><title>Examples of Invalid Qore Identifiers</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Identifier</para></entry>
	  <entry><para>Description</para></entry>
	</row>
      </thead>
      
      <tbody>
	<row>
	  <entry><para><code>1a</code></para></entry>
	  <entry><para>Does not start with an alphabetic character</para></entry>
	</row>
	<row>
	  <entry><para><code>this-and-that</code></para></entry>
	  <entry><para>Contains "-" characters</para></entry>
	</row>
	<row>
	  <entry><para><code>Start#10</code></para></entry>
	  <entry><para>Contains "#" character</para></entry>
	</row>
      </tbody>
    </tgroup>  
    </table>
    
  </sect1>
  <sect1 id="Comments">
    <title>Comments</title>

    <para>Comments are allowed in Qore scripts; line comments are preceded by a hash "#", and block comments are made C-style, ex:</para>

    <programlisting># this is a line comment
/* 
   this is a block comment 
*/</programlisting>
    
    <para>For line comments, all text following a hash until the end-of-line character "\n" is considered a part of the comment.</para>

    <para>For block comments, all text between the /* and */ is ignored by the parser.</para>

<para>Here is an example Qore script containing comments:</para>

<programlisting>#!/usr/bin/qore
#
# these are line comments
# another line comment

/*
   --- this text is in block comments
   print("hello"); &lt;- this won't get executed 
   --- because it's in the block comment
*/</programlisting>

  </sect1>
  <sect1 id="Variables">
    <title>Variables</title>

    <para>Variables are Qore identifiers prefixed by a "$" sign, similar to Perl. The data type of variables does not have to be declared in advance, and variable types are assigned and changed automatically as appropriate in the context of the operations being performed on them or the values being assigned. Any Qore variable can hold any Qore data type including container types (lists, hashes, or objects).</para>

    <para>A few variables are set by the Qore language during the execution of Qore programs. These are normal variables that can be reassigned to other values by the user if necessary.</para>

    <table id="Special_Qore_Variables">
      <title>Special Qore Variables</title>
      <tgroup cols='4' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Variable</para></entry>
	    <entry><para>Type</para></entry>
	    <entry><para>Data Type</para></entry>
	    <entry><para>Explanation</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><code>$argv</code></para></entry>
	    <entry><para>Local</para></entry>
	    <entry><para>List</para></entry>
	    <entry><para>automatically assigned local variable containing the list of subroutine or method arguments that were not assigned to parameter variables (see <link linkend='Subroutines'>Subroutines</link> for more information)</para></entry>
	  </row>
	  <row>
	    <entry><para><code>$ARGV</code></para></entry>
	    <entry><para>Global</para></entry>
	    <entry><para>List</para></entry>
	    <entry><para>script command-line arguments (use the <link linkend='Qore::GetOpt_Class'>GetOpt Class</link> to parse command-line arguments)</para></entry>
	  </row>
	  <row>
	    <entry><para><code>$QORE_ARGV</code></para></entry>
	    <entry><para>Global</para></entry>
	    <entry><para>List</para></entry>
	    <entry><para>complete qore command-line arguments</para></entry>
	  </row>
	  <row>
	    <entry><para><code>$ENV</code></para></entry>
	    <entry><para>Global</para></entry>
	    <entry><para>Hash</para></entry>
	    <entry><para>UNIX program environment</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <note><para><code>$STDERR</code> and <code>$STDOUT</code> have been removed from Qore.  Use the <link linkend="Qore_IO_Constants">I/O constants</link> <command>stderr</command>, <command>stdout</command>, and <command>stdin</command> constants of the <link linkend='Qore_File_Class'>File Class</link> instead.</para></note>

<sect2 id="Lexical_Scope">
<title>Lexical Scope</title>

<para>Variables not in a parameter list automatically have global scope unless the first reference is prefixed with <command>my</command>.  Variable names in a parameter list are always local to their associated subroutine, method, or catch block. Global variables can be explicitly declared with <command>our</command>.  The <command>our</command> keyword is required if the parse option <code>PO_REQUIRE_OUR</code> (<code>-O</code> or <code>--require-our</code> command-line option) is set for the parent program.  See the section on <link linkend="Parse_Options">Parse Options</link> for more information.</para>

<para>Local variables are not shared between threads, however global variables are.  See <link linkend='Threading'>Threading</link> for more information.</para>

<para>For example (in the following script, the <command>our</command> keyword is optional):</para>

<programlisting>#!/usr/bin/qore
#
# variable scoping example

<command>our</command> $a = 1;        # this is a global variable
<command>our</command> ($b, $c, $d);  # list of global variables

<command>if</command> ($a == 1)
{
    <command>my</command> $a = 2; 
    <command>my</command> ($b, $c);
    # $a, $b, and $c are local variables, 
    # the use of which will not affect the 
    # global variables of the same name
    print("local a = %d\n", $a); 
}

print("global a = %d\n", $a); </programlisting>

<para>The first print() statement will output:</para>

<programlisting>local a = 2</programlisting>

<para>The second print() statement will output:</para>

<programlisting>global a = 1</programlisting>

</sect2>
</sect1>

<sect1 id="Basic_Data_Types">
<title>Basic Data Types</title>

<para>The following are the basic data types in Qore:</para>

<table><title>Basic data types</title>
<tgroup cols='4' align='left' colsep='1' rowsep='1'>

  <thead>
  <row>
    <entry><para>Type</para></entry>
    <entry><para>Description</para></entry>
    <entry><para>Example</para></entry>
    <entry><para>Default Value</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para><link linkend="Boolean">Boolean</link></para></entry>
    <entry><para>True or False value</para></entry>
    <entry><code>True</code></entry>
    <entry><para>False</para></entry>
  </row>
  <row>
    <entry><para><link linkend="String">String</link></para></entry>
    <entry><para>A sequence of characters</para></entry>
    <entry><code>"string"</code></entry>
    <entry><para>Empty string</para></entry>
  </row>
  <row>
    <entry><para><link linkend="Integer">Integer</link></para></entry>
    <entry><para>A 64-bit signed integer</para></entry>
    <entry><code>1</code></entry>
    <entry><para>0</para></entry>
  </row>
  <row>
    <entry><para><link linkend="Float">Float</link></para></entry>
    <entry><para>A double-precision floating-point number</para></entry>
    <entry><code>1.00023</code></entry>
    <entry><para>0.0</para></entry>
  </row>
  <row>
    <entry><para><link linkend="Date">Date</link></para></entry>
    <entry><para>A date with an optional time component, with resolution to the millisecond.</para></entry>
    <entry><code>2005-07-20</code></entry>
    <entry><para>1970-01-01 00:00:00</para></entry>
  </row>
  <row>
    <entry><para><link linkend="Binary">Binary</link></para></entry>
    <entry><para>An opaque binary object</para></entry>
    <entry><para>n/a</para></entry>
    <entry><para>an empty object of size 0</para></entry>
  </row>
  <row>
    <entry><para><link linkend="NULL">NULL</link></para></entry>
    <entry><para>Corresponds to a NULL value in a database query (not equivalent to NOTHING)</para></entry>
    <entry><code><command>NULL</command></code></entry>
    <entry><code><command>NULL</command></code></entry>
  </row>
  <row>
    <entry><para><link linkend="NOTHING">NOTHING</link></para></entry>
    <entry><para>Represents the state of a variable having no value or function returning no value (not equivalent to NULL)</para></entry>
    <entry><code><command>NOTHING</command></code></entry>
    <entry><code><command>NOTHING</command></code></entry>
  </row>

</tbody>
</tgroup>
</table>

<sect2 id="Boolean">
  <title>Boolean</title>
  <para>The Boolean type can have two values, True and False. When converting other types to a Boolean, any value that converts to a non-zero integer will be evaluated as True. Otherwise the result of the conversion will be False.</para>
</sect2>

<sect2 id="String">
  <title>String</title>
  <para>String values are specified with text between double or single quotes. Text between double quotes is subject to interpretation of escape characters. Please see <link linkend="String_Formatting">String Formatting</link> for more information.</para>

  <para>Strings are assumed by default to have the encoding given by the <code>QORE_CHARSET</code> or the <code>LANG</code> environment variable. If neither of these variables is set, then all strings will be assumed to have UTF-8 encoding.</para>

  <para>For detailed information on Qore character set handling, please see <link linkend="Qore_Strings_and_Character_Set_Encoding">Qore Strings and Character Set Encoding</link>.</para>
</sect2>

<sect2 id="Integer">
  <title>Integer</title>
  <para>Qore integers are 64-bit signed integers.</para>
</sect2>

<sect2 id="Float">
  <title>Float</title>
  <para>Qore floats are double precision floating-point numbers.</para>
</sect2>

<sect2 id="Date">
  <title>Date</title>
  <para>Qore dates have a time component supporting a resolution to the millisecond and can be either absolute or relative.  Absolute dates are normal dates, such as January 1, 2005 10:35:00 and can be specified with a special syntax as follows:</para>

  <para><code>&lt;4d-year&gt;-&lt;2d-month&gt;-&lt;2d-day&gt;[-&lt;2d-hour&gt;:&lt;2d-minute&gt;:&lt;2d-second&gt;[.&lt;3d-millisecond&gt;]]</code></para>

  <para>or, an almost-ISO-8601-compliant format (without the ISO-8601 time zone component but including an optional millisecond component)</para>

  <para><code>&lt;4d-year&gt;-&lt;2d-month&gt;-&lt;2d-day&gt;[T&lt;2d-hour&gt;:&lt;2d-minute&gt;:&lt;2d-second&gt;[.&lt;3d-millisecond&gt;]]</code></para>

  <para>for example, for just the date, without a time component:</para>

  <para><code>&lt;4d-year&gt;-&lt;2d-month&gt;-&lt;2d-day&gt;</code></para>

  <para>or, for just the time, without a date component (note that in this case the date component will be set to Jan 1, 1970, in order for time arithmetic to function properly):</para>

  <para><code>&lt;2d-hour&gt;:&lt;2d-minute&gt;:&lt;2d-second&gt;[.&lt;3d-millisecond&gt;]]</code></para>

  <para>For example:</para>

  <para><code>2005-03-29-18:12:25</code> represents: March 29, 2005 6:12:25 pm</para>
  <para><code>0512-01-01T01:49:59.213</code> represents: January 1, 512 1:49:59 am and 213 milliseconds</para>

  <para><code>2005-03-29</code> represents: March 29, 2005 00:00:00</para>
  <para><code>18:35:26</code> represents: 6:35:26 pm</para>

  <para>The year must be a four-digit number, and all other values except milliseconds must be two-digit numbers.  If milliseconds are present, 3 digits are required after the decimal point.  Pad the numbers with leading zeros if the numbers are smaller than the required number of spaces.  The hour component must be in 24-hour time format. Except for the month and day values, all other values start with 0 (hour = 00 - 23, minute and second: 00 - 59).  Any deviation from this format will cause a parse exception.</para>

  <para>Relative dates are specified as follows:</para>

  <para><code>&lt;integer&gt;&lt;date component specifier&gt;</code></para>

  <table><title>Date Specifiers For Relative Dates</title>
  <tgroup cols='4' align='left' colsep='1' rowsep='1'>
    
    <thead>
      <row>
	<entry><para>Component</para></entry>
	<entry><para>Meaning</para></entry>
	<entry><para>Example</para></entry>
	<entry><para>Description</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>Y</para></entry>
	<entry><para>Years</para></entry>
	<entry><code>2Y</code></entry>
	<entry><para>2 Years</para></entry>
      </row>
      <row>
	<entry><para>M</para></entry>
	<entry><para>Months</para></entry>
	<entry><code>3M</code></entry>
	<entry><para>3 Months</para></entry>
      </row>
      <row>
	<entry><para>D</para></entry>
	<entry><para>Days</para></entry>
	<entry><code>10D</code></entry>
	<entry><para>10 Days</para></entry>
      </row>
      <row>
	<entry><para>h</para></entry>
	<entry><para>Hours</para></entry>
	<entry><code>15h</code></entry>
	<entry><para>15 hours</para></entry>
      </row>
      <row>
	<entry><para>m</para></entry>
	<entry><para>Minutes</para></entry>
	<entry><code>25m</code></entry>
	<entry><para>25 minutes</para></entry>
      </row>
      <row>
	<entry><para>s</para></entry>
	<entry><para>Seconds</para></entry>
	<entry><code>19s</code></entry>
	<entry><para>19 seconds</para></entry>
      </row>
      <row>
	<entry><para>ms</para></entry>
	<entry><para>Milliseconds</para></entry>
	<entry><code>250ms</code></entry>
	<entry><para>250 milliseconds</para></entry>
      </row>
    </tbody>
  </tgroup>
</table>

<para>Relative dates are normally used for date addition and subtraction.  See <link linkend='Date_Time_Arithmetic'>Date/Time Arithmetic</link> for more information.</para>

<note>
  <para>Currently there is no time-zone component in Qore dates.  Timezone support may be added in future versions of the Qore 
language, either by an addition to this data type, or by adding another date type including a time zone component.  Specifically, ISO-8601 time zone components are not accepted by the qore parser and will cause a parse exception to be thrown.</para>
</note>

</sect2>
<sect2 id="Binary">
  <title>Binary</title>

  <para>The binary data type is used to hold binary arbitrary binary data. Internally it is represented by a memory pointer and a size indicator. </para>

  <para>This data can be manipulated by being written and read from File, Socket, and Datasource objects, or converted and parsed to/from base64 encoded strings using the <link linkend="makeBase64String">makeBase64String()</link> and <link linkend="parseBase64String">parseBase64String()</link> functions, or compressed and decompressed using the <link linkend="compress">compress()</link>, <link linkend="gzip">gzip()</link>, <link linkend="uncompress_to_binary">uncompress_to_binary()</link>, etc. functions, and processed by most <link linkend="Cryptographic_Functions">cryptographic funtions</link>, among others.</para>

  <para>Binary objects can be read from a File object using the <link linkend="Qore_File_readBinary">File::readBinary()</link> method and can be written using the <link linkend="Qore_File_write">File::write()</link> method.  Please see the <link linkend='Qore_File_Class'>File Class</link> for more information.</para>
  
  <para>Binary objects can be read from a Socket object using the <link linkend="Qore_Socket_recvBinary">Socket::recvBinary()</link> method and can be written using the <link linkend="Qore_Socket_send">Socket::send()</link> method. Please see the <link linkend="Qore_Socket_Class">Socket Class</link> for more information.</para>

  <para>Binary objects can be sent and received using classes provided by the <link linkend="tibrv_Module">tibrv module</link> as well.</para>

  <para>The <link linkend="Qore::SQL::Datasource_Class">Datasource Class</link> can also be used to read and write Binary objects as BLOBs.</para>

  <para>Note that this is not an exhaustive list; see the function and class library documentation for more examples.</para>

</sect2>

<sect2 id="NULL">
  <title>NULL</title>
  <para>This data type represents an SQL NULL value.  Note that <command>NULL</command> is not equivalent to <command>NOTHING</command>.</para>
</sect2>

<sect2 id="NOTHING">
  <title>NOTHING</title>
  <para>This special data type represents no value.</para>
  <note><para>The <link linkend="Exists_Operator"><command>exists</command></link> operator will return False when given <command>NOTHING</command> as an argument.</para></note>
</sect2>

<sect2 id="Conversions">
  <title>Conversions</title>
  <para>Boolean, string, integer, date, and floating point data types can be freely converted from one type to the other, although data loss is possible depending on the conversion (particularly when converting to the boolan type as only two possible values are supported).</para>

  <para>The special types <command>NULL</command> and <command>NOTHING</command> are not equivalent and cannot be converted to or from any other type.</para>

  <para>When date types are converted to/from strings, the following format must be used: "YYYYMMDDHHmmSS".</para>

  <para>When dates are converted to and from integer values, the a 64-bit second offset from January 1, 1970 is used for the conversion.  For example <code>int(2006-01-01)</code> gives <code>1136073600</code>.</para>

  <para>When an expression requires a certain data type and the source data type cannot be converted to the desired data type, the default value for the desired data type will be used.  The default values are given <link linkend="Basic_Data_Types">here</link>.</para>
</sect2>

</sect1>

<sect1 id="Container_Data_Types">
  <title>Container Data Types</title>

  <para>Qore supports three types of container types: lists, hashes (associative arrays), and objects (see <link linkend="Objects">Objects</link> and <link linkend="Classes">Classes</link> for more information on objects and classes).  These container types can be combined to make arbitrarily complex data structures.</para>

  <para>The data type of any element can be any basic type or another aggregate type.  The types do not have to be uniform in one container structure.</para>

  <sect2 id="Lists">
    <title>Lists</title>

    <para>Lists (or arrays) are simply ordered containers of values.  A list element can be any Qore type (even another list, hash, or object).</para>

    <para>Lists are specified by giving expressions separated by commas as follows:</para>

    <programlisting>$list = <replaceable>expression</replaceable>, <replaceable>expression</replaceable> [, <replaceable>expression</replaceable> ...];</programlisting>

    <para>Here is a concrete example:</para>

    <programlisting>$list = 1, 2, "three", 4.0, 5, 6;</programlisting>

    <note>
      <para>Note that trailing commas can be left on the end of a list (or a hash, for that matter).  This makes it easier to comment-out the last element of a multi-line list without having to worry about removing the trailing comma.</para>
    </note>

    <para>List elements are dereferenced using square brackets: <link linkend='List_Dereference_Operator'>"[" and "]"</link>. The first element in a list has index zero.</para>

    <programlisting>$element3 = $list[2];</programlisting>

    <para>The following operators perform special processing on lists: <link linkend="Elements_Operator"><command>elements</command></link>, <link linkend="Shift_Operator"><command>shift</command></link>, <link linkend="Unshift_Operator"><command>unshift</command></link>, <link linkend="Push_Operator"><command>push</command></link>, <link linkend="Pop_Operator"><command>pop</command></link>, <link linkend="Splice_Operator"><command>splice</command></link>, <link linkend='List_Dereference_Operator'>[]</link>, <link linkend='Plus_Operator'>+</link>, and <link linkend='Plus_Equals_Operator'>+=</link>.</para>

  </sect2>
  <sect2 id="Hashes">
    <title>Hashes</title>

    <para>Hashes are containers that associate values to a string key.</para>

    <note><para>Note that Qore hashes preserve the insertion order in order to be able to guarantee the order of keys when hashes are serialized to XML strings (see <link linkend="XML_Integration">XML Integration</link>), therefore the <command>keys</command> operator will always return the hash keys in insertion/creation order.</para></note>
    
    <para>Hashes are specified using the following syntax:</para>
    
    <programlisting>$hash = ( "key1" : <replaceable>expression</replaceable>,
          "key2" : <replaceable>expression</replaceable>,
	  ... );</programlisting>

    <para>Here is a concrete example:</para>

    <programlisting>$hash = ( "apple" : 1 + 1,
          "pear"  : "good" );</programlisting>

    <para>Hashes are dereferenced in one of two ways, either using curly brackets: "{" and "}", where any valid Qore expression can be used, or using the dot "." hash member dereferencing operator, where only literal strings can be used.</para>

    <programlisting>$element3 = $hash{"pe" + "ar"};</programlisting>

    <para>Is equivalent to:</para>

    <programlisting>$element3 = $hash.pear;</programlisting>

    <para>and:</para>

    <programlisting>$element3 = $hash."pear";</programlisting>

    <para>A literal string after the dot "." hash member dereferencing operator must be a valid Qore identifier; therefore if you want to use a hash key that's not a valid identifier, enclose the string in quotes.</para>
    
    <para>If you want to use the result of an expression to dereference the hash, then the curly bracket syntax must be used.</para>
    
    <para>Note that hash keys can also be given by constants (as long as the constant resolved to a string).</para>
    
  </sect2>
  <sect2 id="Objects">
    <title>Objects</title>

    <para>Qore objects are instantiations of a Qore class.  They have members (like a hash - values associated to string keys), and methods.  The Qore class definition specifies the methods that run on objects of that class, and any private members.  Qore classes are declared with a special syntax, and objects are instantiated using the <command>new</command> operator as follows.</para>

    <programlisting><replaceable>lvalue</replaceable> = <command>new</command> <replaceable>class_identifier</replaceable>([<replaceable>argument list</replaceable>])</programlisting>

    <para>Objects have named data members that are referenced like hash elements, although this behavior can be modified for objects using the memberGate() method.  Object members are accessed by appending a dot '.' and the member name to the object reference as follows:</para>

<programlisting><replaceable>object_reference.member_name</replaceable></programlisting>

<para>Object methods are called by appending a dot '.' and a method name to the object reference as follows:</para>

<programlisting><replaceable>object_reference</replaceable>.<replaceable>method_name</replaceable>([<replaceable>argument_list</replaceable>])</programlisting>

<para>The object references above are normally variable references holding an object, but could be any expression that returns an object, such as a new expression or even a subroutine call.</para>

<note>
<para>Objects are always passed by reference, like in Java.  Objects can only be explicitly copied; otherwise any object instantiated with the <command>new</command> operator will remain unique until deleted or explicitly copied.  An explicit copy is made with the copy constructor, and does not guarantee an exact copy of the source object (it depends on the definition of the copy method for the class in question).</para>
</note>

<para>Objects exist until they go out of scope, are explicitly deleted, or their last thread exits.  For detailed information, see the section <link linkend='Classes'>Classes</link> on Qore classes.</para>
</sect2>
</sect1>

<sect1 id="Qore_Strings_and_Character_Set_Encoding">
<title>Qore Strings and Character Set Encoding</title>

<para>The Qore language is character-set-encoding aware.  All strings are assumed to have the default character set encoding, unless the program explicitly specified another encoding for certain objects and operations.  Every Qore string has a character set encoding ID attached to it, so, when another character set is required, the Qore language will attempt to do a character set translation.</para>

<para>Qore uses the operating system's iconv library functions to perform any encoding conversions.</para>

<para>Qore supports character sets that are backwards compatible with 7-bit ASCII.  This includes all ISO-8859-* character sets, UTF-8, KOIR-8, KOIU-8, and KOI7, among others.  However, mutibyte character encodings are currently only properly supported for UTF-8.  For UTF-8 strings, the <link linkend="length">length()</link>, <link linkend="index">index()</link>, <link linkend="rindex">rindex()</link>, <link linkend="substr">substr()</link>, <link linkend="reverse">reverse()</link>, the <link linkend="Splice_Operator">splice operator</link>, print formatting (regarding field lengths) functions and methods taking format strings, and regular expression operators and functions, all work with character offsets, which may be different than byte offsets.  For all character set encodings other than UTF-8, a 1 byte=1 character relationship is assumed.</para>

<para>The default Qore character set is determined by environment variables.</para>

<para>First, the <code>QORE_CHARSET</code> environment variable is checked. If it is set, then this character set will be the default character set for the process.  If not, then the <code>LANG</code> environment variable is checked. If a character set is specified in the <code>LANG</code> environment variable, then it will be used as the default character set.  Otherwise, if no character set can be derived from the environment, UTF-8 is assumed.</para>

<para>Character set encodings are automatically converted by the Qore language when necessary.  Encoding conversion errors will cause a Qore exception to be thrown.  The character set encoding conversions supported by Qore depend on the Operating System's iconv library function.</para>

<para>The following is a non-exhaustive list of examples in Qore where character encoding processing is performed.</para>

<para>Character set encodings can be explicitly performed with the <link linkend="convert_encoding">convert_encoding()</link> function, and the encoding attached to a string can be checked with the <link linkend="get_encoding">get_encoding()</link> function. </para>

<para>The <link linkend='Tibae_TibcoAdapter_Class'>TibcoAdapter Class</link> will automatically convert all strings to UTF-8 encoding if necessary before transmitting any messages, as required by the TIBCO SDK.</para>

<para>The <link linkend='TibrvSender_Class'>TibrvSender Class</link>, <link linkend='TibrvListener_Class'>TibrvListener Class</link>, <link linkend='TibrvCmSender_Class'>TibrvCmSender Class</link>, and the <link linkend='TibrvCmListener_Class'>TibrvCmListener Class</link> will convert and tag strings to the encoding set for instantiated objects of these classes.</para>

<para>The <link linkend='Qore::SQL::Datasource_Class'>Datasource Class</link> will translate character set encodings to the encoding required by the database if necessary as well (this is actually the responsibility of the DBI driver for the database in question).</para>

<para>The <link linkend='Qore_File_Class'>File</link> and <link linkend='Qore_Socket_Class'>Socket</link> classes translate character set encodings to the encoding specified for the object if necessary, as well as tagging strings received or read with the object's encoding.</para>

<para>The <link linkend='HTTPClient_Class'>HTTPClient Class</link> will translate character set encodings to the encoding specified for the HTTPClient object, if any has been set, as well as tagging strings received with the object's encoding.  Additionally, if an HTTP server response specifies a specific encoding to use, the encoding will be automatically set to this encoding as well.</para>

<para>Additionally you can serialize a Qore hash to an XML string and specify the character set encoding to use. If the target encoding is different than the source encoding conversions are automatically performed. See <link linkend="XML_Integration">XML Integration</link> for more information about XML handling.</para>

</sect1>

  <sect1 id="Expressions">
    <title>Expressions</title>

    <para>An expression can be any of the following (note that expressions are also recursively defined):</para>
    <table>
      <title>Expressions</title>
      <tgroup cols='4' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Type</para></entry>
	    <entry><para>Description</para></entry>
	    <entry>
	    <para>Examples</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para>An immediate value</para></entry>
	    <entry><para>Qore values that can be expressed directly (see <link linkend="Basic_Data_Types">Basic Data Types</link> for more information)</para></entry>
	    <entry>
	      <programlisting>True
152
1.2
"a string"
2005-10-27
<command>NULL</command>
<command>NOTHING</command>
("key" : $val)
1, 2.0, "three"</programlisting>
	    </entry>
	  </row>
	  <row>
	    <entry><para>A variable reference</para></entry>
	    <entry><para>Qore variables (see <link linkend="Variables">Variables</link> for more information)</para></entry>
	    <entry><programlisting>$var</programlisting></entry>
	  </row>
	  <row>
	    <entry><para>A variable or variable expression assignment</para></entry>
	    <entry><para>Assigns a value to a lvalue (see <link linkend="Assignment_Operator">Assignment Operator</link> for more information)</para></entry>
	    <entry>
	      <para><programlisting>$var = 1
($a, $b, $c, $date) = (1, "two", 3.3, 2005-10-28)</programlisting></para>
	    </entry>
	  </row>
	  <row>
	    <entry><para>A subroutine/function call</para></entry>
	    <entry><para>Qore subroutine calls (see <link linkend="Subroutines">Subroutines</link> for more information)</para></entry>
	    <entry><programlisting>calculate($var1, $var2, "string", 4)</programlisting></entry>
	  </row>
	  <row>
	    <entry><para>A method call</para></entry>
	    <entry><para>Qore object method calls (see <link linkend="Objects">Objects</link> for more information)</para></entry>
	    <entry><programlisting>$object.method("argument")</programlisting></entry>
	  </row>
	  <row>
	    <entry><para>Expressions with operators</para></entry>
	    <entry><para>Use of Qore operators (see <link linkend='Operators'>Operators</link> for more information)</para></entry>
	    <entry>
	      <para><programlisting>1 + 2
$a || $b
<command>background</command> my_function()</programlisting></para>
	    </entry>
	  </row>
	  <row>
	    <entry><para>An expression in parentheses</para></entry>
	    <entry><para>Use of parentheses for clarity or to specify evaluation precedence.</para></entry>
	    <entry>
	      <para><programlisting>(1 + 2)
(2 * (3 + 1))</programlisting></para>
	    </entry>
	  </row>
	  <row>
	    <entry><para>A list</para></entry>
	    <entry><para>a list of values (see <link linkend="Lists">Lists</link> for more information)</para></entry>
	    <entry><programlisting>1, 2, 3, "four", 5.0</programlisting></entry>
	  </row>
	  <row>
	    <entry><para>A hash</para></entry>
	    <entry><para>a hash (associative/keyed array) value container (see <link linkend="Hashes">Hashes</link> for more information)</para></entry>
	    <entry><programlisting>( "key1" : 1, "key2" : "two" )</programlisting>
	    </entry>
	  </row>
	  <row>
	    <entry><para>A <command>find</command> expression</para></entry>
	    <entry><para>Finds a value or values in a hash of lists, such as returned by the <link linkend="Qore::SQL::Datasource::select">Datasource::select() method</link> (see <link linkend="find_Expressions">find expressions</link> for more information)</para></entry>
	    <entry>
	      <programlisting><command>find</command> %name, %id <command>in</command> $data <command>where</command> (%name =~ /Smith/);</programlisting>
	    </entry>
	  </row>
	  <row>
	    <entry><para>A context identifier (<code>%column</code>)</para></entry>
	    <entry><para>A contextual reference to the value of a key of a complex data structure within the current row being iterated by a <link linkend="context_Statements"><command>context</command></link>, <link linkend="summarize_Statements"><command>summarize</command></link>, <link linkend="subcontext_Statements"><command>subcontext</command></link> statement, or a  <link linkend="find_Expressions"><command>find</command> expression</link>.</para></entry>
	    <entry><programlisting>%name</programlisting></entry>
	  </row>
	  <row>
	    <entry><para>A context row identifier (<code>%%</code>)</para></entry>
	    <entry><para>A contextual reference to the current row of complex data structure being iterated by a <link linkend="context_Statements"><command>context</command></link>, <link linkend="summarize_Statements"><command>summarize</command></link>, <link linkend="subcontext_Statements"><command>subcontext</command></link> statement, or a <link linkend="find_Expressions"><command>find</command> expression</link>.  This expression will return a hash of the current row.</para></entry>
	    <entry><programlisting>%%</programlisting></entry>
	  </row>
	  <row>
	    <entry><para>A backquote expression</para></entry>
	    <entry><para>Executes a UNIX process and returns the stdout as a string</para></entry>
	    <entry><programlisting>'ls -l'</programlisting></entry>
	  </row>
	  <row id="call_references">
	    <entry><para>A call reference</para></entry>
	    <entry><para>A reference to a function or object method call.  Function references are resolved in the second phase of parsing (commit phase), and object method references are resolved at run-time.</para></entry>
	    <entry><programlisting>\function_call()
\$object_expression.method_name()</programlisting></entry>
	  </row>
	  <row>
	    <entry><para>A call reference call</para></entry>
	    <entry><para>Calls the code referenced by the call reference expression using any arguments supplied and returns the result.</para></entry>
	    <entry><programlisting>$result = $call_reference($arg1, $arg2)</programlisting></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
    
    <sect2 id="find_Expressions">
      <title>find Expressions</title>
      
      <variablelist>
	<varlistentry>
	  <term>Synopsis</term>
	  <listitem>
	    <para>The <command>find</command> expression can be used to quickly find data in a hash of lists (such as a query result set returned by the <link linkend="Qore::SQL::Datasource::select">Datasource::select()</link> method).  The <command>find</command> expression will loop through a data structure based until an expression becomes True, and then it will evaluate and return a result expression.  In each part of the <command>find</command>, column names can be referred to by preceding the name with a '%" character (as with <link linkend="context_Statements">context</link> statements).</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Syntax</term>
	  <listitem>
	    <para>
	      <programlisting><command>find</command> <replaceable>result_expression</replaceable> <command>in</command> <replaceable>data_expression</replaceable> <command>where</command> ( <replaceable>where_expression</replaceable> )</programlisting>
	    </para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Description</term>
	  <listitem>
	    <para><replaceable>result_expression</replaceable></para>
	    <para>This expression will be evaluated and returned when the <replaceable>where_expression</replaceable> evaluates to True.</para>

	    <para><replaceable>data_expression</replaceable></para>
	    <para>This expression must evaluate to a hash of lists, so that the internal context can be set up for the <command>find</command> loop.</para>
	    
	    <para><replaceable>where_expression</replaceable></para>
	    <para>This expression will be evaluated for each row in the <replaceable>data_expression</replaceable>.  When it returns True, the <replaceable>result_expression</replaceable> will be evaulated and returned.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Example</term>
	  <listitem>
	    <programlisting>$rlist = <command>find</command> %name, %id <command>in</command> $data <command>where</command> (%name =~ /Smith/);</programlisting>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>
  </sect1>

  <sect1 id="Operators">
    <title>Operators</title>

    <para>The following table lists all Qore operators in order of precedence, starting with the highest precedence. The lower the precedence number, the higher the precedence, therefore the operators with precedence level 1 ("{}", "[]", ".") have the highest precedence of all Qore operators.  The precedence levels in Qore are roughly equal to the precedence levels of C language operators (however note the important difference with the , operator as noted below). To explicitly specify the precedence for expression evaluation, use parentheses ().</para>

<table><title>Operators</title>
<tgroup cols='4' align='left' colsep='1' rowsep='1'>

  <thead>
  <row>
    <entry><para>Operator</para></entry>
    <entry><para>Prec.</para></entry>
    <entry><para>Description</para></entry>
    <entry><para>Example</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>``</para></entry>
    <entry><para>1</para></entry>
    <entry><para><link linkend='Backquote_Operator'>backquote/backtick operator</link></para></entry>
    <entry><code>`ls -l`</code></entry>
  </row>
  <row>
    <entry><para>{}</para></entry>
    <entry><para>1</para></entry>
    <entry><para><link linkend='Hash_Element_Expression_Dereference_Operator'>hash element or object member expression dereference operator</link></para></entry>
    <entry><code>$hash{"na" + "me"}</code></entry>
  </row>
  <row>
    <entry><para>.</para></entry>
    <entry><para>1</para></entry>
    <entry><para><link linkend='Hash_Element_Literal_Dereference_Operator'>hash element or object member literal dereference operator</link></para></entry>
    <entry>
      <para><code>$hash.name</code></para>
      <para><code>$obj.method()</code></para>
    </entry>
  </row>
  <row>
    <entry><para>[]</para></entry>
    <entry><para>1</para></entry>
    <entry><para><link linkend='List_Dereference_Operator'>list element dereference operator</link></para></entry>
    <entry><code>$list[1]</code></entry>
  </row>
  <row>
    <entry><para>++</para></entry>
    <entry><para>2</para></entry>
    <entry><para><link linkend='Pre_Increment_Operator'>pre-increment operator</link>, <link linkend='Post_Increment_Operator'>post-increment operator</link></para></entry>
    <entry><code>++$a, $a++</code></entry>
  </row>
  <row>
    <entry><para>--</para></entry>
    <entry><para>2</para></entry>
    <entry><para><link linkend='Pre_Decrement_Operator'>pre-decrement operator</link>, <link linkend='Post_Decrement_Operator'>post-decrement operator</link></para></entry>
    <entry><code>--$a, $a--</code></entry>
  </row>
  <row>
    <entry><para><command>new</command></para></entry>
    <entry><para>3</para></entry>
    <entry><para><link linkend='New_Object_Operator'>class instantiation/new object operator</link></para></entry>
    <entry><code><command>new</command> Socket()</code></entry>
  </row>
  <row>
    <entry><para><command>background</command></para></entry>
    <entry><para>3</para></entry>
    <entry><para><link linkend='Background_Operator'>background/thread creation operator</link></para></entry>
    <entry><code><command>background</command> mainThread()</code></entry>
  </row>
  <row>
    <entry><para>!</para></entry>
    <entry><para>4</para></entry>
    <entry><para><link linkend='Logical_Not_Operator'>logical negation operator</link></para></entry>
    <entry><code><command>if</command> (!($a &gt; 10)) ...</code></entry>
  </row>
  <row>
    <entry><para>~</para></entry>
    <entry><para>5</para></entry>
    <entry><para><link linkend='Binary_Not_Operator'>binary not/bit inversion operator</link></para></entry>
    <entry><code>$var = ~$var</code></entry>
  </row>
  <row>
    <entry><para>- (unary minus)</para></entry>
    <entry><para>6</para></entry>
    <entry><para><link linkend='Unary_Minus_Operator'>unary minus operator</link></para></entry>
    <entry><code>$var = -$var</code></entry>
  </row>
  <row>
    <entry><para><command>shift</command></para></entry>
    <entry><para>7</para></entry>
    <entry><para><link linkend='Shift_Operator'>shift list element operator</link></para></entry>
    <entry><code><command>shift</command> $list</code></entry>
  </row>
  <row>
    <entry><para><command>pop</command></para></entry>
    <entry><para>7</para></entry>
    <entry><para><link linkend='Pop_Operator'>pop list element operator</link></para></entry>
    <entry><code><command>pop</command> $list</code></entry>
  </row>
  <row>
    <entry><para><command>chomp</command></para></entry>
    <entry><para>7</para></entry>
    <entry><para><link linkend='Chomp_Operator'>chomp end-of-line character operator</link></para></entry>
    <entry><code><command>chomp</command> $string</code></entry>
  </row>
  <row>
    <entry><para><command>elements</command></para></entry>
    <entry><para>8</para></entry>
    <entry><para><link linkend='Elements_Operator'>number of elements operator (list, hash, string, binary)</link></para></entry>
    <entry><code><command>elements</command> $list</code></entry>
  </row>
  <row>
    <entry><para><command>keys</command></para></entry>
    <entry><para>8</para></entry>
    <entry><para><link linkend='Keys_Operator'>hash key list operator</link></para></entry>
    <entry><code><command>keys</command> $hash</code></entry>
  </row>
  <row>
    <entry><para>*</para></entry>
    <entry><para>9</para></entry>
    <entry><para><link linkend='Multiply_Operator'>arithmetic multiplication operator</link></para></entry>
    <entry><code>$var = $a * 10</code></entry>
  </row>
  <row>
    <entry><para>/</para></entry>
    <entry><para>9</para></entry>
    <entry><para><link linkend='Divide_Operator'>arithmetic division operator</link></para></entry>
    <entry><code>$var = $a / 10</code></entry>
  </row>
  <row>
    <entry><para>%</para></entry>
    <entry><para>10</para></entry>
    <entry><para><link linkend='Modula_Operator'>arithmetic modula operator</link></para></entry>
    <entry><code>$var = $a % 10</code></entry>
  </row>
  <row>
    <entry><para>+</para></entry>
    <entry><para>11</para></entry>
    <entry><para><link linkend='Plus_Operator'>plus operator: string, list, and hash concatenation, integer and float addition</link></para></entry>
    <entry>
      <para><code>$a + 10</code></para>
      <para><code>"hello" + "there"</code></para>
      <para><code>$list + "new value"</code></para>
      <para><code>$hash + ( "newkey" : 100 )</code></para>
    </entry>
  </row>
  <row>
    <entry><para>-</para></entry>
    <entry><para>11</para></entry>
    <entry><para><link linkend='Minus_Operator'>minus operator (arithmetic subtraction, hash key removal)</link></para></entry>
    <entry><code>$a - 10</code></entry>
  </row>
  <row>
    <entry><para>&gt;&gt;</para></entry>
    <entry><para>12</para></entry>
    <entry><para><link linkend='Shift_Right_Operator'>bitwise shift right operator</link></para></entry>
    <entry><code>0xff00 &gt;&gt; 8</code></entry>
  </row>
  <row>
    <entry><para>&lt;&lt;</para></entry>
    <entry><para>12</para></entry>
    <entry><para><link linkend='Shift_Left_Operator'>bitwise shift left operator</link></para></entry>
    <entry><code>0xff00 &lt;&lt; 8</code></entry>
  </row>
  <row>
    <entry><para><command>exists</command></para></entry>
    <entry><para>13</para></entry>
    <entry><para><link linkend='Exists_Operator'>exists value operator</link></para></entry>
    <entry><code><command>exists</command> $var</code></entry>
  </row>
  <row>
    <entry><para><command>instanceof</command></para></entry>
    <entry><para>13</para></entry>
    <entry><para><link linkend='Instanceof_Operator'>instanceof class operator</link></para></entry>
    <entry><code><command>instanceof</command> Qore::Mutex</code></entry>
  </row>
  <row>
    <entry><para>&lt;</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Less_Than_Operator'>Logical less than operator</link></para></entry>
    <entry><code>$a &lt; 10</code></entry>
  </row>
  <row>
    <entry><para>&gt;</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Greater_Than_Operator'>Logical greater than operator</link></para></entry>
    <entry><code>$a &gt; 10</code></entry>
  </row>
  <row>
    <entry><para>==</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Equals_Operator'>Logical equality operator</link></para></entry>
    <entry><code>$a == 10</code></entry>
  </row>
  <row>
    <entry><para>!=</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Not_Equals_Operator'>logical inequality operator</link></para></entry>
    <entry><code>$a != 10</code></entry>
  </row>
  <row>
    <entry><para>&lt;=</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Less_Than_Or_Equals_Operator'>Logical less then or equals operator</link></para></entry>
    <entry><code>$a &lt;= 10</code></entry>
  </row>
  <row>
    <entry><para>&gt;=</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Greater_Than_Or_Equals_Operator'>logical greater than or equals operator</link></para></entry>
    <entry><code>$a &gt;= 10</code></entry>
  </row>
  <row>
    <entry><para>&lt;=&gt;</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Comparison_Operator'>logical comparison operator</link></para></entry>
    <entry><code>$a &lt;=&gt; $b</code></entry>
  </row>
  <row>
    <entry><para>===</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Absolute_Equals_Operator'>absolute logical equality operator</link></para></entry>
    <entry><code>$a === 10</code></entry>
  </row>
  <row>
    <entry><para>!==</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Absolute_Not_Equals_Operator'>absolute logical inequality operator</link></para></entry>
    <entry><code>$a !== 10</code></entry>
  </row>
  <row>
    <entry><para>=~ //</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Regular_Expression_Match_Operator'>regular expression match operator</link></para></entry>
    <entry><code>$a =~ /text/</code></entry>
  </row>
  <row>
    <entry><para>!~ //</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Regular_Expression_No_Match_Operator'>regular expression no match operator</link></para></entry>
    <entry><code>$a !~ /text/</code></entry>
  </row>
 <row>
    <entry><para>=~ s///</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Regular_Expression_Substitution_Operator'>regular expression substitution operator</link></para></entry>
    <entry><code>$a =~ s/text/text/</code></entry>
  </row>
 <row>
    <entry><para>=~ x//</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Regular_Expression_Pattern_Extraction_Operator'>regular expression pattern extraction operator</link></para></entry>
    <entry><code>$a =~ x/(\w+):(\w+)/</code></entry>
  </row>
 <row>
    <entry><para>=~ tr</para></entry>
    <entry><para>14</para></entry>
    <entry><para><link linkend='Transliteration_Operator'>transliteration operator</link></para></entry>
    <entry><code>$a =~ tr/src_chars/targ_chars/</code></entry>
  </row>
  <row>
    <entry><para>&amp;</para></entry>
    <entry><para>15</para></entry>
    <entry><para><link linkend='Binary_And_Operator'>bitwise AND operator</link></para></entry>
    <entry><code>$a &amp; 0xff</code></entry>
  </row>
  <row>
    <entry><para>|</para></entry>
    <entry><para>15</para></entry>
    <entry><para><link linkend='Binary_Or_Operator'>bitwise OR operator</link></para></entry>
    <entry><code>$a | 0xff</code></entry>
  </row>
  <row>
    <entry><para>^</para></entry>
    <entry><para>15</para></entry>
    <entry><para><link linkend='Binary_Xor_Operator'>bitwise XOR operator</link></para></entry>
    <entry><code>$a ^ 0xff</code></entry>
  </row>
  <row>
    <entry><para>&amp;&amp;</para></entry>
    <entry><para>16</para></entry>
    <entry><para><link linkend='Logical_And_Operator'>logical AND operator</link></para></entry>
    <entry><code>($a = 1) &amp;&amp; ($b &lt; 10)</code></entry>
  </row>
  <row>
    <entry><para>||</para></entry>
    <entry><para>16</para></entry>
    <entry><para><link linkend='Logical_Or_Operator'>logical OR operator</link></para></entry>
    <entry><code>($a = 1) || ($b &lt; 10)</code></entry>
  </row>
  <row>
    <entry><para>? :</para></entry>
    <entry><para>17</para></entry>
    <entry><para><link linkend='Conditional_Operator'>conditional operator</link></para></entry>
    <entry><code>$a == 2 ? "yes" : "no"</code></entry>
  </row>
  <row>
    <entry><para>,</para></entry>
    <entry><para>18</para></entry>
    <entry><para><link linkend='Comma_Operator'>comma operator</link></para></entry>
    <entry><code>1, 2, 3, 4, 5</code></entry>
  </row>
  <row>
    <entry><para><command>unshift</command></para></entry>
    <entry><para>19</para></entry>
    <entry><para><link linkend='Unshift_Operator'>unshift list element operator</link></para></entry>
    <entry><code><command>unshift</command> $list, $val</code></entry>
  </row>
  <row>
    <entry><para><command>push</command></para></entry>
    <entry><para>19</para></entry>
    <entry><para><link linkend='Push_Operator'>push list element operator</link></para></entry>
    <entry><code><command>push</command> $list, $val</code></entry>
  </row>
  <row>
    <entry><para><command>splice</command></para></entry>
    <entry><para>19</para></entry>
    <entry><para><link linkend='Splice_Operator'>splice list or string operator</link></para></entry>
    <entry><code><command>splice</command> $list, 2, 2, (1, 2, 3)</code></entry>
  </row>
  <row>
    <entry><para>=</para></entry>
    <entry><para>20</para></entry>
    <entry><para><link linkend='Assignment_Operator'>assignment operator</link></para></entry>
    <entry><code>$var = 1</code></entry>
  </row>
  <row>
    <entry><para>+=</para></entry>
    <entry><para>21</para></entry>
    <entry><para><link linkend='Plus_Equals_Operator'>plus-equals (add-to) operator</link></para></entry>
    <entry><code>$var += 5</code></entry>
  </row>
  <row>
    <entry><para>-=</para></entry>
    <entry><para>21</para></entry>
    <entry><para><link linkend='Minus_Equals_Operator'>minus-equals (subtract-from) operator</link></para></entry>
    <entry><code>$var -= 5</code></entry>
  </row>
  <row>
    <entry><para>&amp;=</para></entry>
    <entry><para>21</para></entry>
    <entry><para><link linkend='And_Equals_Operator'>and-equals operator</link></para></entry>
    <entry><code>$var &amp;= 0x2000</code></entry>
  </row>
  <row>
    <entry><para>|=</para></entry>
    <entry><para>21</para></entry>
    <entry><para><link linkend='Or_Equals_Operator'>or-equals operator</link></para></entry>
    <entry><code>$var |= 0x2000</code></entry>
  </row>
  <row>
    <entry><para>%=</para></entry>
    <entry><para>21</para></entry>
    <entry><para><link linkend='Modula_Equals_Operator'>modula-equals operator</link></para></entry>
    <entry><code>$var %= 100</code></entry>
  </row>
  <row>
    <entry><para>*=</para></entry>
    <entry><para>21</para></entry>
    <entry><para><link linkend='Multiply_Equals_Operator'>multiply-equals operator</link></para></entry>
    <entry><code>$var *= 10</code></entry>
  </row>
  <row>
    <entry><para>/=</para></entry>
    <entry><para>21</para></entry>
    <entry><para><link linkend='Divide_Equals_Operator'>divide-equals operator</link></para></entry>
    <entry><code>$var /= 10</code></entry>
  </row>
  <row>
    <entry><para>^=</para></entry>
    <entry><para>21</para></entry>
    <entry><para><link linkend='Xor_Equals_Operator'>xor-equals operator</link></para></entry>
    <entry><code>$var ^= 0x2000</code></entry>
  </row>
  <row>
    <entry><para>&lt;&lt;=</para></entry>
    <entry><para>21</para></entry>
    <entry><para><link linkend='Shift_Left_Equals_Operator'>shift-left-equals operator</link></para></entry>
    <entry><code>$var &lt;&lt;= 0x2000</code></entry>
  </row>
  <row>
    <entry><para>&gt;&gt;=</para></entry>
    <entry><para>21</para></entry>
    <entry><para><link linkend='Shift_Right_Equals_Operator'>shift-right-equals operator</link></para></entry>
    <entry><code>$var &gt;&gt;= 0x2000</code></entry>
  </row>

</tbody>
</tgroup>
</table>

<note>
<para>All Qore operators perform thread-atomic actions with respect to the immediate arguments of the operator.  If the operators are used in a complex expression, the entire expression is not thread-atomic unless explicit user-level locking is used.  For example: <code>$a += 5</code> is a thread-atomic action, but <code>$a += $b--</code> is not atomic, but rather made up of two atomic actions.</para>
</note>

<note>
  <para>When an operator taking more than one argument 
  is used with arguments of different data types, Qore automatically converts one 
  or both data types to a data type supported by the operator in order to evaluate 
  the result, according to the precedence lists in the following section. That is; 
  when an operator operates on mixed types, the types listed first in the 
  following sections have precedence over types listed farther down in the lists. 
  The result type will always be equal to the final operation type after any 
  conversions due to type precedence per operator. If no type of either argument 
  matches a supported data type for the operator, both types will be converted to 
  the highest precedence data type for the operator and then the operator will 
  evaluate the result. For explicit type conversion, please see the 
  <link linkend="boolean">boolean()</link>, <link linkend="string">string()</link>, 
  <link linkend="date">date()</link>, <link linkend="int">int()</link>, 
  <link linkend="float">float()</link>, etc functions.</para>
</note>

<note>
  <para>The Qore comma ',' operator has a higher precendece than the '=' operator, meaning that a statement like <code>$a = 1, 2, 3;</code> is possible without parentheses.  However, it means that a statment like <code>$a = func(1, 2, $b = 3, 4);</code> will probably not do what you want (it uses <code>$b</code> as the third argument which is assigned to the list <code>(3, 4)</code>); you must write <code>$a = func(1, 2, ($b = 3), 4);</code> to pass 4 arguments to the function <code>func</code>.</para>
</note>

<sect2 id="Backquote_Operator">
  <title>Backquote Operator (``)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Executes the shell command in a separate process and returns the stdout as a string.  To perform the same action using a Qore expression, see the <link linkend="backquote">backquote() function</link>.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>`shell_command`</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$dirlisting = `ls -l`</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <informaltable>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>shell_command</replaceable></para></entry>
	  <entry><para>The shell command will be executed and the stdout is returned as a string.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </informaltable>

  <table>
    <title>Exceptions Thrown by ``</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>err</para></entry>
	  <entry><para>desc</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><code>BACKQUOTE-ERROR</code></para></entry>
	  <entry><para>An error occurred in fork() or creating the output pipe.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
</sect2>

<sect2 id="Hash_Element_Expression_Dereference_Operator">
  <title>Hash Element or Object Member Expression Dereference Operator ({})</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Retrieves the value of hash key or object member by evaulating an expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>container_expression{expression}</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>printf("%s\n", $hash{getName()});</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>


  <table><title>Arguments Processed by {}</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para><replaceable>container_expression</replaceable></para></entry>
	<entry><para>This expression must evaluate to a hash or an object. If not, then the operator returns no value.</para></entry>
      </row>
      <row>
	<entry><para><replaceable>expression</replaceable></para></entry>
	<entry><para>This expression is evaluated and converted to a string if necessary. The value of the hash key corresponding to this string will be returned. If the key or member does not exist, then no value is returned.</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>

  <table><title>Exceptions Thrown by {}</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>err</para></entry>
	<entry><para>desc</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para><code>PRIVATE-MEMBER</code></para></entry>
	<entry><para>Attempt to access a private member outside the class.</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>
</sect2>

<sect2 id="Hash_Element_Literal_Dereference_Operator">
  <title>Hash Element or Object Member Literal Dereference Operator (.)</title>

    <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Retrieves the value of a hash key or object member using a literal identifier.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>container_expression.identifier</replaceable>
<replaceable>container_expression.method_identifier([arguments...])</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>printf("%s\n", $hash.name);</programlisting>
	<programlisting>$obj.method("argument");</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed by .</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      
      <tbody>
	<row>
	  <entry><para><replaceable>container_expression</replaceable></para></entry>
	  <entry><para>This expression must evaluate to a hash or an object. If not, then the operator returns no value.</para></entry>
	</row>
	<row>
	  <entry><para><replaceable>identifier</replaceable></para></entry>
	  <entry><para>The value of the hash key or object member corresponding to this identifier will be returned. If no such key exists, then no value is returned. In order to use hash keys that are not valid Qore identifiers, please use the {} operator.  If the member is a private member and access is made outside the class, a run-time exception will be thrown.</para></entry>
	</row>
	<row>
	  <entry><para><replaceable>method_ídentifier</replaceable></para></entry>
	  <entry><para>The container expression must evaluate to an object, or a run-time exception is thrown.  If the method does not exist in the class a run-time exception is thrown.  Otherwise the method is called with any optional arguments given.</para></entry>
	</row>

      </tbody>
    </tgroup>
  </table>
  
  <table>
    <title>Exceptions Thrown by .</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>err</para></entry>
	  <entry><para>desc</para></entry>
	</row>
      </thead>
      
      <tbody>
	<row>
	  <entry><para><code>PRIVATE-MEMBER</code></para></entry>
	  <entry><para>Attempt to access a private member outside the class.</para></entry>
	</row>
	<row>
	  <entry><para><code>METHOD-DOES-NOT-EXIST</code></para></entry>
	  <entry><para>Attempt to access a method not defined for this class.</para></entry>
	</row>
	<row>
	  <entry><para><code>METHOD-IS-PRIVATE</code></para></entry>
	  <entry><para>Attempt to access a private method from outside the class.</para></entry>
	</row>
	<row>
	  <entry><para><code>BASE-CLASS-IS-PRIVATE</code></para></entry>
	  <entry><para>Attempt to access a method of a privately-inherited base class from outside the class.</para></entry>
	</row>
	<row>
	  <entry><para><code>OBJECT-METHOD-EVAL-ON-NON-OBJECT</code></para></entry>
	  <entry><para>Attempt to execute a method on a non-object.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

</sect2>
<sect2 id="List_Dereference_Operator">
  <title>List Dereference Operator ([])</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Retrieves the value of a list element.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>list_expression[expression]</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>printf("%s\n", $list[2]);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  
  <table>
    <title>Arguments Processed By []</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>list_expression</replaceable></para></entry>
	  <entry><para>This expression must evaluate to a list. If not, then the operator returns no value.</para></entry>
	</row>
	<row>
	  <entry><para><replaceable>expression</replaceable></para></entry>
	  <entry><para>The expression is evaluated and converted to an integer if necessary. Then the value of the list element given is returned (elements start at position 0).</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>
</sect2>

<sect2 id="Pre_Increment_Operator">
  <title>Integer Pre-Increment Operator (++)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>increments an lvalue and returns the incremented value.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>++lvalue</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>++$i;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By Pre-Increment ++</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>First converts the value of <replaceable>lvalue</replaceable> to an integer if necessary, then increments the value and returns the result.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Post_Increment_Operator">
  <title>Integer Post-Increment Operator (++)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>increments an lvalue and returns the value before the increment.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue++</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$i++;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By Post-Increment ++</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>First converts the value of <replaceable>lvalue</replaceable> to an integer if necessary, then saves this value as the result, then increments the lvalue, then returns the saved original value of <replaceable>lvalue</replaceable> (after conversion to an integer if necessary)</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
  
  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Pre_Decrement_Operator">
  <title>Integer Pre-Decrement Operator (--)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>decrements an lvalue and returns the decremented value.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>--lvalue</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>--$i;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By Pre-Decrement --</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>First converts the value of <replaceable>lvalue</replaceable> to an integer if necessary, then decrements it and returns the result.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Post_Decrement_Operator">
  <title>Integer Post-Decrement Operator (--)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>decrements an lvalue and returns the value before the decrement.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue--</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$i--;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By Post-Decrement --</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>First converts the value of <replaceable>lvalue</replaceable> to an integer if necessary, then saves this value as the result, then decrements the lvalue, then returns the saved original value of <replaceable>lvalue</replaceable> (after conversion to an integer if necessary)</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
  
  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="New_Object_Operator">
  <title>New Object Operator (new)</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Creates an instance of a class and runs the class' constructor on the new class (if any exists).</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>new</command> <replaceable>class_identifier(constructor_arguments ...)</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$obj = <command>new</command> Qore::Mutex();</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  <table>
    <title>Arguments Processed By new</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>class_identifier</replaceable></para></entry>
	  <entry><para>The class_identifier must be an existing class name; if so, the operator instantiates an object of this class, executes the constructor for the class (if any exists, along with any base class constructors, if applicable) on the new object, and returns the object (for constructor execution order in an inherited class, see <link linkend='Class_Inheritance'>Class Inheritance</link>).  If an exception is thrown in the constructor, the object is deleted and NOTHING is returned.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
  <table>
    <title>Exceptions Thrown by new</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>err</para></entry>
	  <entry><para>desc</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>depends on class/constructor</para></entry>
	  <entry><para>See class documentation for possible exceptions.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
</sect2>

<sect2 id="Background_Operator">
  <title>Background Operator (background)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Start a background thread and return the TID (thread ID).</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>background</command> <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>background</command> startThread();</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By background</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>expression</replaceable></para></entry>
	  <entry>
	    <para>The expression given as an argument will be executed in a new thread. The TID of the new thread will be returned as the return value of the operator. </para>      
	  </entry>
	</row>
      </tbody>
    </tgroup>
  </table>

<note>
  <para>Please note the following when using the background operator:</para>
  <itemizedlist mark='bullet'>
    <listitem>
      <para>expressions that have no effect cannot be used with the background operator (a parse exception will be thrown)</para>
    </listitem>
    <listitem>
      <para>it is illegal to make changes to a local variable anywhere in a background expression (a parse exception will be thrown)</para>
    </listitem>
    <listitem>
      <para>local variables and <command>find</command> expressions are evaluated before the new thread is started and the result of the evaluation is used in the expression in the new thread.</para>
    </listitem>
    <listitem>
      <para>it is not possible to pass local variables by reference anywhere in a background expression (a parse exception will be thrown)</para>
    </listitem>
  </itemizedlist>
</note>

  <table>
    <title>Exceptions Thrown by background</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>err</para></entry>
	  <entry><para>desc</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><code>THREAD-CREATION-FAILURE</code></para></entry>
	  <entry><para>If the thread table is full or if the operating system returns an error while starting the thread, this exception is thrown.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

</sect2>
<sect2 id="Logical_Not_Operator">
  <title>Logical Not Operator (!)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Reverses the logical sense of an expression (True becomes False and False becomes True).</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting>!<replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> (!<command>exists</command> $error_code)
    do_something();</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By !</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>expression</replaceable></para></entry>
	  <entry><para>The expression is evaluated and converted to Boolean, if necessary. Then the value is logically reversed (True becomes False, False becomes True)</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Binary_Not_Operator">
  <title>Binary Not Operator (~)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>The value of each bit in an integer is reversed (0 becomes 1, 1 becomes 0).</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting>~<replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = ~$b;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By ~</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>expression</replaceable>: Integer</para></entry>
	  <entry><para>Performs bitwise negation on its argument (ex: 666 &amp; ~27 = 640)</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Unary_Minus_Operator">
  <title>Unary Minus Operator (-)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Changes the sign of numeric values.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting>-<replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = -$b;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By Unary Minus -</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>expression</replaceable>: Float</para></entry>
	  <entry><para>Gives the negative of its argument (ex: -(-1.1) = 1.1, -(1.1) = -1.1 </para></entry>
	</row>
	<row>
	  <entry><para><replaceable>expression</replaceable>: Integer</para></entry>
	  <entry><para>Gives the negative of its argument (ex: -(-1) = 1, -(1) = -1</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Shift_Operator">
  <title>Shift Operator (shift)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Removes the first element from a list and returns that element.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>shift</command> <replaceable>lvalue</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = <command>shift</command> $ARGV;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By shift</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>lvalue</replaceable>: List</para></entry>
	  <entry><para>Returns the first element of the list, and the list is modified by having the first element removed from the list.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Pop_Operator">
  <title>Pop Operator (pop)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Removes the last element from a list and returns that element.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>pop</command> <replaceable>lvalue</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = <command>pop</command> $list;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By pop</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>lvalue</replaceable>: List</para></entry>
	  <entry><para>Returns the last element of the list, and the list is modified, having the last element removed from the list.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Chomp_Operator">
  <title>Chomp Operator (chomp)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Removes the end-of-line marker(s) ('\n' or '\r\n') from a string, or each string element in a list, or each hash key value in a hash (if the value is a string) and returns the number of characters removed.</para><para>To perform this operation on a non-lvalue expression, see the <link linkend="chomp">chomp() function</link>.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>chomp</command> <replaceable>lvalue</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>chomp</command> $str;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By chomp</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>lvalue</replaceable>: String</para></entry>
	  <entry><para>Removes any EOL characters from a string and returns the number of characters removed.</para></entry>
	</row>
	<row>
	  <entry><para><replaceable>lvalue</replaceable>: List</para></entry>
	  <entry><para>Removes any EOL characters from each string element of the list passed and returns the number of characters removed.</para></entry>
	</row>
	<row>
	  <entry><para><replaceable>lvalue</replaceable>: Hash</para></entry>
	  <entry><para>Removes any EOL characters from each hash key's value (where the value is a string) and returns the number of characters removed.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Elements_Operator">
  <title>Elements Operator (elements)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Returns the number of elements in a list, the number of keys in a hash, the number of characters (not bytes) in a string, or the number of bytes in a binary object.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>elements</command> <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$size = <command>elements</command> $list;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By keys</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>List</para></entry>
	  <entry><para>Returns the number of elements in the list.</para></entry>
	</row>
	<row>
	  <entry><para>Hash</para></entry>
	  <entry><para>Returns the number of keys in the hash.</para></entry>
	</row>
	<row>
	  <entry><para>String</para></entry>
	  <entry><para>Returns the number of characters in the string.</para></entry>
	</row>
	<row>
	  <entry><para>Binary</para></entry>
	  <entry><para>Returns the number of bytes in the binary object.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
  <para>This operator does not throw any exceptions.</para>
</sect2>

<sect2 id="Keys_Operator">
  <title>Keys Operator (keys)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Returns a list representing the keys in a hash.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>keys</command> <replaceable>hash_expression</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>foreach</command> <command>my</command> $key <command>in</command> (<command>keys</command> $hash)
    printf("%s = %s\n", $key, $hash.$key);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By keys</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>hash_expression</replaceable></para></entry>
	  <entry><para>Returns a list of strings giving the keys in <replaceable>hash_expression</replaceable>, which must evaluate to a hash.  If not, then no value is returned.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
  <para>This operator does not throw any exceptions.</para>
</sect2>

<sect2 id="Multiply_Operator">
  <title>Multiply Operator (*)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Multiplies two arguments.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> * <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$value = $x * $y</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Argument Processing and Conversion Priorities for *</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Float</para></entry>
	  <entry><para>Gives the result of multiplying its arguments.</para></entry>
	</row>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>Gives the result of multiplying its arguments.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Divide_Operator">
  <title>Divide Operator (/)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Divides a number by another.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> / <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$value = $x / $y;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  
  <table>
    <title>Argument Processing and Conversion Priorities for /</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Float</para></entry>
	  <entry><para>Gives the result of dividing its arguments.</para></entry>
	</row>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>Gives the result of dividing its arguments.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Modula_Operator">
  <title>Modula Operator (%)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Gives the integer remainder after division of one number by another.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> % <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$mod = $x % $y;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By %</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>Gives <replaceable>expression1</replaceable> modula <replaceable>expression2</replaceable> (ex: 12 % 10 = 2).  Arguments are converted to integers if necessary.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Plus_Operator">
  <title>Plus (Addition and Concatentation) Operator (+)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Numeric addition, list, string, and hash concatenation operator.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> + <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = 1 + 2;</programlisting>
	<programlisting>$string = "hello" + "-there";</programlisting>	
	<programlisting>$list = (1, 2) + ("three", "four", "five");</programlisting>
	<programlisting>$hash = ( "key1" : 1, "key2" : 2) + ( "key3" : "three", "key4": "four");</programlisting>	
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Argument Processing and Conversion Priorities for +</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>List</para></entry>
	  <entry><para>Gives the result of concatenating its arguments, i.e. (1, 2) + (3, 4) = (1, 2, 3, 4)</para></entry>
	</row>
	<row>
	  <entry><para>String</para></entry>
	  <entry><para>Gives the result of concatenating its arguments.</para></entry>
	</row>
	<row>
	  <entry><para>Date</para></entry>
	  <entry><para>Gives the result of adding date/time values (see <link linkend='Date_Time_Arithmetic'>Date/Time Arithmetic</link>)</para></entry>
	</row>
	<row>
	  <entry><para>Float</para></entry>
	  <entry><para>Gives the result of adding its arguments.</para></entry>
	</row>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>Gives the result of adding its arguments.</para></entry>
	</row>
	<row>
	  <entry><para>Hash</para></entry>
	  <entry><para>Gives the result of concatenating/merging its arguments. Any common keys will be overwritten by the values in the second hash (<replaceable>expression2</replaceable>)</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Minus_Operator">
  <title>Minus Operator (-)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>With float or integer arguments, subtracts one number from another, however if the left-hand side is a hash, and the right-hand side is a string, then the hash key represented by the string will be removed from the hash.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> - <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$num = $x - $y;</programlisting>
	<programlisting>$hash = $hash - "key";</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Argument Processing and Conversion Priorities for -</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Float</para></entry>
	  <entry><para>arithmetic subtraction: <replaceable>expression1</replaceable> - <replaceable>expression2</replaceable></para></entry>
	</row>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>arithmetic subtraction: <replaceable>expression1</replaceable> - <replaceable>expression2</replaceable></para></entry>
	</row>
	<row>
	  <entry><para>Hash - String</para></entry>
	  <entry><para>hash key deletion: <replaceable>expression1</replaceable> - <replaceable>expression2</replaceable></para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Shift_Right_Operator">
  <title>Shift Right Operator (&gt;&gt;)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Shifts bits in an integer towards zero (divides an integer by a power of 2)</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &gt;&gt; <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = $x &gt;&gt; $y;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Arguments Processed By &gt;&gt;</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>Integer</para></entry>
	<entry><para>Gives the result of shifting <replaceable>expression1</replaceable> right by <replaceable>expression2</replaceable> bits.  Arguments are converted to integers if necesssary.</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Shift_Left_Operator">
  <title>Shift Left Operator (&lt;&lt;)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Shifts bits in an integer towards infinity (multiplies an integer by a power of 2)</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &lt;&lt; <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = $x &lt;&lt; $y;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By &lt;&lt;</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>Gives the result of shifting <replaceable>expression1</replaceable> left by <replaceable>expression2</replaceable> bits.  Arguments are converted to integers if necessary.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
    <sect2 id="Instanceof_Operator">
      <title>Class Instance Operator (instanceof)</title>

      <variablelist>
	<varlistentry>
	  <term>Synopsis</term>
	  <listitem>
	    <para>Tests if an expression is an instance of a class or not.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Syntax</term>
	  <listitem>
	    <programlisting><replaceable>expression</replaceable> <command>instanceof</command> <replaceable>class_specification</replaceable></programlisting>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Example</term>
	  <listitem>
	    <programlisting><command>if</command> ($obj <command>instanceof</command> Qore::Mutex)
    print("object is Mutex\n");</programlisting>
	  </listitem>
	</varlistentry>
      </variablelist>

  <table><title>Arguments Processed By instanceof</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para><replaceable>expression</replaceable></para></entry>
    <entry><para>If <replaceable>expression</replaceable> is an instance of the named class, then the operator returns True, otherwise returns False.  The operator will return True if the class is a base class, also even if it is privately inherited.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Exists_Operator">
  <title>Exists Operator (exists)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if an expression represents a value or not.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>exists</command> <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> (<command>exists</command> $a)
    printf("a = $n\n", $a);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>



<table><title>Arguments Processed By exists</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para><replaceable>expression</replaceable></para></entry>
    <entry><para>If <replaceable>expression</replaceable> evaluates to a value, then the operator returns True, otherwise returns False.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Less_Than_Operator">
  <title>Less Than Operator (&lt;)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if a value is less than another; types are converted if necessary (ex: ("1" &lt; 2) is True).</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &lt; <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x &lt; $y)
    printf("%n is less than %n\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Argument Processing and Conversion Priorities for &lt;</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Float</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically less than <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically less than <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>String</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> comes before <replaceable>expression2</replaceable> in string sort order, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Date</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is before <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Greater_Than_Operator">
  <title>Greater Than Operator (&gt;)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if a value is greater than another; types are converted if necessary (ex: ("2" &gt; 1) is True).</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &gt; <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x &gt; $y)
    printf("%n is less than %n\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<programlisting><replaceable>expression1</replaceable> &gt; <replaceable>expression2</replaceable></programlisting>

<table><title>Argument Processing and Conversion Priorities for &gt;</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Float</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically greater than <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically greater than <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>String</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> comes after <replaceable>expression2</replaceable> in string sort order, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Date</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is after <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Equals_Operator">
  <title>Equals Operator (==)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if a value is equal to another; types are converted if necessary (ex: ("1" == 1) is True).  For absolute equals, where types must also be equal to return true, see the <link linkend="Absolute_Equals_Operator">Absolute Equals Operator (===)</link>.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> == <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x == $y)
    printf("%n is equal to %n\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Argument Processing and Conversion Priorities for ==</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>String</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is equal to <replaceable>expression2</replaceable>, returns True, otherwise False</para></entry>
  </row>
  <row>
    <entry><para>Float</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is equal to <replaceable>expression2</replaceable>, returns True, otherwise False</para></entry>
  </row>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is equal to <replaceable>expression2</replaceable>, returns True, otherwise False</para></entry>
  </row>
  <row>
    <entry><para>Date</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is equal to <replaceable>expression2</replaceable>, returns True, otherwise False</para></entry>
  </row>
  <row>
    <entry><para>List</para></entry>
    <entry><para>If each element in the each list where order is relevant satisfies this operator, the operator returns True, otherwise it returns False</para></entry>
  </row>
  <row>
    <entry><para>Hash</para></entry>
    <entry><para>If each hash has the same keys and the value of each equal key in each hash satisfies this operator, the operator returns True, otherwise it returns False</para></entry>
  </row>
  <row>
    <entry><para>Binary</para></entry>
    <entry><para>If <replaceable>expression1</replaceable>'s memory contents and size are equal to <replaceable>expression2</replaceable>'s, then returns True, otherwise False</para></entry>
  </row>
  <row>
    <entry><para>Object</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is a reference to the same object as <replaceable>expression2</replaceable>, then returns True, otherwise False</para></entry>
  </row>
  <row>
    <entry><para><command>NULL</command></para></entry>
    <entry><para>If both expressions are <command>NULL</command>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para><command>NOTHING</command></para></entry>
    <entry><para>If neither expression has a value, returns True, otherwise returns False</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Not_Equals_Operator">
  <title>Not Equals Operator (!=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if a value is not equal to another; types are converted if necessary (ex: ("1" != 1) is False).</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> != <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x != $y)
    printf("%n is not equal to %n\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Argument Processing and Conversion Priorities for !=</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>String</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is not equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Float</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is not equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is not equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Date</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is not equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>List</para></entry>
    <entry><para>If any element in the each list compared where order is relevant satisfies this operator, the operator returns True, otherwise it returns False</para></entry>
  </row>
  <row>
    <entry><para>Hash</para></entry>
    <entry><para>If the hashes have different key sets, or the values of any equal key in each hash satisfies this operator, the operator returns True, otherwise it returns False</para></entry>
  </row>
  <row>
    <entry><para>Binary</para></entry>
    <entry><para>If either <replaceable>expression1</replaceable>'s memory contents and size are not equal to <replaceable>expression2</replaceable>'s, returns True, otherwise False.</para></entry>
  </row>
  <row>
    <entry><para>Object</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is not a reference to the same object as <replaceable>expression2</replaceable>, then returns True, otherwise False.</para></entry>
  </row>
  <row>
    <entry><para><command>NULL</command></para></entry>
    <entry><para>If one expression is <command>NULL</command> and the other not, returns True, otherwise False.</para></entry>
  </row>
  <row>
    <entry><para><command>NOTHING</command></para></entry>
    <entry><para>If one of the expressions has a value, returns True, otherwise False.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Less_Than_Or_Equals_Operator">
  <title>Less Than Or Equals Operator (&lt;=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if a value is less than or equals to another value; types are converted if necessary (ex: ("1" &lt;= 2) is True).</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &lt;= <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x &lt;= $y)
    printf("%n is less than or equal to %n\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Argument Processing and Conversion Priorities for &lt;=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>Float</para></entry>
	<entry><para>If <replaceable>expression1</replaceable> is numerically less than or equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
      </row>
      <row>
	<entry><para>Integer</para></entry>
	<entry><para>If <replaceable>expression1</replaceable> is numerically less than or equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
      </row>
      <row>
	<entry><para>String</para></entry>
	<entry><para>If <replaceable>expression1</replaceable> comes before in string sort order or is the same as <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
      </row>
      <row>
	<entry><para>Date</para></entry>
	<entry><para>If <replaceable>expression1</replaceable> is before or is the same exact date and time as <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Greater_Than_Or_Equals_Operator">
  <title>Greater Than Or Equals Operator (>=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if a value is greater than or equals to another value; types are converted if necessary (ex: ("2" >= 1) is True).</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &gt;= <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x &gt;= $y)
    printf("%n is greater than or equal to %n\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Argument Processing and Conversion Priorities for &gt;=</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Float</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically greater than or equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically greater than or equal to <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>String</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> comes after in string sort order or is the same as <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>
  <row>
    <entry><para>Date</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is after or is the same exact date and time as <replaceable>expression2</replaceable>, returns True, otherwise returns False</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Comparison_Operator">
  <title>Comparison (&lt;=&gt;) Operator</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Tests if a value is less than, equal, or greater than another value; types are converted if necessary (ex: ("1" &lt;=&gt; 2) returns -1).</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &lt;=&gt; <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>switch</command> ($x &lt;=&gt; $y)
{
    <command>case</command> -1: 
        print("$x is less than $y\n");
        <command>break</command>;

    <command>case</command> 0: 
        print("$x is equal to $y\n");
        <command>break</command>;

    <command>case</command> 1: 
        print("$x is greater than $y\n");
        <command>break</command>;
}</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>



<table><title>Argument Processing and Conversion Priorities for &lt;=&gt;</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>String</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> comes after in string sort order as <replaceable>expression2</replaceable>, returns 1, otherwise if they are equal, returns 0, otherwise if <replaceable>expression1</replaceable> comes before <replaceable>expression2</replaceable>, returns -1</para></entry>
  </row>
  <row>
    <entry><para>Float</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically greater than <replaceable>expression2</replaceable>, returns 1, otherwise if they are equal returns 0, otherwise returns -1</para></entry>
  </row>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is numerically greater than <replaceable>expression2</replaceable>, returns 1, otherwise if they are equal returns 0, otherwise returns -1</para></entry>
  </row>
  <row>
    <entry><para>Date</para></entry>
    <entry><para>If <replaceable>expression1</replaceable> is after <replaceable>expression2</replaceable>, returns 1, otherwise if they are equal returns 0, otherwise returns -1</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Absolute_Equals_Operator">
  <title>Absolute Equals Operator (===)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Checks two values for equality without doing any data type conversions; if the types do not match, then the result is False.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> === <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x === $y)
    printf("%n is equal to %n and has the same data type as well\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By ===</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>All</para></entry>
    <entry><para>This operator returns True only if the types and values of both sides of the operator are exactly equal, otherwise returns False. No type conversions are done.</para></entry>
  </row>
</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Absolute_Not_Equals_Operator">
  <title>Absolute Not Equals Operator (!==)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Checks two values for inequality without doing any data type conversions.  If the data types do not match, then returns True.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<para><replaceable>expression1</replaceable> !== <replaceable>expression2</replaceable></para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x !== $y)
    printf("%n is not equal to %n and may not have the data type as well\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By !==</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>All</para></entry>
    <entry><para>This operator returns True if either the types or the values of the arguments are different, otherwise it retuns False. No type conversions are done.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Regular_Expression_Match_Operator">
  <title>Regular Expression Match Operator (=~)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Checks for a regular expression match.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression</replaceable> =~ <replaceable>regex</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($str =~ /hello/)
    printf("%s contains 'hello'\n", $str);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By =~</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>String</para></entry>
    <entry><para>This operator returns True if the regular expression in <replaceable>regex</replaceable> matches the string in <replaceable>expression</replaceable>.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Regular_Expression_No_Match_Operator">
  <title>Regular Expression No Match Operator (!~)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Checks for a regular expression non match.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression</replaceable> !~ [m]/<replaceable>regex</replaceable>/[isxm]</programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($str !~ /hello/)
    printf("%s does not contain 'hello'\n", $str);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By !~</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>String</para></entry>
	  <entry><para>This operator returns True if the regular expression in <replaceable>regex</replaceable> does not match the string in <replaceable>expression</replaceable>.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Regular_Expression_Substitution_Operator">
  <title>Regular Expression Substitution Operator</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Looks for a regular expression match in a string, and, if found, substitutes the matched string with a new string.  Subpattern backreferences are supported in the target string, $1=first subpattern, $2=second subpattern, etc...</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> =~ s/<replaceable>regex_pattern</replaceable>/<replaceable>target_string</replaceable>/[isxm]</programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$str =~ s/hello/goodbye/i;</programlisting>
	<programlisting>$str =~ s/(\w+) +(\w+)/$2, $1/;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Arguments Processed By =~ s///</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>String</para></entry>
    <entry><para>This operator substitutes text in the <replaceable>lvalue</replaceable> string if the regular expression matches.  Subpattern backreferences are supported in the target string, $1=first subpattern, $2=second subpattern, etc..</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Regular_Expression_Pattern_Extraction_Operator">
  <title>Regular Expression Pattern Extraction Operator</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Matches regular expression patterns (enclosed in parentheses) in a string and returns a list giving the text matched for each pattern.  If the regular expression does not match, then no value (NOTHING) is returned.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>string</replaceable> =~ x/<replaceable>regex_with_patterns</replaceable>/[isxm]</programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$list =~ x/(\w+):(\w+)/;</programlisting>
	<programlisting>$list =~ x/(.*)\.(.*)/;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Arguments Processed By =~ x//</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>String</para></entry>
    <entry><para>This operator extracts strings from the <replaceable>string</replaceable> based on patterns enclosed in parentheses in the regular expression.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Transliteration_Operator">
  <title>Transliteration Operator</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Makes character substitutions in an lvalue; character ranges can also be used.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> =~ tr/<replaceable>source_chars</replaceable>/<replaceable>target_chars</replaceable>/</programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$str =~ tr/a-z/A-Z/;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Arguments Processed By =~ tr//</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>String</para></entry>
    <entry><para>This operator substitutes characters in the <replaceable>lvalue</replaceable> string.  Note that if there are more characters in the source string than in the target string, then the last character in the target string will be used for any source matches where the source character position is greater than the target string.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Binary_And_Operator">
  <title>Binary And Operator (&amp;)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs a bitwise (binary) AND operation on two integers.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &amp; <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = $x &amp; $y;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Arguments Processed By &amp;</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>Gives the result of the binary (bitwise) AND operation between <replaceable>expression1</replaceable> and <replaceable>expression2</replaceable> (ex: 0xffb2 &amp; 0xa1 = 0xa1)</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Binary_Or_Operator">
  <title>Binary Or Operator (|)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs a bitwise (binary) OR operation on two integers.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> | <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = $x | $y;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table>
    <title>Arguments Processed By |</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para>Integer</para></entry>
	  <entry><para>Gives the result of the binary (bitwise) OR operation between <replaceable>expression1</replaceable> and <replaceable>expression2</replaceable> (ex: 0xb001 | 0xfea = 0xbfeb)</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Binary_Xor_Operator">
  <title>Binary Xor Operator (^)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs a bitwise (binary) XOR operation on two integers.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> ^ <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = $x ^ $y;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By ^</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>Gives the result of the binary (bitwise) EXCLUSIVE OR operation between <replaceable>expression1</replaceable> and <replaceable>expression2</replaceable> (ex: 0xaef1 &amp; 0xfb32 = 
      0x55c3)</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Logical_And_Operator">
  <title>Logical And Operator (&amp;&amp;)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Checks to see if two expressions are True.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> &amp;&amp; <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x &amp;&amp; $y)
    printf("%n and %n are both True\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By &amp;&amp;</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>Returns True if both expressions are True, False if otherwise.  Logical short-circuiting is implemented; if <replaceable>expression1</replaceable> is False, then <replaceable>expression2</replaceable> is not evaluated, and the operator returns False.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Logical_Or_Operator">
  <title>Logical Or Operator (||)</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Returns True if either of the arguments are True.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1</replaceable> || <replaceable>expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>if</command> ($x || $y)
    printf("either %n or %n or both are True\n", $x, $y);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By ||</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>Integer</para></entry>
    <entry><para>Returns True if either or both expressions evaluate to True, False if otherwise.  Logical short-circuiting is implemented; if <replaceable>expression1</replaceable> is True, then <replaceable>expression2</replaceable> is not evaluated, and the operator returns True.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Conditional_Operator">
  <title>Conditional Operator (? :)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Evaluates and returns the value of one of two expressions depending on the value of a conditional expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression ? if_true_expression : if_false_expression</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = ($z > 100 ? "Big" : "Small");</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Arguments Processed By ? :</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>All</para></entry>
    <entry><para>If <replaceable>expression</replaceable> is evaluated to be True, then the <replaceable>if_true_expression</replaceable> is evaluated and returned. Otherwise the <replaceable>if_false_expression</replaceable> is evaluated and returned.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>
<sect2 id="Comma_Operator">
  <title>Comma Operator (,)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Makes a list from more than one element.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>expression1, expression2</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = 1, 2, "three";</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By ,</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>All</para></entry>
    <entry><para>The comma operator builds lists of arguments.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>This operator does not throw any exceptions.</para>

</sect2>

<sect2 id="Unshift_Operator">
  <title>Unshift Operator (unshift)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Inserts an element into the first position of a list and moves all other elements up one position.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>unshift</command> <replaceable>lvalue, expression</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>unshift</command> $list, "one";</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By unshift</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>All</para></entry>
    <entry><para>Inserts the value of <replaceable>expression</replaceable> as the first element in the list given by <replaceable>lvalue</replaceable>.  All other elements in the list are moved forward.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

</sect2>

<sect2 id="Push_Operator">
  <title>Push Operator (push)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Adds one element to the end of a list.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>push</command> <replaceable>lvalue, expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>push</command> $list, "last";</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

<table><title>Arguments Processed By push</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Argument</para></entry>
    <entry><para>Processing</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>All</para></entry>
    <entry><para>Appends the value of the expression as the last element in the list given by <replaceable>lvalue</replaceable>.  If <replaceable>expression</replaceable> evaluates to a list, this list will be appended as the last element of <replaceable>lvalue</replaceable>.  To concatenate lists, use the <link linkend='Plus_Operator'>Plus Operator</link>.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

</sect2>

<sect2 id="Splice_Operator">
  <title>Splice Operator (splice)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Removes and optionally inserts elements in lists and strings.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>splice</command> <replaceable>lvalue, offset_expression, [length_expression, [substitution_expression]]</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>splice</command> $list, 2, 2;</programlisting>
	<programlisting><command>splice</command> $string, 2, 2, "-text-";</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>


  <para>Works on either strings or lists in a similar way; removes elements from a list or characters from a string and optionally inserts new ones.  If no <replaceable>length_expression</replaceable> is given, <command>splice</command> removes all elements/characters from the list or string starting at <replaceable>offset_expression</replaceable>) (list and string offsets begin at 0).  Otherwise, a number of elements/characters equal to <replaceable>length_expression</replaceable> is removed (or up to the end of the list/string if applicable).  If <replaceable>substitution_expression</replaceable> is present, then the removed elements/characters are substituted with the elements/string given by this expression.</para>

  <para>Note that string splice takes character offsets, which may not be the same as byte offsets for multi-byte character set encodings, such as UTF-8</para>
  <table>
    <title>Arguments Processed By splice</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Argument</para></entry>
	  <entry><para>Processing</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><replaceable>lvalue</replaceable></para></entry>
	  <entry><para>If the lvalue is a list, list elements are processed, otherwise, if it is a string, characters in the string are processed.  For any other data type, no action is taken.</para></entry>
	</row>
	<row>
	  <entry><para><replaceable>offset_expression</replaceable></para></entry>
	  <entry><para>The start element/character position for removing elements/characters from the list or string.</para></entry>
	</row>
	<row>
	  <entry><para><replaceable>length_expression</replaceable></para></entry>
	  <entry><para>The number of elements/characters to remove.  If this expression is not present, then all elements/characters from the offset to the end of the list/string are removed.  If this expression is present and evaluates to 0, no characters are removed.</para></entry>
	</row>
	<row>
	  <entry><para><replaceable>substitution_expression</replaceable></para></entry>
	  <entry><para>For list splice, an optional element or list to substitute for the removed elements.  For string splice, an optional string to substitute for the removed characters.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
</sect2>

<sect2 id="Assignment_Operator">
  <title>Assignment Operator (=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Assigns a value to an lvalue.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> = <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = 1;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Types Processed =</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>    
    <tbody>
      <row>
	<entry><para>All</para></entry>
	<entry><para>Assigns the value of <replaceable>expression</replaceable> to <replaceable>lvalue</replaceable>.</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>  
</sect2>

<sect2 id="Plus_Equals_Operator">
  <title>Plus Equals Operator (+=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Increments and concatentates an lvalue with the value of an expression depending on the data type of the lvalue.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> += <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a += 10;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Arguments Processed By +=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para><replaceable>lvalue</replaceable>: List</para></entry>
	<entry><para>the expression will be evaluated and concatenated to the lvalue.  If expression is a list, the lists will be concatenated, to ensure adding a single element to a list, use the push operator (see <link linkend='Push_Operator'>Push Operator</link>).</para></entry>
      </row>
      <row>
	<entry><para><replaceable>lvalue</replaceable>: Hash</para></entry>
	<entry><para>the expression will be evaluated, and, if it is a hash or object, then it's members will be added to the lvalue, any duplicate elements in the lvalue will be overridden by elements in the expression.</para></entry>
      </row>
      <row>
	<entry><para><replaceable>lvalue</replaceable>: String</para></entry>
	<entry><para>the expression will be evaluated and converted to a string if necessary and concatenated to the lvalue.</para></entry>
      </row>
      <row>
	<entry><para><replaceable>lvalue</replaceable>: Float</para></entry>
	<entry><para>the expression will be evaluated and converted to a float if necessary and added to the lvalue.</para></entry>
      </row>
      <row>
	<entry><para><replaceable>lvalue</replaceable>: all others</para></entry>
	<entry><para>the lvalue's type will be converted to an integer, and the expression will be evaluated and converted to an integer if necessary, and then the result will be added to the lvalue.</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>
</sect2>

<sect2 id="Minus_Equals_Operator">
  <title>Minus Equals Operator (-=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>For a float or integer argument, decrements the value of an lvalue by the value of an expression.  However if the lvalue is a hash and the expression is a string, removes the key represented by the string from the hash.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> -= <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>

    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a -= 10;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  <table><title>Arguments Processed By -=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para><replaceable>lvalue</replaceable>: Float</para></entry>
	<entry><para>the expression will be evaluated and converted to a float if necessary and subtracted from the lvalue</para></entry>
      </row>
      <row>
	<entry><para><replaceable>lvalue</replaceable>: Hash, <replaceable>expression</replaceable>: String</para></entry>
	<entry><para>the hash key represented by <replaceable>expression</replaceable> will be removed from the lvalue</para></entry>
      </row>
      <row>
	<entry><para><replaceable>lvalue</replaceable>: all others</para></entry>
	<entry><para>the lvalue's type will be converted to an integer, and the expression will be evaluated and converted to an integer if necessary, and then the result will be subtracted from the lvalue</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>
</sect2>

<sect2 id="And_Equals_Operator">
  <title>And Equals Operator (&amp;=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs a bitwise (binary) AND operation on an lvalue using the value of an expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> &amp;= <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a &amp;= 0xfe;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

  <table><title>Arguments Processed By &amp;=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>All</para></entry>
	<entry><para>the lvalue's type will be converted to an integer if necessary, and the expression will be evaluated and converted to an integer as well if necessary, and then the result will be binary and'ed to the lvalue</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>
</sect2>

<sect2 id="Or_Equals_Operator">
  <title>Or Equals Operator (|=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs a bitwise (binary) OR operation on an lvalue using the value of an expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> |= <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a |= 0xba;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  <table><title>Arguments Processed By |=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>All</para></entry>
	<entry><para>the lvalue's type will be converted to an integer if necessary, and the expression will be evaluated and converted to an integer as well if necessary, and then the result will be binary or'ed to the lvalue</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>
</sect2>

<sect2 id="Modula_Equals_Operator">
  <title>Modula Equals Operator (%=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs a modula calculation on an lvalue using the value of an expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> %= <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a %= 100;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  <table><title>Arguments Processed By %=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>All</para></entry>
	<entry><para>the lvalue's type will be converted to an integer if necessary, and the expression will be evaluated and converted to an integer as well if necessary, and then the result will be used to divide the lvalue's value and the remainder will be saved to the lvalue</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>
</sect2>

<sect2 id="Multiply_Equals_Operator">
  <title>Multiply Equals Operator (*=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs a multiplication operation on an lvalue using the value of an expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> *= <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a *= 10;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  <table><title>Arguments Processed By *=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>All</para></entry>
	<entry><para>If either side of the operator is a float, the result will be a float as well.  Otherwise the result is an integer value.  The expression will be evaluated and multiplied by the lvalue, and the result will be saved to the lvalue.</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>
</sect2>

<sect2 id="Divide_Equals_Operator">
  <title>Divide Equals Operator (/=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs a division operation on an lvalue using the value of an expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> /= <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a /= 10;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  <table><title>Arguments Processed By *=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>All</para></entry>
	<entry><para>If either side of the operator is a float, the result will be a float as well.  Otherwise the result is an integer value.  The expression will be evaluated and used to divide the lvalue, and the result will be saved to the lvalue.</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>

  <table>
    <title>Exceptions Thrown by /*</title>
    <tgroup cols='2' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>err</para></entry>
	  <entry><para>desc</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><code>DIVISION-BY-ZERO</code></para></entry>
	  <entry><para>If the divisor expression evaluates to zero, this exception is thrown.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>
</sect2>

<sect2 id="Xor_Equals_Operator">
  <title>Xor Equals Operator (^=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs an exclusive-or operation on an lvalue using the value of an expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> ^= <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a ^= 0xf9034ba7;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  <table><title>Arguments Processed By ^=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>All</para></entry>
	<entry><para>Values are converted to integers if necessary.  The expression will be evaluated and exclusive-or'ed with the lvalue, and the result will be saved to the lvalue.</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>
</sect2>

<sect2 id="Shift_Left_Equals_Operator">
  <title>Shift Left Equals Operator (&lt;&lt;=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs a shift-left operation on an lvalue using the value of an expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> &lt;&lt;= <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a &lt;&lt;= 3;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  <table><title>Arguments Processed By &lt;&lt;=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>All</para></entry>
	<entry><para>Values are converted to integers if necessary.  The expression will be evaluated and this value will determine how many bits the lvalue will be shifted left.  The result will be saved to the lvalue.</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>
</sect2>

<sect2 id="Shift_Right_Equals_Operator">
  <title>Shift Right Equals Operator (&gt;&gt;=)</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Performs a shift-right operation on an lvalue using the value of an expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><replaceable>lvalue</replaceable> &gt;&gt;= <replaceable>expression</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a &gt;&gt;= 3;</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  <table><title>Arguments Processed By &gt;&gt;=</title>
  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
    <thead>
      <row>
	<entry><para>Argument</para></entry>
	<entry><para>Processing</para></entry>
      </row>
    </thead>
    <tbody>
      <row>
	<entry><para>All</para></entry>
	<entry><para>Values are converted to integers if necessary.  The expression will be evaluated and this value will determine how many bits the lvalue will be shifted right.  The result will be saved to the lvalue.</para></entry>
      </row>
    </tbody>
  </tgroup>
  </table>
</sect2>

</sect1>

  <sect1 id="Regular_Expressions">
    <title>Regular Expressions in Qore</title>

    <para>Regular expression functionality in Qore is provided by <ulink url="http://www.pcre.org">PCRE: Perl-Compatible Regular Expression library</ulink>.</para>

    <para>Using this library, Qore implements regular expression pattern matching using the same syntax and semantics as Perl 5.</para>

    <para>The following is a list of operators based on regular expressions (or similar to regular expressions in the case of the <link linkend='Transliteration_Operator'>transliteration operator</link>).</para>

    <table id="Regular_Expression_Operators">
      <title>Regular Expression Operators</title>
      <tgroup cols='2' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Operator</para></entry>
	    <entry><para>Description</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><link linkend='Regular_Expression_Match_Operator'>regular expression match operator</link></para></entry>
	    <entry><para>Returns True if the regular expression matches a string.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend='Regular_Expression_No_Match_Operator'>regular expression no match operator</link></para></entry>
	    <entry><para>Returns True if the regular expression does not match a string.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend='Regular_Expression_Substitution_Operator'>regular expression substitution operator</link></para></entry>
	    <entry><para>Substitutes text in a string based on matching a regular expression.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend='Regular_Expression_Pattern_Extraction_Operator'>regular expression pattern extraction operator</link></para></entry>
	    <entry><para>Returns a list of substrings in a string based on matching patterns defined by a regular expression.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend='Transliteration_Operator'>transliteration operator</link></para></entry>
	    <entry><para>Not a regular expression operator; transliterates one or more characters to other characters in a string.</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
    <para>See the table below for valid regular expression options.</para>

    <table id="Regular_Expression_Options">
      <title>Regular Expression Options</title>
      <tgroup cols='2' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Option</para></entry>
	    <entry><para>Description</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para>/i</para></entry>
	    <entry><para>Ignores case when matching</para></entry>
	  </row>
	  <row>
	    <entry><para>/m</para></entry>
	    <entry><para>makes start-of-line (^) or end-of-line ($) match after or before any newline in the subject string</para></entry>
	  </row>
	  <row>
	    <entry><para>/s</para></entry>
	    <entry><para>makes a dot (.) match a newline character</para></entry>
	  </row>
	  <row>
	    <entry><para>/x</para></entry>
	    <entry><para>ignores whitespace characters and enables comments prefixed by #</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <para>The following is a list of functions providing regular expression functionality where the pattern may be given at run-time:</para>

    <table id="Regular_Expression_Functions">
      <title>Regular Expression Functions</title>
      <tgroup cols='2' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Function</para></entry>
	    <entry><para>Description</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><link linkend='regex'>regex()</link></para></entry>
	    <entry><para>Returns True if the regular expression matches a string.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend='regex_subst'>regex_subst()</link></para></entry>
	    <entry><para>Substitutes a pattern in a string based on regular expressions and returns the new string.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend='regex_extract'>regex_extract()</link></para></entry>
	    <entry><para>Returns a list of substrings in a string based on matching patterns defined by a regular expression.</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
  </sect1>

  <sect1 id="Date_Time_Arithmetic">
    <title>Date/Time Arithmetic</title>

    <para>Date/time arithmetic is relatively straightforward and should normally produce the expected results.  However with leap years and months with different lengths, the situation can be confusing; this section will clarify how Qore does date arithmetic considering these special cases.</para>

    <sect2 id="Addding_And_Subtracting_Years_And_Monts">
      <title>Adding and Subtracting Years and Months</title>

      <para>Adding or subtracting years and months (ex: $date += 2Y + 3M) will give you the same day on the desired month in the desired year. If the target month has fewer days than the source month, then you will get the last day of the month in that year. For example:</para>

      <programlisting>2004-02-29 - 1Y = 2003-02-28</programlisting>
    </sect2>

    <sect2 id="Adding_And_Subtracting_Days">
      <title>Adding and Subtracting Days</title>
      <para>Adding or subtracting days means adding or subtracting 24h periods; i.e. you will get the same time in the result of subtracting days, for example:</para>

      <programlisting>2004-02-29T10:15:00 - 10D = 2004-02-19T10:15:00</programlisting>
    </sect2>
    
    <sect2 id="Date_Differences">
      <title>Finding the Difference Between Two Dates</title>
      <para>Subtracting one absolulte date from another will result in a relative date, normalized to the day value (that is, milliseconds over 999 are converted to seconds, seconds over 59 to minutes, minutes over 59 to hours, hours over 23 to days; months and years will not appear in the result as they do not indicate a fixed period of time but rather can vary in length depending on the absolute date/time starting point.  For example:</para>
	<programlisting>$diff = 2007-02-29T10:15:03.255 - 2004-02-29T10:14:02.100;
printf("%n\n", $diff)</programlisting>
      <para>Results in:</para>
	<programlisting>&lt;time: 1096 days 1 minute 1 second 155 milliseconds&gt;</programlisting>

      <para>To find the difference in seconds between two dates, convert each date value to an integer and subtract as follows:</para>
	<programlisting>int(2004-02-29) - int(2004-02-28) = 86400</programlisting>
    </sect2>
    
    <sect2 id="Timezones_And_Daylight_Savings_Time">
      <title>Timezones and Daylight Savings Time </title>
      <para>Qore has no time zone support and therefore all date/time values are timezone agnostic.  In particular, Daylight Savings Time is not taken into effect with date arithmetic.  For this reason a day in Qore is always exactly 24 hours long.</para>
    </sect2>

    <sect2 id="Leap_Years_and_the_Gregorian_Calendar">
      <title>Leap Years and the Gregorian Calendar</title>
      <para>Qore is capable of representing and performing calculations on dates before the adoption of the Gregorian calendar (proposed in 1582 and adopted at various times in Europe after this point).  However all calculations are made as if the Gregorian calendar were always in effect (Qore implements a proleptic Gregorian calendar).</para>
    </sect2>
  </sect1>
  
  <sect1 id="Statements">
    <title>Statements</title>

    <para>Non-block statements in Qore are always terminated by a semi-colon ";" as in Perl, C, or Java. Statements can be grouped into blocks, which are delimited by curly brackets "{" and "}" containing zero or more semi-colon delimited statements, as in C or Java. Like C, C++, and Java, but unlike perl, any Qore statement taking a statement modifier will accept a single statement or a statement block.</para>

<para>A statement can be any of the following (note that statements are also recursively defined):</para>

<table><title>Qore Statements</title>
<tgroup cols='3' align='left' colsep='1' rowsep='1'>

  <thead>
  <row>
    <entry><para>Type</para></entry>
    <entry><para>Examples</para></entry>
    <entry><para>Reference</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para>An expression that changes an lvalue</para></entry>
    <entry><programlisting>$var = 1;
$var += 5;
$var[1].count++;
<command>shift</command> $var.key[$i];</programlisting></entry>
    <entry><para><link linkend="Expressions">Expressions</link></para></entry>
  </row>
  <row>
    <entry><para>An expression with the <command>new</command> operator</para></entry>
    <entry><programlisting><command>new</command> ObjectClass(1, 2, 3);</programlisting></entry>
    <entry><para><link linkend='New_Object_Operator'>class instantiation/new object operator</link></para></entry>
  </row>
  <row>
    <entry><para>An expression with the <command>background</command> operator</para></entry>
    <entry><programlisting><command>background</command> function();</programlisting></entry>
    <entry><para><link linkend='Background_Operator'>background/thread creation operator</link></para></entry>
  </row>
  <row>
    <entry><para>A call reference call</para></entry>
    <entry><programlisting>$call_reference($arg1, $arg2);</programlisting></entry>
    <entry><para><link linkend='call_references'>call references</link></para></entry>
  </row>
  <row>
    <entry><para>A method call</para></entry>
    <entry><programlisting>$object.method(1, 2, 3);</programlisting></entry>
    <entry><para><link linkend="Classes">Classes</link></para></entry>
  </row>
  <row>
    <entry><para>An <command>if</command> statement </para></entry>
    <entry><programlisting><command>if</command> ($var == 3) <replaceable>statement</replaceable></programlisting></entry>
    <entry><para><link linkend='if_and_else_Statements'>if and else</link> statements</para></entry>
  </row>
  <row>
    <entry><para>An "<command>if ... else</command>" statement</para></entry>
    <entry><programlisting><command>if</command> ($var == 3)
    <replaceable>statement</replaceable>
<command>else</command>
    <replaceable>statement</replaceable></programlisting></entry>
    <entry><para><link linkend='if_and_else_Statements'>if and else</link> statements</para></entry>
  </row>
  <row>
    <entry><para>A <command>while</command> statement</para></entry>
    <entry><programlisting><command>while</command> ($var &lt; 10) 
    <replaceable>statement</replaceable></programlisting></entry>
    <entry><para><link linkend='while_Statements'>while</link> statements</para></entry>
  </row>
  <row>
    <entry><para>A <command>do while</command> statement</para></entry>
    <entry><programlisting><command>do</command> <replaceable>statement</replaceable> <command>while</command> 
    (<replaceable>expression</replaceable>);</programlisting></entry>
    <entry><para><link linkend='do_while_Statements'>do while</link> statements</para></entry>
  </row>
  <row>
    <entry><para>A <command>for</command> statement</para></entry>
    <entry><programlisting><command>for</command> (<replaceable>expression1</replaceable>; <replaceable>expression2</replaceable>; 
    <replaceable>expression3</replaceable>) <replaceable>statement</replaceable></programlisting></entry>
    <entry><para><link linkend='for_Statements'>for</link> statements</para></entry>
  </row>
  <row>
    <entry><para>A <command>foreach</command> statement</para></entry>
    <entry><programlisting><command>foreach</command> <replaceable>$variable</replaceable> <command>in</command> 
    (<replaceable>expression</replaceable>) <replaceable>statement</replaceable></programlisting></entry>
    <entry><para><link linkend='foreach_Statements'>foreach</link> statements</para></entry>
  </row>
  <row>
    <entry><para>A <command>switch</command> statement</para></entry>
    <entry><programlisting><command>switch</command> (<replaceable>expression</replaceable>) 
{
    <command>case</command> <replaceable>case_expression</replaceable>: 
        <replaceable>statement(s)</replaceable> 
    [ <command>default</command> : 
        <replaceable>statement(s)</replaceable> ]
}</programlisting>
    </entry>
    <entry><para><link linkend='switch_Statements'>switch</link> statements</para></entry>
  </row>
  <row>
    <entry><para>A <command>return</command> statement</para></entry>
    <entry><programlisting><command>return</command> <replaceable>expression</replaceable>;</programlisting></entry>
    <entry><para><link linkend='return_Statements'>return</link> statements</para></entry>
  </row>
  <row>
    <entry><para>A local variable declaration</para></entry>
    <entry>
	<programlisting><command>my</command> $var;
<command>my</command> ($a, $b, $c);</programlisting>
    </entry>
    <entry><para><link linkend='Variables'>Variables</link></para></entry>
  </row>
  <row>
    <entry><para>A global variable declaration</para></entry>
    <entry>
      <programlisting><command>our</command> $var;
<command>our</command> ($a, $b, $c);</programlisting>
    </entry>
    <entry><para><link linkend='Variables'>Variables</link></para></entry>
  </row>
  <row>
    <entry><para>A function call</para></entry>
    <entry><programlisting>calculate($this, $that, $the_other);</programlisting></entry>
    <entry><para><link linkend="Function_Library">Function Library</link></para></entry>
  </row>
  <row>
    <entry><para>A <command>continue</command> statement</para></entry>
    <entry><programlisting><command>continue</command>;</programlisting></entry>
    <entry><para><link linkend='continue_Statements'>continue</link> statements</para></entry>
  </row>
  <row>
    <entry><para>A <command>break</command> statement</para></entry>
    <entry><programlisting><command>break</command>;</programlisting></entry>
    <entry><para><link linkend='break_Statements'>break</link> statements</para></entry>
  </row>
  <row>
    <entry><para>A statement block</para></entry>
    <entry><programlisting>{ <replaceable>statement</replaceable> }</programlisting></entry>
    <entry><para>one or more statements enclosed in curly brackets.</para></entry>
  </row>
  <row>
    <entry><para>A <command>delete</command> statement</para></entry>
    <entry><programlisting><command>delete</command> <replaceable>$lvalue</replaceable>;</programlisting></entry>
    <entry><para><link linkend='delete_Statements'>delete</link> statements</para></entry>
  </row>
  <row>
    <entry><para>A <command>throw</command> statement</para></entry>
    <entry><programlisting><command>throw</command> <replaceable>expression</replaceable>;</programlisting></entry>
    <entry><para><link linkend='throw_Statements'>throw</link> statements</para></entry>
  </row>
  <row>
    <entry><para><command>try</command> and <command>catch</command> statements</para></entry>
    <entry><programlisting><command>try</command>
    <replaceable>statement</replaceable>
<command>catch</command> (<replaceable>$vars ...</replaceable>)
    <replaceable>statement</replaceable></programlisting>
      </entry>
    <entry><para><link linkend='try_and_catch_Statements'>try and catch</link> statements</para></entry>
  </row>
  <row>
    <entry><para>A <command>rethrow</command> statement</para></entry>
    <entry><programlisting><command>rethrow</command>;</programlisting></entry>
    <entry><para><link linkend='rethrow_Statements'>rethrow</link> statements</para></entry>
  </row>
  <row>
    <entry><para>A <command>thread_exit</command> statement</para></entry>
    <entry><programlisting><command>thread_exit</command>;</programlisting></entry>
    <entry><para><link linkend='thread_exit_Statements'>thread_exit</link> statements</para></entry>
  </row>
  <row>
    <entry><para>A <command>context</command> statement</para></entry>
    <entry>
      <programlisting><command>context</command> <replaceable>[name] (expression)</replaceable> 
    <replaceable>statement</replaceable></programlisting>
    </entry>
    <entry><para><link linkend='context_Statements'>context</link> statements</para></entry>
  </row>
  <row>
    <entry><para>A <command>summarize</command> statement</para></entry>
    <entry>
      <programlisting><command>summarize</command> <replaceable>expression</replaceable> by ( <replaceable>expression</replaceable> )
    <replaceable>statement</replaceable></programlisting>
    </entry>
    <entry><para><link linkend='summarize_Statements'>summarize</link> statements</para></entry>
  </row>
  <row>
    <entry><para>A <command>subcontext</command> statement</para></entry>
    <entry><programlisting><command>subcontext</command>
    <replaceable>statement</replaceable></programlisting></entry>
    <entry><para><link linkend='subcontext_Statements'>subcontext</link> statements</para></entry>
  </row>
  <row>
    <entry><para>An <command>on_exit</command> statement</para></entry>
    <entry><programlisting><command>on_exit</command>
    <replaceable>statement</replaceable></programlisting></entry>
    <entry><para><link linkend='on_exit_Statements'>on_exit</link> statements</para></entry>
  </row>
  <row>
    <entry><para>An <command>on_success</command> statement</para></entry>
    <entry><programlisting><command>on_success</command>
    <replaceable>statement</replaceable></programlisting></entry>
    <entry><para><link linkend='on_success_Statements'>on_success</link> statements</para></entry>
  </row>
  <row>
    <entry><para>An <command>on_error</command> statement</para></entry>
    <entry><programlisting><command>on_error</command>
    <replaceable>statement</replaceable></programlisting></entry>
    <entry><para><link linkend='on_error_Statements'>on_error</link> statements</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<sect2 id="if_and_else_Statements">
  <title>if and else Statements</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>The <command>if</command> statement allows for conditional logic in a Qore program's flow; the syntax is similar to that of C, C++, or Java.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>if</command> ( <replaceable>expression</replaceable> ) 
    <replaceable>statement</replaceable>
[<command>else</command>
    <replaceable>statement</replaceable>]</programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>Qore if statements work like if statements in C or Java.  If the result of evaluating the expression converted to a Boolean value is True, then the first statement (which can also be a block) is executed.  If the result is False, and there is an else keyword after the first statement, the following statement is executed.</para>
     </listitem>
    </varlistentry>
  </variablelist>
  <note>
    <para>Any expression that evaluates to a non-zero integer value will be converted to a Boolean True.  Any expression that evaluates to zero value is interpreted as False.  This is more like C and Java's behavior and not like Perl's (where any non-null string except "0" is True).</para>
  </note>

</sect2>
<sect2 id="for_Statements">
  <title>for Statements</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>The Qore <command>for</command> statement is most similar to the <command>for</command> statement in C and Java, or the non array iterator <command>for</command> statement in Perl.  This statement is ideal for loops that should execute a given number of times, then complete.  Each of the three expressions in the <command>for</command> statement is optional and may be omitted.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>for</command> ( <replaceable>[initial_expression]</replaceable> ; <replaceable>[test_expression]</replaceable> ; <replaceable>[iterator_expression]</replaceable> )
      <replaceable>statement</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para><replaceable>[initial_expression]</replaceable></para>
	<para>The <replaceable>initial_expression</replaceable> is executed only once at the start of each <command>for</command> loop. It is typically used to initialize a loop variable.</para>
	<para><replaceable>[test_expression]</replaceable></para>
	<para>The <replaceable>test_expression</replaceable> is executed at the start of each <command>for</command> loop iteration. If this expression evaluates to Boolean False, the loop will terminate.</para>
	<para><replaceable>[iterator_expression]</replaceable></para>
	<para>The <replaceable>iterator_expression</replaceable> is executed at the end of each <command>for</command> loop iteration. It is typically used to increment or decrement a loop variable that will be used in the <replaceable>test_expression</replaceable>.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<para>Here is an example of a <command>for</command> loop using a local variable:</para>
	<programlisting><command>for</command> (<command>my</command> $i = 0; $i &lt; 10; $i++)
    print("%d\n", $i);</programlisting>
     </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="foreach_Statements">
  <title>foreach Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>The Qore <command>foreach</command> statement is most similar to the <command>for</command> or <command>foreach</command> array iterator statement in Perl.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>foreach</command> [<command>my</command>] <replaceable>$variable</replaceable> <command>in</command> (<replaceable>expression</replaceable>)
    <replaceable>statement</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>If the <replaceable>expression</replaceable> does not evaluate to a list, then the variable will be assigned the value of the expression evaluation and the statement will only execute one time.  Otherwise the variable will be assigned to each value of the list and the statement will be called once for each value.</para>
     </listitem>
    </varlistentry>
  </variablelist>

  <note><para>Note that if a reference (<replaceable>\$lvalue_expression</replaceable>) is used as the list expression, any changes made to the <command>foreach</command> iterator variable will be written back to the list.</para></note>

</sect2>
<sect2 id="switch_Statements">
  <title>switch Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>The Qore <command>switch</command> statement is similar to the <command>switch</command> statement in C and C++, except that the <command>case</command> values can be any expression that does not need run-time evaluation and can also be expressions with simple relational operators or regular expressions using the switch value as an implied operand.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>switch</command> (<replaceable>expression</replaceable>) 
{ 
    <command>case</command> <replaceable>case_expression</replaceable>: 
        <replaceable>statement(s)</replaceable> 
    ...
    [ <command>default</command> : 
        <replaceable>statement(s)</replaceable> ]
}</programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>switch ($val)
{
    case &lt; -1: 
        printf("less than -1\n");
	break;
    case "string":
        printf("string\n");
	break;
    case &gt; 2007-01-22T15:00:00: 
        printf("greater than 2007-01-22 15:00:00\n");
	break;
    case /abc/:
        printf("string with 'abc' somewhere inside\n");
        break;
    default:
        printf("default\n");
	break;
}</programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>The first expression is evaluated and then compared to the value of each <command>case</command> expression in declaration order until one of the <command>case</command> expressions matches or is evaluated to True.  In this case all code up to a <command>break</command> statement is executed, at which time execution flow exits the <command>switch</command> statement.  Unless relational operators are used, the comparisons are "hard" comparisons; no type conversions are done, so in order for a match to be made, both the value and types of the expressions must match exactly.  When relational operators are used, the operators are executed exactly as they are in the rest of qore, so type conversions may be performed if nesessary.</para>
	<para>If no match is found and a <command>default</command> label has been given, then any statements after the <command>default</command> label will be executed.  If a match is made, then the statements following that <command>case</command> label are executed.</para>
	<para>To break out of the switch statement, use the <command>break</command> statement.</para>

	<table>
	  <title>Valid Case Expression Operators</title>
	  <tgroup cols='2' align='left' colsep='1' rowsep='1'>
	    <thead>
	      <row>
		<entry><para>Operator</para></entry>
		<entry><para>Description</para></entry>
	      </row>
	    </thead>
	    <tbody>
	      <row>
		<entry><para>&gt;</para></entry>
		<entry><para><link linkend='Greater_Than_Operator'>logical greater than operator</link></para></entry>
	      </row>
	      <row>
		<entry><para>&gt;=</para></entry>
		<entry><para><link linkend='Greater_Than_Or_Equals_Operator'>logical greater than or equals operator</link></para></entry>
	      </row>
	      <row>
		<entry><para>&lt;</para></entry>
		<entry><para><link linkend='Less_Than_Operator'>logical less than operator</link></para></entry>
	      </row>
	      <row>
		<entry><para>&lt;=</para></entry>
		<entry><para><link linkend='Less_Than_Or_Equals_Operator'>logical less than or equals operator</link></para></entry>
	      </row>
	      <row>
		<entry><para>~=</para></entry>
		<entry><para><link linkend='Regular_Expression_Match_Operator'>regular expression match operator</link></para></entry>
	      </row>
	      <row>
		<entry><para>!~</para></entry>
		<entry><para><link linkend='Regular_Expression_No_Match_Operator'>regular expression no match operator</link></para></entry>
	      </row>
	    </tbody>
	  </tgroup>
	</table>

     </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="while_Statements">
  <title>while Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para><command>while</command> statements in Qore are similar to <command>while</command> statements in Perl, C and Java. They are used to loop while a given condition is True.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>while</command> ( <replaceable>expression</replaceable> )
    <replaceable>statement</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>First the <replaceable>expression</replaceable> will be evaluated; if it evaluates to True, then <replaceable>statement</replaceable> will be executed. If it evaluates to False, the loop terminates.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting>$a = 1;
<command>while</command> ($a &lt; 10)
    $a++;</programlisting>
     </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="do_while_Statements">
  <title>do while Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para><command>do</command> <command>while</command> statements in Qore are similar to <command>do</command> <command>while</command> statements in C.  They are used to guarantee at least one iteration and loop until a given expression evaluates to False.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>do</command>
    <replaceable>statement</replaceable>
<command>while</command> ( <replaceable>expression</replaceable> );</programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>First, <replaceable>statement</replaceable> will be executed, then <replaceable>expression</replaceable> will be evaluated; if it evaluates to True, then the loop iterates again. If it evaluates to False, the loop terminates. The difference between <command>do</command> <command>while</command> statements and <command>while</command> statements is that the <command>do</command> <command>while</command> statement evaluates its loop expression at the end of the loop, and therefore guarantees at least one iteration of the loop.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
<programlisting>$a = 1;
<command>do</command> 
    $a++;
<command>while</command> ($a &lt; 10);</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="continue_Statements">
<title>continue Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Skips the rest of a loop and jumps right to the evaluation of the iteration expression.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>continue</command>;</programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>The <command>continue</command> statement affects loop processing; that is; it has an affect on <command>for</command>, <command>foreach</command>, <command>while</command>, <command>do</command> <command>while</command>, <command>context</command>, <command>summarize</command>, and <command>subcontext</command> loop processing.  When this statement is encountered while executing a loop, execution control jumps immediately to the evaluation of the iteration expression, skipping any other statements that might otherwise be executed.</para>
      </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="break_Statements">
  <title>break Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Exits immediately from a loop statement or <command>switch</command> block.</para>
     </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>break</command>;</programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>The <command>break</command> statement affects loop processing; that is; it has an affect on <command>for</command>, <command>while</command>, <command>do</command> <command>while</command>, <command>context</command>, <command>summarize</command>, and <command>subcontext</command> loop processing. When this statement is encountered while executing a loop, the loop is immediately exited, and execution control passes to the next statement outside the loop.</para>
      </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="delete_Statements">
  <title>delete Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>In order to delete the contents of an lvalue, the <command>delete</command> statement can be used.  For objects, this will also run the destructor method (if defined for the class).</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>delete</command> <replaceable>$lvalue;</replaceable></programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="throw_Statements">
  <title>throw Statements</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>In order to throw an exception explicitly, the <command>throw</command> statement must be used.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>throw</command> <replaceable>expression;</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>The expression will be passed to the <command>catch</command> block of a <command>try</command>/<command>catch</command> statement, if the <command>throw</command> is executed in a <command>try</command> block.  Otherwise the default system exception handler will be run and the currently running thread will terminate.</para>
	<para>Qore convention dictates that a direct list is thrown with at least two string elements, the error code and a description.  All system exceptions have this format.  See <link linkend="try_and_catch_Statements">try and catch</link> statements for information on how to handle exceptions, and see <link linkend="Exception_Handling">Exception Handling</link> for information about how <command>throw</command> arguments are mapped to the exception hash.</para>
      </listitem>
    </varlistentry>
  </variablelist>

</sect2>
<sect2 id="try_and_catch_Statements">
  <title>try and catch Statements</title>
  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Some error conditions can only be detected and handled using exception handlers. To catch exceptions, <command>try</command> and <command>catch</command> statements can to be used.  When an exception occurs while executing the <command>try</command> block, execution control will immediately be passed to the <command>catch</command> block, which can capture information about the exception.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<para>
	  <programlisting><command>try</command>
    <replaceable>statement</replaceable>
<command>catch</command> ([<replaceable>$exception_hash_variable</replaceable>])
    <replaceable>statement</replaceable></programlisting>
	</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>A single variable can be specified in the <command>catch</command> block to be instantiated with the exception hash, giving information about the exception that has occurred.  For detailed information about the exception hash, see <link linkend="Exception_Handling">Exception Handling</link>.</para>

      <para>If no variable is given in the <command>catch</command> declaration, it will not be possible to access any information about the exception in the <command>catch</command> block.  However, the <link linkend="rethrow_Statements"><command>rethrow</command></link> statement can be used to rethrow exceptions at any time in a catch block.</para></listitem>
    </varlistentry>
  </variablelist>
</sect2>

    <sect2 id="rethrow_Statements">
      <title>rethrow Statements</title>

      <variablelist>
	<varlistentry>
	  <term>Synopsis</term>
	  <listitem>
	    <para>A <command>rethrow</command> statement can be used to rethrow an exception in a <command>catch</command> block.  In this case a entry tagged as a rethrow entry will be placed on the exception call stack.  This statement can be used to maintain coherent call stacks even when exceptions are handled by more than one catch block (for detailed information about the exception hash and the format of call stacks, see <link linkend="Exception_Handling">Exception Handling</link>).</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Syntax</term>
	  <listitem>
	    <programlisting><command>rethrow</command>;</programlisting>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Description</term>
	  <listitem>
	    <para>The rethrown exception will be either passed to the next higher-level catch block, or to the system default exception handler, as with a <command>throw</command> statement.  Note that it is an error to call <command>rethrow</command> outside of a <command>catch</command> block.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="thread_exit_Statements">
      <title>thread_exit Statements</title>

      <variablelist>
	<varlistentry>
	  <term>Synopsis</term>
	  <listitem>
	    <para><command>thread_exit</command> statements cause the current thread to exit immediately.  Use this statement instead of the <link linkend="exit">exit()</link> function when only the current thread should exit.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Syntax</term>
	  <listitem>
	    <programlisting><command>thread_exit</command>;</programlisting>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Description</term>
	  <listitem>
	    <para>This statement will cause the current thread to stop executing immediately.</para>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

<sect2 id="context_Statements">
  <title>context Statements</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>To easily iterate through multiple rows in a hash of arrays (such as a query result set returned by the <link linkend="Qore::SQL::Datasource::select">Datasource::select()</link> method), the <command>context</command> statement can be used. Column names can be referred to directly in expressions in the scope of the <command>context</command> statement by preceding the name with a '%" character.</para>
    </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<para>
	  <programlisting><command>context</command> [name] ( <replaceable>data_expression )</replaceable> 
        [ <command>where</command> ( <replaceable>expression</replaceable> ) ] 
        [ <command>sortBy</command> ( <replaceable>expression</replaceable> ) ] 
        [ <command>sortDescendingBy</command> ( <replaceable>expression</replaceable> ) ]
   <replaceable>statement</replaceable></programlisting>
	</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para><replaceable>data_expression</replaceable></para>
	<para>This must evaluate to a hash of arrays in order for the <command>context</command> statement to execute.</para>

	<para><code>[ <command>where</command> ( <replaceable>expression</replaceable> ) ]</code></para>
	<para>An optional <command>where</command> expression may be given, in which case for each row in the hash, 
	the expression will be executed, and if the <command>where</command> expression evaluates to True, 
	the row will be iterated in the <command>context</command> loop. If this expression evaluates 
	to False, then the row will not be iterated. This option is given so the 
	programmer can create multiple views of a single data structure (such as a query 
	result set) in memory rather than build different data structures by 
	hand.</para>

	<para><code>[ <command>sortBy</command> ( <replaceable>expression</replaceable> ) ]</code></para>
	<para>An optional <command>sort_by</command> expression may also be given. In this case, the expression will be evaluated for each row of the query given, and then the result set will be sorted in ascending order by the results of the expressions according to the resulting type of the evaluated expression (i.e. if the result of the evaluation of the expression gives a string, then string order is used to sort, if the result of the evaluation is an integer, then integer order is used, etc).</para>

	<para><code>[ <command>sortDescendingBy</command> ( <replaceable>expression</replaceable> ) ]</code></para>
	<para>Another optional modifier to the context statement that behaves the same as above except that the results are sorted in descending order.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting># note that "%service_type" and "%effective_start_date" represent values
# in the $service_history hash of arrays.

<command>context</command> ($service_history) <command>where</command> (%service_type == "voice")
<command>sortBy</command> (%effective_start_date)
{
   printf("%s: start date: %s\n", %msisdn, format_date(%effective_start_date, "YYYY-MM-DD HH:mm:SS"));
}</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>

</sect2>
<sect2 id="summarize_Statements">
  <title>summarize Statements</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>
	  <command>summarize</command> statements are like <command>context</command> statements with one important difference: results sets are grouped by a by expression, and the statement is executed only once per discrete <command>by</command> expression result. This statement is designed to be used with the <command>subcontext</command> statement.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>summarize</command> ( <replaceable>expression </replaceable>) <command>by</command> ( <replaceable>expression</replaceable> )
          [ <command>where</command> ( <replaceable>expression</replaceable> ) ] 
          [ <command>sortBy</command> ( <replaceable>expression</replaceable> ) ] 
          [ <command>sortDescendingBy</command> ( <replaceable>expression</replaceable> ) ]
   <replaceable>statement</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para><command>summarize</command> statements modifiers have the same effect as those for the <command>context</command> statement, except for the following:</para>

	<para><code><command>by</command> ( <replaceable>expression</replaceable> )</code></para>
	<para>The <command>by</command> expression is executed for each row in the data structure indicated. 
	The set of unique results defines groups of result rows. For each group of 
	result rows, each row having an identical result of the evaluation of the 
	<command>by</command> expression, the statement is executed only once.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting># note that "%service_type" and "%effective_start_date" represent values 
# in the $services hash of arrays.

<command>summarize</command> ($services) 
    <command>by</command> (%effective_start_date) 
    <command>where</command> (%service_type == "voice") 
    <command>sortBy</command> (%effective_start_date)
{
    printf("account has %d service(s) starting on %s\n", 
           context_rows(),
           format_date(%effective_start_date, "YYYY-MM-DD HH:mm:SS"));
}</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
</sect2>

<sect2 id="subcontext_Statements">
  <title>subcontext Statements</title>

  <variablelist>
    <varlistentry>
      <term>Synopsis</term>
      <listitem>
	<para>Statement used to loop through values within a summarize statement.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Syntax</term>
      <listitem>
	<programlisting><command>subcontext</command> [ <command>where</command> ( <replaceable>expression</replaceable> ) ] 
           [ <command>sortBy</command> ( <replaceable>expression</replaceable> ) ] 
           [ <command>sortDescendingBy</command> ( <replaceable>expression</replaceable> ) ]
    <replaceable>statement</replaceable></programlisting>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Description</term>
      <listitem>
	<para>The <command>subcontext</command> statement is used in conjunction with <command>summarize</command> statements. When result rows of a query should be grouped, and then each row in the result set should be individually processed, the Qore programmer should first use a <command>summarize</command> statement, and then a <command>subcontext</command> statement. The <command>summarize</command> statement will group rows, and then the nested <command>subcontext</command> statement will iterate through each row in the current summary group.</para>
      </listitem>
    </varlistentry>
    <varlistentry>
      <term>Example</term>
      <listitem>
	<programlisting><command>summarize</command> ($services) 
    <command>by</command> (%effective_start_date) 
    <command>where</command> (%service_type == "voice") 
    <command>sortBy</command> (%effective_start_date)
{
    printf("account has %d service(s) starting on %s\n", 
           context_rows(),
           format_date(%effective_start_date, "YYYY-MM-DD HH:mm:SS"));
    <command>subcontext</command> <command>sortDescendingBy</command> (%effective_end_date)
    {
        printf("\tservice %s: ends: %s\n", %msisdn, format_date(%effective_end_date, "YYYY-MM-DD HH:mm:SS"));
    }
}</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
</sect2>

    <sect2 id="return_Statements">
      <title>return Statements</title>

      <variablelist>
	<varlistentry>
	  <term>Synopsis</term>
	  <listitem>
	    <para><command>return</command> statements causes the flow of execution of the subroutine, method or program to stop immediately and return to the caller.  This statement can take an optional expression to return a value to the caller as well.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Syntax</term>
	  <listitem>
	    <programlisting><command>return</command> [<replaceable>expression</replaceable>];</programlisting>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Description</term>
	  <listitem>
	    <para>This statement causes execution of the current subroutine, method, or program to cease and optionalls returns a value to the caller.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Example</term>
	  <listitem>
	    <programlisting><command>sub</command> getName()
{
   <command>return</command> "Barney";
}

$name = getName();</programlisting>
	  </listitem>
	</varlistentry>
      </variablelist>
    </sect2>

    <sect2 id="on_exit_Statements">
      <title>on_exit Statements</title>

      <variablelist>
	<varlistentry>
	  <term>Synopsis</term>
	  <listitem>
	    <para>Queues a statement or statement block for unconditional execution when the block is exited, even in the case of exceptions or <command>return</command> statements.  For similar statement that queue code for execution depending on the exception status when the block exits, see <link linkend="on_success_Statements">on_success</link> statements and <link linkend="on_error_Statements">on_error</link> statements.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Syntax</term>
	  <listitem>
	    <programlisting><command>on_exit</command>
    <replaceable>statement</replaceable></programlisting>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Description</term>
	  <listitem>
	    <para>The <command>on_exit</command> statement provides a clean way to do exception-safe cleanup within Qore code.  Any single statment (or statement block) after the <command>on_exit</command> keyword will be executed when the current block exits (as long as the statement itself is reached when executing - <command>on_exit</command> statements that are never reached when executing will have no effect).  The the position of the <command>on_exit</command> statement in the block is important, as the immediate effect of this statement is to queue its code for execution when the block is exited.  Even if an exception is raised or a <command>return</command> statement is executed, any <command>on_exit</command> code that is queued will be executed.  Therefore it's ideal for putting cleanup code right next to the code that requires the cleanup.</para>
	    <para>Note that if this statement is reached when executing in a loop, the <command>on_exit</command> code will be executed for each iteration of the loop.</para>
	    <para>By using this statement, programmers ensure that necessary cleanup will be performed regardless of the exit status of the block (exception, return, etc).</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Example</term>
      <listitem>
	<programlisting>{
    $mutex.lock();
    # here we queue the unlock of the mutex when the block exits, even if an exception is thrown below
    <command>on_exit</command> $mutex.unlock();
    if ($error)
        <command>throw</command> "ERROR", "Scary error happened";
    print("everything's OK!\n");
    return "OK";
}
# when the block exits for any reason, the mutex will be unlocked
</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  </sect2>

    <sect2 id="on_success_Statements">
      <title>on_success Statements</title>

      <variablelist>
	<varlistentry>
	  <term>Synopsis</term>
	  <listitem>
	    <para>Queues a statement or statement block for execution when the block is exited in the case that no exception is active.  Used often in conjunction with the <link linkend="on_error_Statements">on_error statement</link> and related to the <link linkend="on_exit_Statements">on_exit statement</link>.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Syntax</term>
	  <listitem>
	    <programlisting><command>on_success</command>
    <replaceable>statement</replaceable></programlisting>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Description</term>
	  <listitem>
	    <para>The <command>on_success</command> statement provides a clean way to do block-level cleanup within Qore code in the case that no exception is thrown in the block.  Any single statment (or statement block) after the <command>on_success</command> keyword will be executed when the current block exits as long as no unhandled exception has been thrown (and as long as the statement itself is reached when executing - <command>on_success</command> statements that are never reached when executing will have no effect).  The the position of the <command>on_success</command> statement in the block is important, as the immediate effect of this statement is to queue its code for conditional execution when the block is exited.  Even if a <command>return</command> statement is executed later in the block, any <command>on_exit</command> code that is queued will be executed as long as there is no active (unhandled) exception.  Therefore it's ideal for putting cleanup code right next to the code that requires the cleanup, along with <link linkend="on_error_Statements">on_error</link> statements, which are executed in a manner similar to <command>on_success</command> statements, except <link linkend="on_error_Statements">on_error</link> statements are only executed when there is an active exception when the block is exited.</para>
	    <para>Note that if this statement is reached when executing in a loop, the <command>on_success</command> code will be executed for each iteration of the loop (as long as there is no active exception).</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Example</term>
      <listitem>
	<programlisting>{
    $db.beginTransaction();
    # here we queue the commit in the case there are no errors
    <command>on_success</command> $db.commit();
    # here we queue a rollback in the case of an exception
    <command>on_error</command> $db.rollback();
    $db.select("select * from table where id = %v for update", $id);
    ## .. more code

    return "OK";
}
# when the block exits. the transaction will be either committed or rolled back, 
# depending on if an exception was raised or not
</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  </sect2>

    <sect2 id="on_error_Statements">
      <title>on_error Statements</title>

      <variablelist>
	<varlistentry>
	  <term>Synopsis</term>
	  <listitem>
	    <para>Queues a statement or statement block for execution when the block is exited in the case that no exception is active.  Used often in conjunction with the <link linkend="on_success_Statements">on_success statement</link> and related to the <link linkend="on_exit_Statements">on_exit statement</link>.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Syntax</term>
	  <listitem>
	    <programlisting><command>on_error</command>
    <replaceable>statement</replaceable></programlisting>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Description</term>
	  <listitem>
	    <para>The <command>on_error</command> statement provides a clean way to do block-level cleanup within Qore code in the case that an exception is thrown in the block.  Any single statment (or statement block) after the <command>on_error</command> keyword will be executed when the current block exits as long as an unhandled exception has been thrown (and as long as the statement itself is reached when executing - <command>on_error</command> statements that are never reached when executing will have no effect).  The the position of the <command>on_error</command> statement in the block is important, as the immediate effect of this statement is to queue its code for conditional execution when the block is exited.  Even if a <command>return</command> statement is executed later in the block, any <command>on_exit</command> code that is queued will be executed as long as there is an active (unhandled) exception.  Therefore it's ideal for putting cleanup code right next to the code that requires the cleanup, along with <link linkend="on_success_Statements">on_success</link> statements, which are executed in a manner similar to <command>on_error</command> statements, except <link linkend="on_success_Statements">on_success</link> statements are only executed when there is no active exception when the block is exited.</para>
	    <para>Note that the code in this statement can only be executed once in any block, as a block (even a block within a loop) can only exit the loop once with an active exception.</para>
	  </listitem>
	</varlistentry>
	<varlistentry>
	  <term>Example</term>
      <listitem>
	<programlisting>{
    $db.beginTransaction();
    # here we queue the commit in the case there are no errors
    <command>on_success</command> $db.commit();
    # here we queue a rollback in the case of an exception
    <command>on_error</command> $db.rollback();
    $db.select("select * from table where id = %v for update", $id);
    ## .. more code

    return "OK";
}
# when the block exits. the transaction will be either committed or rolled back, 
# depending on if an exception was raised or not
</programlisting>
      </listitem>
    </varlistentry>
  </variablelist>
  </sect2>

</sect1>

<sect1 id="Subroutines">
<title>Subroutines</title>

<para>A subroutine is declared in Qore by using the key word <command>sub</command> as follows:</para>

<programlisting><command>sub</command> <replaceable>subroutine_name</replaceable>([<replaceable>variable1, variable2, ...</replaceable>])
{
    <replaceable>statements;</replaceable>
}
</programlisting>

<para>Variables listed in parentheses by the subroutine name automatically get local lexical scoping. In order to process a variable number of arguments to a function, the <code>$argv</code> variable (local variable) is instantiated as a list with the remaining arguments passed to the subroutine.</para>

<para>Subroutines can use the <command>return</command> statement to provide a return value. Subroutine names must be valid Qore identifiers.</para>

<note><para>Variables passed as function arguments are passed by value by default, unless the caller places a "\" character before an lvalue in the argument list. In this case the subroutine must have a parameter defined to accept the variable passed by reference. Any changes to the local variable will be reflected in the original variable for variables passed by reference. Also note that it is illegal to pass an argument by reference in a background expression.</para></note>

<para>Subroutines can return values to the calling expression by using the <command>return</command> statement, with the following syntax:</para>

<programlisting><command>return</command> <replaceable>expression</replaceable>;</programlisting>

<para>Here is an example subroutine declaration for a function returning a value:</para>

<programlisting>#!/usr/bin/qore
#
# subroutine declaration example

<command>sub</command> print_string($string)
{
    print("%s\n", $string);
    <command>return</command> 1;
}
</programlisting>

<para>Subroutines may also be recursive.  Here is an example of a recursive Qore subroutine definition implementing the Fibonacci function:</para>

<programlisting>#!/usr/bin/qore
#
# recursive subroutine example

<command>sub</command> fibonacci($num)
{
    <command>if</command> ($num == 1)
        <command>return</command> 1;
    <command>return</command> $num * fibonacci($num - 1);
}
</programlisting>

<note>
<para>Function names are resolved during the second parse pass; therefore functions do not need to be declared before being referenced. This allows an easy definition of 2 or more self-referencing functions.</para></note>  

</sect1>
<sect1 id="Namespaces">
<title>Namespaces</title>

<para>Namespaces allow constants, classes, and even other namespaces with the same name to co-exist in the same program by defining them in separate namespaces. Constants, classes, and sub-namespaces can be declared to belong to a particular namespace either by defining them in-line within a namespace declaration, or by including the namespace name/path prepended to the constant, class, or namespace declaration separated by two colons "::".</para>

<para>If the user does not specify the parent namespace with a namespace path in constant, class, or namespace declarations, the declaration will be by default in the unnamed default root namespace.</para>

<sect2 id="Namespace_Declarations">
<title>Namespace Declarations</title>

<para>In-line namespace declaration:</para>

<programlisting><command>namespace</command> [<replaceable>namespace_path</replaceable>::]<replaceable>namespace_identifier</replaceable> 
{
    [<replaceable>constant_declarations</replaceable>]
    [<replaceable>class_declarations</replaceable>]
    [<replaceable>sub-namespace-declarations</replaceable>]
}
</programlisting>

<para>Out of line namespace declaration:</para>

<programlisting><command>namespace</command> [<replaceable>namespace_path</replaceable>::]<replaceable>namespace_identifier</replaceable>;
</programlisting>

</sect2>
<sect2 id="Namespace_Resolution">
<title>Namespace Resolution</title>

<para>Namespaces can either be resolved by giving a path to the constant, class, or namespace desired, or by leaving out the namespace path and allowing the system to search for the constant, class, or namespace. In either case, a breadth-first search of the namespace tree is made for a match. If a namespace path is included, then the tree is searched for the first namespace match. and, if the rest of the declaration cannot be matched, the search continues in the entire namespace tree until a complete match is found.</para>

<para>Namespace paths look like the following:</para>

<para><replaceable>starting_namespace</replaceable>::[<replaceable>sub-namespaces</replaceable>::]<replaceable>constant|class|namespace</replaceable></para>

</sect2>
<sect2 id="System_Namespaces">
<title>System Namespaces</title>


<para>All Qore-language constants and classes are defined in the Qore namespace or in a subnamespace of the Qore namespace. The Qore namespace is a direct child of the unnamed default root namespace (::).</para>

<para>For detailed information on all constants and classes defined in system namespaces, see <link linkend="System_Namespaces_and_Class_Library">System Namespaces and Class Library</link>.</para>
</sect2>
</sect1>
<sect1 id="Constants">
<title>Constants</title>

<para>Constant definitions allow programmers to refer to values with Qore identifiers rather than using the value.  Constants are defined with the following syntax:</para>

<para><command>const</command> [<replaceable>namespace_path</replaceable>::]<replaceable>constant_identifier</replaceable> = <replaceable>value</replaceable>;</para>

<note><para>The value cannot require run-time evaluation (executes a function, has a variable reference, uses an operator that changes values, etc) or a parse exception will be raised.</para></note>

</sect1>
<sect1 id="Classes">
<title>Classes</title>

<para>Objects are instantiations of a Qore class.  Classes define private members and methods, which are functions that operate only on the objects of that class.</para>

<para>Classes are declared with the following syntax:</para>

<programlisting><command>class</command> [<replaceable>namespace_path::</replaceable>...]<replaceable>class_identifier</replaceable> [<command>inherits</command> [<command>private</command>] [<replaceable>namespace_path::</replaceable>...]<replaceable>class_identifier</replaceable>[, ...]]
{
    [<command>private </command> <replaceable>$.var1[, ...]</replaceable>;]

    [<command>synchronized</command>] [<command>private</command>] [<replaceable>namespace_path</replaceable>::]<replaceable>method_name_identifier</replaceable>([$var1, $var2, ...])
    {
         <replaceable>statements</replaceable>;
    }
    ...
}
</programlisting>

<para>Alternatively objects can be defined out of line as follows:</para>

<programlisting><command>class</command> [<replaceable>namespace_path::</replaceable>]<replaceable>class_identifier</replaceable> [<command>inherits</command> [<command>private</command>] [<replaceable>namespace_path::</replaceable>...]<replaceable>class_identifier</replaceable>[, ...]];

[<command>synchronized</command>] [<command>private</command>] [<replaceable>namespace_path::</replaceable>]<replaceable>class_identifier</replaceable>::<replaceable>method_identifier</replaceable>([$var1, $var2, ...])
{
    <replaceable>statements</replaceable>;
}
</programlisting>

<note><para>Private members can only be declared in an in-line class definition (the first example above).</para></note>

<note><para>In a class hierarchy, base class constructor methods can be explicitly specified using a special syntax unique to subclass constructor methods.  Please see <link linkend='Class_Inheritance'>Class Inheritance</link> for more information.</para></note>

<note><para>It's possible to write purely object-oriented scripts/programs in Qore by defining an application class and using the -x or --exec-class command-line arguments to tell Qore to instantiate the class instead of doing normal top-level execution (in fact, the --exec-class arguments disallow the use of top-level statements entirely).  For more information, please see <link linkend="Command-Line_Parsing">Command-Line Parsing</link> and <link linkend="Parse_Directives">Parse Directives</link>.</para></note>

<sect2 id="Private_and_Synchronized_Methods">
<title>Private and Synchronized Methods</title>

<para>Methods declared with the <command>private</command> keyword can only be called by other member functions of the same class.  Any attempt to call these methods from outside the class will result in a run-time exception.</para>

<para>Methods declared with the <command>synchronized</command> keyword will only run in one thread at a time.</para>
</sect2>

<sect2 id="Constructors_Destructors_and_Other_Special_Methods">
<title>Constructors, Destructors, and Other Special Methods</title>

<para>All class methods are optional, but some methods have a special meaning.</para>

<table><title>Special Methods</title>
<tgroup cols='2' align='left' colsep='1' rowsep='1'>
  <thead>
  <row>
    <entry><para>Name</para></entry>
    <entry><para>Description</para></entry>
  </row>
  </thead>

<tbody>
  <row>
    <entry><para><code>constructor()</code></para></entry>
    <entry><para>Called when objects are created with the <command>new</command> operator. User code may not explicitly call <code>constructor()</code> methods.  In a class tree, <code>constructor()</code> methods are called for base classes first in left-to-right, depth-first declaration order.</para></entry>
  </row>
  <row>
    <entry><para><code>copy()</code></para></entry>
    <entry><para>When a user explicitly calls a copy method, Qore will generate a new object with references to the same members as the source object.  Then, if there are any base classes, base class <code>copy()</code> methods are called in the same order as the <code>constructor()</code> methods.  If a <code>copy()</code> method is defined, it will be run in the new object with a reference to the old object passed as the first argument.  Any other arguments passed to the <code>copy()</code> method are ignored.</para></entry>
  </row>
  <row>
    <entry><para><code>destructor()</code></para></entry>
    <entry><para>Called when objects go out of scope or are explicitly deleted. User code may not explicitly call <code>destructor()</code> methods.  In a class tree, <code>destructor()</code> methods are called for base classes in the opposite order in which the constructors are called</para></entry>
  </row>
  <row>
    <entry><para><code>memberGate()</code></para></entry>
    <entry><para>Called when read access is attempted to private member or members that do not exist in the current object.  In a class tree, <code>memberGate()</code> methods are not inherited.</para></entry>
  </row>
  <row>
    <entry><para><code>methodGate()</code></para></entry>
    <entry><para>Called when methods are called on the object that do not exist in the current object.  In a class tree, <code>methodGate()</code> methods are not inherited.</para></entry>
  </row>

</tbody>
</tgroup>
</table>

<para>Within class methods, members of the current object can be referred to with a special syntax as follows:</para>

<programlisting>$.<replaceable>member_name_identifier</replaceable></programlisting>

<para>Furthermore the automatic variable <code>$self</code> is instantiated which represents the current object (similar to the <code>this</code> in C++ or Java). Therefore if you need to access hash members which are not valid Qore identifiers, then enclose the member name in double quotes after the dot operator as follows: </para>

<programlisting>$self."&amp;member-name"</programlisting>

<para>The automatic <code>$argv</code> local variable is instantiated as usual in all class methods where there are more arguments than variables declared in the method declaration.</para>

</sect2>

<sect2 id="Class_Inheritance">
<title>Class Inheritance</title>

<para>Class inheritance is a powerful concept for easily extending and resuing object-oriented code, but is also subject to some limitations.  This section will explain how class inheritance works in Qore.</para>

<para>Classes inherit the methods of a parent class by using the <command>inherits</command> as specified above.  Multiple inheritance is supported; a single Qore class can inherit one or more classes.  When a class is inherited by another class, it is called a base class.  Private inheritance is speficied by including the keyword <command>private</command> before the inherited class name.  When a class is privately inherited, it means that the inherited class' public members are treated as private members in the context of accesses outside the class.</para>

<para>It is not legal to directly inherit the same class more than once; that is; it is not legal to list the same class more than once after the <command>inherits</command> keyword.  However, it is possible that a base class could appear more than once in the inheritance tree if that class is inherited separately by two or more classes in the tree.  In this case, the base class will actually only be inherited once in the subclass, even though it appears in the inheritance tree more than once.  This must be taken into consideration when designing class hierarchies, particularly if base class constructor parameters for that class are explicitly provided in a different way by the inheriting classes.</para>

<note><para>Class members only exist once for each object; therefore if classes in an inheritance tree have different uses for members with the same name, then a class hierarchy built of such classes will probably not function properly.</para></note>

<para>Subclasses can give explicit arguments to their base class constructors using a special syntax (only available to subclass constructors) similar to the C++ syntax for the same purpose as follows:</para>

<programlisting><replaceable>class_name</replaceable>::constructor([$var1[, ...]) : <replaceable>base_class_identifier</replaceable>(<replaceable>expression(s)</replaceable>)[, ...]
{
    <replaceable>statements</replaceable>;
}
</programlisting>

<para>Here is a concrete example of giving arguments to an inherited base class:</para>
<programlisting><command>class</command> XmlRpcClient::XmlRpcClient <command>inherits</command> HTTPClient::HTTPClient
{
    # calls the base class HTTPClient constructor, overrides the "protocols" key to "xmlrpc"
    constructor($opts) : HTTPClient::HTTPClient($opts + ( "protocols" : "xmlrpc" ))
    ...
}
</programlisting>

<para>Because base class constructors are executed before subclass constructors, the only local variables in the constructor that can be referenced are those declared in the subclass constructor declaration (if any).</para>

<note><para>Base classes that give explicit arguments to their base class constructors can be overridden by subclasses by simply listing the base class in the base class constructor list and providing new arguments.</para></note>

</sect2>

<sect2 id="Object_Scope_and_References">
<title>Object Scope and References</title>

<para>In Qore (like Java) objects are by default referenced and not copied.  That means that passing an object to a function that modifies the object will by default modify the original object and not a copy.</para>

<para>To explicitly generate a copy of an object, the <code>copy()</code> constructor must be called.  This is a special method that exists implicitly for every class even if it is not explicitly defined (like <code>constructor()</code> and <code>destructor()</code> methods).  The implicit behavior of the <code>copy()</code> constructor is to create a new object with new members that are copies of the original members (except objects are once again referenced).  Then, if any <code>copy()</code> method exists, it will be executed in the new object, passing a reference to the old object as the first paramter.</para>

<note>
<para>In a class hierarchy <code>copy()</code> methods are called in the same order as <code>constructor()</code> methods.</para>
</note>

<note>
<para>Not all built-in classes can be copied.  Classes not supporting copying will throw an exception when the <code>copy()</code> methods are called.  See the documentation for each class for more information.</para>
</note>

</sect2>

<sect2 id="Object_Scope_and_Threading">
<title>Object Scope and Threading</title>

<para>An object's destructor is called when it goes out of scope and the last thread running any of the object's methods returns from the object method, or if the destructor is called explicitly with the <command>delete</command> statement.</para>

<para>This means that an object assigned to a local variable, but has a running method in another thread (for example, by launching the method explicitly with the <command>background</command> expression), will not be deleted until the last thread terminates.</para>

<note>
<para>If an object spawns an object method in another thread using the <command>background</command> operator, that object will remain in scope until the last thread terminates or it's <code>destructor()</code> method is explicitly called with the <command>delete</command> operator. This means, for example, that objects assigned to local variables can exist for longer than the scope of their host variable if they have one or more methods running in other threads.</para>
</note>

<para>However, if an object with running threads is explicitly deleted, if this case is not handled in the object's <code>destructor()</code> method (by ensuring that all other running threads terminate gracefully), exceptions will be thrown in other threads at any attempt to access the already-deleted object.</para>

<para>For more information about threading, please see the following section <link linkend="Threading">Threading</link></para>

</sect2>
</sect1>

<sect1 id="Threading">
  <title>Threading</title>

  <para>The Qore language is thread-safe and Qore programs should not crash the Qore executable due to threading errors.  Threading errors should only cause application errors.</para>

  <para>Threading functionality in Qore is provided by the operating system's POSIX threads library.</para>

  <sect2 id="Creating_and_Terminating_Threads">
    <title>Creating and Terminating Threads</title>

    <para>New threads are created with the <link linkend="Background_Operator"><command>background</command> operator</link>.  This operator executes the expression given as an argument in a new thread and returns the TID of the new thread to the calling thread.  This is most useful for calling user subroutines or object methods designed to run in a separate thread.</para>

    <para>To terminate a thread, the <link linkend="thread_exit_Statements"><command>thread_exit</command> statement</link> should be called, as calling the <link linkend="exit">exit() function</link> will terminate the entire UNIX process (and therefore all threads) immediately.</para>

  </sect2>
  <sect2 id="Threading_And_Variables">
    <title>Threading and Variables</title>
    <para>All global variables are shared in Qore programs, while local variables (declared with <command>my</command>) are always local to each thread, regardless of location. </para>
    <para>That means that even if a variable is declared with <command>my</command> at the top level, each thread will have its own copy of the variable.</para>
    <para>To have the equivalent of global thread-local variables, see the <link linkend="save_thread_data">save_thread_data()</link> and <link linkend="get_thread_data">get_thread_data()</link> in the <link linkend="Threading_Functions">Threading Functions</link> section.</para>
  </sect2>

  <sect2 id="Thread_Synchronization_and_Inter-Thread_Communication">
    <title>Thread Synchronization and Inter-Thread Communication</title>

    <para>The <command>synchronized</command> keyword can be used before subroutine or class method definitions in order to guarantee that the function or method call will only be executed in one thread at a time.  As in Java, this keyword can also be used safely with recursive functions and methods (internally a <link linkend="Qore::Thread::Gate_Class">Gate</link>-like object is used to guarantee thread-exclusivity and allow recursion).</para>

    <para>The following classes are useful when developing multi-threaded Qore programs:</para>

    <table>
      <title>Classes Useful With Threading</title>
      <tgroup cols='2' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Class</para></entry>
	    <entry><para>Description</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><link linkend="Qore::Thread::Mutex_Class">Mutex</link></para></entry>
	    <entry><para>A mutual-exclusion thread lock.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::Gate_Class">Gate</link></para></entry>
	    <entry><para>A recursive thread lock.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::RWLock_Class">RWLock</link></para></entry>
	    <entry><para>A read-write thread lock.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::Condition_Class">Condition</link></para></entry>
	    <entry><para>Allows Qore programs to block until a certain condition becomes true.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::Counter_Class">Counter</link></para></entry>
	    <entry><para>A blocking counter class.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::Queue_Class">Queue</link></para></entry>
	    <entry><para>A thread-safe, blocking queue class (useful for message passing).</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::RMutex_Class">RMutex</link></para></entry>
	    <entry><para>DEPRECATED in favor of the <link linkend="Qore::Thread::Gate_Class">Gate</link> class: A recursive mutual-exclusion thread lock.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::Sequence_Class">Sequence</link></para></entry>
	    <entry><para>A simple, thread-atomic sequence object (increment-only).</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::AutoLock_Class">AutoLock</link></para></entry>
	    <entry><para>A helper class to automatically release Mutex locks when the AutoLock object is deleted.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::AutoGate_Class">AutoGate</link></para></entry>
	    <entry><para>A helper class to automatically exit Gate locks when the AutoGate object is deleted.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::AutoReadLock_Class">AutoReadLock</link></para></entry>
	    <entry><para>A helper class to automatically release read locks when the AutoReadLock object is deleted.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Qore::Thread::AutoWriteLock_Class">AutoWriteLock</link></para></entry>
	    <entry><para>A helper class to automatically release read locks when the AutoWriteLock object is deleted.</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <para>The following functions assist writing safe and efficient multi-threaded Qore programs:</para>

    <table>
      <title>Thread Functions</title>
      <tgroup cols='2' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Function</para></entry>
	    <entry><para>Description</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><link linkend="save_thread_data">save_thread_data()</link></para></entry>
	    <entry><para>Saves a thread-local value against a key.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="get_all_thread_data">get_all_thread_data()</link></para></entry>
	    <entry><para>Retrieves the entire thread-local hash.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="get_thread_data">get_thread_data()</link></para></entry>
	    <entry><para>Retrieves a thread-local value based on a key.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="delete_all_thread_data">delete_all_thread_data()</link></para></entry>
	    <entry><para>Deletes the entire thread-local data hash.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="delete_thread_data">delete_thread_data()</link></para></entry>
	    <entry><para>Delete the value of a key in the thread-local data hash.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="gettid">gettid()</link></para></entry>
	    <entry><para>Gets the thread's TID (thread identifier)</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="thread_list">thread_list()</link></para></entry>
	    <entry><para>Returns a list of TIDs of running threads</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="num_threads">num_threads()</link></para></entry>
	    <entry><para>Returns the number of running threads</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
    
    </sect2>

    <sect2 id="Deadlocks">
      <title>Deadlocks</title>
  
      <para>Qore supports deadlock detection in complex locking scenarios and will throw a <code>THREAD-DEADLOCK</code> exception rather than allow an operation to be performed that would cause a deadlock.  Deadlock detection is implemented for internal locking (global variable and object access), synchronized methods and subroutinges, etc, as well as for all Qore threading classes.</para>

      <para>Qore can only detect deadlocks when a lock resource acquired by one thread is required by another who holds a lock that the first thread also needs.  Other errors such as forgetting to unlock a global lock and trying to acquire that lock in another thread cannot be differentiated from valid use of threading primitives and will result in a process that never terminates.  However, common threading errors such as trying to lock the same Mutex twice in the same thread without unlocking it between the two Mutex::lock() calls are caught in Qore and exceptions are thrown.  Additionally, locks are tracked as thread resources, so if a thread terminates while holding a lock, an exception will be thrown and the lock will be automatically released.</para>

    </sect2>
  </sect1>

<sect1 id="Exception_Handling">
  <title>Exception Handling</title>

  <para>Exceptions are errors that can only be handled using a <link linkend='try_and_catch_Statements'><command>try catch</command> block</link>.  Any exception that is thrown in a <command>try</command> block will immediately cause execution of that thread to begin with the first statement of the <command>catch</command> block, regardless of the position of the program pointer of the running thread, even if nested subroutines or object method calls have been made.</para>

  <para>Exceptions can be thrown by the Qore system for a number of reasons, see the documentation for each function and object method for details.</para>

  <para>Programmers can also throw exceptions explicitly by using the <link linkend="throw_Statements"><command>throw</command></link> and <link linkend="rethrow_Statements"><command>rethrow</command></link> statements.</para>

  <para>Information about the exception, including the context in which the exception occurred, is saved in the exception hash, which can be retrieved by using a parameter variable in the catch block (for more information about <command>try catch</command> blocks, see <link linkend='try_and_catch_Statements'>try and catch</link> statements).</para>

  <para>The exception hash contains the following members:</para>

  <table>
    <title>Exception Hash Keys</title>
    <tgroup cols='3' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Name</para></entry>
	  <entry><para>Type</para></entry>
	  <entry><para>Description</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><code>type</code></para></entry>
	  <entry><para>string</para></entry>
	  <entry><para>"System" or "User" depending on exception type</para></entry>
	</row>
	<row>
	  <entry><para><code>file</code></para></entry>
	  <entry><para>string</para></entry>
	  <entry><para>File name of file where exception occurred</para></entry>
	</row>
	<row>
	  <entry><para><code>line</code></para></entry>
	  <entry><para>integer</para></entry>
	  <entry><para>Line number where exception occurred</para></entry>
	</row>
	<row>
	  <entry><para><code>callStack</code></para></entry>
	  <entry><para>list of hashes</para></entry>
	  <entry><para>Backtrace information</para></entry>
	</row>
	<row>
	  <entry><para><code>err</code></para></entry>
	  <entry><para>any</para></entry>
	  <entry><para>This key is populated with the value of the first expression of the <command>throw</command> statement.  For system exceptions, this is a string giving the exception code.</para></entry>
	</row>
	<row>
	  <entry><para><code>desc</code></para></entry>
	  <entry><para>any</para></entry>
	  <entry><para>This key is populated with the value of the second expression of the <command>throw</command> statement (if a list was thrown).  For system exceptions, this is a string giving a text description of the error.</para></entry>
	</row>
	<row>
	  <entry><para><code>arg</code></para></entry>
	  <entry><para>any</para></entry>
	  <entry><para>This key is populated with the value of the third expression of the <command>throw</command> statement (if a list was thrown).  For system exceptions, this is not populated.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <table id="Call_Stack_Description">
    <title>Call Stack Description</title>
    <tgroup cols='3' align='left' colsep='1' rowsep='1'>
      <thead>
	<row>
	  <entry><para>Name</para></entry>
	  <entry><para>Type</para></entry>
	  <entry><para>Description</para></entry>
	</row>
      </thead>
      <tbody>
	<row>
	  <entry><para><code>function</code></para></entry>
	  <entry><para>string</para></entry>
	  <entry><para>function name </para></entry>
	</row>
	<row>
	  <entry><para><code>line</code></para></entry>
	  <entry><para>integer</para></entry>
	  <entry><para>line number</para></entry>
	</row>
	<row>
	  <entry><para><code>file</code></para></entry>
	  <entry><para>string</para></entry>
	  <entry><para>file name</para></entry>
	</row>
	<row>
	  <entry><para><code>type</code></para></entry>
	  <entry><para>string</para></entry>
	  <entry><para>Exception Type (ET_*) constants; see <link linkend="Qore_Exception_Constants">Exception Constants</link> for values.</para></entry>
	</row>
	<row>
	  <entry><para><code>typecode</code></para></entry>
	  <entry><para>integer</para></entry>
	  <entry><para>Call Type (CT_*) constants; see <link linkend="Qore_Exception_Constants">Exception Constants</link> for values.</para></entry>
	</row>
      </tbody>
    </tgroup>
  </table>

  <para>System exceptions always throw 2 values, populating the "err" and "desc" keys of the exception hash, giving the exception string code and the exception description string, respectively. User exceptions have no restrictions, any values given in the throw statement will be mapped to exception keys as per the table above.</para>

  <para>See the <link linkend="on_exit_Statements">on_exit statement</link>, <link linkend="on_success_Statements">on_success statement</link>, and <link linkend="on_error_Statements">on_error statement</link> for statements that allow for exception-safe and exception-dependent cleanup in Qore code.</para>

  <para>Classes that assist in exception-safe lock handling are the <link linkend="Qore::Thread::AutoLock_Class">AutoLock class</link>, the <link linkend="Qore::Thread::AutoGate_Class">AutoGate class</link>, the <link linkend="Qore::Thread::AutoReadLock_Class">AutoReadLock class</link>, and the <link linkend="Qore::Thread::AutoWriteLock_Class">AutoWriteLock class</link>.</para>

</sect1>

  <sect1 id="XML_Integration">
    <title>XML Integration</title>

    <para>XML functionality in Qore is provided by the <ulink url="http://www.xmlsoft.org">libxml2</ulink> library, which provides a powerful, stable, clean, and thread-safe basis for XML integration in Qore.</para>

    <para>XML provides an excellent way to describe hierarchical data, and thanks to libxml2, Qore can allow for easy serialization and deserialization between XML strings and Qore data structures.</para>

    <para>XML serialization (conversion from Qore data structures to XML strings) in Qore relies on the fact that Qore <link linkend="Hashes">hashes</link> retain insertion order, which means that conversion to and from Qore data structures and XML strings can be done without data loss and without reordering the XML elements.  In general, XML serialization is relatively straighforward, but there are a few issues to be aware of, particularly regarding element attributes and lists.  These issues are described in the following paragraphs.</para>

    <para>First, a straightforward example:</para>

    <programlisting>$h = ( "record" : ( "name" : ( "first" : "Fred", "last" : "Smith" ) ) );
printf("%s\n", makeFormattedXMLString($h));</programlisting>

    <para>This produces the following result</para>

    <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;record&gt;
  &lt;name&gt;
    &lt;first&gt;Fred&lt;/first&gt;
    &lt;last&gt;Smith&lt;/last&gt;
  &lt;/name&gt;
&lt;/record&gt;</programlisting>

    <para>To set XML attributes, the Qore value must be a hash and the attributes are stored in another hash in the key <code>^attributes^</code>.  That is; the value of the <code>^attributes^</code> key must be a hash, and each member of this hash will represent an attribute-value pair.</para>

    <para>For example:</para>

    <programlisting>$h = ( "record" : ( "^attributes^" : ( "type" : "customer" ) , 
	            "name" : ( "first" : "Fred", "last" : "Smith" ) ) );
printf("%s\n", makeFormattedXMLString($h));</programlisting>

    <para>This produces the following results:</para>

    <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;record type="customer"&gt;
  &lt;name&gt;
    &lt;first&gt;Fred&lt;/first&gt;
    &lt;last&gt;Smith&lt;/last&gt;
  &lt;/name&gt;
&lt;/record&gt;</programlisting>

    <para>If instead we wanted to have text instead of child data under the "record" node, we must set the <code>^value^</code> key of the hash along with the <code>^attributes^</code> key as follows: </para>

    <programlisting>$h = ( "record" : ( "^attributes^" : ( "type" : "customer" ) , 
	            "^value^" : "NO-RECORD" ) );
printf("%s\n", makeFormattedXMLString($h));</programlisting>

    <para>Giving the following results:</para>

    <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;record type="customer"&gt;NO-RECORD&lt;/record&gt;</programlisting>

    <para>Arrays are serialized with repeating node names as follows:</para>

    <programlisting>$h = ( "record" : ( "part" : ( "part-02-05", "part-99-23", "part-34-28" ) ) );
printf("%s\n", makeFormattedXMLString($h));</programlisting>

    <para>Producing the following results:</para>

    <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;record type="customer"&gt;
  &lt;part&gt;part-02-05&lt;/part&gt;
  &lt;part&gt;part-99-23&lt;/part&gt;
  &lt;part&gt;part-34-28&lt;/part&gt;
&lt;/record&gt;
</programlisting>

   <para>It gets a little trickier when a key should repeated at the same level in an XML string, but other keys come between, for example, take the following XML string:</para>

   <programlisting>&lt;?xml version="1.0" encoding="UTF-8"?&gt;
&lt;para&gt;Keywords: &lt;code&gt;this&lt;/code&gt;, &lt;code&gt;that&lt;/code&gt;, and &lt;code&gt;the_other&lt;/code&gt;.&lt;/para&gt;</programlisting>

   <para>It's not possible to use a list, because text is required in between.  As described earlier, the <code>^value^</code> hash key can be used to serialize text in an XML string.  In this case, we need to have several text nodes and several <code>code</code> nodes in a mixed-up order to give us the XML string we want.  Because qore hases have unique keys (we can't use the same key twice in the same hash), we resort to a key naming trick that allows us to virtually duplicate our key names and therefore arrive at the XML string we want.  We do this by appending a '^' character to the end of the key name and then some unique text.  When serializing hash keys, any text after (and including) the '^' character is ignored.  For the special key name <code>^value^</code>, we do not need to duplicate the final '^' character.  Instead we just add unique text to ensure that our hash can contain all the data we want and that it will be serialized in the right order to the XML string as follows:</para>

    <programlisting>
$h = ( "para" : ( "^value^" : "Keywords: ", 
                  "code" : "this", 
                  "^value^1" : ", ", 
                  "code^1" : "that", 
                  "^value^2" : ", and ", 
                  "code^2" : "the_other", 
                  "^value^3" : "." ) );
printf("%s\n", makeFormattedXMLString($h));</programlisting>

    <para>By ignoring the text after the '^' character, the above code will serialize to the XML string we want.  In general, by using this convention, we can properly serialize multiple out-of-order keys without losing data and still have unique names for our hash keys.</para>

   <para>Note than when deserializing XML strings to Qore data structures, the above rules are applied in reverse.  If any out-of-order duplicate keys are detected, Qore will automatically generate unique hash key names based on the above rules.</para>

   <para>Also note that CDATA text will be generated if a hash key starts with '^cdata'; such text will not be processed for escape code substitution.  When deserializing XML strings to qore data structures, CDATA text will be placed unmodified under such a hash key as well.</para>

    <table>
      <title>Functions For XML Serialization and Deserialization</title>
      <tgroup cols='2' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Function Name</para></entry>
	    <entry><para>Description</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><link linkend="makeFormattedXMLFragment">makeFormattedXMLFragment()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string with formatting without an XML header.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeFormattedXMLString">makeFormattedXMLString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string with formatting and an XML header.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeXMLFragment">makeXMLFragment()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string without an XML header or formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeXMLString">makeXMLString()</link></para></entry>
	    <entry><para>Serializes a hash into a complete XML string with an XML header and without formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="parseXML">parseXML()</link></para></entry>
	    <entry><para>parses an XML string and returns a Qore hash structure.</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <para>XML-RPC is a lightweight but powerful XML over HTTP web service protocol.  Qore includes builtin support for this protocol.  You can find more information about XML-RPC, including specifications and examples at <ulink url="http://xmlrpc.org">http://xmlrpc.org</ulink>.</para>
    
    <table>
      <title>Functions Providing XML-RPC Functionality</title>
      <tgroup cols='2' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Function Name</para></entry>
	    <entry><para>Description</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><link linkend="makeFormattedXMLRPCCallString">makeFormattedXMLRPCCallString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC call with formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeFormattedXMLRPCCallStringArgs">makeFormattedXMLRPCCallStringArgs()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC call with formatting, taking a single list argument for the argument list.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeFormattedXMLRPCFaultResponseString">makeFormattedXMLRPCFaultResponseString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC fault response with formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeFormattedXMLRPCResponseString">makeFormattedXMLRPCResponseString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC response with formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeFormattedXMLRPCValueString">makeFormattedXMLRPCValueString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string in XML-RPC Value format with formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeXMLRPCCallString">makeXMLRPCCallString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC call without formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeXMLRPCCallStringArgs">makeXMLRPCCallStringArgs()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC call without formatting, taking a single list argument for the argument list.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeXMLRPCFaultResponseString">makeXMLRPCFaultResponseString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC fault response without formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeXMLRPCResponseString">makeXMLRPCResponseString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string formatted for an XML-RPC response without formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="makeXMLRPCValueString">makeXMLRPCValueString()</link></para></entry>
	    <entry><para>Serializes a hash into an XML string in XML-RPC Value format without formatting.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="parseXMLRPCCall">parseXMLRPCCall()</link></para></entry>
	    <entry><para>deserializies an XML-RPC call string, returning a Qore hash respresenting the call information.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="parseXMLRPCResponse">parseXMLRPCResponse()</link></para></entry>
	    <entry><para>deserializies an XML-RPC response string, returning a Qore hash respresenting the response information.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="parseXMLRPCValue">parseXMLRPCValue()</link></para></entry>
	    <entry><para>deserializies an XML-RPC value tree, returning a Qore hash respresenting the information.</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>
  </sect1>
  <sect1 id="signal_handling">
    <title>Signal Handling</title>
    <para>Qore signal handling support is experimental.</para>
    <para>Qore-language signal handlers are installed with <link linkend="set_signal_handler">set_signal_handler()</link>.  Signal handlers are removed with <link linkend="remove_signal_handler">remove_signal_handler()</link>.</para>
    <para>Qore signal handlers are dispatched (when the appropriate signal has been raised) before executing statements, or when blocked threads are awoken with a spurious wakeup, to ensure that sleeping processes can still process signals.</para>
    <para>It is not currently possible to set signal masks per thread; signals are handled in the first thread that sees the signal has been raised.  Signal checking is very fast; it is currently done by checking a fixed single byte without locking.  If the flag is set, then the lock is acquired and the flag is checked again and the signal handler is run in an atomic fashion.</para>
    <para>While executing signal handlers, Qore saves the value of the C <code>errno</code> thread-local variable and restores it after all handlers have been run.</para>
    <para>Note that exceptions thrown by error handlers cannot be caught; the exception information will simply be displayed on stderr as an unhandled exception.</para>
  </sect1>
</chapter>

