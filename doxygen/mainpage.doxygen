/** @mainpage Programming with the Qore Library

    @section introduction Introduction to the Qore Library

    The Qore library is designed to facilitate dynamic embedding of code in applications.  The Qore library is thread-safe, and Qore code taking advantage of Qore's threading facilities is highly scalable on SMP machines.

    Qore data is generally atomically referenced counted (with some exceptions for performance and memory usage reasons), and the library supports some constructors in order to reduce the number of atomic operations and avoid evaluations wherever possible.

    @note The Qore library currently does not throw C++ exceptions; Qore-language exceptions are managed via the ExceptionSink class.

    @section embedding Embedding Qore Code

    All code using the qore library should include the header file Qore.h as follows:

    @code
    #include <qore/Qore.h>
    @endcode

    @subsection initializing_and_closing_library Initializing and Closing the Qore Library

    The first step is to initialize the library.  To do this, call qore_init() as follows (note that this function can only be called once and must be called before any other functionality of the Qore library is used):

    @code
    // qore_init() optionally takes several arguments as well
    qore_init();
    @endcode

    When your program terminates, you should call qore_cleanup() as follows:

    @code
    qore_cleanup();
    @endcode

    @subsection parsing_and_running Parsing and Running Qore Code
    
    First you should declare a variable of type ExceptionSink to capture and manage Qore exceptions (declare an additional variable if you want to capture and manage warnings when parsing Qore code):

    @code
    ExceptionSink xsink, wsink;
    @endcode

    Then you can use the QoreProgramHelper class to manage QoreProgram objects.  The QoreProgramHelper class contains a QoreProgram object and calls QoreProgram::waitForTerminationAndDeref() in the destructor.  The constructor takes a pointer to an ExceptionSink object, so make sure that the ExceptionSink object has at least as long a scope as the QoreProgramHelper object, as follows:

    @code
    ExceptionSink xsink, wsink;
    {
       // creates and manages a QoreProgram object
       QoreProgramHelper pgm(&xsink);
       // ... rest of code here
    }
    @endcode

    Then the QoreProgramHelper object can be used like a QoreProgram object.  For example, to parse a file named "test.q" and run it, do the following:

    @code
    ExceptionSink xsink, wsink;
    {
       // creates and manages a QoreProgram object
       QoreProgramHelper pgm(&xsink);

       pgm->parseFile("test.q", &xsink, &wsink, QP_WARN_ALL);

       // display any warnings immediately
       wsink.handleWarnings();

       // execute program if there were no parse exceptions
       if (!xsink)
          pgm->run(&xsink);
    }
    // display any exceptions on stdout
    xsink.handleExceptions();
    @endcode

    There are many functions for parsing and running Qore code; see the QoreProgram class documentation for more information.

    @section module_dev Qore Module development

    @subsection module_header Module Header Info

    To develop a Qore module, several functions and several global variables must be declared in the module with public visibility so the module can be initialized and used by the Qore library.

    The global variables are as follows:
    - char \c qore_module_name[] - must give the name of the feature provided by the module.
    - char \c qore_module_version[] - must give the version of the module
    - char \c qore_module_description[] - a description of the module
    - char \c qore_module_author[] - the author of the module
    - char \c qore_module_url[] - a URL for the module
    - int \c qore_module_api_major - must be assigned to \ref QORE_MODULE_API_MAJOR
    - int \c qore_module_api_minor - must be assigned to \ref QORE_MODULE_API_MINOR

    The functions are as follows:
    - \ref qore_module_init_t \c qore_module_init - the module initialization function
    - \ref qore_module_ns_init_t \c qore_module_ns_init - the module namespace delta functions
    - \ref qore_module_delete_t \c qore_module_delete - the module deletion function

    @note All variables and all functions are required, even if the functions are empty.

    Here is an example:
    @code
    DLLEXPORT char qore_module_name[] = "ncurses";
    DLLEXPORT char qore_module_version[] = "0.1";
    DLLEXPORT char qore_module_description[] = "ncurses class module";
    DLLEXPORT char qore_module_author[] = "David Nichols";
    DLLEXPORT char qore_module_url[] = "http://qore.sourceforge.net";
    DLLEXPORT int qore_module_api_major = QORE_MODULE_API_MAJOR;
    DLLEXPORT int qore_module_api_minor = QORE_MODULE_API_MINOR;

    DLLEXPORT qore_module_init_t qore_module_init = ncurses_module_init;
    DLLEXPORT qore_module_ns_init_t qore_module_ns_init = ncurses_module_ns_init;
    DLLEXPORT qore_module_delete_t qore_module_delete = ncurses_module_delete;
    @endcode

    Note that the module name (or the module's feature name) as given by \c qore_module_name is used to uniquely identify the feature provided by the module.  Therefore if a module is loaded that provides feature "widget" and another module also claims to provided feature "widget", the second module cannot be loaded in the Qore library after the first has been loaded due to the duplicate feature name.

    The \c qore_module_api_major and \c qore_module_api_minor variables are used to determine if the module corresponds to the API (and ABI) of the Qore library trying to load it.

    @subsection module_functions Module Functions

    The module initialization function \c qore_module_init() will be run when the module is loaded by the Qore library.  If any errors occur when initializing the module, a description should be returned as a QoreString pointer (the library will own the pointer and delete it later).  If a non-zero pointer is returned by the \c qore_module_init() function, the feature will not be added to the Qore library and the module load will fail.

    If the module provides any namespaces, classes or constants, they will be added on demand to QoreProgram objects by calling the module's \c qore_module_ns_init() function.  In this case, the namespace additions should be initialized in the \c qore_module_init() function and copies should be provisioned in the \c qore_module_ns_init() function.  In particular classes must not be created more than once, because a Qore class gets a unique ID assigned when it is created, and this ID must be unique in the entire Qore library.

    Here are example functions from the ncurses module:

    @code
    // this is the reference namespace for the ncurses module
    static QoreNamespace NCNS("NCurses");

    // this function is called when the module is loaded
    QoreStringNode *ncurses_module_init()
    {
       // the NCurses reference namespace is set up here
       NCNS.addSystemClass(initWindowClass());
       NCNS.addSystemClass(initPanelClass());

       init_constants(&NCNS); // here constants are added to the NCurses namespace
    
       builtinFunctions.add("initscr",          f_initscr, QDOM_TERMINAL_IO);
       builtinFunctions.add("printw",           f_printw, QDOM_TERMINAL_IO);
       builtinFunctions.add("refresh",          f_refresh, QDOM_TERMINAL_IO);
       //... more builtin functions are added

       return 0;
    }

    // this function is called when the Qore library needs to provision the NCurses namespace 
    // to a new QoreProgram object (or to a QoreProgram object that existed before the module
    // was loaded by another QoreProgram object and then later requests the feature "ncurses")
    void ncurses_module_ns_init(QoreNamespace *rns, QoreNamespace *qns)
    {
       // add the NCurses namespace as a subnamespace to the Qore namespace
       qns->addInitialNamespace(NCNS.copy());
    }

    // this function is called when the module is deleted (when the qore library is closed)
    // it should free all resources allocated in the module's initilization function
    void ncurses_module_delete()
    {
       // calls endwin() if necessary
       q_nc_init.close();
    }
    @endcode

    @section builtin_functions Qore Builtin Functions

    To add a builtin function to the library, you have to call BuiltinFunctionList::add().  The BuiltinFunctionList class only contains static functions, but it can also be accessed through the global \c builtinFunctions object.

    Builtin functions must have the following signature:

    @code
    // "testfunction()" ignores all arguments and returns the string "testing"
    AbstractQoreNode *f_testfunction(const QoreListNode *params, ExceptionSink *xsink)
    {
       return new QoreStringNode("testing");
    }
    @endcode

    Then the function can be added to the library's builtin function list with the following command:
    @code
    builtinFunctions.add("testfunction", f_testfunction);
    @endcode

    @subsection handling_function_arguments Handling Function Arguments

    Use the inline functions in params.h to access function arguments.  These are:
    - num_params() - returns the number of arguments passed to the function
    - get_param() - returns the argument in the position given or 0 if there is none

    The following inline functions provide arguments of a specific type:
    - test_binary_param() - returns a const BinaryNode pointer or 0
    - test_string_param() - returns a const QoreStringNode pointer or 0
    - test_object_param() - returns a QoreObject pointer or 0
    - test_date_param() - returns a const DateTimeNode pointer or 0
    - test_hash_param() - returns a const QoreHashNode pointer or 0
    - test_list_param() - returns a const QoreListNode pointer or 0
    - test_funcref_param() - returns a const ResolvedFunctionReferenceNode pointer or 0
    - test_reference_param() - returns a const ReferenceNode pointer or 0
    - test_nothing_param() - returns true if there is no value at the given position

    Note that there are no functions for the integer (\ref NT_INT) and floating-point (\ref NT_FLOAT) types.  These values should be acquired as necessary using the AbstractQoreNode::getAsInt(), AbstractQoreNode::getAsBigInt(), and AbstractQoreNode::getAsFloat() functions to allow for transparent type conversion from other data types.

    Here are some examples:

    @code
    AbstractQoreNode *f_testfunction(const QoreListNode *params, ExceptionSink *xsink)
    {
       // get the first integer argument
       const AbstractQoreNode *p = get_param(params, 0);
       int64 i = p ? p->getAsBigInt() : 0;
       
       // get the second floating-point argument
       p = get_param(params, 1);
       double f = p ? p->getAsFloat() : 0.0;

       int64 rc = do_something(i, f);

       // returns an integer value
       return new QoreBigIntNode(rc);
    }
    @endcode

    To use a string value, but accept conversion from other data types, use the QoreStringValueHelper class.  This class is best for getting QoreString values or simply getting a "char *" for the converted value.  The QoreStringValueHelper class also provides a constructor that allows the target character encoding to be specified (there is an example in the class documentation).  If you need a QoreStringNode (\ref NT_STRING) value, then use the QoreStringNodeValueHelper class instead.

    Here is an example of interpreting a function argument as a string value using the QoreStringValueHelper class:

    @code
    AbstractQoreNode *f_testfunction(const QoreListNode *params, ExceptionSink *xsink)
    {
       // get a pointer to the first argument
       const AbstractQoreNode *p = get_param(params, 0);
       
       // this will convert p to a string if necessary
       QoreStringValueHelper str(p);

       // call a function with the "const char *" to the string buffer of str
       do_something(str->getBuffer());

       return 0;
    }
    @endcode

    To process arguments meant to be timeout values (or meant to specify a period of time) where an integer implies certain units (such as milliseconds or seconds) but also allow relative DateTimeNode (\ref NT_DATE) values to be processed, use the following functions:
    - getSecZeroInt(const AbstractQoreNode *a)
    - getSecZeroBigInt(const AbstractQoreNode *a)
    - getSecMinusOneInt(const AbstractQoreNode *a)
    - getSecMinusOneBigInt(const AbstractQoreNode *a)
    - getMsZeroInt(const AbstractQoreNode *a)
    - getMsZeroBigInt(const AbstractQoreNode *a)
    - getMsMinusOneInt(const AbstractQoreNode *a)
    - getMsMinusOneBigInt(const AbstractQoreNode *a)
    - getMicroSecZeroInt(const AbstractQoreNode *a)

    Each of the above functions returns an integer, assuming a certain unit for non DateTimeNode values, and also returns a default value if no argument was present (either 0 or -1). 

    The following is an example of using getMsZeroInt():

    @anchor MUTEX_lock
    @code
    static AbstractQoreNode *MUTEX_lock(QoreObject *self, SmartMutex *m, const QoreListNode *params, ExceptionSink *xsink)
    {
       // the the first argument
       const AbstractQoreNode *p = get_param(params, 0);

       // we only return a return value if we have a timeout, otherwise we save allocating a QoreBigIntNode
       if (!is_nothing(p)) {
          // get the timeout value in milliseconds from the argument
          int timeout_ms = getMsZeroInt(p);
	  // grab the lock with a timeout value
	  int rc = m->grab(xsink, timeout_ms);
	  // return the return code if there was no exception
	  if (!*xsink)
	     return new QoreBigIntNode(rc);
       }
       else // grab the lock unconditionally (without a timeout)
          m->grab(xsink); 

       return 0;
    }
    @endcode

    @subsection function_return_value Function Return Value

    Each Qore function should return a pointer to an AbstractQoreNode giving the return value of the function.  If the function does not return a value, then it should simply return 0 as follows:

    @code
    // "testfunction()" ignores all arguments and returns no value
    AbstractQoreNode *f_testfunction(const QoreListNode *params, ExceptionSink *xsink)
    {
       return 0;
    }
    @endcode

    Otherwise, the pointer's reference count will be owned by the caller of builtin function, so returning a descendent of AbstractQoreNode created with the C++ new operator is OK, otherwise you have to make sure that the value returned by the builtin function is referenced for the return.  In other words, returning AbstractQoreNode descendents that have an incremented reference count is OK, but, for example, to return an argument of the function as the return value of the function, you have to increment the reference count manually -- the easiest way to do this is to call AbstractQoreNode::refSelf() on the value to be returned, as in the following example:

    @code
    static AbstractQoreNode *f_return_first_argument(const QoreListNode *params, ExceptionSink *xsink)
    {
       const AbstractQoreNode *p = get_param(params, 0);
       return p ? p->refSelf() : 0;
    }
    @endcode

    See the section below on Handling Qore Data for more information.
    
    @subsection function_raising_exceptions Raising Exceptions in a Function

    If your function raises an exception, then you must call ExceptionSink::raiseException() against the ExceptionSink argument to the function.  In the case that your function raises a Qore-language exception, the function must \b always return 0 as a return value.  The following is an example:

    @code
    static AbstractQoreNode *f_remove_signal_handler(const QoreListNode *params, ExceptionSink *xsink)
    {
       const AbstractQoreNode *p0 = get_param(params, 0);
       int signal = p0 ? p0->getAsInt() : 0;
       if (!signal || signal > QORE_SIGNAL_MAX) {
          xsink->raiseException("REMOVE-SIGNAL-HANDLER-ERROR", "%d is not a valid signal", signal);
	  return 0;
       }
       QoreSignalManager::removeHandler(signal, xsink);
       return 0;
    }
    @endcode

    @section handling_data Handling Qore Data

    All data value in Qore (and, in fact, all elements of Qore parse trees) are descended from AbstractQoreNode.

    The following are the basic data types in Qore, implemented as C++ classes descended from AbstractQoreNode, and their type codes, accessed via AbstractQoreNode::getType():
    - QoreBoolNode (\ref NT_BOOLEAN) for the boolean data type
    - QoreBigIntNode (\ref NT_INT) for the 64-bit integer data type
    - QoreFloatNode (\ref NT_FLOAT) for the double-precision floating-point type
    - QoreStringNode (\ref NT_STRING) for the string data type
    - DateTimeNode (\ref NT_DATE) for the date/time data type
    - BinaryNode (\ref NT_BINARY) for the opaque binary data type
    - QoreNothingNode (\ref NT_NOTHING) for a type signifying no value (also equivalent to 0!)
    - QoreNullNode (\ref NT_NULL) for the SQL NULL data type
    - QoreHashNode (\ref NT_HASH) for an associative array or hash data type
    - QoreListNode (\ref NT_LIST) for a list or array data type
    - QoreObject (\ref NT_OBJECT) for the data type representing the instantiation of a Qore class (QoreClass)

    Additionally, the following classes are exposed in the library:
    - ReferenceNode (\ref NT_REFERENCE)
    - AbstractFunctionReferenceNode (\ref NT_FUNCREF)

    @see node_types.h for a complete list of all type codes.

    @subsection simple_value_types Simple Value Types: QoreBigIntNode, QoreFloatNode, QoreStringNode, DateTimeNode, BinaryNode

    The QoreBigIntNode, QoreFloatNode, QoreStringNode, DateTimeNode, BinaryNode and classes are reference counted and can only be dynamically allocated.

    They are all descendents of SimpleQoreNode, meaning that dereferencing their objects cannot cause a Qore-language exception to be thrown, therefore the SimpleRefHolder class can be used to manage temporary references to objects of these types.

    For example:

    @code
    {
       // here a QoreBigIntNode value is returned with an incremented reference count
       SimpleRefHolder<QoreBigIntNode> qint(getQoreBigIntNode());
       printf("the result is: %lld\n", qint->val);
       // when qint goes out of scope, the reference count is decremented
    }
    @endcode

    @subsection unique_value_types Unique Value Types: QoreBoolNode, QoreNullNode, QoreNothingNode

    None of these classes can be directly instantiated with the new operator.  They are all represented by single objects managed directly by the Qore library.  Each of these classes represents a type that has only one value, therefore as a memory and performance optimization, reference counting is disabled for these objects.  Actually in the case of QoreBoolNode the subclasses QoreBoolTrueNode and QoreBoolFalseNode have actual instantiations.

    For the QoreBoolNode class, you can use these objects by referring to the global \ref True and \ref False objects, or by calling get_bool_node() as follows in the example function:

    @code
    static AbstractQoreNode *f_convert_first_argument_to_bool(const QoreListNode *params, ExceptionSink *xsink)
    {
       const AbstractQoreNode *p = get_param(params, 0);
       return get_bool_node(p ? p->getAsBool() : false);
    }
    @endcode

    Or, some even simpler functions:

    @code
    static AbstractQoreNode *f_return_true(const QoreListNode *params, ExceptionSink *xsink)
    {
       return &True; // QoreBoolNode objects are not reference counted (reference counting operations are ignored)
    }

    static AbstractQoreNode *f_return_false(const QoreListNode *params, ExceptionSink *xsink)
    {
       return &False; // QoreBoolNode objects are not reference counted (reference counting operations are ignored)
    }
    @endcode

    Similarly, for QoreNullNode there is the global \ref Null object or the inline function null() that returns a pointer to this object.

    QoreNothingNode has the gobal \ref Nothing object and the inline function nothing() that returns a pointer to it as well.

    @note that in Qore a C++ null pointer (0) is the same as \c NOTHING, therefore the inline function is_nothing() should always be used to test for \c NOTHING.

    @subsection container_types Container Value Types: QoreHashNode, QoreListNode, QoreObject

    The QoreHashNode, QoreListNode, and QoreObject classes define container types in Qore.  QoreObject objects in particular could throw an exception when dereferenced (if the object goes out of scope and its destructor is run, the destructor could throw an exception).  Because container types can hold any type, when they are deferenced it could cause a QoreObject to go out of scope, and therefore the possibility that a Qore-language exception could be thrown must be taken into consideration.  Therefore, to dereference these objects a pointer to an ExceptionSink object must be passed to AbstractQoreNode::deref().
    
    The ReferenceHolder class can be used to manage temporary reference counts as follows:

    @code
    {
       // here a QoreHashNode value is returned with an incremented reference count
       // note that xsink must be "ExceptionSink *"
       ReferenceHolder<QoreHashNode> qhash(getQoreHashNode(), xsink);
       printf("there are %ld elements in the hash\n", qhash->size());
       // when qhash goes out of scope, the reference count is decremented
    }
    @endcode

    @subsection qoreobject Object Value Type: QoreObject

    QoreObject is special in that the implementation for objects in Qore mirrors that of Java, in that objects are pased by reference when used as function or method arguments, unlike other types.  However, like Java, the reference to the object is passed, and not the variable, so, while an object passed as an argument to a function can be modified by that function (modifications are made to the original object), in order to write a swap method, for example, you would need to pass the variables by reference (or the lvalue expression by reference, as the case may be) to the swap function.  Unlike Java, Qore does support passing arguments by reference.

    @section class_implementation Implementing Qore Classes

    In order to implement a Qore-language class, you have to create an object of type QoreClass and add it somewhere to a namespace to be included in QoreProgram objects.  In a module, for example, this is done by adding the class the reference namespace in the \c module_init() function.

    Once the QoreClass object has been created, the class' unique class identifier should be saved and all methods should be added to the class object, as in the following example:

    @code
    // returns the QoreClass definition for the "Mutex" class to be added to the Qore system namespace
    QoreClass *initMutexClass()
    {
       // creates the QoreClass object representing the "Mutex" class
       QoreClass *QC_MUTEX = new QoreClass("Mutex", QDOM_THREAD_CLASS);

       // save the class ID for use in the constructor method
       CID_MUTEX = QC_MUTEX->getID();

       // set the constructor method
       QC_MUTEX->setConstructor(MUTEX_constructor);

       // set the destructor method
       QC_MUTEX->setDestructor((q_destructor_t)MUTEX_destructor);

       // set the copy method
       QC_MUTEX->setCopy((q_copy_t)MUTEX_copy);

       // set the regular methods of the class
       QC_MUTEX->addMethod("lock",          (q_method_t)MUTEX_lock);
       QC_MUTEX->addMethod("trylock",       (q_method_t)MUTEX_trylock);
       QC_MUTEX->addMethod("unlock",        (q_method_t)MUTEX_unlock);

       // return the new class to be added to the Qore system namespace
       return QC_MUTEX;
    }
    @endcode

    @subsection constructor_methods Constructor Methods

    The goal of the constructor method is to create and save the object's private data against the QoreObject object representing the object in Qore by using the class ID.

    A Qore object's private data must be descended from the AbstractPrivateData class.  Normally the actual class implementation is made as the class representing the private data, and the bindings to Qore are provided as the QoreClass methods.  This way, the methods added to QoreClass can handle Qore-language argument processing and the actual work of the method can be performed by the class repsenting the object's private data.

    Here is an example for the Mutex class (note that all constructor method arguments are ignored, for argument handling see the section on function argument handling), for each method in the class the SmartMutex class performs the actual work:

    @code
    static void MUTEX_constructor(QoreObject *self, const QoreListNode *params, ExceptionSink *xsink)
    {
       // unconditionally save the SmartMutex object as the private data for the QoreObject 
       // using the class ID CID_MUTEX as saved in initMutexClass()
       self->setPrivate(CID_MUTEX, new SmartMutex());
    }
    @endcode

    If there are any Qore-language exceptions raised in the constructor, it's important that no private data is saved against the object, therefore all setup and argument processing code should be executed before the QoreObject::setPrivate() function is run.

    @subsection copy_methods Copy Methods

    Copy methods are similar to constructor methods, in so far as they also should create and save private data representing the state of the object against the QoreObject object by using the class ID.  Copy methods also get a pointer to the original object and the original private data to facilitate the copy operation.

    Like constructors, if a Qore-language exception is raised in the copy method, no private data should be stored against the new QoreObject.

    The original object should not be modified by a copy method.

    Here is an example of the Mutex' class copy method:

    @code
    static void MUTEX_copy(QoreObject *self, QoreObject *old, SmartMutex *m, ExceptionSink *xsink)
    {
       // the "old" and "m" parameters representing the old object are ignored
       self->setPrivate(CID_MUTEX, new SmartMutex());
    }
    @endcode

    Notice that the third parameter of the function is defined as "SmartMutex *" and not as "AbstractPrivateData *".  This is for convenience to avoid a cast in the function, there is a cast when the copy method is assigned to the QoreClass object as follows:

    @code
    // set the copy method
    QC_MUTEX->setCopy((q_copy_t)MUTEX_copy);
    @endcode

    @note Copy methods are run after the object's hash members have already been copied to the new QoreObject

    @subsection destructor_methods Destructor Methods

    Destructor methods are optional.  If no destructor method is defined, then the private data's AbstractPrivateData::deref(ExceptionSink *) method is run when the destructor would otherwise be run.  This is suitable for objects that simply expire when the last reference count reaches zero and where the destructor takes no action (the qore library will mark the object as deleted when the destructor is run anyway, so no more access can be made to the object after the destructor is run even if the reference count is not zero).

    If the destructor could throw an exception, or should otherwise take some special action, then a destructor method must be defined in the class.  In this case, the destructor method must also call AbstractPrivateData::deref() on it's private data.

    The Mutex class can throw an exception when deleted (for example, if a thread is still holding the lock when the object should be deleted), here is the code:

    @code
    static void MUTEX_destructor(QoreObject *self, SmartMutex *m, ExceptionSink *xsink)
    {
       // run the actual destructor code implemented in SmartMutex
       m->destructor(xsink);

       // dereference the SmartMutex private data
       m->deref(xsink);
    }
    @endcode

    As with the copy method, a cast is used when the destructor is assigned to the QoreClass object as follows:

    @code
    // set the destructor method
    QC_MUTEX->setDestructor((q_destructor_t)MUTEX_destructor);
    @endcode

    @subsection regular_class_methods Regular Class Methods

    Regular, or non-special class methods (the constructor, destructor, and copy method are special methods, all other methods are regular methods; note that it's currently not possible to define builtin memberGate or methodGate methods, this restriction will be lifted in a future version of the Qore library) are defined in a similar manner.  A pointer to the QoreObject is passed to the method, along with the private data and an ExceptionSink pointer in case the method needs to raise a Qore-language exception.

    As with functions, if the method raises a Qore-language exception against the ExceptionSink pointer, the return value should be 0.  Argument handling is the same as with builtin functions.

    Previously the \ref MUTEX_lock function implementation (for Qore class method Mutex::lock()) was given as an example, and here you can see how it's bound to the QoreClass object:

    @code
       QC_MUTEX->addMethod("lock",          (q_method_t)MUTEX_lock);
    @endcode

    Note the cast to q_method_t so that "SmartLock *" can be given directly in the function signature.

    @subsection object_threading_issues Threading Issues in Class Implementation

    Note that the highly-threaded nature of Qore means that all Qore code including classes can be executed in a multi-threaded context.  By using atomic reference counts, the qore library guarantees that the private data object will stay valid during the execution of each method, however any method could be executed in parallel with any other method.

    @note the only exception to this rule is the contructor, which is always executed in a single thread without the possibility of access in another thread, as no pointers to the object are yet available outside this method.

    Therefore it's also possible that a class method could be in progress while the destructor method is run.  If your class should guarantee that the destructor (or any other method) should run with exclusive access to the object, then appropriate locking must be implemented in the implementation of the private data class (descended from AbstractPrivateData).

   @subsection class_hierarchies Implementing Class Hierarchies

   There are two methods of implementing class hierarchies in builing classes in Qore:
   - use QoreClass::addDefaultBuiltinBaseClass() to use a base class' private data in the child clas
   - use QoreClass::addBuiltinVirtualBaseClass() to speficy that the child class' private data is a child of the parent's private data class

   One of these functions (but never both for the same QoreClass object) must be called when setting up the QoreClass object.  However, they have very different implications for handling private data in the class implementation.

   After executing QoreClass::addDefaultBuiltinBaseClass(), this tells the Qore library that this child class will not save its own private data against the QoreObject.  Instead, the private data from the parent class will be passed to all methods.  The constructor method of the child class should not save any private data against the QoreObject.

   Here is an example of the XmlRpcClient class implementation calling QoreClass::addDefaultBuiltinBaseClass() to add the HTTPClient class as the default base class:

   @code
   // to set up the XmlRpcClient class, a pointer to the HTTPClient class implementation is passed as an argument
   QoreClass *initXmlRpcClientClass(QoreClass *http_client)
   {
      // create the XmlRpcClient QoreClass object
      QoreClass* client = new QoreClass("XmlRpcClient", QDOM_NETWORK); 

      // get the class ID (although it's not used anywhere at the moment)
      CID_XMLRPCCLIENT = client->getID();

      // add the HTTPClient class as the default base class
      client->addDefaultBuiltinBaseClass(http_client);

      // set the constructor
      client->setConstructor(XRC_constructor);

      // set the copy method
      client->setCopy((q_copy_t)XRC_copy);

      // add the regular methods
      client->addMethod("callArgs", (q_method_t)XRC_callArgs);
      client->addMethod("call",     (q_method_t)XRC_call);
      
      // return the new class implementation
      return client;
   }
   @endcode

   However, the parent's constructor will have already been run by the time the child's constructor is run, so the parent's private data may be retrieved and modified by the child' constructor, for example as in the implementation of the XmlRpcClient class in the Qore library (which adds the HTTPClienht as the default base class) as follows:

   @code
   static void XRC_constructor(QoreObject *self, const QoreListNode *params, ExceptionSink *xsink)
   {
      // get HTTPClient object's private data
      safe_httpclient_t client((QoreHTTPClient *)getStackObject()->getReferencedPrivateData(CID_HTTPCLIENT, xsink), xsink);
      if (!client)
         return;

      // set options for XML-RPC communication
      client->setDefaultPath("RPC2");
      client->setDefaultHeaderValue("Content-Type", "text/xml");
      client->setDefaultHeaderValue("Accept", "text/xml");
      client->setDefaultHeaderValue("User-Agent", "Qore XML-RPC Client v" PACKAGE_VERSION);
      
      client->addProtocol("xmlrpc", 80, false);
      client->addProtocol("xmlrpcs", 443, true);

      // set user-defined options if the options hash is present
      const QoreHashNode* n = test_hash_param(params, 0);
      if (n && client->setOptions(n, xsink))
         return;

      // connect to the client in the constructor
      client->connect(xsink); 
   }
   @endcode

   To add a parent class and specify that the child class' private data is actually a descendent of a parent class' private data, call QoreClass::addBuiltinVirtualBaseClass().

   In this case, the parent class' constructor will never be called.  The child class' constructor is responsible for saving the private data against the QoreObject, and when the parent class' methods are called, the child class' private data is passed to the parent class' method functions.

   This means that the child class' private data must be directly descended from the parent class' private data class, and objects of the child class' private data class must be valid pointers of the parent class' private data class as well.

   In this case the parent class' copy and destructor methods also will not be run.

   Here is an example (in the Qt module) of the QWidget class adding two builtin virtual base classes:

   @code
   QoreClass *initQWidgetClass(QoreClass *qobject, QoreClass *qpaintdevice)
   {
      QC_QWidget = new QoreClass("QWidget", QDOM_GUI);
      CID_QWIDGET = QC_QWidget->getID();

      // set QObject as a virtual base class
      QC_QWidget->addBuiltinVirtualBaseClass(qobject);
      // set QPaintDevice as a virtual base class
      QC_QWidget->addBuiltinVirtualBaseClass(qpaintdevice);
      
      QC_QWidget->setConstructor(QWIDGET_constructor);
      QC_QWidget->setCopy((q_copy_t)QWIDGET_copy);

      QC_QWidget->addMethod("acceptDrops",                  (q_method_t)QWIDGET_acceptDrops);

      // more methods added...

      return QC_QWidget;
   }
   @endcode

   In this case the class' constructor, copy, and destructor methods are implemented normally, and the constructor, copy, and destructor methods of the parent classes (in this case QObject and QPaintDevice) are never run, instead the child class' special methods must take care to provide all the required functionality of the parent class' special methods.
 
   @section dbi_drivers Implementing DBI Qore Drivers

*/
