/** @page description Language Description

    @section desc_contents Contents of this Section
    - @ref desc_overview
    - @ref environment_variables
    - @ref conditional_parsing
    - @ref modules
    - @ref include_files
    - @ref identifiers
    - @ref comments
    - @ref variables
    - @ref basic_data_types
      - @ref boolean
      - @ref string
      - @ref integer
      - @ref float
      - @ref date
      - @ref binary
      - @ref null
      - @ref nothing
    - @ref container_data_types
      - @ref list
      - @ref hash
      - @ref object
    - @ref data_type_declarations
    - @ref overloading
    - @ref time_zones
    - @ref character_encoding
    - @ref expressions
    - @ref operators
    
    @section desc_overview Language Overview

    A %Qore program is composed of a series of declarations, statements, function definitions, and/or class definitions. Non-block statements are terminated by a semi-colon ";". Block statements are grouped by using curly brackets ("{" and "}"), as in C, C++, Java, and Perl.

    Programmers familiar with C, C++, Java, and/or Perl should find the standard %Qore syntax intuitive and should be productive fairly quickly with the language. However %Qore has unique features that differentiate it from other languages, and these features must be mastered in order to leverage the full power of %Qore.

    %Qore programs/scripts are free form. Formatting does not affect the execution of the program; formatting is at the discretion of the programmer and should be used to enhance readability and clarity of the source code.

    %Qore was created as a weakly typed language. That means that @ref variables "variables" (without type restrictions) can hold values of any type and functions (without a return type restriction or parameter type descriptions) can return any data type and take arguments of any type. Furthermore list elements can be of any type (they do not have to be uniform), and multidimensional lists can have a different number of elements in each list. The same type flexibility holds true of hashes, objects, and all combinations of container types.

    %Qore also allows variable, parameter, class member, and return types to be declared, so that APIs can be formally defined or the programmer can decide to declare types to catch more errors at parse time (which is often preferable to discovering a type error at runtime).

    %Qore can be used as a traditional function-based scripting language or as a pure object-oriented language, where the application is defined as a class. Aside from traditional local and global variables, constants, and functions, %Qore also supports nested @ref namespaces "namespaces", @ref classes "classes", @ref inheritance "multiple inheritance", overriding base class constructor arguments, public and private @ref class_members "members" and @ref class_methods "methods", @ref static_class_methods "static class methods", and @ref static_class_variables "static class variables".

    All elements of %Qore are designed to work together: @ref Qore::Datasource "database access", @ref Qore::Socket "socket communication", @ref Qore::Program "embedding logic in subprograms", @ref regular_expressions "regular expressions", @ref operators "operators", @ref function_library "functions", and all other elements are thread-safe and built on an execution engine that was designed for SMP scalability.

    %Qore automatically converts data types when necessary when evaluating operators. The goal is to provide the expected result for the programmer without requiring the programmer to explicitly convert data types. Please see @ref operators for more information.

    %Qore supports @ref signal_handling "signal handling" by executing %Qore-language signal handlers in special single-handling thread.

    UNIX operating systems allow an executable script to specify their interpreter. This is done by setting the first line in the program to a special string indicating the location of the %Qore binary. For the purposes of this document, the location for the %Qore binary is assumed to be \c /usr/bin/qore. The first line of %Qore scripts in this case should look as follows:

    @code
#!/usr/bin/qore
    @endcode

    If another installation directory is used (such as \c /usr/local/bin), then the correct path must be reflected in the first line of the %Qore script.

    %Qore convention dictates that %Qore script file names end with \c ".q".

    @section environment_variables Environment Variables

    This section will outline the environment variables that are used by %Qore.

    <b>%Qore Environment Variables</b>
    |!Environment Variable|!Description
    |\c QORE_AUTO_MODULE_DIR|This environment variable should contain a colon-separated list of directories which will be searched for %Qore modules when %Qore starts. If any modules are found in any of these directories, they are loaded automatically before any parsing starts.
    |\c QORE_MODULE_DIR|This environment variable should contain a colon-separated list of directories which will be searched when modules are loaded with the @ref requires "%requires" parse directive
    |\c QORE_INCLUDE_DIR|This variable should be a colon-separated list of directories where the %Qore binary should look for include files
    |\c QORE_CHARSET|If this variable is set, then the default character encoding name for the process will be the value of this variable. This variable takes precedence over the \c LANG variable, but can be overridden by the command line using option \c --charset (see @ref character_encoding for more information on this option)
    |\c LANG|If this variable is set and includes a character encoding specification, then, if the \c QORE_CHARSET variable is not set (and no character encoding was specified on the command line), this character encoding will be the default for the process.

    @section conditional_parsing Conditional Parsing and Parse Defines

    %Qore supports conditional parsing with parse defines similar to the C/C++ preprocessor. In the current version of %Qore, the implementation is very simple; only the following parse directives are supported: @ref define "%define", @ref else "%else", @ref endif "%endif", @ref ifdef "%ifdef", and @ref ifndef "%ifndef".

    Basically, the above allow for the existence (or lack thereof) of a parse define to affect which code is parsed into the program at parse time.

    Parse defines are defined on the command-line (or through the C++ API when executed in embedded code), as well as created automatically based on sytem options; all library options (if the option is \c True, then it is defined as \c True, if the option is \c False, then it is not defined at all).

    Note that \c "Unix" is defined on all Unix platforms (also on Cygwin), while \c "Windows" is defined on native Windows ports (but not on Cygwin, as this is treated as Unix when compiling, as all Unix features are available).

    Additionally, the following options are defined in every program (however they are not yet useful when parsing as the value of parse options cannot be used yet at parse time; only the existence or lack thereof can affect parsing in this version of %Qore when parsing at least).

    <b>%Qore Parse Defines</b>
    |!Define|!Value
    |\c %QoreVersionString|Version string for the %Qore library
    |\c %QoreVersionMajor|Major version for the %Qore library
    |\c %QoreVersionMinor|Minor version for the %Qore library
    |\c %QoreVersionSub|Sub version for the %Qore library
    |\c %QoreVersionBuild|Build version for the %Qore library
    |\c %QoreVersionBits|32 or 64 depending on the library target
    |\c %QorePlatformCPU|The CPU targeted by the library
    |\c %QorePlatformOS|The OS targeted by the library

    Additionally, only if the %Qore library was compiled with debugging support, the following parse define is present (otherwise it is not defined):

    <b>%Qore Optional Parse Defines</b>
    |!Define|!Value
    |\c %QoreDebug|\c True

    Here is an example of using parse defines in a program:

    @code
%ifndef HAVE_TERMIOS
printf("This program requires UNIX TermIOS features to be present; it does not run on platforms without this feature (current platform: %s); exiting...\n", Qore::PlatformOS);
exit(1);
%endif
    @endcode

    Furthermore, parse defines can be manipulated in embedded code using the following functions:
    - Qore::Program::define()
    - Qore::Program::getDefine()
    - Qore::Program::isDefined()
    - Qore::Program::undefine()

    @section modules Qore Modules
    
    %Qore modules allow the %Qore language to be extended at run-time. %Qore modules must conform to the %Qore Module API and have the file extension \c "*.qmod". %Qore modules normally depend on other shared libraries and therefore can only be loaded if the libraries they require are present on the system and can be found in the library path.

    Please note that as of version 0.7.0 onwards, modules are no longer delivered with the %Qore library. Modules must be downloaded separately; see <a href="http://www.qore.org">%Qore's home page</a> for more information.

    To load a module at parse time (normally required for most modules), use the @ref requires "%requires" parse directive. If the named feature is not already present in %Qore, %Qore looks for a module with this name in the directories listed in the \c QORE_MODULE_DIR environment variable (see @ref environment_variables).

    Use the load_module() function to load %Qore modules at run-time; however, note that any module providing parse support (classes, constants, functions, etc) must be loaded at parse time using the @ref requires "%requires" directive.

    From %Qore 0.7.1 onwards, you can specify a comparison operator (one of < <=, =, >=, or >) and version information after the module name as well. Version numbers are compared via integer comparisons of each element, where elements are separated by a '.'. If one of the versions does not have as many elements as another, the missing elements are assumed to be '0' (i.e. version \c "1.0" compared with version \c "1.0.1" will be exteneded to "1.0.0").

    Also note that DBI drivers are loaded on demand by the @ref Qore::Datasource and @ref Qore::DatasourcePool classes.

    At the time of writing this documentation, the following modules exist for %Qore:

    <b>%Qore Modules</b>
    |!Module|!Description
    |\c asn1|Provides ASN.1 functionality to %Qore
    |\c xml|Provides XML, XPath, etc functionality to %Qore.
    |\c xmlsec|Provides xmldsig and xmlenc functionality to %Qore.
    |\c json|Provides JSON functionality to %Qore.
    |\c ssh2|Provides SSH2 and SFTP functionality to %Qore.
    |\c tibrv|Provides TIBCO Rendezvous(R) (TIBCO, Inc) functionality to %Qore.
    |\c tibae|Provides TIBCO ActiveEnterprise(TM) (TIBCO, Inc) functionality to %Qore.
    |\c tuxedo|Provides Oracle (ex Bea) Tuxedo functionality to %Qore.
    |\c mysql|Provides a MySQL DBI driver to %Qore.
    |\c pgsql|Provides a PostgreSQL DBI driver to %Qore.
    |\c sqlite3|Provides a SQLite3 DBI driver to %Qore.
    |\c sybase|Provides a Sybase DBI driver to %Qore.
    |\c freetds|Provides a FreeTDS-based DBI driver to %Qore.
    |\c oracle|Provides an Oracle DBI driver to %Qore.
    |\c db2|Provides an IBM DB2 driver to %Qore.
    |\c glut|Provides GLUT functionality to %Qore.
    |\c opengl|Provides an OpenGL API to %Qore.
    |\c qt4|Provides Nokia (formerly Trolltech) QT4 APIs for GUI development in %Qore.
    |\c ncurses|Provides curses APIs to %Qore.
    |\c yaml|Provides YAML functionality to %Qore.

    @section include_files Include Files

    A %Qore program can include other program code to be used and executed in the current program by using the @ref include "%include" directive. The @ref include "%include" directive must be the first text on the line, and the file name to include must follow. All text on the line after the @ref include "%include" directive will be used for the file name to include. The file name should not be quoted.

    Here is an example:

    @code
#!/usr/bin/qore
%include /usr/qore/lib/functions.ql
    @endcode

    After this, any variable, function, namespace, constant, or object declared in the above file can be used by the %Qore program.

    The \c QORE_INCLUDE_DIR environment variable determines the search path for include files (see @ref environment_variables).

    @section identifiers Identifiers

    %Qore identifiers must start with an alphabetic character, and then may contain any number of alphabetic, numeric, or "_" characters. There is no length limit on %Qore identifiers.

    All %Qore identifiers are case-sensitive, therefore the identifier \c hello_there is not the same as \c Hello_There or \c HELLO_THERE.

    The following are examples of valid %Qore identifiers:

    <b>Examples of Valid %Qore Identifiers</b>
    |!Identifier|!Description
    |\c i|Simple one-character identifier
    |\c foo21|Identifier with number
    |\c this_is_a_long_identifier|Long identifier with underline characters
    |\c Total_318|Identifier with underline and number
    |\c AVeryBigNumber|Mixed case identifier name
    |\c CAPS|Identifier in all capital letters

    The following are invalid identifiers:

    <b>Examples of Invalid %Qore Identifiers</b>
    |!Identifier|!Description
    |\c 1a|Does not start with an alphabetic character
    |\c this-and-that|Contains "-" characters
    |\c Start#10|Contains "#" character

    @section comments Comments

    Comments are allowed in %Qore scripts; line comments are preceded by a hash \c "#", and block comments are made C-style, ex:

    @code
# this is a line comment
/* 
   this is a block comment 
*/
    @endcode

    For line comments, all text following a hash until the end-of-line character \c "\n" is considered a part of the comment.

    For block comments, all text in the block comment is ignored by the parser.

    Here is an example %Qore script containing comments:

    @code
#!/usr/bin/env qore
#
# these are line comments
# another line comment

/*
   --- this text is in block comments
   print("hello"); <- this won't get executed 
   --- because it's in the block comment
*/
    @endcode

    @section variables Variables

    Unless parse option @ref allow-bare-refs "%allow-bare-refs" or @ref new-style "%new-style" are set, variables are %Qore identifiers prefixed by a \c "$" sign, similar to <a href="http://www.perl.org">Perl</a>. If a variable is declared without any type restriction, then it is assumed to have type @ref any_type "any". In this case, variables so declared can hold any data type.

    @subsection special_variables

    A few variables are set by the %Qore language during the execution of %Qore programs. These are normal variables that can be reassigned to other values by the user if necessary.

    <b>Special %Qore Variables</b>
    |!Variable|!Scope|!Data Type|!Explanation
    |\c $argv|Local|List|automatically assigned local variable containing the list of function or method arguments that were not assigned to parameter variables (see @ref functions_and_implicit_arguments for more information)
    |\c $ARGV|Global|List|script command-line arguments (use the @ref Qore::GetOpt class to parse command-line arguments)
    |\c $QORE_ARGV|Global|List|complete qore command-line arguments
    |\c $ENV|Global|Hash|UNIX program environment

    @note As of version 0.5.0, \c $STDERR and \c $STDOUT have been removed from %Qore. Use the I/O constants @ref stderr, @ref stdout, and @ref stdin constants of the @ref Qore::File class instead.

    @subsection variable_declarations Variable Declarations and Lexical Scope

    Unless the @ref assume-local "%assume-local" parse directive is used, variables not in a parameter list automatically have global scope unless the first reference is prefixed with @ref my. Variable names in a parameter list are always local to their associated function, method, or catch block. Global variables can be explicitly declared with @ref our. The @ref our keyword is required if the parse option @ref require-our "%require-our" (\c -O or \c --require-our command-line option) is set for the parent program. See @ref parse_options for more information.

    When the @ref assume-local "%assume-local" parse directive is used, variables without an explicit scope declaration (i.e. @ref my or @ref our) are assumed to be local variables.

    Variables may be assigned any value unless restricted with a type declaration. If no type declaration is given, then the variable is assumed to be type @ref any_type "any". Note that type declarations are required for all variables (and for function and method parameters and class members) when the @ref require-types "%require-types" parse option is set.

    Local variables are not shared between threads (local variables have a distinct value in each thread), however global variables are. See @ref threading (and in particular @ref threading_and_variables) for more information.

    For example (in the following script, the @ref our keyword is optional):

    @code
#!/usr/bin/qore
#
# variable scoping example

our int $a = 1;                    # this is a global variable
our (string $b, any $c, hash $d);  # list of global variables

if ($a == 1) {
    my int $a = 2; 
    my (string $b, any $c);
    # $a, $b, and $c are local variables, 
    # the use of which will not affect the 
    # global variables of the same name
    print("local a = %d\n", $a); 
}

print("global a = %d\n", $a); 
    @endcode

    The first print() statement will output:
    @verbatim
local a = 2@endverbatim

    The second print() statement will output:
    @verbatim
global a = 1@endverbatim

    @note If parse option @ref allow-bare-refs "%allow-bare-refs" is set, then variable references <b>must</b> be made without the "$" character.

    @section basic_data_types Basic Data Types

    The following are the basic data types in %Qore (see @ref container_data_types for container data types):

    <b>Basic Data Types</b>
    |!Type|!Description|!Example|!Default Value
    |@ref boolean|\c True or \c False value|\c True|\c False
    |@ref string|A sequence of characters with an encoding|\c "string"|Empty string (i.e. \c "")
    |@ref integer|A 64-bit signed integer|\c 1|\c 0
    |@ref float|A double-precision floating-point number|\c 1.00023|\c 0.0
    |@ref date|A date/time value with an optional time zone component, with resolution to the microsecond|\c 2010-05-10T18:35:21.001456-07:00|\c 1970-01-01Z
    |@ref binary|An opaque binary object|<tt><23deadbeef></tt>|an empty object of size 0
    |@ref null|Corresponds to a \c NULL value in a database query (not equivalent to @ref nothing|\c NULL|\c NULL
    |@ref nothing|Represents the state of a variable having no value or function returning no value (not equivalent to @ref null)|\c NOTHING|\c NOTHING

    @subsection boolean Boolean

    The Boolean type can have two values, \c True and \c False.

    When converting other types to a Boolean, any value that converts to a non-zero integer will be evaluated as \c True. Otherwise the result of the conversion will be \c False.

    @see @ref bool_type, @ref softbool_type

    @subsection string String

    String values are specified with text between double or single quotes. Text between double quotes is subject to interpretation of escape characters; text between single quotes is not with the exception of the single quote character, which may be escaped (ex: <tt>'hello \'there\''</tt>).

    Strings are assumed by default to have the encoding given by the \c QORE_CHARSET or the \c LANG environment variable (see @ref environment_variables). If neither of these variables is set, then all strings will be assumed to have \c UTF-8 encoding.

    For detailed information on %Qore character encoding handling, please see @ref character_encoding.

    It is legal to specify a string literal with newline characters like the following:

    @code
$str = "this string
on more than 1 line";
    @endcode

    Internally, strings are stored as a pointer to the string data, an unsigned integer giving the length of the string, and a pointer to an encoding object, giving the string's character encoding.

    @see @ref string_type, @ref softstring_type

    @subsection integer Integer

    %Qore integers are 64-bit signed integers.

    @see @ref int_type, @ref softint_type

    @subsection float Float

    %Qore floats are double precision floating-point numbers (C/C++ type double), normally a 64-bit value.

    @see @ref float_type, @ref softfloat_type

    @subsection date Date

    %Qore dates have a time component supporting a resolution to the microsecond and can be either absolute or relative.

    @see @ref date_and_time_functions for a list of functions related to date/time processing.

    @subsection absolute_dates Absolute Date/Time Values
    Absolute date/time values specify a specific point in time in a certain time zone, such as January 1, 2005 10:35:00 +01:00. They are stored interally as a 64-bit signed offset from the %Qore epoch (\c 1970-01-01Z), a positive 4-byte integer for microseconds, and a pointer to a time zone description object that provides the UTC offset and daylight savings time information (see @ref time_zones for more information). Note that all absolute date/time values in %Qore are stored internally in UTC and are converted for display purposes to the representation of wall time in their tagged time zone.

    Absolute date/time values can be specified with a syntax based on ISO-8601 date formats as follows:

    @verbatim
YYYY-MM-DD[THH:mm:SS[.n*]][Z|[+-]HH[:mm[:SS]]]@endverbatim

    Note that if no time zone information is given, the local time zone will be assumed. If a time zone UTC offset is given, it is given in units of time east of UTC (i.e. \c +05:00 means five hours east of UTC).

    Or an alternative format (with a '-' instead ofa 'T' to separate the time component):

    @verbatim
YYYY-MM-DD[-HH:mm:SS[.n*]][Z|[+-]HH[:mm[:SS]]]@endverbatim

    for example, for just the date in UTC, without a time component:
    - \c 2010-05-26

    or, for just the time, without a date component (note that in this case the date component will be set to Jan 1, 1970, in order for time arithmetic to function properly and will also be tagged with the local time zone):
    - \c 20:05:10.458342

    Some further examples (note that the date/time values without a time zone specification here are tagged with the local time zone):

    @code
prompt% qore -X '2005-03-29-18:12:25'
2005-03-29 18:12:25 Tue +02:00 (CEST)
prompt% qore -X '0512-01-01T01:49:59.002213Z'
0512-01-01 01:49:59.002213 Fri Z (UTC)
prompt% qore -X '2005-03-29'
2005-03-29 00:00:00 Tue +02:00 (CEST)
prompt% qore -X '18:35:26+08:00'
1970-01-01 18:35:26 Thu +08:00 (+08)
    @endcode

    The year must be a four-digit number, and all other values except microseconds must be two-digit numbers. If microseconds are present, at least one and up to 6 digits may be given after the decimal point. Pad the numbers with leading zeros if the numbers are smaller than the required number of digits. The hour component must be in 24-hour time format. Except for the month and day values, all other values start with 0 (hour = 00 - 23, minute and second: 00 - 59). Any deviation from this format will cause a parse exception.

    When a date/time value is converted to an integer or vice-versa, a 64-bit offset in seconds from the start of the "epoch" is used for the conversion. %Qore's "zero date" (the start of %Qore's "epoch") is January 1, 1970 UTC. When calculating second offsets from this date, a 64-bit integer is used.

    @note The default local time zone for qore is set when the qore library is initialized; see @ref time_zones for more information.

    @subsection relative_dates Relative Date/Time Values (Durations)
    Relative dates (durations) are normally used for date addition and subtraction. See @ref date_time_arithmetic for more information.

    Internally, durations are stored as a set of seven discrete signed integer values, one each for years, months, days, hours, minutes, seconds, and microseconds.

    There are 3 different formats understood by the %Qore parser for describing literal durations in %Qore.

    <b>Single Relative Time Format</b>\n
    A single relative date/time value (or a duration) may be specified as follows (note that this format is specific to %Qore and not based on ISO-8601):
    - @verbatim <integer><date component specifier>@endverbatim

    <b>Date Specifiers For Single Values For Relative Dates (non-ISO-8601 syntax)</b>
    |!Component|!Meaning|!Example|!Description
    |\c Y|Years|\c 2Y|2 Years
    |\c M|Months|\c 3M|3 Months
    |\c D|Days|\c 10D|10 Days
    |\c h|Hours|\c 15h|15 hours
    |\c m|Minutes|\c 25m|25 minutes
    |\c s|Seconds|\c 19s|19 seconds
    |\c ms|Milliseconds|\c 250ms|250 milliseconds
    |\c us|Microseconds|\c 21194us|21194 microseconds

    <b>Short Relative Time Format</b>\n
    This and the next duration format for composite relative date/time values are both based on ISO-8601.

    This first format has the following syntax:
    - \c PnYnMnDTnHnMnSnu

    Each element above is optional, but at least one element must be present. Note that "M" means months when before the "T" and minutes when found after the "T". The other elements are years, days, hours, seconds, and, as an extension to ISO-8601, "u" for microseconds. Additionally, the values may be negative.

    Here are some examples (using qore's -X command-line option to evaluate and expression and print out the result):

    @code
prompt% qore -X 'P1Y3MT4S'
<time: 1 year 3 months 4 seconds>
prompt% qore -X 'PT4M551u'
<time: 4 minutes 551 microseconds>
prompt% qore -X 'P3DT21H'
<time: 3 days 21 hours>
    @endcode

    <b>Long Relative Time Format</b>\n
    The second ISO-8601-based format for specifing complex durations with multiple time units has the following syntax:
    - \c PYYYY-MM-DDTHH:mm:SS

    This format is more limited than the first format, in that all values must be positive, and furthermore, all values must be present (although they may be zero).

    Here are some examples of the second format (equivalent to the first examples):

    @code
prompt% qore -X 'P0001-03-00T00:00:04'
<time: 1 year 3 months 4 seconds>
prompt% qore -X 'P0000-00-00T00:04:00.000551'
<time: 4 minutes 551 microseconds>
prompt% qore -X 'P0000-00-03T21:00:00'
<time: 3 days 21 hours>
    @endcode

    @see @ref date_type, @ref softdate_type

    @subsection binary Binary

    The binary data type is used to hold binary arbitrary binary data. Internally it is represented by a pointer to a memory location for the data and a size indicator.

    Binary data can be concatenated with the + and += operators.

    This data can be manipulated by being written and read from @ref Qore::File, @ref Qore::Socket, @ref Qore::Datasource, @ref Qore::DatasourcePool, or @ref Qore::SQLStatement objects, or converted and parsed to/from base64 encoded strings using the makeBase64String() and parseBase64String() functions, or compressed and decompressed using the compress(), gzip(), bzip2(), etc. functions, and processed by most cryptographic funtions, among others.

    Binary objects can be read from a @ref Qore::File object using the Qore::File::readBinary() method and can be written using the Qore::File::write() method. Please see the @ref Qore::File class for more information.

    Binary objects can be read from a @ref Qore::Socket object using the Qore::Socket::recvBinary() method and can be written using the Qore::Socket::send() method. Please see the @ref Qore::Socket class for more information.

    The @ref Qore::Datasource, @ref Qore::DatasourcePool, and @ref Qore::SQLStatement classes can also be used to read and write binary objects as BLOBs.

    Note that this is not an exhaustive list; see the function and class library documentation for more examples.

    @see @ref binary_type

    @subsection null NULL

    This data type represents an SQL \c NULL value. Note that \c NULL is not equivalent to @ref nothing.

    @subsection nothing NOTHING

    This special data type represents no value.

    @note The exists operator will return \c False when given \c NOTHING as an argument; for example: @verbatim prompt% qore -X 'exists NOTHING'
False@endverbatim

    @subsection conversions Data Conversions

    Boolean, string, integer, date, and floating point data types can be freely converted from one type to the other, although data loss is possible depending on the conversion (particularly when converting to the boolan type as only two possible values are supported).

    The special types @ref null and @ref nothing are not equivalent and cannot be converted to or from any other type.

    When date types are converted from strings, any of the following formats can be used: \c "YYYYMMDDHHmmSS[.us][Z|+-HH[:MM[:SS]]]", \c "YYYY-MM-DD HH:mm:SS.us", \c "YYYY-MM-DDTHH:mm:SS", \c "YYYY-MM-DDTHH:mm:SS[.us][Z|+-HH[:MM[:SS]]]", and most reasonable combinations thereof. If the time zone component is missing, then the local time zone will be assumed (see @ref time_zones).

    When dates are converted to and from integer values, the a 64-bit second offset from January 1, 1970 in the local time zone is used for the conversion. For example @code int(2006-01-01)@endcode gives \c 1136073600 (regardless of the local time zone the date is in). To get the second offset of a date from \c 1970-01-01Z (i.e. the true epoch offset), call get_epoch_seconds() instead.

    When an expression requires a certain data type and the source data type cannot be converted to the desired data type, the default value for the desired data type will be used. The default values are given in @ref basic_data_types.

    @section container_data_types Container Data Types

    %Qore supports three types of container types: @ref list "lists", @ref hash "hashes" (associative arrays), and @ref object "objects" (see @ref object and @ref classes for more information). These container types can be combined to make arbitrarily complex data structures.

    The data type of any element can be any basic type or another aggregate type. The types do not have to be uniform in one container structure.

    @subsection list Lists

    Lists (or arrays) are simply ordered containers of values. A list element can be any %Qore type (even another list, @ref hash "hash", or @ref object "object").

    Lists are specified by giving expressions separated by commas as follows:

    @code
$list = (expression, expression [, expression ...]);
    @endcode

Here is a concrete example:

    @code
my list $list = (1, 2, "three", 4.0, 5, 6, 2001-01-15Z);
    @endcode

    @note Trailing commas can be left on the end of a list (or a hash, for that matter). This makes it easier to comment-out the last element of a multi-line list without having to worry about removing the trailing comma.

    List elements are dereferenced using square brackets: \c "[" and \c "]". The first element in a list has index zero.

    @code
$element3 = $list[2];
    @endcode

    The following operators perform special processing on lists: @ref elements "elements", @ref shift "shift", @ref unshift "unshift", @ref push "push", @ref pop "pop", @ref splice "splice", @ref list_element_operator "[]", @ref plus_operator "+", @ref plus_equals_operator "+=", @ref map "map", @ref foldl "foldl", @ref foldr "foldr", and @ref select "select".

    @see @ref list_type, @ref softlist_type

    @subsection hash Hashes

    Hashes are containers that associate values to a string key.

    @note %Qore hashes preserve the insertion order in order to be able to guarantee the order of keys when hashes are serialized to XML strings, therefore the keys operator will always return the hash keys in insertion/creation order.

    Hashes are specified using the following syntax:

    @code
$hash = ( "key1" : expression,
          "key2" : expression,
	  ... );
    @endcode

    Here is a concrete example:

    @code
my hash $hash = ( "apple" : 1 + 1,
                  "pear"  : "good" );
    @endcode

    Hashes are dereferenced in one of two ways, either using curly brackets: \c "{" and \c "}", where any valid %Qore expression can be used, or using the dot "." hash member dereferencing operator, where literal strings can be used.

    @code
$element3 = $hash{"pe" + "ar"};
    @endcode

    Is equivalent to:

    @code
$element3 = $hash.pear;
    @endcode

    and:

    @code
$element3 = $hash."pear";
    @endcode

    and:

    @code
$element3 = $hash.("pe" + "ar");
    @endcode

    Hash members can have the names of keywords, but in this case to dereference them, you cannot use the dot operator with a literal string, otherwise a parse error will be raised. Use quotes around the member name when dereferencing hash members with the same name as a qore keyword as follows:

    @code
$element3 = $hash."keys";
$element3 = $hash{"keys"};
    @endcode

    A literal string after the dot "." hash member dereferencing operator must be a valid %Qore identifier; therefore if you want to use a hash key that's not a valid identifier, enclose the string in quotes.

    If you want to use the result of an expression to dereference the hash, then either the curly bracket syntax must be used or the expression must be enclosed in parentheses.

    Note that hash keys can also be given by constants (as long as the constant resolves to a string) when using curly brackets.

    @see @ref hash_type

    @subsection object Objects

    %Qore objects are instantiations of a class. They have members (like a hash; values associated to string keys), and methods. The class definition specifies the methods that run on objects of that class, private members, and static methods associated with the class (however note that static methods do not run in the scope of an object). %Qore classes are declared with a special syntax.

    The recommend way to instantiate an object is to declare its type and give constructor arguments after the variable name in parentheses as follows:

    @code
my class_name_or_path $var_name([argument list])
    @endcode

    For example (for a constructor taking no arguments or having only default values for the aguments, the list is empty):
    @code
my Mutex $m();
    @endcode

    If parse option @ref new-style "%new-style" is set, the above example declaring a local variable of class @ref Qore::Mutex would look as follows:

    @code
Mutex m();
    @endcode

    Objects can also be instantiated using the @ref new "new operator" as follows.

    @code
new class_identifier([argument list])
    @endcode

    For example:

    @code
my Mutex $m = new Mutex();
    @endcode

    Or, with parse option %new-style:

    @code
Mutex m = new Mutex();
    @endcode

    Objects have named data members that are referenced like hash elements, although this behavior can be modified for objects using the memberGate() method. Object members are accessed by appending a dot '.' and the member name to the object reference as follows:

    @code
object_reference.member_name
    @endcode

    For more information, see @ref class_members.

    Object methods are called by appending a dot '.' and a method name to the object reference as follows:

    @code
object_reference.method_name([argument_list])
    @endcode

    Or, from within the class code itself to call another method from inside the same class hierarchy:

    @code
$.method_name([argument_list])
    @endcode

    Or, with parse option %new-style, the method call is made without the "$.":

    @code
method_name([argument_list])
    @endcode

    For more information, see @ref object_method_calls.

    The object references above are normally variable references holding an object, but could be any expression that returns an object, such as a @ref new "new expression" or even a function call.

    @note Objects are treated differently than other %Qore data types; they are only explicitly copied (see @ref object_references for more informaion). Any object instantiated with the new operator will remain unique until deleted or explicitly copied. An explicit copy is made with the copy method, and does not always guarantee an exact copy of the source object (it depends on the definition of the copy method for the class in question).

    Objects exist until they go out of scope, are explicitly deleted, or their last thread exits. For detailed information, see @ref classes.

    @see @ref object_type

    @section data_type_declarations Data Type Declarations and Restrictions

    Starting in %Qore 0.8.0, it is possible to restrict variables, class members, and function and method parameters to certain data types. This allows programmers to write safer code, as many more errors can be caught at parse time that would otherwise be caught at run time. Furthermore, providing type information to the parser allows %Qore to implement performance optimizations by performing lookups and resolutions once at parse time rather than every time a variable or class member is accessed at run time.

    When types are declared in a parameter list, functions and methods can be overloaded as well.

    The types in the following table can be used as well as any class name or \c '*classname' (i.e. an asterix followed by the class name), meaning either the given class or @ref nothing (no value).

    <b>Data Type Declaration Names</b>
    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |@ref int_type "int"|@ref integer|@ref integer|Restricts values @ref integer values
    |@ref float_type "float"|@ref float|@ref float|Restricts values to @ref float values
    |@ref bool_type "bool"|@ref boolean|@ref boolean|Restricts values to @ref boolean values
    |@ref string_type "string"|@ref string|@ref string|Restricts values to @ref string values
    |@ref date_type "date"|@ref date|@ref date|Restricts values to @ref date values; values may be either @ref absolute_dates "absolute" or @relative_dates "relative"
    |@ref binary_type "binary"|@ref binary|@ref binary|Restricts values to @ref binary values
    |@ref hash_type "hash"|@ref hash|@ref hash|Restricts values to @ref hash values
    |@ref list_type "list"|@ref list|@ref list|Restricts values to @ref list values
    |@ref object_type "object"|@ref object|@ref object|Restricts values to @ref object values
    |@ref classname_type "<classname>"|@ref object|@ref object|Restricts values to objects of the specific class given; either the class name can be given (ex: @ref Qore::Mutex "Mutex" or a qualified path to the class: @ref Qore::Mutex)
    |@ref null_type "null"|@ref null|@ref null|Restricts values to %Qore's @ref null type; this type has few (if any) practical applications and has been included for completeness' sake
    |@ref nothing_type "nothing"|@ref nothing|@ref nothing|Restricts values to %Qore's @ref nothing type; this type is mostly useful for declaring that a function or method returns no value
    |@ref timeout_type "timeout"|@ref integer, @ref date|@ref integer|Accepts @ref integer, @ref date and converts dates to an integer value representing milliseconds and returns the integer; incoming integers are assumed to represent milliseconds
    |@ref softint_type "softint"|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref integer|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-integer values to an integer and returns the integer
    |@ref softfloat_type "softfloat"|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref float|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-float values to a float and returns the new value
    |@ref softbool_type "softbool"|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref boolean|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-boolean values to a boolean and returns the new value
    |@ref softstring_type "softstring"|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref string|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-string values to a string and returns the new value
    |@ref softdate_type "softdate"|@ref integer, @ref float, @ref boolean, @ref string, @ref date, @ref null|@ref date|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref date, and @ref null and converts non-date values to a date and returns the new value
    |@ref softlist_type "softlist"|all types|@ref list|Accepts all types; @ref nothing is returned as an empty list; a list is returned unchanged, and any other type is returned as the first element of a new list
    |@ref data_type "data"|@ref string or @ref binary|same as received|Restricts input to @ref string and @ref binary and returns the same type
    |@ref code_type "code"|@ref closure, @ref call_reference|same as received|Restricts values to @ref closure "closures" and @ref call_reference "call references"
    |@ref reference_type "reference"|@ref lvalue_references|@ref lvalue_references|Restricts values to references to lvalues; currently only usable in function or method parameters
    |@ref int_or_nothing_type "*int"|@ref integer or @ref nothing|same as received|Restricts values to %Qore's @ref integer or @ref nothing types
    |@ref float_or_nothing_type "*float"|@ref float or @ref nothing|same as received|Restricts values to %Qore's @ref float or @ref nothing types
    |@ref bool_or_nothing_type "*bool"|@ref boolean or @ref nothing|same as received|Restricts values to %Qore's @ref boolean or @ref nothing types
    |@ref string_or_nothing_type "*string"|@ref string or @ref nothing|same as received|Restricts values to %Qore's @ref string or @ref nothing types
    |@ref date_or_nothing_type "*date"|@ref date or @ref nothing|same as received|Restricts values to %Qore's @ref date or @ref nothing type; values may be either absolute or relative date/time values
    |@ref binary_or_nothing_type "*binary"|@ref binary or @ref nothing|same as received|Restricts values to %Qore's @ref binary or @ref nothing types
    |@ref hash_or_nothing_type "*hash"|@ref hash or @ref nothing|same as received|Restricts values to %Qore's @ref hash or @ref nothing types
    |@ref list_or_nothing_type "*list"|@ref list or @ref nothing|same as received|Accepts either a @ref list or @ref nothing
    |@ref data_or_nothing_type "*data"|@ref string, @ref binary, or @ref nothing|same as received|Restricts input to @ref string, @ref binary, or @ref nothing and returns the same type
    |@ref code_or_nothing_type "*code"|@ref closure, @ref call_reference, @ref nothing|same as received|Restricts values to @ref closure "closures", @ref call_reference "call references" and @ref nothing
    |@ref timeout_or_nothing_type "*timeout"|@ref integer, @ref date or @ref nothing|@ref integer or @ref nothing|Accepts @ref integer, @ref date and converts dates to an integer value representing milliseconds and returns the integer; incoming integers are assumed to represent milliseconds. If no value is passed, then @ref nothing is returned
    |@ref softint_or_nothing_type "*softint"|@ref integer, @ref float, @ref boolean, @ref string, @ref null or @ref nothing|@ref integer or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-integer values to an integer and returns the integer. If no value is passed, then @ref nothing is returned
    |@ref softfloat_or_nothing_type "*softfloat"|@ref integer, @ref float, @ref boolean, @ref string, @ref null or @ref nothing|@ref float or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-float values to a float and returns the new value. If no value is passed, then @ref nothing is returned
    |@ref softbool_or_nothing_type "*softbool"|@ref integer, @ref float, @ref boolean, @ref string, @ref null or @ref nothing|@ref boolean or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-boolean values to a boolean and returns the new value. If no value is passed, then @ref nothing is returned
    |@ref softstring_or_nothing_type "*softstring"|@ref integer, @ref float, @ref boolean, @ref string, @ref null or @ref nothing|@ref string or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-string values to a string and returns the new value. If no value is passed, then @ref nothing is returned
    |@ref softdate_or_nothing_type "*softdate"|@ref integer, @ref float, @ref boolean, @ref string, @ref date, @ref null or @ref nothing|@ref date or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref date, and @ref null and converts non-date values to a date and returns the new value. If no value is passed, then @ref nothing is returned
    |@ref softlist_or_nothing_type "*softlist"|all types|@ref list or @ref nothing|Accepts all types; @ref nothing and list values are returned as the same value; any other type is returned as the first element of a new list
    |@ref any_type "any"|any|same as received|Provides no restrictions on the type of value it receives and returns the same value

    @subsection int_type "int" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c int|@ref integer|@ref integer|Restricts values to %Qore's @ref integer type

    @par Example
    @code
my int $i = 0;
    @endcode

    @subsection float_type "float" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c float|@ref float|@ref float|Restricts values to %Qore's @ref float type

    @par Example
    @code
my float $pi = M_PI;
    @endcode

    @subsection bool_type "bool" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c bool|@ref boolean|@ref boolean|Restricts values to %Qore's @ref boolean type

    @par Example
    @code
my float $pi = M_PI;
    @endcode

    @subsection string_type "string" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c string|@ref string|@ref string|Restricts values to %Qore's @ref string type

    @par Example
    @code
my string $str = "foo";
    @endcode

    @subsection date_type "date" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c date|@ref date|@ref date|Restricts values to %Qore's @ref date type; date/time values can be either @ref absolute_dates "absolute" or @ref relative_dates "relative"

    @par Example
    @code
my date $now = now_us;
    @endcode

    @subsection binary_type "binary" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c binary|@ref binary|@ref binary|Restricts values to %Qore's @ref binary type

    @par Example
    @code
my string $str = "foo";
    @endcode

    @subsection hash_type "hash" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c hash|@ref hash|@ref hash|Restricts values to %Qore's @ref hash type

    @par Example
    @code
my hash $str = ("foo": "bar", "x": 2);
    @endcode

    @subsection list_type "list" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c list|@ref list|@ref list|Restricts values to %Qore's @ref list type

    @par Example
    @code
my list $l = ("foo", "bar");
    @endcode

    @subsection object_type "object" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c object|@ref object|@ref object|Restricts values to %Qore's @ref object type; note that any class name can also be used as a type restriction directly

    @par Example
    @code
my object $o = new Mutex();
    @endcode

    @subsection classname_type "<classname>" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |<tt><any class name></tt>|@ref object of the particular class given|@ref object of the particular class given|Restricts values to objects of the particular class given; subclasses are also accepted

    @par Example
    @code
my Qore::Mutex $o = new Mutex();
    @endcode

    @subsection null_type "null" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c null|@ref null|@ref null|Restricts values to %Qore's @ref null type; this type has few (if any) practical applications and has been included for completeness' sake

    @par Example
    @code
my null $n = NULL;
    @endcode

    @subsection nothing_type "nothing" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c nothing|@ref nothing|@ref nothing|Restricts values to %Qore's @ref nothing type; this type is mostly useful for declaring that a function or method returns no value

    @par Example
    @code
nothing sub bar() {
    printf("foo\n");
}
    @endcode

    @subsection timeout_type "timeout" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c timeout|@ref integer, @ref date|@ref integer|Accepts @ref integer, @ref date values and converts dates to an integer value representing milliseconds and returns the integer; incoming integers are assumed to represent milliseconds

    @par Example
    @code
my timeout $to = 1250ms;
    @endcode

    @subsection softint_type "softint" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c softint|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref integer|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-integer values to an integer and returns the integer

    @par Example
    @code
my softint $i = "1000";
    @endcode

    @subsection softfloat_type "softfloat" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c softfloat|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref float|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-float values to a float and returns the float

    @par Example
    @code
my softfloat $f = "1000.0";
    @endcode

    @subsection softbool_type "softbool" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c softbool|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref boolean|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-boolean values to a boolean and returns the boolean

    @par Example
    @code
my softbool $b = "0.5";
    @endcode

    @subsection softstring_type "softstring" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c softstring|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref string|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-string values to a string and returns the string

    @par Example
    @code
my softstring $str = 200;
    @endcode

    @subsection softdate_type "softdate" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c softdate|@ref integer, @ref float, @ref boolean, @ref string, @ref date, @ref null|@ref date|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref date, and @ref null values and converts non-date values to a date and returns the date

    @par Example
    @code
my softdate $d = "2001-10-10T20:00:05 +04:00";
    @endcode

    @subsection softlist_type "softlist" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c softlist|all data types|@ref list|Accepts all data types; @ref nothing is returned as an empty list; a list is returned unchanged, and any other type is returned as the first element of a new list

    @par Example
    @code
my softlist $d = $v;
    @endcode

    @subsection data_type "data" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c data|@ref string or @ref binary|same as received|Restricts values to @ref string and @ref binary

    @par Example
    @code
sub foo(data $d) {
}
    @endcode

    @subsection code_type "code" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c code|@ref closure, @ref call_reference|same as received|Restricts values to @ref closure and @ref call_reference

    @par Example
    @code
sub foo(code $c) {
}
    @endcode

    @note that also \c "closure" and \c "callref" are accepted as synonyms for \c "code" (they are not more specific than \c "code" but rather provide identical type restrictions)

    @subsection reference_type "reference" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c reference|@ref reference|@ref reference|Requires a reference to an lvalue to be assigned; this type is only usable in parameter lists

    @par Example
    @code
sub foo(reference $f) {
}
    @endcode

    @subsection int_or_nothing_type "*int" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *int|@ref integer or @ref nothing|same as received|Restricts values to @ref integer and @ref nothing

    @par Example
    @code
sub foo(*int $i) {
}
    @endcode

    @subsection float_or_nothing_type "*float" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *float|@ref float or @ref nothing|same as received|Restricts values to @ref float and @ref nothing

    @par Example
    @code
sub foo(*float $f) {
}
    @endcode

    @subsection bool_or_nothing_type "*bool" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *bool|@ref float or @ref nothing|same as received|Restricts values to @ref bool and @ref nothing

    @par Example
    @code
sub foo(*bool $b) {
}
    @endcode

    @subsection string_or_nothing_type "*string" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *string|@ref string or @ref nothing|same as received|Restricts values to @ref string and @ref nothing

    @par Example
    @code
sub foo(*string $str) {
}
    @endcode

    @subsection date_or_nothing_type "*date" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *date|@ref date or @ref nothing|same as received|Restricts values to @ref date and @ref nothing

    @par Example
    @code
sub foo(*date $str) {
}
    @endcode

    @subsection binary_or_nothing_type "*binary" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *binary|@ref binary or @ref nothing|same as received|Restricts values to @ref binary and @ref nothing

    @par Example
    @code
sub foo(*binary $b) {
}
    @endcode

    @subsection hash_or_nothing_type "*hash" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *hash|@ref hash or @ref nothing|same as received|Restricts values to @ref hash and @ref nothing

    @par Example
    @code
sub foo(*hash $h) {
}
    @endcode

    @subsection list_or_nothing_type "*list" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *list|@ref list or @ref nothing|same as received|Restricts values to @ref list and @ref nothing

    @par Example
    @code
sub foo(*list $h) {
}
    @endcode

    @subsection data_or_nothing_type "*data" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *data|@ref string, @ref binary, or @ref nothing|same as received|Restricts values to @ref string, @ref binary, and @ref nothing

    @par Example
    @code
sub foo(*data $d) {
}
    @endcode

    @subsection code_or_nothing_type "*code" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *code|@ref closure, @ref call_reference, or @ref nothing|same as received|Restricts values to @ref closure, @ref call_reference, and @ref nothing

    @par Example
    @code
sub foo(*code $c) {
}
    @endcode

    @subsection timeout_or_nothing_type "*timeout" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *timeout|@ref integer, @ref date, or @ref nothing|same as received|Restricts values to @ref integer, @ref date, and @ref nothing

    @par Example
    @code
sub foo(*timeout $c) {
}
    @endcode

    @subsection softint_or_nothing_type "*softint" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *softint|@ref integer, @ref float, @ref boolean, @ref string, @ref null, @ref nothing|@ref integer or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-integer values to an integer and returns the integer; also accepts @ref nothing and returns @ref nothing

    @par Example
    @code
sub foo(*softint $i) {
}
    @endcode

    @subsection softfloat_or_nothing_type "*softfloat" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *softfloat|@ref integer, @ref float, @ref boolean, @ref string, @ref null, @ref nothing|@ref float or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-float values to a float and returns the float; also accepts @ref nothing and returns @ref nothing

    @par Example
    @code
sub foo(*softfloat $f) {
}
    @endcode

    @subsection softbool_or_nothing_type "*softbool" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *softbool|@ref integer, @ref float, @ref boolean, @ref string, @ref null, @ref nothing|@ref boolean or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-boolean values to a boolean and returns the boolean; also accepts @ref nothing and returns @ref nothing

    @par Example
    @code
sub foo(*softbool $b) {
}
    @endcode

    @subsection softstring_or_nothing_type "*softstring" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *softstring|@ref integer, @ref float, @ref boolean, @ref string, @ref null, @ref nothing|@ref string or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-string values to a string and returns the string; also accepts @ref nothing and returns @ref nothing

    @par Example
    @code
sub foo(*softstring $str) {
}
    @endcode

    @subsection softdate_or_nothing_type "*softdate" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *softdate|@ref integer, @ref float, @ref boolean, @ref string, @ref date, @ref null, @ref nothing|@ref string or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref date, and @ref null values and converts non-date values to a date and returns the date; also accepts @ref nothing and returns @ref nothing

    @par Example
    @code
sub foo(*softdate $d) {
}
    @endcode

    @subsection softlist_or_nothing_type "*softlist" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *softlist|all data types|@ref list or @ref nothing|Accepts all data types; @ref nothing is returned as @ref nothing directly; a list is returned unchanged, and any other type is returned as the first element of a new list

    @par Example
    @code
my *softlist $d = $v;
    @endcode

    @subsection any_type "any" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c any|all data types|all data types|Accepts all data types and returns the same data type

    @par Example
    @code
my any $v = $bar;
    @endcode

    @note Complex types (hash of lists, reference to string, etc) are currently not possible to declare but support may be added in future versions of %Qore for this.

    @section overloading Overloading

    Functions and methods can be overloaded if parameter types are declared as in the following example:

    @code
int sub example(int $i) {
    printf("i=%d\n", $i);
    return $i + 1;
}

string sub example(string $str) {
    printf("str=%s\n", $str);
    return $str + "foo";
}
    @endcode

    In this case, the first version (<tt>example(int)</tt>) will be executed if called with an integer argument, and the second (<tt>example(string)</tt>) if called with a string argument.

    Class methods may also be overloaded, but note that @ref destructors "destructor()", @ref copy_methods "copy()", @ref methodGate_methods "methodGate()", @ref memberGate_methods "memberGate()", and @ref memberNotification_methods "memberNotification()" methods may not be overloaded (see @ref classes for more information).

    @section time_zones Time Zone Handling
    
    %Qore assumes a default time zone for all programs when it starts up. The rules for determining the default time zone are similar to those for the C library in most UNIX or UNIX-like operating systems.

    @subsection unix_time_zones UNIX Time Zone Handling

    If the \c TZ environment variable is defined, then the contents of that variable are used to find a zoneinfo file that contains the time zone definition. If this file cannot be found, then the default time zone will default to \c UTC.

    If the \c TZ environment variable is not defined or is empty, then the %Qore library tries to find the default zoneinfo definition file (normally \c /etc/localtime). If found, this file is read in and provides the information about the local time zone. If not found, the default time zone will default to \c UTC.

    When a zoneinfo file is found, information about local time zone names and daylight savings time is available for times tagged with that time zone.

    Note that posix-style time zone rules are not understood if assigned to the \c TZ environment variable, only file names to a zoneinfo file can be processed at the moment. Furthermore if the zoneinfo file contains leap second information, it is currently ignored.

    @subsection windows_time_zones Windows Time Zone Handling

    Time zone information is read in from binary time zone data in the Windows registry under \c HKEY_LOCAL_MACHINE SOFTWARE\Microsoft\Windows NT\CurrentVersion\Time Zones.

    Time zone region names must correspond to registry keys under the above key or the time zine information will not be loaded.

    The region name reported by Qore::TimeZone::region() will be the display name for the time zone, as found in the registry.

    For example:

    @verbatim
O:\bin>qore -ne "TimeZone tz('Central Europe Standard Time'); printf(\"%s\n\", tz.region());"
(GMT+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague@endverbatim

    This differs from UNIX where the region name passed to the TimeZone constructor is the same region name that appears in the @ref Qore::TimeZone::region() output; this is because Windows uses \c "Standard Time" in the key name in the registry, even though the underlying zone definition is for both standard and daylight savings time.

    @note Please be aware that the region names may differ in localized versions of Windows

    @subsection time_zone_examples More Time Zone Information and Examples

    See the @ref Qore::TimeZone class for information about retrieving, setting, and querying time zone information; see @ref date_and_time_functions for a list of functions related to date/time processing.

    Here are some examples using %Qore's '-X' option for evaluating an expression and displaying the result immediately:

    @verbatim
prompt% TZ=America/Chicago qore -X 'now_us()'
2010-05-11 06:14:28.845857 Tue -05:00 (CDT)
prompt% TZ=Europe/Rome qore -X 'now_us()'
2010-05-11 13:14:35.070568 Tue +02:00 (CEST)
prompt% TZ=Australia/Sydney qore -X 'now_us()'
2010-05-11 21:14:45.422222 Tue +10:00 (EST)
prompt% TZ=Asia/Tokyo qore -X 'now_us()'
2010-05-11 20:14:59.609249 Tue +09:00 (CJT)@endverbatim

    @section character_encoding Strings and Character Encoding

    @subsection character_encoding_overview Overview

    The %Qore language is character-encoding aware. All strings are assumed to have the default character encoding, unless the program explicitly specified another encoding for certain objects and operations. Every %Qore string has a character encoding ID attached to it, so, when another encoding is required, the %Qore language will attempt to do an encoding translation.

    %Qore uses the operating system's \c iconv library functions to perform any encoding conversions.

    %Qore supports character encodings that are backwards compatible with 7-bit \c ASCII. This includes all \c ISO-8859-* character encodings, \c UTF-8, \c KOIR-8, \c KOIU-8, and \c KOI7, among others (see the table below: @ref known_encodings "Known Character Encodings").

    However, mutibyte character encodings are currently only properly supported for \c UTF-8. For \c UTF-8 strings, the length(), index(), rindex(), substr(), reverse(), the @ref splice "splice operator", @ref printf_formatting "print formatting" (regarding field lengths) functions and methods taking format strings, and regular expression operators and functions, all work with character offsets, which may be different than byte offsets. For all character encodings other than \c UTF-8, a 1 byte=1 character relationship is assumed.

    %Qore will accept any encoding name given to it, even if it is not a known encoding name or alias. In this case, %Qore will tag the strings with this encoding, and pass this user-defined encoding name to the \c iconv library when encodings must be converted. This allows programmers to use encodings known by the system's \c iconv library, but unknown to %Qore. In this case, %Qore will assume that the strings are backwards compatible with \c ASCII, meanin that that one character is represented by one byte and that the strings are null-terminated.

    Note that when %Qore matches an encoding name to a code or alias in the following table, the comparison is not case-sensitive.

    @subsection known_encodings Character Encodings Known to Qore

    |!Code|!Aliases|!Description
    |\c ISO-8859-1|\c ISO88591, \c ISO8859-1, \c ISO-88591, \c ISO8859P1, \c ISO81, \c LATIN1, \c LATIN-1|latin-1, Western European character set
    |\c ISO-8859-2|\c ISO88592, \c ISO8859-2, \c ISO-88592, \c ISO8859P2, \c ISO82, \c LATIN2, \c LATIN-2|latin-2, Central European character set
    |\c ISO-8859-3|\c ISO88593, \c ISO8859-3, \c ISO-88593, \c ISO8859P3, \c ISO83, \c LATIN3, \c LATIN-3|latin-3, Southern European character set
    |\c ISO-8859-4|\c ISO88594, \c ISO8859-4, \c ISO-88594, \c ISO8859P4, \c ISO84, \c LATIN4, \c LATIN-4|latin-4, Northern European character set
    |\c ISO-8859-5|\c ISO88595, \c ISO8859-5, \c ISO-88595, \c ISO8859P5, \c ISO85|Cyrillic character set
    |\c ISO-8859-6|\c ISO88596, \c ISO8859-6, \c ISO-88596, \c ISO8859P6, \c ISO86|Arabic character set
    |\c ISO-8859-7|\c ISO88597, \c ISO8859-7, \c ISO-88597, \c ISO8859P7, \c ISO87|Greek character set
    |\c ISO-8859-8|\c ISO88598, \c ISO8859-8, \c ISO-88598, \c ISO8859P8, \c ISO88|Hebrew character set
    |\c ISO-8859-9|\c ISO88599, \c ISO8859-9, \c ISO-88599, \c ISO8859P9, \c ISO89, \c LATIN5, \c LATIN-5|latin-5, Turkish character set
    |\c ISO-8859-10|\c ISO885910, \c ISO8859-10, \c ISO-885910, \c ISO8859P10, \c ISO810, \c LATIN6, \c LATIN-6|latin-6, Nordic character set
    |\c ISO-8859-11|\c ISO885911, \c ISO8859-11, \c ISO-885911, \c ISO8859P11, \c ISO811|Thai character set
    |\c ISO-8859-13|\c ISO885913, \c ISO8859-13, \c ISO-885913, \c ISO8859P13, \c ISO813, \c LATIN7, \c LATIN-7|latin-7, Baltic rim character set
    |\c ISO-8859-14|\c ISO885914, \c ISO8859-14, \c ISO-885914, \c ISO8859P14, \c ISO814, \c LATIN8, \c LATIN-8|latin-8, Celtic character set
    |\c ISO-8859-15|\c ISO885915, \c ISO8859-15, \c ISO-885915, \c ISO8859P15, \c ISO815, \c LATIN9, \c LATIN-9|latin-9, Western European with euro symbol
    |\c ISO-8859-16|\c ISO885916, \c ISO8859-16, \c ISO-885916, \c ISO8859P16, \c ISO816, \c LATIN10, \c LATIN-10|latin-10, Southeast European character set
    |\c KOI7|n/a|Russian: Kod Obmena Informatsiey, 7 bit characters
    |\c KOI8-R|\c KOI8R|Russian: Kod Obmena Informatsiey, 8 bit
    |\c KOI8-U|\c KOI8U|Ukrainian: Kod Obmena Informatsiey, 8 bit
    |\c US-ASCII|\c ASCII, USASCII|7-bit ASCII character set
    |\c UTF-8|\c UTF8|variable-width universal character set

    @subsection default_encoding Default Character Encoding

    The default character encoding for %Qore is determined by environment variables.

    First, the \c QORE_CHARSET environment variable is checked. If it is set, then this character encoding will be the default character encoding for the process. If not, then the \c LANG environment variable is checked. If a character encoding is specified in the \c LANG environment variable, then it will be used as the default character encoding. Otherwise, if no character encoding can be derived from the environment, \c UTF-8 is assumed.

    Character encodings are automatically converted by the %Qore language when necessary. Encoding conversion errors will cause a %Qore exception to be thrown. The character encoding conversions supported by %Qore depend on the operating system's \c iconv library function.

    @subsection encoding_examples Character Encoding Usage Examples

    The following is a non-exhaustive list of examples in %Qore where character encoding processing is performed.

    Character encodings can be explicitly performed with the convert_encoding() function, and the encoding attached to a string can be checked with the get_encoding() function. If you have a string with incorrect encoding and want to change the encoding tag of the string (without changing the actual bytes of the string), use the force_encoding() function.

    The @ref Qore::Datasource, @ref Qore::DatasourcePool, and @ref Qore::SQLStatement classes will translate character encodings to the encoding required by the database if necessary as well (this is actually the responsibility of the DBI driver for the database in question).

    The @ref Qore::File and @ref Qore::Socket classes translate character encodings to the encoding specified for the object if necessary, as well as tagging strings received or read with the object's encoding.

    The @ref Qore::HTTPClient class will translate character encodings to the encoding specified for the object if necessary, as well as tag strings received with the object's encoding. Additionally, if an HTTP server response specifies a specific encoding to use, the encoding of strings read from the server will be automatically set to this encoding as well.

    @section expressions Expressions

    An expression can be any of the following (note that expressions are also recursively defined):

    <b>Expressions</b>
    |!Type|!Description|!Examples
    |An immediate value|Qore values that can be expressed directly (see @ref basic_data_types and @ref container_types for more information)|@code True@endcode @code1.2@endcode @code "a string"@endcode @code 2005-10-27@endcode @code NULL@endcode @code NOTHING@endcode @code ("key" : $val)@endcode
    |A variable reference|@ref variables<br>see also @ref allow-bare-refs "%allow-bare-refs"|@code $var@endcode
    |A variable declaration|@ref variable_declarations, @ref variables<br>see also @ref assume-local "%assume-local"|@code my int $var@endcode
    |An in-class object member reference|References to members of an object from within the class<br>see @ref class_members<br>see also allow-bare-refs "%allow-bare-refs"|@code $.member@endcode
    |An lvalue assignment|Assigns a value to a lvalue (see @ref assignment_operator)|@code $var = 1@endcode @code ($a, $b, $c, $date) = (1, "two", 3.3, 2005-10-28)@endcode
    |A function call|Qore function calls (see @ref functions)|@code calculate($var1, $var2, "string", 4)@endcode
    |A method call|Qore object method calls (see @ref object_method_calls)<br>see also @ref allow-bare-refs "%allow-bare-refs"|@code $object.method("argument")@endcode
    |An in-class method call|Qore in-class object method calls (see @ref object_method_calls)<br>see also @ref allow-bare-refs "%allow-bare-refs"|@code $.method("argument")@endcode
    |A @ref static_method_call "static method call"|Qore static method calls (see @ref static_methods)|@code ClassName::static_method("argument")@endcode
    |Expressions with operators|Use of @ref operators "Qore operators"|@code 1 + 2@endcode @code $a || $b@endcode @code background my_function()@endcode
    |An expression in parentheses|Use of parentheses for clarity or to specify evaluation precedence|@code (3 * (2 + $a))@endcode
    |A @ref find_expression "find expression"|Finds a value or values in a hash of lists, such as returned by the Qore::Datasource::select() or Qore::SQLStatement::fetchColumns() method|@code find %name, %id in $data where (%name =~ /Smith/)@endcode
    |A context reference (<tt>%name</tt>)|A contextual reference to the value of a key of the current row being iterated by a @ref context_statement "context", @ref summarize_statement "summarize", @ref subcontext_statement "subcontext" statement, or a @ref find_expression "find expression"|@code %name@endcode
    |A context row reference (<tt>%%</tt>)|A contextual reference to the current row being iterated by a @ref context_statement "context", @ref summarize_statement "summarize", @ref subcontext_statement "subcontext" statement, or a @ref find_expression "find expression"; this expression returns a hash of the current row|@code %%@endcode
    |A @ref call_reference "call reference"|A reference to a function or object method call (similar to a function pointer in C or C++). Function references are resolved in the second phase of parsing (commit phase), while object method references are resolved at run-time|@code \function_call()@endcode @code \$object_expression.method_name()@endcode
    |A @ref closure "closure"|An anonymous function used a value; technically a closure must have at least one bound variable, but in %Qore a closure is any function used as a value, whether or not it encloses local variables from the scope in which it was created or not|@code string sub (string $a) { return $a + $b; }@endcode
    |A call reference call|An expression executing a @ref call_reference "call reference" or @ref closure "closure"|@code $my_closure($arg1, $arg2)@endcode
    |An @ref implicit_arguments "implicit argument" reference (\c $1)|References an implicit argument|@code $1@endcode
    |A reference to the entire @ref implicit_arguments "implicit argument" list (\c $$)|References the implicit argument list|@code $$@endcode
    |An @ref implicit_index "implicit index" reference|Gives the list index position when implicitly iterating a list|@code $#@endcode

    @subsection static_method_calls Static Method Calls

    @par Synopsis
    Calls to static class methods are made by giving the class name followed by two colons and then the method name. The method name must be implemented and accessible (i.e. not private and accessed outside the class) somewhere within the class hierarchy and must be static or a parse exception will occur.

    @par Syntax
    \a class_name::method_name <tt>(</tt><em>[argument_expressions...]</em><tt>)</tt>

    @par Description
    \a class_name \n
    The name of the class implementing the static method.\n\n
    \a method_name \n
    The name of the static method to call.\n\n
    <em>[argument_expressions...]</em>\n
    Expressions passing arguments to the static method.

    @par Example
    @code TimeZone::setRegion("Europe/Prague");@endcode

    @subsection find_expression Find Expressions

    @par Synopsis
    The find expression can be used to quickly find data in a hash of lists (such as a query result set returned by the Qore::Datasource::select() or Qore::SQLStatement::fetchColumns() methods). The find expression will loop through a data structure, and for each element in the structure where the \c where expression is \c True, it will evaluate and return a result expression. If the \a where_expression only is \c True for one element in the list, it will return the result of evaluating the result expression directly, otherwise if the \a where_expression is \c True more than once, then a list of the results of evaluting the result expression for each element is returned. In each expression in the find expression, column values can be referred to by preceding the name with a \c "%" character (as with @ref context_statement "context statements").

    @par Syntax
    \c \b find \a result_expression \c \b in \a data_expression <tt>\b where (</tt>\a where_expression<tt>)</tt>

    @par Description
    \a result_expression \n
    This expression will be evaluated and returned when the \a where_expression evaluates to \c True.\n\n
    \a data_expression \n
    This expression must evaluate to a hash of lists, so that the internal context can be set up for the find loop.\n\n
    \a where_expression \n
    This expression will be evaluated for each row in the \a data_expression. Each time it evaluates to \c True, the \a result_expression will be evaulated and used for the return value for the find expression.

    @par Example
    @code $rlist = find %fname, %id in $data where (%lname =~ /^Smith/);@endcode

    @subsection call_reference Call References

    @par Synopsis
    References to functions or object methods are called call references. A call reference can be used like a function pointer; a call reference is a %Qore data type that can be returned by functions or methods or assigned to variables.  Note that the empty parentheses after the call are required to identify the expression as a call reference.

    @par Syntax
    <tt>\\</tt><em>function_name</em><tt>()</tt>\n
    <tt>\\</tt><em>class</em><tt>::</tt><em>static_method</em><tt>()</tt>\n
    <tt>\\</tt><em>object.method</em><tt>()</tt>

    @par Description
    <tt>\\</tt> \a function_name <tt>()</tt>\n
    This makes a call reference to a function. Call references to functions are resolved at parse time; if the function does not exist a parse exception will be thrown.\n\n
    <tt>\\</tt> \a class <tt>::</tt> \a static_method <tt>()</tt>\n
    This makes a call reference to a static method. Call references to static methods are resolved at parse time; if the static method does not exist a parse exception will be thrown.\n\n
    <tt>\\</tt> \a object <tt>.</tt> \a method <tt>()</tt>\n
    - \a object: can be any valid %Qore expression that evaluates to an object
    - \a method: must be an unquoted string (see example below) and must represent a valid method name of the object's class.
    .
    This makes a call reference to an object method call, binding the object and the method in the call reference. Call references to object methods are executed and resolved at run time; if the object expression does not evaluate to an object at run-time, an \c OBJECT-METHOD-REFERENCE-ERROR exception will be thrown. If the method does not exist, a \c METHOD-DOES-NOT-EXIST run-time exception will be thrown.  When called, a call reference to an object method will be executed in the context of the object originally referenced. Object method call references do not prolong the lifetime of an object; if the object is deleted (for example, by going out of scope), then if called the call reference will cause an \nOBJECT-ALREADY-DELETED exception to be thrown.

    @par Example
    @code my code $c = \printf(); @endcode
    @code my code $c = \MyClass::method(); @endcode
    @code my code $c = \$obj.method(); @endcode

    @note The backslash at the beginning and the empty parentheses at the end; these are required when specifying a call reference.

    @subsection closure Closures

    @par Synopsis
    A closure is an anonymous function used as a value. Closures can be returned from functions or methods, assigned to variables, or passed as arguments to other functions.

    @par Syntax
    <em>[return_type]</em> <tt>sub (</tt> <em>[[type] variable1, ...]</em><tt>) {</tt> <em>[code]</em> <tt>}</tt>\n\n
    or the alternate (deprecated) syntax with the \c returns keyword after the parameters:\n\n
    <tt>sub (</tt> <em>[[type] variable1, ...]</em><tt>) \c returns <em>return_type</em> {</tt> <em>[code]</em> <tt>}</tt>

    @par Description
    Closures encapsulate the state and value of local variables of the outer code block referenced from within the closure when the closure is created. Whenever local variables are bound within a closure, these variables are subject to concurrent thread access protection (locking) just as with global variables, in order to allow closures to be used in any context without restriction and to preseve thread-safety regarding bound local variables.\n\n
    Note that returning a closure from within an object method encapsulates the state of the object as well (it's legal to refer to \c $self and <tt>$.<variable></tt> from within closures created from objects) and additionally prolongs the scope of the object for the lifetime of the closure.\n\n
    Note that parameter and return types are required when the @ref PO_REQUIRE_TYPES or @ref PO_REQUIRE_PROTOTYPES parse options are set.

    @par Example
    @code
# if $b is a local variable in the function where the closure is created
# then $b will be bound to the closure when the closure is created
my code $closure = int sub (int $a) { return $a + $b; };
    @endcode

    @subsection implicit_arguments Implicit Argument References

    @par Synopsis
    Implicit arguments are arguments not captured by parameter variables as well as automatic arguments in list-processing operator expressions. A special syntax to reference these arguments is documented here.

    @par Syntax
    <tt>$</tt><em>int</em>   (for a single implicit argument)\n
    <tt>$$</tt>              (for the entire implicit argument list)

    @par Description
    Implicit arguments can be directly referenced using the dollar sign (<tt>$</tt>) and either a number from \c 1 onwards (giving the position in the argument list, where \c 1 is the first element) or a double dollar sign (<tt>$$</tt>) giving the entire implicit argument list.\n\n
    For unassigned arguments to functions or methods, this syntax supplements the automatic $argv variable holding all function arguments not assigned to parameter variables.\n\n
    This syntax is particularly useful when writing expressions for the @ref map "map", @ref foldl "foldl", @ref foldr "foldr", and @ref select "select" operators, where implicit argument references are the only way the operator expressions can reference the current list values that are populated as implicit arguments as the operators traverse the list.

    @par Example
    @code
# extract a list of even numbers from a list
my list $l = select $list, !($1 % 2);
    @endcode

    @subsection implicit_index Implicit Index

    @par Synopsis
    The current list index position when implicitly iterating through lists can be referenced using the implicit index reference characters: <tt>$#</tt>.

    @par Syntax
    <tt>$#</tt>

    @par Description
    The implicit index reference expression (<tt>$#</tt>) can be used whenever a list is iterated implicitly, such as with @ref foreach_statement "foreach statements" and the @ref map "map", @ref foldl "foldl", @ref foldr "foldr", and @ref select "select" operators.

    @par Example
    @code
# create a list of indexes with negative values
my list $l = map $#, $list, ($1 < 0);
    @endcode

    @section operators Operators

    The following table lists all %Qore operators in order of precedence, starting with the highest precedence. The lower the precedence number, the higher the precedence, therefore the operators with precedence level 1 (\c "{}", \c "[]", \c ".") have the highest precedence of all %Qore operators. The precedence levels in %Qore are roughly equal to the precedence levels of C language operators. To explicitly specify the precedence for expression evaluation, use parentheses <tt>()</tt>.

    <b>Operators</b>
    |!Operator|!Prec.|!Description|!Example
    |@ref backquote_operator "``"|\c 1|@ref backquote_operator "backquote/backtick operator"|@code `ls -l`@endcode
    |@ref hash_element_operator "{}"|\c 1|@ref hash_element_operator "hash element or object member expression dereference operator"|@code $hash{"na" + "me"}@endcode
    |@ref dot_operator "."|\c 1|@ref dot_operator "hash element or object member literal dereference operator"|@code $hash.name@endcode @code $obj.method()@endcode
    |@ref list_element_operator "[]"|\c 1|@ref list_element_operator "list element, string, and binary dereference operator"|@code $list[1]@endcode
    |@ref pre_increment_operator "++"|\c 2|@ref pre_increment_operator "pre-increment operator"|@code ++$a@endcode
    |@ref post_increment_operator "++"|\c 2|@ref post_increment_operator "post-increment operator"|@code $a++@endcode
    |@ref pre_decrement_operator "--"|\c 2|@ref pre_decrement_operator "pre-decrement operator"|@code --$a@endcode
    |@ref post_decrement_operator "--"|\c 2|@ref post_decrement_operator "post-decrement operator"|@code $a--@endcode
    |@ref new "new"|\c 3|@ref new "class instantiation/new object operator"|@code new Socket()@endcode
    |@ref background "background"|\c 3|@ref background "background/thread creation operator"|@code background mainThread()@endcode
    |@ref delete "delete"|\c 3|@ref delete "delete operator"|@code delete $var@endcode
    |@ref remove "remove"|\c 3|@ref remove "remove operator"|@code remove $var@endcode
    |@ref cast "cast<>()"|\c 3|@ref cast "cast<>() operator"|@code cast<SubClass>($var)@endcode
    |@ref logical_negation_operator "!"|\c 4|@ref logical_negation_operator "logical negation operator"|@code if (!($a > 10)) {}@endcode
    |@ref binary_not_operator "~"|\c 5|@ref binary_not_operator "binary not/bit inversion operator"|@code $var = ~$var@endcode
    |@ref unary_minus_operator "- (unary minus)"|\c 6|@ref unary_minus_operator "unary minus operator"|@code $var = -$var@endcode
    |@ref shift "shift"|\c 7|@ref shift "shift list element operator"|@code shift $list@endcode
    |@ref pop "pop"|\c 7|@ref pop "pop list element operator"|@code pop $list@endcode
    |@ref chomp "chomp"|\c 7|@ref chomp "chomp end-of-line character operator"|@code chomp $string@endcode
    |@ref trim "trim"|\c 7|@ref trim "trim characters operator"|@code trim $string@endcode
    |@ref elements "elements"|\c 8|@ref elements "number of elements operator (list, hash, string, binary)"|@code elements $list@endcode
    |@ref keys "keys"|\c 8|@ref keys "hash key list operator"|@code keys $hash@endcode
    |@ref multiplication_operator "*"|\c 9|@ref multiplication_operator "multiplication operator"|@code $var = $a * 10@endcode
    |@ref division_operator "/"|\c 9|@ref division_operator "division operator"|@code $var = $a / 10@endcode
    |@ref modula_operator "%"|\c 10|@ref modula_operator "modula operator"|@code $var = $a % 10@endcode
    |@ref plus_operator "+"|\c 11|@ref plus_operator "plus operator: string, binary, list, and hash concatenation, integer and float addition"|@code $a + 10@endcode @code "hello" + "there"@endcode @code $list + "new value"@endcode @code $hash + ( "newkey" : 100 )@endcode
    |@ref minus_operator "-"|\c 11|@ref minus_operator "minus operator (arithmetic subtraction, hash key removal)"|@code $a - 10@endcode
    |@ref shift_right_operator ">>"|\c 12|@ref shift_right_operator "bitwise shift right operator"|@code 0xff00 >> 8@endcode
    |@ref shift_left_operator "<<"|\c 12|@ref shift_left_operator "bitwise shift left operator"|@code 0xff00 << 8@endcode
    |@ref exists "exists"|\c 13|@ref exists "exists value operator"|@code exists $var@endcode
    |@ref instanceof "instanceof"|\c 13|@ref instanceof "instanceof class operator"|@code instanceof Qore::Mutex@endcode
    |@ref logical_less_than_operator "<"|\c 14|@ref logical_less_than_operator "Logical less than operator"|@code $a < 10@endcode
    |@ref logical_greater_than_operator ">"|\c 14|@ref logical_greater_than_operator "Logical greater than operator"|@code $a > 10@endcode
    |@ref logical_equality_operator "=="|\c 14|@ref logical_equality_operator "Logical equality operator"|@code $a == 10@endcode
    |@ref logical_inequality_operator "!="|\c 14|@ref logical_inequality_operator "logical inequality operator"|@code $a != 10@endcode
    |@ref logical_less_than_or_equals_operator "<="|\c 14|@ref logical_less_than_or_equals_operator "Logical less then or equals operator"|@code $a <= 10@endcode
    |@ref logical_greater_than_or_equals_operator ">="|\c 14|@ref logical_greater_than_or_equals_operator "logical greater than or equals operator"|@code $a >= 10@endcode
    |@ref logical_comparison_operator "<=>"|\c 14|@ref logical_comparison_operator "logical comparison operator"|@code $a <=> $b@endcode
    |@ref logical_absolute_equality_operator "==="|\c 14|@ref logical_absolute_equality_operator "absolute logical equality operator"|@code $a === 10@endcode
    |@ref logical_absolute_inequality_operator "!=="|\c 14|@ref logical_absolute_inequality_operator "absolute logical inequality operator"|@code $a !== 10@endcode
    |@ref regex_match_operator "=~ //"|\c 14|@ref regex_match_operator "regular expression match operator"|@code $a =~ /text/@endcode
    |@ref regex_no_match_operator "!~ //"|\c 14|@ref regex_no_match_operator "regular expression no match operator"|@code $a !~ /text/@endcode
    |@ref regex_subst_operator "=~ s///"|\c 14|@ref regex_subst_operator "regular expression substitution operator"|@code $a =~ s/text/text/@endcode
    |@ref regex_extract_operator "=~ x//"|\c 14|@ref regex_extract_operator "regular expression pattern extraction operator"|@code $a =~ x/(\w+):(\w+)/@endcode
    |@ref transliteration_operator "=~ tr"|\c 14|@ref transliteration_operator "transliteration operator"|@code $a =~ tr/a-z/A-Z/@endcode
    |@ref bitwise_and_operator "&"|\c 15|@ref bitwise_and_operator "bitwise/binary AND operator"|@code $a & 0xff@endcode
    |@ref bitwise_or_operator "|"|\c 15|@ref bitwise_or_operator "bitwise/binary OR operator"|@code $a | 0xff@endcode
    |@ref bitwise_xor_operator "^"|\c 15|@ref bitwise_xor_operator "bitwise/binary XOR operator"|@code $a ^ 0xff@endcode
    |@ref logical_and_operator "&&"|\c 16|@ref logical_and_operator "logical AND operator"|@code ($a = 1) && ($b < 10)@endcode
    |@ref logical_or_operator "||"|\c 16|@ref logical_or_operator "logical OR operator"|@code ($a = 1) || ($b < 10)@endcode
    |@ref conditional_operator "? :"|\c 17|@ref conditional_operator "conditional operator"|@code $a == 2 ? "yes" : "no"@endcode
    |@ref comma_operator ","|\c 18|@ref comma_operator "comma operator"|@code 1, 2, 3, 4, 5@endcode
    |@ref unshift "unshift"|\c 19|@ref unshift "unshift list element operator"|@code unshift $list, $val@endcode
    |@ref push "push"|\c 19|@ref push "push list element operator"|@code push $list, $val@endcode
    |@ref splice "splice"|\c 19|@ref splice "splice list or string operator"|@code splice $list, 2, 2, (1, 2, 3)@endcode
    |@ref extract "extract"|\c 19|@ref extract "extract list or string operator"|@code my $sublist = extract $list, 2, 2, (1, 2, 3)@endcode
    |@ref map "map"|\c 19|@ref map "map operator"|@code map $closure($1), $list@endcode
    |@ref foldl "foldl"|\c 19|@ref foldl "fold left to right operator"|@code foldl $closure($1 - $2), $list@endcode
    |@ref foldr "foldr"|\c 19|@ref foldr "fold right to left operator"|@code foldr $closure($1 - $2), $list@endcode
    |@ref select "select"|\c 19|@ref select "select elements from list operator"|@code select $list, $1 > 1@endcode
    |@ref assignment_operator "="|\c 20|@ref assignment_operator "assignment operator"|@code $var = 1@endcode
    |@ref plus_equals_operator "+="|\c 21|@ref plus_equals_operator "plus-equals (add-to) operator"|@code $var += 5@endcode
    |@ref minus_equals_operator "-="|\c 21|@ref minus_equals_operator "minus-equals (subtract-from) operator"|@code $var -= 5@endcode
    |@ref and_equals_operator "&="|\c 21|@ref and_equals_operator "and-equals operator"|@code $var &= 0x2000@endcode
    |@ref or_equals_operator "|="|\c 21|@ref or_equals_operator "or-equals operator"|@code $var |= 0x2000@endcode
    |@ref modula_equals_operator "%="|\c 21|@ref modula_equals_operator "modula-equals operator"|@code $var %= 100@endcode
    |@ref multiply_equals_operator "*="|\c 21|@ref multiply_equals_operator "multiply-equals operator"|@code $var *= 10@endcode
    |@ref divide_equals_operator "/="|\c 21|@ref divide_equals_operator "divide-equals operator"|@code $var /= 10@endcode
    |@ref xor_equals_operator "^="|\c 21|@ref xor_equals_operator "xor-equals operator"|@code $var ^= 0x2000@endcode
    |@ref shift_left_equals_operator "<<="|\c 21|@ref shift_left_equals_operator "shift-left-equals operator"|@code $var <<= 0x2000@endcode
    |@ref shift_right_equals_operator ">>="|\c 21|@ref shift_right_equals_operator "shift-right-equals operator"|@code $var >>= 0x2000@endcode

    @note All Qore operators perform thread-atomic actions with respect to the immediate arguments of the operator. If the operators are used in a complex expression, the entire expression is not thread-atomic unless explicit user-level locking is used. For example: <tt>$a += 5</tt> is a thread-atomic action, but <tt>$a += $b--</tt> is not atomic, but rather made up of two atomic actions.\n\n
    When an operator taking more than one argument is used with arguments of different data types, Qore automatically converts one or both data types to a data type supported by the operator in order to evaluate the result, according to the precedence lists given for each operator. That is; when an operator operates on mixed types, the types listed first in the following sections have precedence over types listed farther down in the lists. The result type will always be equal to the final operation type after any conversions due to type precedence per operator. If no type of either argument matches a supported data type for the operator, both types will be converted to the highest precedence data type for the operator and then the operator will evaluate the result. For explicit type conversion, please see the boolean(), string(), date(), int(), float(), etc functions.

    @subsection backquote_operator Backquote Operator (``)

    @par Synopsis
    Executes the shell command in a separate process and returns the stdout as a string. To perform the same action using a %Qore expression, see the backquote() function.

    @par Syntax
    <tt>`</tt><em>shell_command</em><tt>`</tt>

    @par Return Type
    @ref string_type "string"

    @par Example
    @code my string $dir = `ls -l`@endcode

    <b>Arguments Processed by ``</b>
    |!Argument|!Returns|!Processing
    |unquoted @ref string "string" \a shell_command|@ref string_type "string"|The shell command will be executed and the \c stdout is returned as a string

    <b>Exceptions Thrown by ``</b>
    |!err|!desc
    |\c BACKQUOTE-ERROR|An error occurred in fork() or creating the output pipe

    @subsection hash_element_operator Hash Element or Object Member Expression Dereference Operator ({})

    @par Synopsis
    Retrieves the value of hash key or object member by evaulating an expression.

    @par Syntax
    \a container_expression <tt>{</tt> \a expression <tt>}</tt>

    @par Return Type
    @ref any_type "any"

    @par Example
    @code printf("%s\n", $hash{getName()});@endcode

    <b>Arguments Processed by {}</b>
    |!Argument|!Processing
    |\a container_expression|This expression must evaluate to a @ref hash "hash" or an @ref object "object"; if not, the operator returns no value (@ref nothing)
    |\a expression|- @ref list "list": if the expression evaluates to a list, then a slice of the hash or object is returned as a hash containing keys given in the list that are present in the hash or object. If the key as given in the list (converted to a string if necessary) is not present in the hash or object, then it is also not present in the hash returned; of none of the given keys exist in the hash, an empty hash is returned.\n- anything other than @ref list "list": the expression is converted to a string (if necessary); the value of the hash key corresponding to this string will be returned; if the key or member does not exist, then no value is returned

    <b>Exceptions Thrown by {}</b>
    |!err|!desc
    |\c PRIVATE-MEMBER|Attempt to access a private member outside the class

    @subsection dot_operator Hash Element or Object Member Literal Dereference Operator (.)

    @par Synopsis
    Retrieves the value of a hash key or object member using a literal identifier or an expression.

    @par Syntax
    \a hash_or_object_expression <tt>.</tt> \a identifier\n
    \a object_expression <tt>.</tt> \a method_name<tt>(</tt><em>[args ...]</em><tt>)</tt>\n
    \a hash_or_object_expression <tt>.</tt> \a expression\n

    @par Return Type
    @ref any_type "any"

    @par Example
    @code printf("%s\n", $hash.name);@endcode
    @code $obj.method("argument");@endcode

    <b>Arguments Processed by .</b>
    |!Argument|!Processing
    |\a hash_or_object_expression|This expression must evaluate to a hash or an object; if not, then the operator returns no value
    |\a identifier|An unquoted string taken as the literal name of the hash key or object member. If no such key exists, then no value is returned. In order to use hash keys that are not valid Qore identifiers, please use the {} operator. If the member is a private member and access is made outside the class, a run-time exception will be thrown.  Also note that constants or static class member names will not be resolved, in this case the string given is used as the literal name of the hash key or object member
    \n
    |!Argument|!Processing
    |\a object_expression|The \a object_expression must evaluate to an object or a run-time exception is thrown. If the method does not exist in the class a run-time exception is thrown. Otherwise the method is called with any optional arguments given and the return value of the method is returned.
    \n
    |!Argument|!Processing
    |\a hash_or_object_expression|This expression must evaluate to a hash or an object; if not, then the operator returns no value
    |\a expression|- @ref list "list": if the expression evaluates to a list, then a slice of the hash or object is returned as a hash containing keys given in the list that are present in the hash or object. If the key as given in the list (converted to a string if necessary) is not present in the hash or object, then it is also not present in the hash returned; of none of the given keys exist in the hash, an empty hash is returned.\n- anything other than @ref list "list": the expression is converted to a string (if necessary); the value of the hash key corresponding to this string will be returned; if the key or member does not exist, then no value is returned
    
    <b>Exceptions Thrown by ``</b>
    |!err|!desc
    |\c PRIVATE-MEMBER|Attempt to access a private member outside the class
    |\c METHOD-DOES-NOT-EXIST|Attempt to access a method not defined for this class
    |\c METHOD-IS-PRIVATE|Attempt to access a private method from outside the class
    |\c BASE-CLASS-IS-PRIVATE|Attempt to access a method of a privately-inherited base class from outside the class
    |\c OBJECT-METHOD-EVAL-ON-NON-OBJECT|Attempt to execute a method on a non-object

    @subsection list_element_operator List, String, and Binary Dereference Operator ([])

    @par Synopsis
    Retrieves the value of a list element, the given character of a string, or the integer value of a byte for a binary object. If the index value is not valid for the argument, @ref nothing is returned. Note that this operator only works as a list dereferencing operator in lvalue expressions; you cannot assign a character or a byte value to strings or binaries using this operator.

    @par Syntax
    <em>list_expression</em><tt>[</tt>\a offset_expression<tt>]</tt>
    <em>string_expression</em><tt>[</tt>\a offset_expression<tt>]</tt>
    <em>binary_expression</em><tt>[</tt>\a offset_expression<tt>]</tt>

    @par Return Type
    @ref any_type "any"

    @par Example
    @code printf("%s\n", $list[2]);@endcode
    @code printf("%s\n", $str[2]);@endcode
    @code printf("0x%x\n", $binary[2]);@endcode

    <b>Arguments Processed by []</b>
    |!Argument|!Processing
    |\a list_expression|If the expression evaluates to a list, then the \a offset_expression will be used to return the given element from the list
    |\a string_expression|If the expression evaluates to a string, then the \a offset_expression will be used to return the given character from the list; note that multi-byte characters with UTF-8 are properly respected with this operator
    |\a binary_expression|If the expression evaluates to a binary, then the \a offset_expression will be used to return the integer value of the byte given from the binary object
    |\a offset_expression|The expression is evaluated and converted to an integer if necessary. Then the value of the given element given is returned according to the type of the first expression (as listed above; elements start at position 0)

    This operator does not throw any exceptions; if the first expression does not evaluate to either a list, string, or binary, then no value (@ref nothing) is returned.

    @subsection pre_increment_operator Integer Pre-Increment Operator (++)

    @par Synopsis
    Increments an lvalue and returns the incremented value.

    @par Syntax
    <tt>++</tt><em>lvalue</em>

    @par Return Type
    @ref int_type "int"

    @par Example
    @code ++$i;@endcode

    <b>Arguments Processed by ++ (pre-increement)</b>
    |!Argument|!Processing
    |@ref integer|First converts the value of \a lvalue to an integer if necessary, then increments \a lvalue and returns the result

    This operator does not throw any exceptions.

    @subsection post_increment_operator Integer Post-Increment Operator (++)

    @par Synopsis
    Increments an lvalue and returns the value before the increment.

    @par Syntax
    <em>lvalue</em><tt>++</tt>

    @par Return Type
    @ref any_type "any"

    @par Example
    @code $i++;@endcode

    <b>Arguments Processed by ++ (post-increment)</b>
    |!Argument|!Processing
    |@ref integer|First converts the value of \a lvalue to an integer if necessary, then saves this value as the result, then increments \a lvalue, then returns the saved original value of \a lvalue

    This operator does not throw any exceptions.

    @subsection pre_decrement_operator Integer Pre-Decrement Operator (--)

    @par Synopsis
    Decrements an lvalue and returns the decremented value.

    @par Syntax
    <tt>--</tt><em>lvalue</em>

    @par Return Type
    @ref int_type "int"

    @par Example
    @code --$i;@endcode

    <b>Arguments Processed by -- (pre-decrement)</b>
    |!Argument|!Processing
    |@ref integer|First converts the value of \a lvalue to an integer if necessary, then decrements it and returns the result

    This operator does not throw any exceptions.

    @subsection post_decrement_operator Integer Post-Decrement Operator (--)

    @par Synopsis
    Decrements an lvalue and returns the value before the decrement.

    @par Syntax
    <em>lvalue</em><tt>--</tt>

    @par Return Type
    @ref any_type "any"

    @par Example
    $i--;

    <b>Arguments Processed by -- (post-decrement)</b>
    |!Argument|!Processing
    |@ref integer|First converts the value of \a lvalue to an integer if necessary, then saves this value as the result, then decrements \a lvalue, then returns the saved original value of lvalue

    This operator does not throw any exceptions.

    @subsection new New Object Operator (new)

    @par Synopsis
    Creates an instance of a class by running the class' constructor on the new class (if any exists) and returns the new object.\n\n
    Note that if possible it is normally better to declare an object with its type and use the abbreviated form to construct the object as follows:\n
    @code my Mutex $m();@endcode
    This provides type information to the parser which allows more errors to be caught at parse time (instead of at run time), and furthermore allows Qore improve performance by performing more work once at parse time rather than for every time the object is accessed at run time (for example, method and variant resolution), and normally requires less typing.

    @par Syntax
    \c \b new <em>class_identifier</em><tt>(</tt><em>constructor_args ...</em><tt>)</tt>

    @par Return Type
    an object of the specific class given

    @par Example
    @code my Mutex $obj = new Qore::Mutex();@endcode

    <b>Arguments Processed by new</b>
    |!Argument|!Processing
    |\a class_identifier|The class_identifier must be an existing class name; if so, the operator instantiates an object of this class, executes the constructor for the class (if any exists, along with any base class constructors, if applicable) on the new object, and returns the object (for constructor execution order in an inherited class, see @inheritance). If an exception is thrown in the constructor, the object is deleted immediately.

    <b>Exceptions Thrown by new</b>
    |!err|!desc
    |depends on class/constructor|See class documentation for possible exceptions

    @subsection background Background Operator (background)

    @par Synopsis
    Start a background thread and return the TID (thread ID).

    @par Syntax
    \c \b background \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code my int $tid = background startThread();@endcode

    <b>Arguments Processed by background</b>
    |!Argument|!Processing
    |\a expression|The \a expression given as an argument will be executed in a new thread. The TID of the new thread will be returned as the return value of the operator

    @par Limitations of the Background Operator
    Please note the following when using the background operator:
    - expressions that have no effect cannot be used with the background operator (a parse exception will be thrown)
    - it is illegal to make changes to a local variable anywhere in a background expression (a parse exception will be thrown)
    - local variables and find expressions are evaluated before the new thread is started and the result of the evaluation is used in the expression in the new thread
    - it is not possible to pass local variables by reference anywhere in a background expression (a parse exception will be thrown)

    <b>Exceptions Thrown by background</b>
    |!err|!desc
    |\c THREAD-CREATION-FAILURE|If the thread table is full or if the operating system returns an error while starting the thread, this exception is thrown

    @subsection delete Delete Operator (delete)

    @par Synopsis
    The delete operator deletes the contents of an lvalue. If the delete operator is called on an object, the object will be destroyed unconditionally. The delete operator does not return any value.\n\n
    When called on a hash key, the key is removed from the hash entirely; when called on a list element, the element is assigned @ref nothing (i.e. the list size does not change).\n\n
    The delete operator will delete multiple keys from a hash (i.e. delete a slice from a hash) when called on a hash dereferenced by a list of strings, giving the keys to delete (see example below).\n\n
    In the case the delete operator operates on an object, any exception can be thrown that is thrown by the class' destructor.\n\n
    For a similar operator that returns the value that is removed from the data structure, and does not delete objects, see the @ref remove_operator "remove operator".

    @par Syntax
    \c \b delete \a lvalue_expression

    @par Return Type
    Does not return any value

    @par Example
    @code
# delete a single key from a hash
delete $value;
# delete multiple values from a hash
delete $h.("a", "b", "c");
    @endcode

    This operator does not throw any exceptions, however exceptions could be thrown in an object's destructor method when deleted by this operator.

    @subsection remove Remove Operator (remove)

    @par Synopsis
    The remove operator removes a value from a data structure, or, in the case the operand of the remove operator is a simple value, the value itself is removed from the variable and returned. The remove operator returns the value removed from the lvalue.\n\n
    When called on a hash key, the key is removed from the hash entirely, and the value returned is the value of the key removed from the hash; when called on a list element, the element is assigned @ref nothing (i.e. the list size does not change).\n\n
    The remove operator will remove and return a slice from a hash when called on a hash dereferenced by a list of strings, giving the keys to remove (see example below).\n\n
    The remove operator does not call destructors when operating on objects, but if removing an object from an lvalue or from a data structure within the lvalue causes the object to go out of scope, it will be destroyed, and then its destructor could throw an exception.\n\n
    For a similar operator that deletes the value that is removed from the data structure, see the @ref delete_operator "delete operator".

    @par Syntax
    \c \b remove \a lvalue_expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code
# remove a single value from a hash
my any $var = remove $hash.value;
# remove a slice from a hash
my hash $nh = remove $h.("a", "b", "c");
    @endcode

    This operator does not throw any exceptions, however exception could be thrown in an object's destructor if it goes out of scope due to the action of this operator.

    @subsection cast Cast Operator (cast<>())

    @par Synopsis
    The cast<>() operator provides a way to tell the parser that the type of object is not actually the declared type but rather a subclass as given between the angle brackets.

    @par Syntax
    <tt><b>cast</b></tt>\<<em>class_identifier</em><tt>\>(</tt><em>object_expression</em><tt>)</tt>

    @par Return Type
    the specific class given

    @par Example
    @code cast<SubClass>($obj).method();@endcode

    <b>Arguments Processed by cast<>()</b>
    |!Argument|!Processing
    |\a class_identifier|This must be a literal unquoted string giving a class name or a namespace-qualified path to a class (ex: \c Namespace::MyClass)
    |\a object_expression|This must be an expression that evaluates to an object that can be cast to the given class; this is mostly useful at parse time to avoid @ref non-existent-method-call "non-existent-method-call warnings"

    <b>Exceptions Thrown by cast</b>
    |!err|!desc
    |\c RUNTIME-CAST-ERROR|The expression given does not evaluate to an object that can be cast to the given class

    @subsection logical_negation_operator Logical Not Operator (!)

    @par Synopsis
    Reverses the logical sense of an expression (\c True becomes \c False and \c False becomes \c True).

    @par Syntax
    <tt>!</tt><em>expression</em>

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if (!exists $error_code)
    do_something();
    @endcode

    <b>Arguments Processed by !</b>
    |!Argument|!Processing
    |\a expression|The expression is evaluated and converted to a @ref boolean "bool", if necessary. Then the value is logically reversed (\c True becomes \c False, \c False becomes \c True)

    This operator does not throw any exceptions.

    @subsection binary_not_operator Binary Not Operator (~)

    @par Synopsis
    The value of each bit in an integer is reversed (0 becomes 1, 1 becomes 0).

    @par Syntax
    <tt>~</tt><em>expression</em>

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a = ~$b;@endcode

    <b>Arguments Processed by ~</b>
    |!Argument|!Processing
    |\a expression|The argument is converted to an integer (if necessary), and bitwise negation is performed on the argument (ex: <tt>666 & ~27</tt> results in \c 640)

    This operator does not throw any exceptions

    @subsection unary_minus_operator Unary Minus Operator (-)

    @par Synopsis
    Changes the sign of numeric values.

    @par Syntax
    -expression

    @par Return Type
    @ref int_type "int" or @ref float_type "float"

    @par Example
    @code $a = -$b;@endcode

    <b>Arguments Processed by - (unary minus)</b>
    |!Argument|!Processing
    |@ref float|Gives the negative of its argument as a @ref float (ex: <tt>-(-1.1) = 1.1, -(1.1) = -1.1</tt>
    |@ref integer|Gives the negative of its argument as an @ref integer (ex: <tt>-(-1) = 1, -(1) = -1</tt>

    This operator does not throw any exceptions

    @subsection shift Shift Operator (shift)

    @par Synopsis
    Removes the first element from a list and returns that element.

    @par Syntax
    \c \b shift \a lvalue

    @par Return Type
    @ref any_type "any"

    @par Example
    @code my *string $a = shift $ARGV;@endcode

    <b>Arguments Processed by shift</b>
    |!Argument|!Processing
    |\a lvalue|Returns the first element of the list, and the list is modified by having the first element removed from the list.  If the \a lvalue is not a list, no action is performed and the operator returns no value (@ref nothing)

    This operator does not throw any exceptions.

    @subsection pop Pop Operator (pop)

    @par Synopsis
    Removes the last element from a list and returns that element.

    @par Syntax
    \c \b pop \a lvalue

    @par Return Type
    @ref any_type "any"

    @par Example
    @code $a = pop $list;@endcode

    <b>Arguments Processed by pop</b>
    |!Argument|!Processing
    |\a lvalue|Returns the last element of the list, and the list is modified, having the last element removed from the list. If the \a lvalue is not a list, no action is performed and the operator returns no value (@ref nothing)

    This operator does not throw any exceptions.

    @subsection chomp Chomp Operator (chomp)

    @par Synopsis
    Removes the end-of-line marker(s) (\c '\\n' or \c '\\r\\n') from a string, or each string element in a list, or each hash key value in a hash (if the value is a string) and returns the number of characters removed.\n\n
    To perform this operation on a non-lvalue expression, see the chomp() function.

    @par Syntax
    \c \b chomp \a lvalue

    @par Return Type
    @ref int_type "int"

    @par Example
    @code chomp $str;@endcode

    <b>Arguments Processed by chomp</b>
    |!Argument|!Processing
    |\a lvalue (@ref string)|Removes any EOL characters from a string and returns the number of characters removed.
    |\a lvalue (@ref list)|Removes any EOL characters from each string element of the list passed and returns the number of characters removed.
    |\a lvalue (@ref hash)|Removes any EOL characters from each hash key's value (where the value is a string) and returns the number of characters removed.

    This operator does not throw any exceptions.

    @subsection trim Trim Operator (trim)

    @par Synopsis
    Removes whitespace characters from the beginning and end of a string, or each string element in a list, or each hash key value in a hash (if the value is a string) and returns the value processed (string, list, or hash).\n\n
    To perform this operation on a non-lvalue expression, see the trim() function.\n\n
    The following whitespace characters are removed from the beginning and end of strings: <tt>' '</tt> (blank spaces), \c '\\n', \c '\\r', \c '\\t', \c '\\v' (vertical tab, ASCII 11), and \c '\\0' (null character).

    @par Syntax
    \c \b trim \a lvalue

    @par Return Type
    @ref string_type "string", @ref list_type "list", or @ref hash_type "hash"

    @par Example
    @code trim $str;@endcode

    <b>Arguments Processed by trim</b>
    |!Argument|!Processing
    |\a lvalue (@ref string)|Removes whitespace characters from the beginning and end of a string and returns the value processed.
    |\a lvalue (@ref list)|Removes whitespace characters from the beginning and end of each string element of the list passed and returns the list.
    |\a lvalue (@ref hash)|Removes whitespace characters from the beginning and end of each string value of the hash passed and returns the hash.

    This operator does not throw any exceptions.

    @subsection map Map Operator (map)

    @par Synopsis
    Executes (or maps) an expression on a list and returns the result. An optional select expression can be given to filter elements out from the result list.\n\n
    If the second argument is not a list, then \a map_expression is executed on the single value and the result is returned, and any \a select_expression is ignored.

    @par Return Type
    @ref any_type "any"

    @par Syntax
    \c \b map \a map_expression, <em>list_expression [, select_expression]</em>

    @par Example
    @code
# returns (2, 4, 6)
map $1 * 2, (1, 2, 3);
    @endcode

    <b>Arguments Processed by map</b>
    |!Argument|!Processing
    |\a map_expression|The expression to map on the list; the implicit argument <tt>$1</tt> represents the current element being processed.
    |\a list_expression|The data to process; if this is not a list then the \a map_expression is run on the single argument passed
    |<em>[select_expression]</em>|An optional expression than can be used to filter out elements of the list before the map expression is applied; if this expression evaluates to \c False on an element, then the element will be skipped and the \a map_expression will not be applied on that element.

    This operator does not throw any exceptions (however note that exceptions could be thrown by expressions executed by this operator).

    @subsection foldl Fold Left Operator (foldl)

    @par Synopsis
    Folds an operation on a list from left to right and returns the result. The result of each individual operation is used as the first argument in the foldl expression for the next element in the list. The first operation of the fold is made by executing the fold expression on the first and second elements of the list, from this point onwards, the result of each successive operation is used as the first argument for the next operation, the second argument being the next element in the list.\n\n
    If the \a list_expression does not evaluate to a list, then the evaluated argument is returned immediately with no processing by the fold expression.

    @par Syntax
    \c \b foldl \a expression, \a list_expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code
# returns 5
foldl $1 - $2, (10, 4, 1);
    @endcode

    <b>Arguments Processed by foldl</b>
    |!Argument|!Processing
    |\a expression|The expression to fold on the list; the implicit argument <tt>$1</tt> represents the result of the last operation (or the first element in the list when beginning the fold), and <tt>$2</tt> represents the next element of the list.
    |\a list_expression|The list to process

    This operator does not throw any exceptions (however note that exceptions could be thrown by expressions executed by this operator).

    @subsection foldr Fold Right Operator (foldr)

    @par Synopsis
    Folds an operation on a list from right to left and returns the result. The result of each individual operation is used as the first argument in the foldr expression for the next element in the list in reverse order. The first operation of the right fold is made by executing the fold expression on the last and penultimate elements of the list, from this point onwards, the result of each successive operation is used as the first argument for the next operation, the second argument being the next element in the list in reverse order.\n\n
    If the \a list_expression does not evaluate to a list, then the evaluated argument is returned immediately with no processing by the fold expression.

    @par Syntax
    \c \b foldr \a expression, \a list_expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code
# returns -13
foldr $1 - $2, (10, 4, 1);
    @endcode

    <b>Arguments Processed by foldr</b>
    |!Argument|!Processing
    |\a expression|The expression to fold on the list; the implicit argument <tt>$1</tt> represents the result of the last operation (or the last element in the list when beginning the fold), and <tt>$2</tt> represents the next element of the list in reverse order.
    |\a list_expression|The list to process

    This operator does not throw any exceptions (however note that exceptions could be thrown by expressions executed by this operator).

    @subsection select Select From List Operator (select)

    @par Synopsis
    Selects elements from a list that meet the given criteria and returns the new list.\n\n
    If the list expression does not evaluate to a list, then the select expression is evaluated using the value of the list expression as an argument, if it evalutes to true, then the value is returned, otherwise, no value is returned.

    @par Syntax
    \b \c select \a list_expression, \a expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code
# returns (2, 4, 6)
select (1, 2, 3, 4, 5, 6), !($1 % 2);
    @endcode

    <b>Arguments Processed by select</b>
    |!Argument|!Processing
    |\a list_expression|The list to process
    |\a expression|The expression will be evaluated on each element of the list, the implicit argument <tt>$1</tt> represents current element of the list; only if the expression evaluates to \c True will the element appear in the result list

    This operator does not throw any exceptions (however note that exceptions could be thrown by the expression executed by this operator).

    @subsection elements Elements Operator (elements)

    @par Synopsis
    Returns the number of elements in a list, the number of keys in a hash, the number of characters (not bytes) in a string, or the number of bytes in a binary object.

    @par Syntax
    \b \c elements \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code my int $size = elements $list;@endcode

    <b>Arguments Processed by elements</b>
    |!Argument|!Processing
    |\a expression @ref list_type "list"|Returns the number of elements in the list
    |\a expression @ref hash_type "hash"|Returns the number of keys in the hash
    |\a expression @ref string_type "string"|Returns the number of characters in the string (which may be different than the number of bytes for multi-byte character encodings such as \c UTF-8
    |\a expression @ref binary_type "binary"|Returns the number of bytes in the binary object

    This operator does not throw any exceptions.

    @subsection keys Keys Operator (keys)

    @par Synopsis
    Returns a list representing the keys in a hash.

    @par Syntax
    \b \c keys \a hash_expression

    @par Return Type
    @ref list_type "list" or @ref nothing

    @par Example
    @code
foreach my string $key in (keys $hash)
    printf("%s = %s\n", $key, $hash.$key);
    @endcode

    <b>Arguments Processed by keys</b>
    |!Argument|!Processing
    |\a hash_expression|Returns a list of strings giving the keys in \a hash_expression, which must evaluate to a hash. If not, then no value is returned.

    This operator does not throw any exceptions.

    @subsection multiplication_operator Multiply Operator (*)

    @par Synopsis
    Multiplies two arguments.

    @par Syntax
    \a expression1 <tt>*</tt> \a expression2

    @par Return Type
    @ref int_type "int" or @ref float_type "float"

    @par Example
    @code $value = $x * $y;@endcode

    <b>Arguments Processed by * (in order of precedence)</b>
    |!Argument|!Processing
    |@ref float_type "float"|Gives the result of multiplying its arguments; if either of the arguments is a @ref float "float" then the result is also a @ref float "float"
    |@ref int_type "int"|Gives the result of multiplying its arguments
    |any other type|Converts argument to a float and performs the multiplication

    This operator does not throw any exceptions.

    @subsection division_operator Divide Operator (/)

    @par Synopsis
    Divides a number by another.

    @par Syntax
    \a expression1 <tt>/</tt> \a expression2

    @par Return Type
    @ref int_type "int" or @ref float_type "float"

    @par Example
    @code $value = $x / $y;@endcode

    <b>Arguments Processed by / (in order of precedence)</b>
    |!Argument|!Processing
    |@ref float_type "float"|Gives the result of dividing its arguments; if either of the arguments is a @ref float "float" then the result is also a @ref float "float"
    |@ref int_type "int"|Gives the result of dividing its arguments
    |any other type|Converts argument to a float and performs the division

    <b>Exceptions Thrown by /</b>
    |!err|!desc
    |\c DIVISION-BY-ZERO|division by zero error

    @subsection modula_operator Modula Operator (%)

    @par Synopsis
    Gives the integer remainder after division of one number by another.

    @par Syntax
    \a expression1 <tt>%</tt> \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $mod = $x % $y;@endcode

    <b>Arguments Processed by %</b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives \a expression1 modula \a expression2 (ex: <tt>12 % 10</tt> result in \c 2). Arguments are converted to integers if necessary.

    This operator does not throw any exceptions.

    @subsection plus_operator Plus (Addition and Concatentation) Operator (+)

    @par Synopsis
    Numeric addition, list, string, binary, and hash concatenation operator.

    @par Syntax
    \a expression1 <tt>+</tt> \a expression2

    @par Return Type
    @ref int_type "int", @ref float_type "float", @ref date_type "date", @ref list_type "list", @ref string_type "string", @ref binary_type "binary", or @ref hash_type "hash"

    @par Example
    @code $a = 1 + 2;@endcode
    @code $string = "hello" + "-there";@endcode
    @code $list = (1, 2) + ("three", "four", "five");@endcode
    @code $hash = ( "key1" : 1, "key2" : 2) + ( "key3" : "three", "key4": "four");@endcode
    @code $bin = $bin1 + $bin2;@endcode

    <b>Arguments Processed by + (in order of precedence)</b>
    |!Argument|!Processing
    |@ref list_type list|Gives the result of concatenating its arguments, i.e. <tt>(1, 2) + (3, 4) = (1, 2, 3, 4)</tt>
    |@ref string_type "string"|Gives the result of concatenating its arguments
    |@ref date_type "date"|Gives the result of adding date/time values (see @ref date_time_arithmetic)
    |@ref float_type "float"|Gives the result of adding its arguments
    |@ref int_type "int"|Gives the result of adding its arguments
    |@ref hash_type "hash"|Gives the result of concatenating/merging its arguments. Any common keys will be overwritten by the values in the second hash (\a expression2)

    This operator does not throw any exceptions.

    @subsection minus_operator Minus Operator (-)

    @par Synopsis
    With float or integer arguments, subtracts one number from another.\n\n
    With date arguments, subtracts one date from another; if both date arguments are absolute dates, the result is a relative date (duration) giving the time between them; if the first date argument is an absolute date and the second is a relative date (duration), then the result is an absolute date. If both date arguments are relative dates, then the result is a relative date. If the first argument is a relative date and the second date is an absolute date, the result is an absolute date as if the operands were reversed.\n\n
    However, if the left-hand side is a hash, and the right-hand side is a string, then the hash key represented by the string will be removed from the hash. If the left-hand side is a hash and the right-hand side is a list, then each element in the list will be converted to a string and any hash key with that name will be deleted from the hash.

    @par Syntax
    \a expression1 <tt>-</tt> \a expression2

    @par Return Type
    @ref int_type "int", @ref float_type "float", @ref date_type "date", or @ref hash_type "hash"

    @par Example
    @code $num = $x - $y;@endcode
    @code $date = 2010-05-13 - P3MT14H10M;@endcode
    @code $hash = $hash - "key";@endcode
    @code $hash = $hash - ("key1", "key2", "key3");@endcode

    <b>Arguments Processed by - (in order of precedence)</b>
    |!Argument|!Processing
    |@ref date_type "date"|date subtraction: \a expression1 - \a expression2
    |@ref float_type "float"|arithmetic subtraction: \a expression1 - \a expression2
    |@ref int_type "int"|arithmetic subtraction: \a expression1 - \a expression2
    |@ref hash_type "hash" - @ref string_type "string"|hash key deletion: \a expression1 - \a expression2
    |@ref hash_type "hash" - @ref list_type "list"|hash key deletion: \a expression1 - \a expression2; all elements of the list are converted to strings (if necessary) and any keys with those names are deleted from the hash.

    This operator does not throw any exceptions.

    @subsection shift_right_operator Shift Right Operator (>>)

    @par Synopsis
    Shifts bits in an integer towards zero (divides an integer by a power of 2)

    @par Syntax
    \a expression1 <tt>\>\></tt> \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a = $x >> $y;@endcode

    <b>Arguments Processed by >></b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives the result of shifting \a expression1 right by \a expression2 bits. Arguments are converted to integers if necesssary.

    This operator does not throw any exceptions.

    @subsection shift_left_operator Shift Left Operator (<<)

    @par Synopsis
    Shifts bits in an integer towards infinity (multiplies an integer by a power of 2)

    @par Syntax
    \a expression1 <tt>\<\<</tt> \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a = $x << $y;@endcode

    <b>Arguments Processed by <<</b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives the result of shifting \a expression1 left by \a expression2 bits. Arguments are converted to integers if necessary.

    This operator does not throw any exceptions.

    @subsection instanceof Class Instance Operator (instanceof)

    @par Synopsis
    Tests if an expression is an instance of a given class or not.

    @par Syntax
    \a expression \c \b instanceof \a class_identifier

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($obj instanceof Qore::Mutex)
    print("object is Mutex\n");
    @endcode

    <b>Arguments Processed by instanceof</b>
    |!Argument|!Processing
    |\a expression|If expression is an instance of the named class, then the operator returns \c True, otherwise returns \c False. The operator will return \c True if the class is a base class, also even if it is privately inherited.

    This operator does not throw any exceptions.

    @subsection exists Exists Operator (exists)

    @par Synopsis
    Tests if an expression represents a value or not.

    @par Syntax
    \c \b exists \a expression

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if (exists $a)
    printf("a = $n\n", $a);
    @endcode

    <b>Arguments Processed by exists</b>
    |!Argument|!Processing
    |\a expression|If \a expression evaluates to a value, then the operator returns \c True, otherwise returns \c False.

    This operator does not throw any exceptions.

    @subsection logical_less_than_operator Less Than Operator (<)

    @par Synopsis
    Tests if a value is less than another; types are converted if necessary (ex: <tt>("1" < 2)</tt> is \c True).

    @par Syntax
    \a expression1 < \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x < $y)
    printf("%n is less than %n\n", $x, $y);
    @endcode

    <b>Arguments Processed by < (in order of precedence)</b>
    |!Argument|!Processing
    |@ref float_type "float"|If \a expression1 is numerically less than \a expression2, returns \c True, otherwise returns \c False
    |@ref int_type "int"|If \a expression1 is numerically less than \a expression2, returns \c True, otherwise returns \c False
    |@ref string_type "string"|If \a expression1 comes before \a expression2 in string sort order, returns \c True, otherwise returns \c False
    |@ref date_type "date"|If \a expression1 is before (or a shorter amount of time than of the arguments are @ref relative_dates) \a expression2, returns \c True, otherwise returns \c False

    This operator does not throw any exceptions.

    @subsection logical_greater_than_operator Greater Than Operator (>)

    @par Synopsis
    Tests if a value is greater than another; types are converted if necessary (ex: <tt>("2" > 1)</tt> is \c True).

    @par Syntax
    \a expression1 > \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x > $y)
    printf("%n is less than %n\n", $x, $y);
    @endcode

    <b>Arguments Processed by > (in order of precedence)</b>
    |!Argument|!Processing
    |@ref float_type "float"|If \a expression1 is numerically greater than \a expression2, returns \c True, otherwise returns \c False
    |@ref int_type "int"|If \a expression1 is numerically greater than \a expression2, returns \c True, otherwise returns \c False
    |@ref string_type "string"|If \a expression1 comes after \a expression2 in string sort order, returns \c True, otherwise returns \c False
    |@ref date_type "date"|If \a expression1 is after \a expression2, returns \c True, otherwise returns \c False

    This operator does not throw any exceptions.

    @subsection logical_equality_operator Equals Operator (==)

    @par Synopsis
    Tests if a value is equal to another; types are converted if necessary (ex: <tt>("1" == 1)</tt> is \c True). For absolute equals, where types must also be equal to return true, see the @ref logical_absolute_equality_operator.

    @par Syntax
    \a expression1 == \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x == $y)
    printf("%n is equal to %n\n", $x, $y);
    @endcode

    <b>Arguments Processed by == (in order of precedence)</b>
    |!Argument|!Processing
    |@ref string_type "string"|If \a expression1 is equal to \a expression2, returns \c True, otherwise \c False
    |@ref float_type "float"|If \a expression1 is equal to \a expression2, returns \c True, otherwise \c False
    |@ref int_type "int"|If \a expression1 is equal to \a expression2, returns \c True, otherwise \c False
    |@ref date_type "date"|If \a expression1 is equal to \a expression2, returns \c True, otherwise \c False
    |@ref list_type "list"|If each element in the each list where order is relevant satisfies this operator, the operator returns \c True, otherwise it returns \c False
    |@ref hash_type "hash"|If each hash has the same keys and the value of each equal key in each hash satisfies this operator, the operator returns \c True, otherwise it returns \c False
    |@ref binary_type "binary"|If \a expression1's memory contents and size are equal to \a expression2's, then returns \c True, otherwise \c False
    |@ref object_type "object"|If \a expression1 is a reference to the same object as \a expression2, then returns \c True, otherwise \c False
    |@ref null|If both expressions are @ref null, returns \c True, otherwise returns \c False
    |@ref nothing|If neither expression has a value, returns \c True, otherwise returns \c False

    This operator does not throw any exceptions.

    @subsection logical_inequality_operator Not Equals Operator (!=)

    @par Synopsis
    Tests if a value is not equal to another; types are converted if necessary (ex: <tt>("1" != 1)</tt> is \c False).

    @par Syntax
expression1 != expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x != $y)
    printf("%n is not equal to %n\n", $x, $y);
    @endcode

    <b>Arguments Processed by != (in order of precedence)</b>
    |!Argument|!Processing
    |@ref string_type "string"|If \a expression1 is not equal to \a expression2, returns \c True, otherwise \c False
    |@ref float_type "float"|If \a expression1 is not equal to \a expression2, returns \c True, otherwise \c False
    |@ref int_type "int"|If \a expression1 is not equal to \a expression2, returns \c True, otherwise \c False
    |@ref date_type "date"|If \a expression1 is not equal to \a expression2, returns \c True, otherwise \c False
    |@ref list_type "list"|If each element in the each list where order is relevant satisfies this operator, the operator returns \c True, otherwise it returns \c False
    |@ref hash_type "hash"|If the hashes have different keys or the value of each equal key in each hash satisfies this operator, the operator returns \c True, otherwise it returns \c False
    |@ref binary_type "binary"|If \a expression1's memory contents or size are not equal to \a expression2's, then returns \c True, otherwise \c False
    |@ref object_type "object"|If \a expression1 is not a reference to the same object as \a expression2, then returns \c True, otherwise \c False
    |@ref null|If either expressions is not @ref null, returns \c True, otherwise returns \c False
    |@ref nothing|If one of the expressions has a value, returns \c True, otherwise returns \c False

    This operator does not throw any exceptions.

    @subsection logical_less_than_or_equals_operator Less Than Or Equals Operator (<=)

    @par Synopsis
    Tests if a value is less than or equals to another value; types are converted if necessary (ex: <tt>("1" <= 2)</tt> is \c True).

    @par Syntax
    \a expression1 <= \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x <= $y)
    printf("%n is less than or equal to %n\n", $x, $y);
    @endcode

    <b>Arguments Processed by <= (in order of precedence)</b>
    |!Argument|!Processing
    |@ref float_type "float"|If \a expression1 is numerically less than or equal to \a expression2, returns \c True, otherwise returns \c False
    |@ref int_type "int"|If \a expression1 is numerically less than or equal to \a expression2, returns \c True, otherwise returns \c False
    |@ref string_type "string"|If \a expression1 comes before in string sort order or is the same as \a expression2, returns \c True, otherwise returns \c False
    |@ref date_type "date"|If \a expression1 is before or is the same exact date and time as \a expression2, returns \c True, otherwise returns \c False

    This operator does not throw any exceptions.

    @subsection logical_greater_than_or_equals_operator Greater Than Or Equals Operator (>=)

    @par Synopsis
    Tests if a value is greater than or equals to another value; types are converted if necessary (ex: ("2" >= 1) is True).

    @par Syntax
    \a expression1 >= \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x >= $y)
    printf("%n is greater than or equal to %n\n", $x, $y);
    @endcode

    <b>Arguments Processed by >= (in order of precedence)</b>
    |!Argument|!Processing
    |@ref float_type "float"|If \a expression1 is numerically greater than or equal to \a expression2, returns \c True, otherwise returns \c False
    |@ref int_type "int"|If \a expression1 is numerically greater than or equal to \a expression2, returns \c True, otherwise returns \c False
    |@ref string_type "string"|If \a expression1 comes after in string sort order or is the same as \a expression2, returns \c True, otherwise returns \c False
    |@ref date_type "date"|If \a expression1 is after or is the same exact date and time as \a expression2, returns \c True, otherwise returns \c False

    This operator does not throw any exceptions.

    @subsection logical_comparison_operator Comparison (<=>) Operator

    @par Synopsis
    Tests if the left-hand value is less than, equal, or greater than the right-hand value; types are converted if necessary (ex: ("1" <=> 2) returns -1).

    @par Syntax
expression1 <=> expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code
switch ($x <=> $y) {
    case -1: 
        print("$x is less than $y\n");
        break;

    case 0: 
        print("$x is equal to $y\n");
        break;

    case 1: 
        print("$x is greater than $y\n");
        break;
}
    @endcode

    <b>Arguments Processed by <=> (in order of precedence)</b>
    |!Argument|!Processing
    |@ref string_type "string"|If \a expression1 comes after in string sort order as \a expression2, returns \c 1, otherwise if they are equal, returns \c 0, otherwise if \a expression1 comes before \a expression2, returns \c -1
    |@ref float_type "float"|If \a expression1 is numerically greater than \a expression2, returns \c 1, otherwise if they are equal returns \c 0, otherwise returns \c -1
    |@ref int_type "int"|If \a expression1 is numerically greater than \a expression2, returns \c 1, otherwise if they are equal returns \c 0, otherwise returns \c -1
    |@ref date_type "date"|If \a expression1 is after \a expression2, returns \c 1, otherwise if they are equal returns \c 0, otherwise returns \c -1

    This operator does not throw any exceptions.

    @subsection logical_absolute_equality_operator Absolute Equals Operator (===)

    @par Synopsis
    Checks two values for equality without doing any data type conversions; if the types do not match, then the result is \c False.

    @par Syntax
    \a expression1 === \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x === $y)
    printf("%n is equal to %n and has the same data type as well\n", $x, $y);
    @endcode

    <b>Arguments Processed by ===</b>
    |!Argument|!Processing
    |All|This operator returns \c True only if the types and values of both sides of the operator are exactly equal, otherwise returns \c False. No type conversions are done.

    This operator does not throw any exceptions.

    @subsection logical_absolute_inequality_operator Absolute Not Equals Operator (!==)

    @par Synopsis
    Checks two values for inequality without doing any data type conversions. If the data types do not match, then returns \c True.

    @par Syntax
    \a expression1 !== \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x !== $y)
    printf("%n is not equal to %n and may not have the data type as well\n", $x, $y);
    @endcode

    <b>Arguments Processed by !==</b>
    |!Argument|!Processing
    |All|This operator returns \c True if either the types or the values of the arguments are different, otherwise it retuns \c False. No type conversions are done.

    This operator does not throw any exceptions.

    @subsection regex_match_operator Regular Expression Match Operator (=~)

    @par Synopsis
    Checks for a regular expression match; returns \c True if the expression matches the string, \c False if not. See @ref regex_options for the meaning of the \c i, \c s, \c x, and \c m options after the regular expression.\n\n
    See @ref regular_expressions for more information about regular expression support in %Qore.

    @par Syntax
    \a expression <tt>=~ [m]/</tt><em>regex</em><tt>/[isxm]</tt>

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($str =~ /hello/)
    printf("%s contains 'hello'\n", $str);
    @endcode

    <b>Arguments Processed by =~</b>
    |!Argument|!Processing
    |@ref string_type "string"|This operator returns \c True if the regular expression in \a regex matches the string in \a expression.

    This operator does not throw any exceptions.

    @subsection regex_no_match_operator Regular Expression No Match Operator (!~)

    @par Synopsis
    Checks for a regular expression non match; returns \c True if the expression does not match the string, \c False if it does. See @ref regex_options for the meaning of the \c i, \c s, \c x, and \c m options after the regular expression.\n\n
    See @ref regular_expressions for more information about regular expression support in %Qore.

    @par Syntax
    \a expression <tt>!~ [m]/</tt><em>regex</em><tt>/[isxm]</tt>

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($str !~ /hello/)
    printf("%s does not contain 'hello'\n", $str);
    @endcode

    <b>Arguments Processed by !~</b>
    |!Argument|!Processing
    |@ref string_type "string"|This operator returns \c True if the regular expression in \a regex does not match the string in \a expression.

    This operator does not throw any exceptions.

    @subsection regex_subst_operator Regular Expression Substitution Operator

    @par Synopsis
    Looks for a regular expression match in a string, and, if found, substitutes the matched string with a new string. Subpattern backreferences are supported in the target string, <tt>$1</tt>=first subpattern, <tt>$2</tt>=second subpattern, etc... See @regex_options for the meaning of the \c i, \c s, \c x, and \c m options after the regular expression.\n\n
    See @ref regular_expressions for more information about regular expression support in %Qore.

    @par Syntax
    \a lvalue <tt>=~ s/</tt><em>regex_pattern</em><tt>/</tt><em>target_string</em><tt>/[isxmg]</tt>

    @par Return Type
    @ref string_type "string" or @ref nothing (if the lvalue does not hold a string)

    @par Example
    @code
$str =~ s/hello/goodbye/i;
$str =~ s/(\w+) +(\w+)/$2, $1/;
    @endcode

    <b>Arguments Processed by =~ s///</b>
    |!Argument|!Processing
    |@ref string_type "string"|This operator substitutes text in the \a lvalue string if the regular expression matches. Subpattern backreferences are supported in \a target_string, <tt>$1</tt>=first subpattern, <tt>$2</tt>=second subpattern, etc..

    This operator does not throw any exceptions.

    @subsection regex_extract_operator Regular Expression Pattern Extraction Operator

    @par Synopsis
    Matches regular expression patterns (enclosed in parentheses) in a string and returns a list giving the text matched for each pattern. If the regular expression does not match, then no value (@ref nothing) is returned. See @regex_options for the meaning of the \c i, \c s, \c x, and \c m options after the regular expression.\n\n
    See @ref regular_expressions for more information about regular expression support in %Qore.

    @par Syntax
    \a string <tt>=~ x/</tt><em>regex_with_patterns</em><tt>/[isxm]</tt>

    @par Return Type
    @ref list_type "list" or @ref nothing (if the lvalue does not hold a string or if the pattern is not matched)

    @par Example
    @code
$list =~ x/(\w+):(\w+)/;
$list =~ x/(.*)\.(.*)/;
    @endcode

    <b>Arguments Processed by =~ x//</b>
    |!Argument|!Processing
    |@ref string_type "string"|This operator extracts strings from \a string based on patterns enclosed in parentheses in the regular expression.

    This operator does not throw any exceptions.

    @subsection transliteration_operator Transliteration Operator

    @par Synopsis
    Makes character substitutions in an lvalue; character ranges can also be used.

    @par Syntax
    \a lvalue <tt>=~ tr/</tt><em>source_chars</em><tt>/</tt><em>target_chars</em><tt>/</tt>

    @par Return Type
    @ref string_type "string" or @ref nothing (if the lvalue does not hold a string)

    @par Example
    @code $str =~ tr/a-z/A-Z/;@endcode

    <b>Arguments Processed by =~ tr//</b>
    |!Argument|!Processing
    |@ref string_type "string"|This operator substitutes characters in the \a lvalue string. Note that if there are more characters in \a source_chars than in \a target_chars, then the last character in \a target_chars will be used for any source matches where the source character position is greater than the length of \a target_chars.

    This operator does not throw any exceptions.

    @subsection bitwise_and_operator Bitwise/Binary And Operator (&)

    @par Synopsis
    Performs a bitwise (binary) AND operation on two integers.

    @par Syntax
    \a expression1 & \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a = $x & $y;@endcode

    <b>Arguments Processed by &</b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives the result of the binary (bitwise) AND operation between \a expression1 and \a expression2 (ex: <tt>0xffb2 & 0xa1 = 0xa1</tt>); operands are converted to integers if necessary.

    This operator does not throw any exceptions.

    @subsection bitwise_or_operator Bitwise/Binary Or Operator (|)

    @par Synopsis
    Performs a bitwise (binary) OR operation on two integers.

    @par Syntax
    \a expression1 | \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a = $x | $y;@endcode

    <b>Arguments Processed by |</b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives the result of the binary (bitwise) OR operation between \a expression1 and \a expression2 (ex: <tt>0xb001 | 0xfea = 0xbfeb</tt>); operands are converted to integers if necessary

    This operator does not throw any exceptions.

    @subsection bitwise_xor_operator Bitwise/Binary Xor Operator (^)

    @par Synopsis
    Performs a bitwise (binary) XOR operation on two integers.

    @par Syntax
    \a expression1 ^ \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a = $x ^ $y;@endcode

    <b>Arguments Processed by ^</b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives the result of the binary (bitwise) EXCLUSIVE OR operation between \a expression1 and \a expression2 (ex: <tt>0xaef1 & 0xfb32 = 0x55c3</tt>); operands are converted to integers if necessary

    This operator does not throw any exceptions.

    @subsection logical_and_operator Logical And Operator (&&)

    @par Synopsis
    Checks to see if two expressions are \c True with logical short-circuiting.

    @par Syntax
    \a expression1 && \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x && $y)
    printf("%n and %n are both True\n", $x, $y);
    @endcode

    <b>Arguments Processed by &&</b>
    |!Argument|!Processing
    |@ref bool_type "bool"|Returns \c True if both expressions are \c True, \c False if otherwise. Logical short-circuiting is implemented; if \a expression1 is \c False, then \a expression2 is not evaluated, and the operator returns \c False.

    This operator does not throw any exceptions.

    @subsection logical_or_operator Logical Or Operator (||)

    @par Synopsis
    Returns \c True if either of the arguments are \c True with logical short-circuiting.

    @par Syntax
    \a expression1 || \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x || $y)
    printf("either %n or %n or both are True\n", $x, $y);
    @endcode

    <b>Arguments Processed by ||</b>
    |!Argument|!Processing
    |@ref bool_type "bool"|Returns \c True if either or both expressions evaluate to \c True, \c False if otherwise. Logical short-circuiting is implemented; if \a expression1 is \c True, then \a expression2 is not evaluated, and the operator returns \c True.

    This operator does not throw any exceptions.

    @subsection conditional_operator Conditional Operator (? :)

    @par Synopsis
    Evaluates and returns the value of one of two expressions depending on the value of a conditional expression.

    @par Syntax
    \a expression ? \a if_true_expression : \a if_false_expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code $a = ($z > 100 ? "Big" : "Small");@endcode

    <b>Arguments Processed by ? :</b>
    |!Argument|!Processing
    |All|If \a expression is evaluated to be \c True, then the \a if_true_expression is evaluated and returned. Otherwise the \a if_false_expression is evaluated and returned.

    This operator does not throw any exceptions.

    @subsection comma_operator Comma Operator (,)

    @par Synopsis
    Makes a list from more than one element.

    @par Syntax
    \a expression1, \a expression2

    @par Return Type
    @ref list_type "list"

    @par Example
    @code $a = 1, 2, "three";@endcode

    <b>Arguments Processed by ,</b>
    |!Argument|!Processing
    |All|The comma operator builds lists of arguments

    This operator does not throw any exceptions.

    @subsection unshift Unshift Operator (unshift)

    @par Synopsis
    Inserts an element into the first position of a list and moves all other elements up one position.

    @par Syntax
    \c \b unshift \a lvalue, \a expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code unshift $list, "one";@endcode

    <b>Arguments Processed by unshift</b>
    |!Argument|!Processing
    |All|Inserts the value of \a expression as the first element in the list given by \a lvalue. All other elements in the list are moved forward.

    @subsection push Push Operator (push)

    @par Synopsis
    Adds one element to the end of a list and returns the list processed (or @ref nothing if the \a lvalue is not a list).

    @par Syntax
    \c \b push \a lvalue, \a expression

    @par Return Type
    @ref list_type "list" or @ref nothing (if the lvalue is not a list)

    @par Example
    @code push $list, "last";@endcode

    <b>Arguments Processed by push</b>
    |!Argument|!Processing
    |All|Appends the value of the \a expression as the last element in the list given by \a lvalue. If \a expression evaluates to a list, this list will be appended as the last element of \a lvalue. To concatenate lists, use the @ref plus_operator "plus operator".

    @subsection splice Splice Operator (splice)

    @par Synopsis
    Removes and optionally inserts elements in lists and strings and returns the lvalue after processing. For a similar operator that returns the values removed, see the @ref extract "extract operator".\n\n
    Works on either strings or lists in a similar way; removes elements from a list or characters from a string and optionally inserts new ones. If no \a length_expression is given, splice removes all elements/characters from the list or string starting at \a offset_expression (list and string offsets begin at 0). Otherwise, a number of elements/characters equal to \a length_expression is removed (or up to the end of the list/string if applicable). If \a substitution_expression is present, then the removed elements/characters are substituted with the elements/string given by this expression.\n\n
    Note that string splice takes character offsets, which may not be the same as byte offsets for multi-byte character encodings, such as \c UTF-8

    @par Syntax
    \c \b splice \a lvalue, \a offset_expression<em>, [length_expression, [substitution_expression]]</em>

    @par Return Type
    @ref list_type "list" or @ref string_type "string" (returns \a lvalue after processing)

    @par Example
    @code splice $list, 2, 2;@endcode
    @code splice $string, 2, 2, "-text-";@endcode

    <b>Arguments Processed by splice</b>
    |!Argument|!Processing
    |\a lvalue (@ref list_type "list" or @ref string_type "string")|If the lvalue is a list, list elements are processed, otherwise, if it is a string, characters in the string are processed. For any other data type, no action is taken.
    |\a offset_expression|The start element/character position for removing elements/characters from the list or string.
    |\a length_expression|The number of elements/characters to remove. If this expression is not present, then all elements/characters from the offset to the end of the list/string are removed. If this expression is present and evaluates to 0, no characters/elements are removed.
    |\a substitution_expression|For list splice, an optional element or list to substitute for the removed elements (to insert a list in a single element's position, make sure that the list to be inserted is the first and only element of another list used as the argument in this position; in other words, pass a list within a single-element list). For string splice, an optional string to substitute for the removed characters.

    @subsection extract Extract Operator (extract)

    @par Synopsis
    Removes and optionally inserts elements in lists and strings. For a similar operator that removes values from an lvalue and returns the lvalue (instead of the value removed), see the @ref splice "splice operator".\n\n
    Works on either strings or lists in a similar way; removes elements from a list or characters from a string and optionally inserts new ones. If no length_expression is given, extract removes all elements/characters from the list or string starting at \a offset_expression (list and string offsets begin at 0). Otherwise, a number of elements/characters equal to \a length_expression is removed (or up to the end of the list/string if applicable). If \a substitution_expression is present, then the removed elements/characters are substituted with the elements/string given by this expression.\n\n
    When operating on lists, a list is returned of any elements extracted (if no elements are extracted, then an empty list is returned); when operating on strings, a string is extracted of all characters extracted from the string (if no characters are extracted, then an empty string is returned).\n\n
    Note that string extract takes character offsets, which may not be the same as byte offsets for multi-byte character encodings, such as \c UTF-8

    @par Syntax
    \c \b extract \a lvalue, \a offset_expression<em>, [length_expression, [substitution_expression]]</em>

    @par Return Type
    @ref list_type "list" or @ref string_type "string" (the value(s) removed from \a lvalue)

    @par Example
    @code my list $sublist = extract $list, 2, 2;@endcode
    @code my string $substring = extract $string, 2, 2, "-text-";@endcode

    <b>Arguments Processed by extract</b>
    |!Argument|!Processing
    |\a lvalue (@ref list_type "list" or @ref string_type "string")|If the lvalue is a list, list elements are processed, otherwise, if it is a string, characters in the string are processed. For any other data type, no action is taken.
    |\a offset_expression|The start element/character position for removing elements/characters from the list or string.
    |\a length_expression|The number of elements/characters to remove. If this expression is not present, then all elements/characters from the offset to the end of the list/string are removed. If this expression is present and evaluates to 0, no characters/elements are removed.
    |\a substitution_expression|For list splice, an optional element or list to substitute for the removed elements (to insert a list in a single element's position, make sure that the list to be inserted is the first and only element of another list used as the argument in this position; in other words, pass a list within a single-element list). For string splice, an optional string to substitute for the removed characters.

    @subsection assignment_operator Assignment Operator (=)

    @par Synopsis
    Assigns a value to an lvalue and returns the value assigned.

    @par Syntax
    \a lvalue <tt>=</tt> \a expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code $a = 1;@endcode

    <b>Arguments Processed by =</b>
    |!Argument|!Processing
    |All|Assigns the value of \a expression to \a lvalue

    @subsection plus_equals_operator Plus Equals Operator (+=)

    @par Synopsis
    Increments and concatentates an lvalue with the value of an expression depending on the data type of the lvalue, unless the lvalue is @ref nothing, in which case this operator acts like the assignment operator (simply assigns the value of the right hand side to the lvalue).

    @par Syntax
    \a lvalue <tt>+=</tt> \a expression

    @par Return Type
    @ref int_type "int", @ref float_type "float", @ref date_type "date", @ref list_type "list", @ref string_type "string", @ref binary_type "binary", @ref hash_type "hash", or @ref object_type "object"

    @par Example
    @code $a += 10;@endcode
    @code $date += P1M2DT45M;@endcode
    @code $list += $new_element;@endcode
    @code $string += ".foo";@endcode
    @code $binary += <0c67a374>@endcode
    @code $hash += ("new-key" : 1, "other" : "two");@endcode
    @code $object += $hash;@endcode

    <b>Arguments Processed by +=</b>
    |!Argument|!Processing
    |\a lvalue (@ref list_type "list")|
the expression will be evaluated and concatenated to the lvalue. If \a expression is a list, the lists will be concatenated, to ensure adding a single element to a list, use the @push "push operator"
    |\a lvalue (@ref hash_type "hash" or (@ref object_type "object")|the \a expression will be evaluated, and, if it is a hash or object, then it's members will be added to the \a lvalue, any duplicate elements in the \a lvalue will be overridden by elements in the \a expression.
    |\a lvalue (@ref string_type "string")|the \a expression will be evaluated and converted to a string if necessary and concatenated to the \a lvalue.
    |\a lvalue (@ref float_type "float")|the \a expression will be evaluated and converted to a float if necessary and added to the \a lvalue.
    |\a lvalue (@ref binary_type "binary")|the \a expression will be evaluated and converted to a binary if necessary and added to the \a lvalue.
    |\a lvalue (@ref date_type "date")|the \a expression will be evaluated and converted to a date if necessary and added to the \a lvalue.
    |\a lvalue (@ref nothing)|the \a lvalue will be assigned to the value of \a expression.
    |\a lvalue (all other types)|the \a lvalue's type will be converted to an integer, and the \a expression will be evaluated and converted to an integer if necessary, and then the result will be added to the \a lvalue.

    @subsection minus_equals_operator Minus Equals Operator (-=)

    @par Synopsis
    For a float or integer argument, decrements the value of an \a lvalue by the value of an \a expression. However if the \a lvalue is a hash or object and the \a expression is a string, removes the key represented by the string from the hash or object.

    @par Syntax
    \a lvalue <tt>-=</tt> \a expression

    @par Return Type
    @ref int_type "int", @ref float_type "float", @ref date_type "date", @ref hash_type "hash", or @ref object_type "object"

    @par Example
    @code $a -= 10;@endcode
    @code $date -= PT45H213S;@endcode
    @code $hash -= "key";@endcode
    @code $hash -= ("key1", "key2");@endcode
    @code $object -= "key";@endcode
    @code $object -= $list_of_keys;@endcode

    <b>Arguments Processed by -=</b>
    |!Argument|!Processing
    |\a lvalue (@ref float_type "float")|the \a expression will be evaluated and converted to a float if necessary and subtracted from the \a lvalue
    |\a lvalue (@ref date_type "date")|the \a expression will be evaluated and converted to a date if necessary and subtracted from the \a lvalue
    |\a lvalue (@ref hash_type "hash" or (@ref object_type "object"), \a expression (@ref string_type "string")|the hash key represented by \a expression will be removed from the \a lvalue
    |\a lvalue (@ref hash_type "hash" or (@ref object_type "object"), \a expression (@ref list_type "list")|each element in the list will be converted to a string (if necessary) and the key represented by each string will be removed from the hash or object
    |\a lvalue (@ref nothing), \a expression (any type)|the \a expression will be assigned to \a lvalue
    |\a lvalue (all other types)|the \a lvalue's type will be converted to an integer (if necessary), and the \a expression will be evaluated and converted to an integer (if necessary), and then the result will be subtracted from the \a lvalue

    @subsection and_equals_operator And Equals Operator (&=)

    @par Synopsis
    Performs a bitwise (binary) AND operation on an \a lvalue using the value of an \a expression and returns the new value.

    @par Syntax
    \a lvalue <tt>&=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a &= 0xfe;@endcode

    <b>Arguments Processed by &=</b>
    |!Argument|!Processing
    |All|the \a lvalue's type will be converted to an integer if necessary, and the \a expression will be evaluated and converted to an integer as well if necessary, and then the result will be binary and'ed to the lvalue

    @subsection or_equals_operator Or Equals Operator (|=)

    @par Synopsis
    Performs a bitwise (binary) OR operation on an \a lvalue using the value of an \a expression and returns the new value.

    @par Syntax
    \a lvalue <tt>|=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a |= 0xba;@endcode

    <b>Arguments Processed by |=</b>
    |!Argument|!Processing
    |All|the \a lvalue's type will be converted to an integer if necessary, and the \a expression will be evaluated and converted to an integer as well if necessary, and then the result will be binary or'ed to the \a lvalue

    @subsection modula_equals_operator Modula Equals Operator (%=)

    @par Synopsis
    Performs a modula calculation on an lvalue using the value of an expression and returns the new value.

    @par Syntax
    \a lvalue <tt>%=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a %= 100;@endcode

    <b>Arguments Processed by %=</b>
    |!Argument|!Processing
    |All|the \a lvalue's type will be converted to an integer if necessary, and the \a expression will be evaluated and converted to an integer as well if necessary, and then the result will be used to divide the \a lvalue's value and the remainder will be saved to the \a lvalue

    @subsection multiply_equals_operator Multiply Equals Operator (*=)

    @par Synopsis
    Performs a multiplication operation on an lvalue using the value of an expression and returns the value assigned.

    @par Syntax
    \a lvalue <tt>*=</tt> \a expression

    @par Return Type
    @ref int_type "int" or @ref float_type "float"

    @par Example
    @code $a *= 10;@endcode

    <b>Arguments Processed by *=</b>
    |!Argument|!Processing
    |All|If either side of the operator is a float, the result will be a float as well. Otherwise the result is an integer value. The \a expression will be evaluated and multiplied by the \a lvalue, and the result will be saved to the \a lvalue.

    @subsection divide_equals_operator Divide Equals Operator (/=)

    @par Synopsis
    Performs a division operation on an lvalue using the value of an expression and returns the value assigned.

    @par Syntax
    \a lvalue <tt>/=</tt> \a expression

    @par Return Type
    @ref int_type "int" or @ref float_type "float"

    @par Example
    @code $a /= 10;@endcode

    <b>Arguments Processed by /=</b>
    |!Argument|!Processing
    |All|If either side of the operator is a float, the result will be a float as well. Otherwise the result is an integer value. The \a expression will be evaluated and used to divide the \a lvalue, and the result will be saved to the \a lvalue.

    <b>Exceptions Thrown by /*</b>
    |!err|!desc
    |\c DIVISION-BY-ZERO|If the divisor expression evaluates to zero, this exception is thrown

    @subsection xor_equals_operator Xor Equals Operator (^=)

    @par Synopsis
    Performs an exclusive-or operation on an lvalue using the value of an expression.

    @par Syntax
    \a lvalue <tt>^=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a ^= 0xf9034ba7;@endcode

    <b>Arguments Processed by ^=</b>
    |!Argument|!Processing
    |All|Values are converted to integers if necessary. The \a expression will be evaluated and exclusive-or'ed with the \a lvalue, and the result will be saved to the \a lvalue

    @subsection shift_left_equals_operator Shift Left Equals Operator (\<\<=)

    @par Synopsis
    Performs a shift-left operation on an lvalue using the value of an expression and returns the value assigned.

    @par Syntax
    \a lvalue <tt>\<\<=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a <<= 3;@endcode

    <b>Arguments Processed by \<\<=</b>
    |!Argument|!Processing
    |All|Values are converted to integers if necessary. The \a expression will be evaluated and this value will determine how many bits the \a lvalue will be shifted left. The result will be saved to the \a lvalue.

    @subsection shift_right_equals_operator Shift Right Equals Operator (\>\>=)

    @par Synopsis
    Performs a shift-right operation on an lvalue using the value of an expression and returns the value assigned.

    @par Syntax
    \a lvalue <tt>\>\>=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example$
    @code $a >>= 3;@endcode

    <b>Arguments Processed by >>=</b>
    |!Argument|!Processing
    |All|Values are converted to integers if necessary. The \a expression will be evaluated and this value will determine how many bits the \a lvalue will be shifted right. The result will be saved to the \a lvalue.

*/
