#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%enable-all-warnings
%require-types
%strict-args

%requires ../../../../qlib/QUnit.qm
%requires ../../../../qlib/CsvUtil.qm

%exec-class CsvUtilTest

public class CsvUtilTest inherits QUnit::Test {
    private {
        const CsvInput = "UK,1234567890,\"Sony, Xperia S\",31052012
UK,1234567891,\"Sony, Xperia S\",31052012
UK,1234567892,\"Sony, Xperia S\",31052012
UK,1234567893,\"Sony, Xperia S\",31052012";

        const CsvRecords = (
            ("cc": "UK", "serno": 1234567890, "desc": "Sony, Xperia S", "received": 2012-05-31),
            ("cc": "UK", "serno": 1234567891, "desc": "Sony, Xperia S", "received": 2012-05-31),
            ("cc": "UK", "serno": 1234567892, "desc": "Sony, Xperia S", "received": 2012-05-31),
            ("cc": "UK", "serno": 1234567893, "desc": "Sony, Xperia S", "received": 2012-05-31),
        );
        const CsvMultiInput = "1,2016-01,20160401
2,123,\"Sony, Xperia S\",1,100
2,124,\"Nokia, Lumia\",2,150
3,250
";

        const CsvMultiRecords = (
            ("type": "header", "record": ("type": 1, "invoice_no": "2016-01", "date": 2016-04-01)),
            ("type": "item", "record": ("type": 2, "item_no": 123, "item": "Sony, Xperia S", "pcs": 1, "price": 100)),
            ("type": "item", "record": ("type": 2, "item_no": 124, "item": "Nokia, Lumia", "pcs": 2, "price": 150)),
            ("type": "footer", "record": ("type": 3, "total": 250)),
        );
}

    constructor() : Test("CsvUtilTest", "1.0") {
        addTestCase("Basic CSV tests", \csvTest(), NOTHING);
        addTestCase("Multi-type CSV tests", \csvMultiTest(), NOTHING);
        addTestCase("Escaping", \escapeTest());

        # Return for compatibility with test harness that checks return value.
        set_return_value(main());
    }

    csvTest() {
        hash opts = ("fields": ("cc": "string", "serno": "int", "desc": "string", "received": ("type": "date", "format": "DDMMYYYY")),);

        # Iterate through source
        CsvDataIterator i(CsvInput, opts);
        #list l = map $1, i;
        testAssertion("CsvDataIterator 1", \equalsIterated(), (new ListIterator(CsvRecords), i));

        CsvStringWriter w( ("write-headers": False, "optimal-quotes" : True, "quote_escape" : '"')+opts );
        string outstr = w.write(CsvRecords);
        testAssertion("CsvDataWriter writer", \equals(), (CsvInput+"\n", outstr));  # ending CR is assymetrical when empty lines are not ignored

        # test with empty data and header lines
        i = new CsvDataIterator("", ("header-lines": 1));
        testAssertion("CsvDataIterator 2", \i.next(), (), RESULT_FAILURE);

        i = new CsvDataIterator("CaMeL,lilliput,SHREK\nRoW1,row1,ROW1\n", ("header-lines": 1, "header_names": True, "tolwr": True));
        testAssertionValue("CsvDataIterator lwr 1", i.index(), 0);
        testAssertionValue("CsvDataIterator lwr 1", i.lineNumber(), 0);
        testAssertionValue("CsvDataIterator lwr 1", i.next(), True);
        testAssertionValue("CsvDataIterator lwr 1", i.index(), 1);
        testAssertionValue("CsvDataIterator lwr 1", i.lineNumber(), 2);
        testAssertion("CsvDataIterator lwr 2", \equals(), (("camel": "RoW1", "lilliput": "row1", "shrek": "ROW1"), i.getValue()));
        testAssertionValue("CsvDataIterator lwr 3", i.getHeaders(), ("camel", "lilliput", "shrek"));
        testAssertionValue("CsvDataIterator lwr 4", i.next(), False);

        i = new CsvDataIterator("CaMeL,lilliput,SHREK\nRoW1,row1,ROW1\n", ("header-lines": 1, "header_names": True, ));
        testAssertionValue("CsvDataIterator !lwr 1", i.next(), True);
        testAssertion("CsvDataIterator !lwr 2", \equals(), (("CaMeL": "RoW1", "lilliput": "row1", "SHREK": "ROW1"), i.getValue()));
        testAssertionValue("CsvDataIterator !lwr 3", i.getHeaders(), ("CaMeL", "lilliput", "SHREK"));

        i = new CsvDataIterator("CaMeL,lilliput,SHREK\nRoW1,row1,ROW1\n", ("header-lines": 0, "header_names": False, "tolwr": True, "headers": ("CaMeL","lilliput","SHREK")));
        testAssertionValue("CsvDataIterator lwr h 1", i.getHeaders(), ("camel", "lilliput", "shrek"));

        i = new CsvDataIterator("row1-1,row1-2,row1-3\n", ("header-lines": 0, "header_names": False, ));
        testAssertionValue("CsvDataIterator header by idx 1", i.next(), True);
        testAssertion("CsvDataIterator header by idx 2", \equals(), (("0": "row1-1", "1": "row1-2", "2": "row1-3"), i.getValue()));
        testAssertion("CsvDataIterator header by idx 3", \equals(), (("row1-1", "row1-2", "row1-3"), i.getRecordList()));
        testAssertionValue("CsvDataIterator header by idx 4", i.getHeaders(), ("0", "1", "2"));
    }

    csvMultiTest() { return;
        hash spec = (
            "header": (
                "type": ("type": "int", "value": 1),
                "invoice_no": "string",
                "date": ("type": "date", "format": "YYYYMMDD"),
            ),
            "item": (
                "type": "int",
                "item_no": "string",
                "item": "string",
                "pcs": "int",
                "price": "number",
            ),
            "footer": (
                "type": "int",
                "total": "number",
            ),
        );
        hash opts = hash(
        );

        # Iterate through source
        CsvDataIterator i(CsvMultiInput, spec, ("multi_type": True) + opts);

        #list l = map $1, i;
        testAssertion("multi iterator ", \equalsIterated(), (new ListIterator(CsvMultiRecords), i));

        CsvStringWriter w( spec, ("write-headers": False, "optimal-quotes" : True, "quote_escape" : '"')+opts );
        string outstr = w.write(CsvMultiRecords);
        testAssertion("multi writer", \equals(), (CsvMultiInput, outstr));

    }

    escapeTest() {
        list row = ( ( '12"', 'a"bc"', ), );
        string esc_default = '"12\"","a\"bc\""'+"\n";
        string esc_double = '"12""","a""bc"""'+"\n";

        CsvStringWriter w( ("optimal-quotes" : False) );
        string outstr = w.write(row);
        testAssertion("default escaping", \equals(), (esc_default, outstr));

        w = new CsvStringWriter(("optimal_quotes": False) );
        outstr = w.write(row);
        assertEq(esc_default, outstr);

        w = new CsvStringWriter( ("optimal-quotes" : False, "quote_escape" : '"') );
        outstr = w.write(row);
        testAssertion("double escaping", \equals(), (esc_double, outstr));

        hash dmh = ("cc": "XX");
        w = new CsvStringWriter(("headers": ("XX", "serno", "desc", "received"), "fields": ("received": ("type": "date", "format": "DDMMYYYY")), "datamap": dmh));
        outstr = w.write(CsvRecords.iterator());
        assertEq("XX,serno,desc,received\n" + CsvInput + "\n", outstr);
    }

    csvData() {
        hash opts = ("fields": ("id": "int", "name": "string", "descr": "string"));
        string CsvInput2 = "1,UK,United Kingdom
2,AT,Austria
3,CZ,Czech rep.
4,IE,Ireland
";
        list Output = (
            {"id": 1, "name": "UK", "descr": "United Kingdom"},
            {"id": 2, "name": "AT", "descr": "Austria"},
            {"id": 3, "name": "UK", "descr": "Czech rep."},
            {"id": 4, "name": "IE", "descr": "Ireland"},
        );

        # Iterate through source
        CsvDataIterator i(CsvInput, opts);

        testAssertion("CsvDataIterator 2", \equalsIterated(), (i, new ListIterator(Output)));

    }

}
