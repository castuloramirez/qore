#!/usr/local/bin/qore

# This script is meant to demonstrate qore's event support.  Currently only
# socket events are supported (from the Socket, FtpClient, and HTTPClient
# classes).  It is not intended to be a replacement for "wget", which is a much
# better and more complete program (with undoubtably better socket handling).
#
# basically qore provides very high-level access to socket functions.  The
# event mechanism allows the program to be informed about the details of
# socket-level actions, however without actually having control over them.
#
# it would be possible to duplicate the functionality in this script using just
# functionality from the Socket class without using qore events, but would
# require on the order of 2 or more levels of magnitude more code to be
# written.

%require-our
%enable-all-warnings

our $o; # global variable for options

const cstr = "*************************************************";
const bstr = "-------------------------------------------------";

const opts = 
    ( "verbose"  : "v,verbose:+",
      "help"     : "h,help" 
    );

# QueueCallBack class
#
# this class provides callback-like functionality for socket events.
# Qore provides only a Queue to post callback events on; using a real callback
# function from within Qore internal socket code would be too susceptible to
# deadlocks, therefore the event queue mechanism is supported.  The result of
# this is that socket events must be processed in a separate thread; this class
# provides that functionality.  The class uses the "listen()" method, running
# in a background thread, to process the events.  The "listen()" method waits
# for an "EVENT_DELETED" event to stop listening and exit the thread.
class QueueCallBack {
    constructor($o, $url) {
	printf("retrieving %s\n", $url);
	$.queue = new Queue();
	$.counter = new Counter(1);
	$o.setEventQueue($.queue);
	background $.listen();
    }

    static getstr($h) {
	my $str;
	map ($str += sprintf("%s=%n ", $1, $h.$1)), keys $h;
	return $str;
    }

    listen() {
	while (exists (my $e = $.queue.get())) {
	    if ($e.event == EVENT_DELETED) {
		$.counter.dec();
		return;
	    }

	    if ($o.verbose) {
		printf("%s %s: %s\n", EVENT_SOURCE_MAP.($e.source), EVENT_MAP.($e.event), QueueCallBack::getstr($e - ("event", "source")));
		continue;
	    }
	    switch ($e.event) {
		case EVENT_HOSTNAME_LOOKUP: {
		if (!$.lookup)
			printf("resolving %s: ", $e.name);
		    break;
		}

		case EVENT_HOSTNAME_RESOLVED: {
		    if (!$.lookup) {
			printf("%s\n", $e.address);
			$.lookup = True;
		    }
		    break;
		}

		case EVENT_HTTP_CHUNKED_DATA_RECEIVED:
		case EVENT_PACKET_READ: {
		    if ($.in_body && $e.socket != $.ignore) {
			$.total_read += $e.read;
			$.update_total();
		    }
		    break;
		}

		case EVENT_HTTP_CONTENT_LENGTH: {
		    printf("content length: %d", $e.len);
		    $.body_len = $e.len;
		    $.in_body = True;
		    break;
		}

		case EVENT_FTP_MESSAGE_RECEIVED: {
		    # ignore reads on control channel
		    if (!$.ignore)
			$.ignore = $e.socket;
		    if (($e.code / 100) == 1) {
			#printf("%s\n", $e.message);
			my $l = ($e.message =~ x/opening.*connection for.*\(([0-9]*) byte/i);
			$.body_len = $l[0];
			$.in_body = True;
		    }
		}
		
		case EVENT_HTTP_CHUNKED_START: {
		    $.in_body = True;
		    break;
		}
		
		case EVENT_HTTP_CHUNKED_END: {
		    $.in_body = False;
		    break;
		}
		
		case EVENT_HTTP_REDIRECT: {
		    printf("redirected to %s", $e.location);
		    if (exists $e.status_message)
			printf(" (%s)", $e.status_message);
		    printf("\n");
		    flush();
		    break;
		}
	    }	    
	}
    }

    update_total() {
	my $now = clock_getmillis();
	if (!exists $.stime) {
	    $.stime = $now;
	    $.utime = $now;
	    $.units = "n/a";
	}
	else {
	    if (!$.bps || $now - $.utime > 250 || $.total_read == $.body_len) {
		$.utime = $now;
		if (my $diff = $now - $.stime) {
		    $.bps = 1000 * $.total_read / float($diff);

		    if ($.bps > 1024 * 1024 * 1024) {
			$.units = "GB/s";
			$.bps /= 1024 * 1024 * 1024;
		    }
		    else if ($.bps > 1024 * 1024) {
			$.units = "MB/s";
			$.bps /= 1024 * 1024;
		    }
		    else if ($.bps > 1024) {
			$.units = "KB/s";
			$.bps /= 1024;
		    }
		    else
			$.units = "B/s";
		}
	    }
	}

	if ($.body_len) {
	    my $nh = $.total_read * 50 / float($.body_len); 
	    printf("\r%3d% %s%s %f %s (%d/%d)    ", $.total_read * 100 / float($.body_len), substr(cstr, 0, $nh), substr(bstr, $nh), $.bps, $.units, $.total_read, $.body_len);
	}
	else {
	    printf("\r%d bytes %f %s     ", $.total_read, $.bps, $.units);
	}
	flush();
    }

    wait() { $.counter.waitForZero(); }
}

sub usage($long) {
    printf("usage: %s [-vh] URL\n", get_script_name());
    if ($long) {
    	printf("  -v,--verbose       show socket events\n");
	printf("  -h,--help          this help text\n");
    }
    exit(1);
}

sub main() {
    my $g = new GetOpt(opts);

    try {
	$o = $g.parse2(\$ARGV);
    }
    catch ($ex) {
	printf("option error: %s\n", $ex.desc);
	exit(1);
    }

    if ($o.help)
	usage(True);

    my $url = shift $ARGV;
    if (!exists $url)
	usage();

    my $u = parseURL($url);
    my $x;
    my $cb;
    try {
	switch ($u.protocol) {
	    case NOTHING:
	    case "http": {
		my $hc = new HTTPClient(("url" : $url));
		$cb = new QueueCallBack($hc, $url);
		
		$x = $hc.get(exists $u.path ? $u.path : "/");
		break;
	    }
	    case "ftps":
		case "ftp": {
		    my $file = basename($u.path);
		    if (!exists $file) {
			printf("missing file name in url %n\n", $url);
			exit(1);
		    }

		    my $f = new FtpClient($url);
		    $cb = new QueueCallBack($f, $url);
		    $f.connect();
		    
		    my $dir = dirname($u.path);
		    if (exists $dir) {
			#printf("dir=%n\n", $dir);
			$f.cwd($dir);
		    }

		    #printf("%n: %n + %n\n", $f.pwd(), $dir, $file);
		    $x = $f.getAsBinary($file);
	    }
	}
    }
    catch ($ex) {
	printf("%s: %s\n", $ex.err, $ex.desc);
	exit(1);
    }
    my $fn = basename($u.path);
    if (!exists $fn)
	$fn = $u.host;
    $cb.wait();
    if (!$o.verbose) 
	print("\n");
    printf("done, saving %s (%d bytes)\n", $fn, type($x) == Type::String ? strlen($x) : elements $x);
    my $f = new File();
    $f.open($fn, O_CREAT | O_TRUNC | O_WRONLY);
    $f.write(binary($x));
}

main();

