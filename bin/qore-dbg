#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%enable-all-warnings
%new-style
%allow-debugging

%requires linenoise
%requires qore >= 0.8.13
%requires ../qlib/DebugUtil.qm

%exec-class DebugWrapper

class DebugCommandLineLocal inherits DebugCommandLine {
	public {
		DebugProgramControl dpc;
	}
	constructor (DebugProgramControl n_dpc): DebugCommandLine() {
	    dpc = n_dpc;
		dpc.dcl = self;
	}
	public nothing doCommandImpl(hash data) {
		dpc.processCommand(dpc.cx, data);
	}
}

class DebugProgramControlLocal inherits DebugProgramControl {
	public {
		DebugCommandLine dcl;
	}
	const cx = ('id': 1);
	constructor () {
		registerConnection(cx);
	}
	destructor() {
		unregisterConnection(cx);
	}
    public nothing sendDataImpl(hash cx, any data) {    # TODO: nothing needed. why? I cannot reproduce in simple case to report issue
		dcl.printData(data);
	}
    public nothing broadcastDataImpl(any data) {
		dcl.printData(data);
	}
	public log(int verbosity, string fmt) {
		dcl.log(verbosity, fmt);
	}
}

class DebugWrapper {
	private {
        hash opts = (
    		'help': 'h,help',
	    	'verbose': 'v,verbose:+',
			'run': 'r,run',
            'listen': 'l,listen=s@',
        );
		DebugCommandLineLocal dcl;
	}

	constructor() {
		WrapperGetOpt g(opts);
		# first we need split debug args and program args, 'qore-dbg debug-args program-name program-args'
		# it is not trivial, e.g.
		#	qore-dbg -v -l xxx xxx     #the second xxx is program name
		#   qore-dbg -v -h xxx xxx     #the first xxx is program name
		#	qore-dbg -v --listen=xxx xxx     #the second xxx is program name
		#	qore-dbg -v --listen xxx xxx     #the second xxx is program name
		# GetOpt does not support such a parse function
		#
		list dargs;
		hash opt;
        *string fileName;
		g.split(ARGV, \dargs, \fileName, \ARGV);

		try {
			opt = g.parse2(\dargs);
		} catch (hash ex) {
			stderr.printf("%s: %s\n", ex.err, ex.desc);
			help(-1);
		}

		if (opt.help) {
			help();
		}
		dcl = new DebugCommandLineLocal(new DebugProgramControlLocal());
        if (opt.verbose) {
            dcl.verbose = opt.verbose;
        }
printf("opts:%N\n%y\n%N\n", opt, fileName, ARGV);
#exit(1);
        try {
			if (exists fileName) {
				Program pgm = dcl.dpc.createProgram(fileName, ARGV);
				dcl.log(DUV_INFO, "run program");
				background pgm.run();
				sleep(1);  # to avoid OBJECT-ALREADY-DELETED: attempt to access member 'pgm' of an already-deleted object of class 'DebugWrapper'
			}

			dcl.runCmdLine();

        } catch (hash e) {
            stderr.printf("%s: %s\n", e.err, e.desc);
            exit(-1);
        }

	}

	private help(int exCode=1) {
        printf("usage: %s [options] <program> [<program params> ...]\n"
            "  where <file> is program being debugged, use \"--\" to get code from stdin\n"
            "  -v     verbose\n"
            "  -h     help\n"
            "  -l <addr:port>  listener address, multiple listeners is supported, default: %s\n"
			"  -l /<sock>      if begins with a \"/\" character then it is assumed to be a UNIX socket\n"
            "\n"
            "Example:\n"
            "  %s -v myfile.q -my -program params\n"
            "\n"
            ,
            get_script_name(),
            0,
            get_script_name()

        );
        exit(exCode);
    }


	public dummy() {
	}
}


