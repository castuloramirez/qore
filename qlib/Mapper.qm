# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file Mapper.qm data mapping module

/*  Mapper.qm Copyright 2014 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.9 or better
%requires qore >= 0.8.9

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module Mapper {
    version = "1.0";
    desc = "user module providing basic data mapping infrastructure";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/*  Version History
    * 2014-01-03 v1.0: David Nichols <david@qore.org>
      + the initial version of the Mapper module
*/

/** @mainpage Mapper Module

    @tableofcontents

    @section mapperintro Mapper Module Introduction

    This module provides classes that help with structured data mapping, meaning the transformation of data in one or more input
    formats to a different output format.

    Classes provided by this module:
    - @ref Mapper::Mapper "Mapper": the base data mapping class
    - @ref Mapper::AbstractMapperIterator "AbstractMapperIterator": an abstract base class for iterator mapper classes
    - @ref Mapper::MapperIterator "MapperIterator": a class that automatically applies a data mapper to iterated data

    @section mapperexamples Mapper Examples

    The following is an example map hash with comments:
    @code
const DataMap = (
    # output field: "id" mapper from the "Id" element of any "^attributes^" hash in the input record
    "id": "^attributes^.Id",
    # output field: "name": maps from an input field with the same name (no translations are made)
    "name": True,
    # output field: "explicit_count": maps from the input "Count" field, if any value is present then it is converted to an integer
    "explicit_count": ("type": "int", "name": "Count"),
    # output field: "implicit_count": runs the given code on the input record and retuns the result, the code returns the number of "Products" sub-records
    "implicit_count": int sub (any $ignored, hash $rec) { return $rec.Products.size(); },
    # output field: "order_date": converts the "OrderDate" string input field to a date in the specified format
    "order_date": ("name": "OrderDate", "date_format": "DD.MM.YYYY HH:mm:SS.us"),
);
    @endcode

    If this map is applied to the following data in the following way:
    @code
const MapInput = ((
    "^attributes^": ("Id": 1),
    "name": "John Smith",
    "Count": 1,
    "OrderDate": "02.01.2014 10:37:45.103948",
    "Products": ((
        "ProductName": "Widget 1",
        "Quantity": 1,
        ),
    )), (
    "^attributes^": ("Id": 2),
    "name": "Steve Austin",
    "Count": 2,
    "OrderDate": "04.01.2014 19:21:08.882634",
    "Products": ((
        "ProductName": "Widget X",
        "Quantity": 4,
        ), (
        "ProductName": "Widget 2",
        "Quantity": 2,
        ),
    )),
);

my Mapper $map(DataMap);
my list $l = $map.mapAll(MapInput);
printf("%N\n", $l);
    @endcode

    The result will be:
    @verbatim
list: (2 elements)
  [0]=hash: (5 members)
    id : 1
    name : "John Smith"
    explicit_count : 1
    implicit_count : 1
    order_date : 2014-01-02 10:37:45.103948 Thu +01:00 (CET)
  [1]=hash: (5 members)
    id : 2
    name : "Steve Austin"
    explicit_count : 2
    implicit_count : 2
    order_date : 2014-01-04 19:21:08.882634 Sat +01:00 (CET))
    @endverbatim

    @section mapperkeys Mapper Specification Format

    The mapper hash is made up of target (ie output) field names as the key values assigned to field specifications as follows:
    - @ref Qore::True "True": this is a shortcut meaning map from an input field with the same name
    - a @ref closure "closure" or @ref call_reference "call reference": meaning map from a field of the same name an apply the given code to give the value for the mapping; the @ref closure "closure" or @ref call_reference "call reference" must accept the following arguments:
      - @ref any_type "any" <i>$value</i>: the input field value (with the same name as the output field; to use a different name, see the \a code hash option below)
      - @ref @ref hash_type "hash" <i>$rec</i>: the current input record
    - a @ref hash_type "hash" describing the mapping; the following keys are all optional (an empty hash means map from an input field with the same name with no translations):
      - \c "name": the value of this key gives the name of the input field; only use this if the input record name is different than the output field name; note that if this value contains \c "." characters and the \a allow_dot option is not set (see @ref mapperoptions), then the value will be treated like \c "struct"
      - \c "struct": the value of this key gives the location of the input field in an input hash in dot notation, ex: \c "element.name" would ook for the field's value in the \c "name" key of the \c "element" hash in the input record
      - \c "code": a closure or call reference to process the field data
      - \c "date_format": gives the format for converting a string to a date; see @ref date_formatting for the format of this string; note that this also implies \c "type" = \c "date"
      - \c "maxlen": an integer giving the maximum output string field length in bytes
      - \c "trunc": assign to boolean @ref Qore::True "True" if the field should be truncated if over the maximum field length; this key can only be set to @ref Qore::True "True" if the \c "maxlen" key is also given
      - \c "mand": assign to boolean @ref Qore::True "True" if the field is mandatory and an exception should be thrown if no input data is supplied
      - \c "type": this gives the output field type, can be:
        - \c "number": field accepts only numeric values (any non-numeric values on input will cause an exception to be thrown when mapping) 
        - \c "integer": fields accepts only integer values (any non-integer values on input will cause an exception to be thrown when mapping; note: also \c "int" is accepted as an alias for \c "integer") 
        - \c "date": date field

    @section mapperoptions Mapper Options

    Mapper objects accept the following options in the option hash:
    - \c "enc": the output character encoding; if not present then \c "UTF-8" is assumed
    - \c "name": the name of the mapper for use in logging and error strings
    - \c "trunc": an optional @ref closure "closure" or @ref call_reference "call reference" for a callback for field truncation warnings; must accept a single string giving the warning text
    - \c "trunc_all": if @ref Qore::True "True" (as evaluated by @ref Qore::parse_boolean() "parse_boolean()") then any field without a \c "trunc" key (see @ref mapperkeys \c "trunc" description) will automatically be truncated if a \c "maxlen" attribute is set for the field
    - \c "allow_dot": if @ref Qore::True "True" (as evaluated by @ref Qore::parse_boolean() "parse_boolean()") then field names with \c "." characters do not imply a structured internal element lookup; in this case input field names may have \c "." characters in them, use the \c "struct" key to use structured internal element loopups (see @ref mapperkeys \c "struct" docs for more info)
    - \c "input_log": an optional input data logging callback; must accept a hash giving the input data hash
    - \c "output_log": an optional output data logging callback; must accept a hash giving the output data hash

    @section mapperrelnotes Release Notes

    @subsection mapperv1_0 Mapper v1.0

    Initial release.
*/

#! the Mapper namespace contains all the definitions in the Mapper module
public namespace Mapper {
    #! this class is a base class for mapping data; see @ref mapperexamples for usage examples
    public class Mapper {
        # no public members
        public {
        }

        private {
            #! the hash providing output field names and mappings
            hash $.map;

            #! the output character encoding; if not given then the output encoding is assumed to be UTF-8
            string $.enc = "utf-8";

            #! the optional name for the object (for example a table name); will be prepended to field names in error messages
            *string $.name;

            #! an optional field truncation callback
            *code $.trunc;

            #! an optional input data logging callback; must accept a hash giving the input data hash
            *code $.input_log;

            #! an optional output data logging callback; must accept a hash giving the output data hash
            *code $.output_log;

            #! an optional timezone for output date fields
            *Qore::TimeZone $.timezone;

            #! the timezone for input fields in case of parsing text values; if not set defaults to the current TimeZone (see @ref Qore::TimeZone::get())
            Qore::TimeZone $.input_timezone = TimeZone::get();

            #! truncate all option
            bool $.trunc_all = False;

            #! do not assume \a struct when field names have a \c "." in them; instead allow input field names to have a \c "." in them
            bool $.allow_dot = False;

            #! constant hash value for output mappings
            *hash $.crec;

            #! count of records mapped
            int $.count = 0;

            #! constructor option keys (can be extended by subclassing and reimplementing optionKeys())
            const OptionKeys = (
                "enc": True,
                "name": True,
                "trunc": True,
                "input_log": True,
                "output_log": True,
                "timezone": True,
                "input_timezone": True,
                "trunc_all": True,
                "crec": True,
                "date_format": True,
                );

            #! default known mapper hash field keys (can be extended by subclassing and reimplementing validKeys())
            const ValidKeys = (
                "name": True,
                "struct": True,
                "code": True,
                "maxlen": True,
                "trunc": True, 
                "mand": True,
                "number": True,
                "type": True,
                "date_format": True,
                );

            #! default known field types (can be extended by subclassing and reimplementing validTypes() and mapFieldType()) 
            const ValidTypes = (
                "number": True,
                "integer": True,
                "int": True, # is an alias for "integer"
                "date": True,
                );
        }

        #! builds the object based on a hash providing field mappings, data constraints, and optionally custom mapping logic
        /** @par Example:
            @code
const DataMap = (
    # output field: "id" mapper from the "Id" element of any "^attributes^" hash in the input record
    "id": "^attributes^.Id",
    # output field: "name": maps from an input field with the same name (no translations are made)
    "name": True,
    # output field: "explicit_count": maps from the input "Count" field, if any value is present then it is converted to an integer
    "explicit_count": ("type": "int", "name": "Count"),
    # output field: "implicit_count": runs the given code on the input record and retuns the result, the code returns the number of "Products" sub-records
    "implicit_count": int sub (any $ignored, hash $rec) { return $rec.Products.size(); },
    # output field: "order_date": converts the "OrderDate" string input field to a date in the specified format
    "order_date": ("name": "OrderDate", "date_format": "DD.MM.YYYY HH:mm:SS.us"),
);

my Mapper $map(DataMap);
            @endcode

            @param map a hash providing field mappings; each hash key is the name of the output field; each value is either @ref Qore::True "True" (meaning no translations are done; the data is copied 1:1) or a hash describing the mapping; see @ref mapperkeys for detailed documnentation for this option
            @param opts an optional hash of options for the mapper; see @ref mapperoptions for a description of valid mapper options

            @throw MAP-ERROR the map hash has a logical error (ex: \c "trunc" key given without \c "maxlen", invalid map key)
         */
        constructor(hash $map, *hash $opts) {
            $.setup($map, $opts);

            # check map for logical errors
            $.checkMap();
        }

        #! private constructor for subclasses
        private constructor() {
        }

        #! sets up the mapper object before checking the mapper hash
        private setup(hash $map, *hash $opts) {
            $.name = $opts.name;
            $.input_log = $opts.input_log;
            $.output_log = $opts.output_log;

            if ($opts.trunc_all)
                $.trunc_all = parse_boolean($opts.trunc_all);

            $.crec = $opts.crec;

            if (!$map)
                $.error("empty map passed to Mapper::constructor()");

            $.map = $map;
            my hash $ck = $.optionKeys();
            foreach my string $k in ($opts.keyIterator()) {
                if (!$ck.$k)
                    $.error("unknown option key %y passed to Mapper::constructor(); recognized option keys: %y", $.getFieldName($k), $ck.keys());
            }

            if ($opts.enc)
                $.enc = $opts.enc;
            $.trunc = $opts.trunc;
            
            if ($opts) {
                $.checkTimezoneOption($opts, "timezone");
                $.checkTimezoneOption($opts, "input_timezone");
            }
        }

        #! verifies the input map in the constructor
        private checkMap() {
            map $.checkMapField($1, \$.map.$1), $.map.keyIterator();
        }

        #! convert a field definition to a hash if possible
        private convertToHash(int $t, string $k, reference $fh) {
            switch ($t) {
                # convert to a hash if the value of the column is a string (giving the source key name)
                case NT_STRING: $fh = (!$.allow_dot && $fh =~ /\./ ? ("struct": $fh.split(".")) : ("name": $fh)); break;
                case NT_CALLREF:
                case NT_CLOSURE: $fh = ("code": $fh); break;
                case NT_BOOLEAN: if ($fh) {
                    $fh = hash();
                    break;
                }
                case NT_NOTHING: {
                    $fh = hash();
                    break;
                }
                default: $.error("unsupported type %y assigned to map key %y", $fh.type(), $k);
            }
        }

        #! perform per-field pre-processing on the passed map in the constructor
        /** @param k the field name
            @param fh a reference to the field's value in the map
        */
        private checkMapField(string $k, reference $fh, *hash $th) {
            # check field description
            my int $t = $fh.typeCode();
            if ($t != NT_HASH)
                $.convertToHash($t, $k, \$fh);
            else if ($fh.name) {
                if ($fh.struct)
                    $.error("field '%s' has both 'name' (%y) and 'struct' (%y) values; only one can be given to identify the input field", $.getFieldName($k), $fh.name, $fh.struct);
                if (!$.allow_dot && $fh.name =~ /\./)
                    $fh.struct = (remove $fh.name).split(".");
            }

            switch ($fh.struct.typeCode()) {
                case NT_NOTHING: break;
                case NT_STRING: $fh.struct = $fh.struct.split("."); # then fall down to next case
                case NT_LIST: {
                    if (!$fh.struct)
                        $.error("field '%s' has an empty 'struct' key", $.getFieldName($k));
                    if ($fh.struct.size() == 1)
                        $fh.name = (remove $fh.struct)[0];
                    break;
                }
                default: $.error("field '%s' has an invalid struct key assigned to type %y (%y)", $.getFieldName($k), $fh.struct.type(), $fh);
            }

            if ($fh.date_format) {
                if ($fh.date_format.typeCode() != NT_STRING)
                    $.error("field '%s' has a 'date_format' key assigned to type '%s'; expecting 'string'", $.getFieldName($k), $fh.date_format.type());
                if (exists $fh.type) {
                    if ($fh.type != "date")
                        $.error("field '%s' has a 'date_format' key but the field's type is '%s'", $.getFieldName($k), $fh.type);
                }
                else
                    $fh.type = "date";
            }
            
            if ($fh.trunc && !$fh.maxlen)
                $.error("field '%s' has the 'trunc' key set to True but has no 'maxlen' key", $.getFieldName($k));
            
            if ($fh.maxlen && !exists $fh.trunc && $.trunc_all)
                $fh.trunc = True;

            my hash $vk = $.validKeys();
            my hash $vt = $.validTypes();

            foreach my string $hk in ($fh.keyIterator())
                if (!$vk.$hk)
                    $.error("field '%s' in map hash contains unknown key '%s' (valid keys: %y)", $.getFieldName($k), $hk, $vk.keys());
            
            # convert old "number" tag to new "type" tag
            if ($fh.number) {
                if (exists $fh.type)
                    $.error("field '%s' has both 'type' and deprecated 'number' tags", $.getFieldName($k));
                $fh.type = "number";
                delete $fh.number;
            }
            else if (exists $fh.type && !$vt.($fh.type))
                $.error("field '%s' contains an invalid type value '%s' (valid types: %y)", $.getFieldName($k), $fh.type, $vt.keys());
            
            if (exists $fh.code && !$fh.code.callp())
                $.error("field '%s' has a code argument assigned to type '%s'", $.getFieldName($k), $fh.code.type());

            if ($.hasMapping($fh)) {
                if (exists $.crec.$k)
                    $.error("field '%s' is has a mapping and also a constant value", $.getFieldName($k));
            }
        }

        #! returns @ref Qore::True "True" if the field has a mapping, @ref Qore::False "False" if not
        private bool hasMapping(hash $fh) {
            return $fh.name || $fh.struct || $fh.code;
        }

        #! verifies a timezone constructor option
        private checkTimezoneOption(hash $opts, string $rn) {
            my any $val = $opts.$rn;
            if (!exists $val)
                return;
            if ($val instanceof TimeZone) {
                $self.$rn = $val;
                return;
            }

            switch ($val.typeCode()) {
                case NT_STRING:
                case NT_INT: $self.$rn = new TimeZone($val.timezone); break;
                default: $.error("type %y assigned to the %s option (expecting TimeZone, string, or int)", $val.type(), $rn);
            }
        }

        string getFieldName(string $name) {
            return $.name.val() ? sprintf("%s.%s", $.name, $name) : $name;
        }

        #! returns a list of valid field keys for this class (can be overridden in subclasses)
        /** @return a list of valid field keys for this class (can be overridden in subclasses)
        */
        hash validKeys() {
            return ValidKeys;
        }

        #! returns a list of valid field types for this class (can be overridden in subclasses)
        /** @return a list of valid types for this class (can be overridden in subclasses)
        */
        hash validTypes() {
            return ValidTypes;
        }

        #! returns a list of valid constructor options for this class (can be overridden in subclasses)
        /** @return a list of valid constructor options for this class (can be overridden in subclasses)
        */
        hash optionKeys() {
            return OptionKeys;
        }

        #! maps all input records and returns the mapped data as a list of output records
        /** this method applies the @ref mapData() method to all input records and returns the resulting list
            @param recs the list of input records

            @return the mapped data as a list of output records

            @throw MISSING-INPUT a field marked mandatory is missing
            @throw STRING-TOO-LONG a field value exceeds the maximum value and the 'trunc' key is not set
            @throw INVALID-NUMBER the field is marked as numeric but the input value contains non-numeric data
        */
        list mapAll(softlist $recs) {
            return map $.mapData($1), $recs;
        }
        
        #! processes the input record and returns a hash of the mapped values where the keys in the hash returned are the target field names; the order of the fields in the hash returned is the same order as the keys in the map hash.
        /** @param rec the record to translate

            @return a hash of field values in the target format based on the input data and processed according to the logic in the map hash

            @throw MISSING-INPUT a field marked mandatory is missing
            @throw STRING-TOO-LONG a field value exceeds the maximum value and the 'trunc' key is not set
            @throw INVALID-NUMBER the field is marked as numeric but the input value contains non-numeric data

            @note each time this method is executed successfully, the record count is updated (see @ref getCount() and @ref resetCount())
        */
        hash mapData(hash $rec) {
            if ($.input_log)
                call_function($.input_log, $rec);

            if ($.crec)
                $rec += $.crec;

            # we know the map has at least 1 element so no need to initialize $h as a hash to guarantee the return type
            my hash $h;

            # iterate through target fields
            foreach my string $key in ($.map.keyIterator()) {
                my any $m = $.map.$key;

                # get source field name
                my string $name = exists $m.name ? $m.name : $key;

                # get source record value
                my any $v;
                if ($m.struct) {
                    # get the value
                    $v = $rec;
                    map $v = $v{$m.struct[$1]}, xrange(0, $m.struct.size() - 1);
                }
                else
                    $v = $rec.$name !== NULL ? $rec.$name : NOTHING;

                # move any XML CDATA into the field value
                if ($v."^cdata^")
                    $v = $v."^cdata^";

                # if the internal field was marked as needing processing by a subclass, then call the mapSubclass method
                if ($m.subclass)
                    $v = $.mapSubclass($m, $v);

                # execute any field filter if necessary
                if (exists $m.code) {
                    try {
                        $v = $m.code($v, $rec);
                    }
                    catch (hash $ex) {
                        $ex.desc = sprintf("field %y closure: %s", $key, $ex.desc);
                        throw $ex.err, $ex.desc, $ex.arg;
                    }
                }

                # check maximum length
                if ($m.maxlen && $v.size() > $m.maxlen) {
                    # truncate the string if necessary
                    if ($m.trunc) {
                        if ($.trunc) {
                            my string $msg = sprintf("field %y = %y input length %d truncating to %d bytes", $.getFieldName($key), $v, $v.size(), $m.maxlen);
                            call_function($.trunc, $msg);
                        }
                        $v = trunc_str($v, $m.maxlen, $.enc);
                    }
                    else
                        $.error2("STRING-TOO-LONG", "field %y = %y, input length %d exceeds maximum byte length %d for input row: %y", $.getFieldName($key), $v, strlen($v), $m.maxlen, $rec);
                }

                if ($v.typeCode() == NT_STRING && $v.empty())
                    delete $v;

                if ($m.type)
                    $.mapFieldType($key, $m, \$v, $rec);

                if ($m.mand && !exists $v)
                    $.error2("MISSING-INPUT", "field %y is marked as mandatory but is missing in the input row: %y", $.getFieldName($key), $rec);
                
                # add value to row list
                $h.$key = $v;
            }

            if ($.output_log)
                call_function($.output_log, $h);

            # increment record count
            ++$.count;

            # return list of values for row
            return $h;
        }

        #! returns the internal record count
        /** @see resetCount()
        */
        int getCount() {
            return $.count;
        }

        #! resets the internal record count
        /** @see getCount()
        */
        resetCount() {
            $.count = 0;
        }

        #! performs type handling
        private mapFieldType(string $key, hash $m, reference $v, hash $rec) {
            switch ($m.type) {
                case "number": {
                    # check for valid numeric values
                    if (exists $v) {
                        if ($v !~ /^([-+])?[0-9\.]+$/)
                            $.error2("INVALID-NUMBER", "field %y = %y is marked as a numeric field, but the input data contains non-numeric text in input row: %y", $.getFieldName($key), $v, $rec);
                        $v = number($v);
                    }
                    break;
                }
                case "int":
                case "integer": {
                    # check for valid integer values
                    if (exists $v) {
                        if ($v !~ /^([-+])?[0-9]+$/)
                            $.error2("INVALID-INTEGER", "field %y = %y is marked as an integer field, but the input data contains non-integer text in input row: %y", $.getFieldName($key), $v, $rec);
                        $v = int($v);
                    }
                    break;
                }
                case "date": {
                    if ($v.val()) {
                        if ($v.typeCode() != NT_DATE) {
                            $v = $.input_timezone.date($v, $m.date_format);
                        }
                        # convert to the output TimeZone if necessary
                        if ($.timezone)
                            $v = $.timezone.date($v);
                    }
                    break;
                }
            }
        }

        #! throws a \c MAP-ERROR exception; prepends the map name to the description if known
        private error(string $fmt) {
            my string $err = vsprintf($fmt, $argv);
            if ($.name)
                $err = sprintf("%y mapper: %s", $.name, $err);
            throw "MAP-ERROR", $err;
        }

        #! throws the given exception; prepends the map name to the description if known
        private error2(string $ex, string $fmt) {
            my string $err = vsprintf($fmt, $argv);
            if ($.name)
                $err = sprintf("%y mapper: %s", $.name, $err);
            throw $ex, $err;
        }

        #! to be overridden as necessary in subclasses
        private any mapSubclass(hash $m, any $v) {
            return $v;
        }
    }

    #! abstract base class for hash iterator mappping classes based on a mapper object and an iterator input source
    public class AbstractMapperIterator inherits Qore::AbstractIterator {
        public {
        }

        private {
            #! input iterator; @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()" must return a hash
            Qore::AbstractIterator $.i;
        }

        #! creates the iterator from the arguments passed
        /** @param i input iterator; @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()" must return a hash
            @param map the mapper to transform the data
        */
        constructor(Qore::AbstractIterator $i) {
            $.i = $i;
        }

        #! Moves the current position of the input iterator to the next element; returns @ref Qore::False "False" if there are no more elements
        bool next() {
            return $.i.next();
        }

        #! returns @ref Qore::True "True" if the input iterator is currently pointing at a valid element, @ref Qore::False "False" if not
        bool valid() {
            return $.i.valid();
        }
    }

    #! provides a hash iterator based on a mapper object and an iterator input source
    public class MapperIterator inherits Mapper::AbstractMapperIterator {
        public {
        }

        private {
            #! data mapper
            Mapper::Mapper $.map;
        }

        #! creates the iterator from the arguments passed
        /** @param i input iterator; @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()" must return a hash
            @param map a hash providing field mappings; each hash key is the name of the output field; each value is either @ref Qore::True "True" (meaning no translations are done; the data is copied 1:1) or a hash describing the mapping; see @ref mapperkeys for detailed documnentation for this option
            @param opts an optional hash of options for the mapper; see @ref mapperoptions for a description of valid mapper options

            @throw MAP-ERROR the map hash has a logical error (ex: \c "trunc" key given without \c "maxlen", invalid map key)
         */
        constructor(Qore::AbstractIterator $i, hash $map, *hash $opts) : Mapper::AbstractMapperIterator($i) {
            $.map = new Mapper($map, $opts);
        }

        #! creates the iterator from the arguments passed
        /** @param i input iterator; @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()" must return a hash
            @param map the mapper to transform the data
        */
        constructor(Qore::AbstractIterator $i, Mapper::Mapper $map) : Mapper::AbstractMapperIterator($i) {
            $.map = $map;
        }

        #! returns the current row transformed with the mapper
        hash getValue() {
            return $.map.mapData($.i.getValue());
        }

        #! returns the internal record count
        /** @see resetCount()
        */
        int getCount() {
            return $.map.getCount();
        }

        #! resets the internal record count
        /** @see getCount()
        */
        resetCount() {
            $.map.resetCount();
        }
    }
}
