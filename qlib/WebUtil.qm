# -*- mode: qore; indent-tabs-mode: nil -*-
# @file WebUtil.qm Qore user module supprting web server operations

/*  WebUtil.qm Copyright 2013 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.8 or better
%requires qore >= 0.8.8

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module WebUtil {
    version = "1.0";
    desc = "user module supprting web server operations";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
}

%requires HttpServer >= 0.3.7
%requires Mime >= 1.0
%requires Util >= 1.0

/*  Version History
    * 2013-xx-xx v1.0: David Nichols <david@qore.org>
      + the initial version of the WebUtil module
*/

/** @mainpage WebUtil Module

    The %WebUtil module provides code that support web server operations.

    To use this module, use \c "%requires WebUtil" in your code.
    
    All the public symbols in the module are defined in the WebUtil namespace

    Classes:
    - @ref WebUtil::TemplateManager "TemplateManager": manages mixed Qore and text templates that are rendered to generate a final file; useful for HTML rendering for example
    - @ref WebUtil::FileHandler "FileHandler": a class for serving files from the file system anchored at a particular URL; also uses @ref WebUtil::TemplateManager "TemplateManager"
*/

#! the WebUtil namespace contains all the objects in the WebUtil module
public namespace WebUtil {
    #! A container for holding text templates with mixed text and Qore code
    /** To give the template programs a specific imported API, subclass this object and use the following methods to import an API into the template @ref Qore::Program "Program" object in your subclass's constructor:
        - @ref Qore::Program::importClass()
        - @ref Qore::Program::importFunction()
        - @ref Qore::Program::importGlobalVariable()
     */
    public class TemplateManager {
        private {
            #! Holds the template generation functions
            Program $.p;

            #! Maps template names to function names
            hash $.th;

            #! Sequence for template function names
            Sequence $.seq();
        }

        public {
            #! default parse options for template Programs
            const DefaultProgramOptions = PO_REQUIRE_OUR|PO_NO_TOP_LEVEL_STATEMENTS|PO_NO_INHERIT_USER_FUNC_VARIANTS|PO_NO_INHERIT_GLOBAL_VARS|PO_NO_USER_CLASSES|PO_NO_TERMINAL_IO;
        }

        #! sets up the object
        constructor(int $po = DefaultProgramOptions) {
            # create Program
            $.p = new Program($po);
        }

        #! adds a template to the object
        /** @par Example:
            @code
my string $qhtml = "<form id=\"upload_form\" enctype=\"multipart/form-data\" method=\"post\" action=\"{{ $URL_PREFIX }}upload-file">
    <fieldset class=\"workflow_list\">
        <legend>Step 1: Select Workflow</legend>
          <select class=\"worfklows\" name=\"workflow\" id=\"workflow\">
            {% foreach my hash $h ($ctx.workflows.pairIterator()) { %}
            <option value="{{ $h.key }}">{{ $h.value.label }}</option>
            {% } %}
          </select>
    </fieldset>
</form>";
$tm.add("/html/index.qhtml", $qhtml);
            @endcode

            @param name the name of the template
            @param src the source of the template; %Qore source code is delimited as follows:
            - expressions: %Qore expressions are delimited by double curly brackets: <tt>{{ }}</tt>; such expressions are expected to return a string value that will be inserted directly into the text generated by the template
            - statements: %Qore statements are delimited by a curly bracket and percent sign: <tt>{% %}</tt>; these statements can be any %Qore code legal for the template @ref Qore::Program "Program" object; for example loop constructs are often used (see the example above)
            @param ct the Content-Type of the rendered output; if not given then the content-type is derived from the extension in the name if possible; if the content-type cannot be derived from the extension, then content-type \c "text/plain" is assumed

            The \a $ctx hash variable is always present in the template code; this is the call context variable, and is set to the same value as the \a cx argument in @ref HttpServer::AbstractHttpRequestHandler::handleRequest() plus any context added by the actual handler handing the request.  In the example above, a \c "workflows" key assigned to a hash has been added to the call context variable.

            @return the source code of the generated template (without @ref Qore::Program "Program" overhead)
        */
        string add(string $name, string $src, *string $ct) {
            # generate function name
            my string $fn = sprintf("t%d", $.seq.next());

            # break down source into components
            my list $l = ();

            my int $i = 0;
            while ($src) {
                $i = $src.find("{", $i);
                if ($i == -1)
                    break;
                ++$i;
                my string $c = $src[$i];
                if ($c == "{") {
                    if ($.doBlock("}}", \$src, "exp", \$i, \$l))
                        break;
                    continue;
                }
                if ($c == "%") {
                    if ($.doBlock("%}", \$src, "stmt", \$i, \$l))
                        break;
                    continue;
                }
            }

            # add any remaining text as a text element
            if ($src)
                $l += (
                    "type": "text",
                    "text": $src,
                );

            #printf("DBG l: %N\n", $l);

            # now process and rebuild source
            $src = "";
            foreach my hash $h in (\$l) {
                switch ($h.type) {
                    case "text": $h.text =~ s/"/\"/g; $src += $h.text; break;
                    case "exp": $src += "\"+("+ $h.text + ")+\""; break;
                    case "stmt": $src += "\";" + $h.text + "$rv_TEMPLATE_str+=\""; break;
                }
            }

            #printf("template %y: found vars: %y\n", $name, $vh.keys());

            # build function source
            my string $tpl = sprintf("string sub %s(*hash $ctx) {\n", $fn);
            $tpl += sprintf("    my string $rv_TEMPLATE_str = \"%s\";\n    return $rv_TEMPLATE_str;\n}\n", $src);
            $.p.parse($tpl, $name);

            # derived content type if necessary
            if (!$ct) {
                my *string $ext = ($name =~ x/\.([a-z0-9]+)$/i)[0];
                # if the extension starts with a  "q", then remove the leading "q"
                if ($ext[0] == "q")
                    $ext = $ext.substr(1);
                $ct = ($ext && ($ext = MimeTypes{$ext.lwr()})) ? $ext : MimeTypeText;
            }

            # add entry in template hash
            $.th.$name = (
                "func": $fn,
                "ct": $ct,
                );

            # return the final source string produced
            return $src;
        }

        #! returns @ref Qore::True "True" if the given template exists, @ref Qore::False "False" if not
        bool hasTemplate(string $tname) {
            return boolean($.th.$tname);
        }

        #! explicitly renders the given template with the given argument
        /** @par Example:
            @code
my hash $h = $tm.render("html/index.qhtml", $ctx);
            @endcode

            @param tname the template name
            @param ctx the context argument for the template
            @param code the HTTP response code for the response, if not present then 200 \c "OK" is assumed
            @param hdr any optional headers for the response (the \c "Content-Type" header is set from the templates \c "Content-Type" value automatically)

            @return a hash with the following keys:
            - \c code: the HTTP response code corresponding to the \a code argument
            - \c body: the rendered template
            - \c hdr: a hash of headers corresponding to the \a hdr argument plus the \c "Content-Type" key set from the template's "Content-Type" value)

            @throw TEMPLATE-ERROR the given template does not exist
        */
        hash render(string $tname, hash $ctx, int $code = 200, *hash $hdr) {
            my *hash $th = $.th.$tname;
            if (!$th)
                throw "TEMPLATE-ERROR", sprintf("no template %y exists; known templates: %y", $tname, $.th.keys());

            return (
                "code": $code,
                "body": $.p.callFunction($th.func, $ctx),
                "hdr": $hdr + ("Content-Type": $th.ct),
                );
        }

        #! explicitly renders the given template with the given argument context hash if the template exists; if not, returns @ref nothing
        /** @par Example:
            @code
my *hash $h = $tm.tryRender("html/index.qhtml", $ctx);
            @endcode

            @param tname the template name
            @param ctx the context argument for the template
            @param code the HTTP response code for the response, if not present then 200 \c "OK" is assumed
            @param hdr any optional headers for the response (the \c "Content-Type" header is set from the templates \c "Content-Type" value automatically)

            @return @ref nothing if the template does not exist, otherwise  a hash with the following keys:
            - \c code: the HTTP response code corresponding to the \a code argument
            - \c body: the rendered template
            - \c hdr: a hash of headers corresponding to the \a hdr argument plus the \c "Content-Type" key set from the template's "Content-Type" value)
        */
        *hash tryRender(string $tname, hash $ctx, int $code = 200, *hash $hdr) {
            my *hash $th = $.th.$tname;
            if (!$th)
                return;

            return (
                "code": $code,
                "body": $.p.callFunction($th.func, $ctx),
                "hdr": $hdr + ("Content-Type": $th.ct),
                );
        }

        #! returns a hash of template names, values are @ref Qore::True "True" or @ref nothing if no templates are currently cached
        *hash getTemplateHash() {
            my hash $h;
            map $h.$1 = True, $.th.keyIterator();
            return $h;
        }

        #! returns a list of template names, an empty list is returned if there are no templates
        list getTemplateList() {
            return $.th.keys();
        }

        private bool doBlock(string $end, reference $src, string $type, reference $i, reference $l) {
            my int $j = $src.find($end, $i + 1);
            if ($j == -1)
                return True;
            if ($i > 1)
                $l += (
                    "type": "text",
                    "text": extract $src, 0, $i - 1,
                );
            # remove open brackets
            splice $src, 0, 2;
            $j -= $i;
            # add source expression reference
            $l += (
                "type": $type,
                "text": extract $src, 0, $j - 1,
                );
            # remove close brackets
            splice $src, 0, 2;
            $i = 0;
            return False;
        }
    }

    #! this class serves files from the file system based on a root location
    public class FileHandler inherits public HttpServer::AbstractUrlHandler, private WebUtil::TemplateManager {
        public {
            #! root directory for serving files
            string $.file_root;

            #! indexes for directories; handled in order of appearance
            softlist $.indexes = (Defaults.IndexTemplate, Defaults.IndexFile);

            #! file extensions handled as templates
            hash $.template_extensions = Defaults.TemplateExtensions;

            #! the default target if a URL cannot be satisfied
            *string $.default_target;

            #! set for error info level
            /** - 0: no details
                - 1: error summary info
                - 2: complete error details including stack trace (can expose internal implementation details)
             */
            int $.error_level = 0;

            #! flag for UNIX operating systems
            const Unix = (PlatformOS != "Windows");

            #! directory separator character
            const DirSep = (Unix ? "/" : "\\");

            #! default configuration values
            const Defaults = (
                # default index file
                "IndexFile": "index.html",
                "IndexTemplate": "index.qhtml",
                "TemplateExtensions": (
                    "qhtml": True,
                ),
                );

            #! dirlisting template
            const Dirlisting = "<html lang=\"en\" >"
"{%"
"    my Dir $d();"
"    $d.chdir($ctx.path);"
"    my string $title = sprintf(\"Index of /%s\", $ctx.resource_path);"
"%}"
"    <head>"
"        <meta charset=\"utf-8\" />"
"        <title>{{ $title }}</title>"
"    </head>"
"    <body>"
"        <header>"
"            <h1>{{ $title }}</h1>"
"        </header>"
"        <div class=\"container\">"
"            <table>"
"                <tr>"
"                    <th>Name</th>"
"                    <th width=\"40\">Type</th>"
"                    <th width=\"80\">Size</th>"
"                </tr>"
"                {% if ($ctx.parent_url) { %}"
"                <tr>"
"                    <td colspan=\"2\"><a href=\"{{ $ctx.parent_url }}\">Parent Directory</a></td>"
"                </tr>"
"                {% } %}"
"                {% foreach my string $dir in (sort($d.listDirs())) { %}"
"                {% if ($dir[0]!=\".\") {"
"                    my string $path = replace($ctx.path, $ctx.file_root, \"\");"
"                %}"
"                <tr><td><a href=\"{{ $ctx.url_root + $path + \"/\" + $dir }}\">{{ $dir }}</a></td><td width=\"40\">Directory</td></tr>"
"                {% } %}"
"                {% } %}"
"                {% foreach my string $file in (sort($d.listFiles())) { %}"
"                {% if ($file[0]!=\".\") {"
"                    my string $path = replace($ctx.path, $ctx.file_root, \"\");"
"                %}"
"                <tr><td><a href=\"{{ $ctx.url_root + $path + \"/\" + $file }}\">{{ $file }}</a></td><td width=\"40\">File</td><td align=\"right\">{{hstat($ctx.path + \"/\" + $file).size }}</td></tr>"
"                {% } %}"
"                {% } %}"
"            </table>"
"        </div>"
"    </body>"
"</html>";
        }

        private {
            #! read-write lock for managing template access
            RWLock $.rwl();
        }

        #! create the object optionally with the given AbstractAuthenticator
        /** @param file_root the filesystem root directory for serving files
            @param url_root the root part of the URL path without the leading \c "/"
            @param default_target the default relative path to use if a request cannot be satisfied
            @param auth the authentication object to use to authenticate connections (see AbstractAuthenticator); if no AbstractAuthenticator object is passed, then by default no authentication will be required
        */
        constructor(string $file_root, string $url_root, *string $default_target, *AbstractAuthenticator $auth) : AbstractUrlHandler($url_root, $auth) {
            $.file_root = normalize_dir($file_root);
            # make sure file_root ends in a directory separator character
            if ($.file_root[$.file_root.size() - 1] != DirSep)
                $.file_root += DirSep;
            $.default_target = $default_target;

            # setup :dirlisting template
            $.add(":dirlisting", $.getDirlistingTemplate(), MimeTypeHtml);
        }

        private string getDirlistingTemplate() {
            return Dirlisting;
        }

        #! this method calls handleRequestImpl() to service the request, if handleRequestImpl() returns @ref nothing, then it tries to automatically serve a matching template or files from the filesystem or serve the default resource if no resource can be matched
        /** @param cx call context hash; this hash will have the following keys:
            - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
            - \c socket-info: a hash of socket information for the listening socket (as returned by @ref Qore::Socket::getSocketInfo())
            - \c peer-info: a hash of socket information for the remote socket (as returned by @ref Qore::Socket::getPeerInfo())
            - \c url: a hash of broken-down URL information (as returned from @ref Qore::parse_url())
            - \c id: the unique HTTP connection ID
            - \c listener-id: the HTTP server listener ID (see HttpServer::getListenerInfo())
            - \c user: the current RBAC username (if any)
            @param hdr incoming header hash; all keys will be converted to lower-case, additionally the following keys will be present:
            - \c method: the HTTP method received (ie \c "GET", \c "POST", etc)
            - \c path: the HTTP path given in the request, after processing by @ref Qore::decode_url()
            - \c http_version: the HTTP version number in the request (either \c "1.0" or \c "1.1")
            @param body message body, if any

            @return a hash with the following keys:
            - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
            - \c "body": the message body to return in the response
            - \c "close": (optional) set this key to @ref Qore::True "True" if the connection should be unconditionally closed when the handler returns
            - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response

            The following keys are added to the \a cx argument when calling handleRequestImpl():
            - \c resource_path: the relative path without any query arguments and with the URL root stripped off (if the request was matched by the URL root, otherwise this will be the request path with any URI query arguments removed)
            - \c url_root: the root URL
            - \c file_root: the root directory for serving files
            - \c isregex: if the \a url_root string is a regular expression or not (this is always @ref Qore::False "False" when this class is used)
            - \c hdr: this is added to the \a cx argument directly from the \a hdr argument

            If handleRequestImpl() returns @ref nothing and the requested path cannot be matched and served, then unhandledRequest() is called to handle the error
        */
        hash handleRequest(hash $cx, hash $hdr, *data $body) {
            # get local request path and "localize" it and strip off any query args
            my string $path = $.getRelativePath($hdr.path);

            $cx += ("resource_path": $path, "url_root": $.url_root, "file_root": $.file_root, "isregex": False, "hdr": $hdr);

            try {
                my *hash $h = $.handleRequestImpl(\$cx, $hdr, $body);
                if (!$h) {
                    $h = $.tryServeRequest($cx);
                    if (!$h) {
                        $cx.resource_path = $.default_target;
                        $h = $.tryServeRequest($cx);
                    }
                }
                if ($h)
                    return $h;

            }
            catch (hash $ex) {
                return $.serverError($cx, $ex);
            }

            return $.unhandledRequest($cx, $hdr, $body);
        }

        #! default implementation is empty; this method is called with informational log messages; reimplement in subclasses to provide for logging
        logInfo(string $fmt) {
            delete $argv;
        }

        #! default implementation is empty; this method is called with error log messages; reimplement in subclasses to provide for logging
        logError(string $fmt) {
            delete $argv;
        }

        #! default implementation is empty; this method is called with debug log messages; reimplement in subclasses to provide for logging
        logDebug(string $fmt) {
            delete $argv;
        }

        #! this method returns a 404 \c "Not Found" error code to \c GET requests and a 501 \c "Not Implemented" error code to all other requests
        /** this method is called when a request cannot be handled; reimplement this method in subclasses to customize unhandled request error handling
        */
        private hash unhandledRequest(hash $cx, hash $hdr, *data $body) {
            return $hdr.method == "GET"
                ? $.makeResponse(404, "The requested page cannot be found")
                : $.make501("The requested operation is not supported");
        }

        #! this method returns a 400 \c "Bad Request" error code when a file should be served that's not a regular file
        /** this method is called when a file cannot be served because it's not a regular file; reimplement this method in subclasses to customize error handling
        */
        private hash fileError(hash $cx, hash $sh) {
            return $.makeResponse(400, "The requested resource cannot be served");
        }

        #! this method returns a 500 \c "Internal Server Error" error code when an exception occurs
        /** this method is called when an exception occurs; reimplement this method in subclasses to customize error handling
        */
        private hash serverError(hash $cx, hash $ex) {
            my string $errstr = get_exception_string($ex);
            $.logError($errstr);
            my string $desc;
            if (!$.error_level)
                $desc = "A server error occurred";
            else if ($.error_level == 1)
                $desc = sprintf("%s: %s: %s", get_ex_pos($ex), $ex.err, $ex.desc);
            else
                $desc = $errstr;
            return $.makeResponse(500, $desc);
        }

        private *hash tryServeRequest(hash $cx) {
            my *string $path = $cx.resource_path;

            # use Windows directory separator chars on Windows
            if (!Unix)
                $path =~ s/\//\\/g;
        
            $path = $.file_root + $path;

            my *hash $sh = hstat($path);
            if (!$sh)
                return;

            # add index if the request corresponds to a directory
            if ($sh.type == "DIRECTORY") {
                my bool $found = False;
                foreach my string $idx in ($.indexes) {
                    my string $p = $path + DirSep + $idx;
                    if (hstat($p).type == "REGULAR") {
                        # set resource path
                        $cx.resource_path += "/" + $idx;
                        $found = True;
                        $path = $p;
                        break;
                    }
                }
                if (!$found)
                    return $.renderDirectory($cx, $path);
            }
            else if ($sh.type != "REGULAR")
                return $.fileError($cx, $sh);

            # see if we should handle as a template
            my *string $ext = ($cx.resource_path =~ x/\.([a-z0-9]+)$/i)[0];
            if ($ext && $.template_extensions.$ext)
                return $.renderTemplateFromFile($cx.resource_path, $path, $cx);

            my File $f();
            if ($f.open($path))
                return;

            my *string $data = $f.read(-1);

            return !$data
                ? $.makeResponse(204, "")
                : (
                "code": 200,
                "body": $data,
                "hdr": ("Content-Type": get_mime_type_from_ext($path)),
                );
        }

        #! this method is called when a directory should be rendered
        /** if this method returns @ref nothing then any \a default_target will be used, so to turn off directory rendering, 
            subclass this class and have the reimplemented method return @ref nothing
        */
        *hash renderDirectory(hash $cx, string $path) {
            $cx += (
                "path": $path,
                "parent_url": "/" + dirname($cx.hdr.path),
            );
            return $.render(":dirlisting", $cx);
        }

        #! this method is called by this class's handleRequest() before trying to service the request automatically based on file resources
        /** @param cx call context hash; this hash will have the following keys:
            - \c socket: the bind address used to bind the listener (\c "socket-info" provides more detailed information)
            - \c socket-info: a hash of socket information for the listening socket (as returned by @ref Qore::Socket::getSocketInfo())
            - \c peer-info: a hash of socket information for the remote socket (as returned by @ref Qore::Socket::getPeerInfo())
            - \c url: a hash of broken-down URL information (as returned from @ref Qore::parse_url())
            - \c id: the unique HTTP connection ID
            - \c listener-id: the HTTP server listener ID (see HttpServer::getListenerInfo())
            - \c user: the current RBAC username (if any)
            - \c resource_path: the relative path without any query arguments and with the URL root stripped off (if the request was matched by the URL root, otherwise this will be the request path with any URI query arguments removed)
            - \c url_root: the root URL
            - \c file_root: the root directory for serving files
            - \c isregex: if the \a url_root string is a regular expression or not (this is always @ref Qore::False "False" when this class is used)
            - \c hdr: this is a copy of the \a hdr argument
            @param hdr incoming header hash; all keys will be converted to lower-case, additionally the following keys will be present:
            - \c method: the HTTP method received (ie \c "GET", \c "POST", etc)
            - \c path: the HTTP path given in the request, after processing by @ref Qore::decode_url()
            - \c http_version: the HTTP version number in the request (either \c "1.0" or \c "1.1")
            @param body message body, if any
            
            @return a hash with the following keys:
            - \c "code": the HTTP return code (see @ref HttpServer::HttpCodes)
            - \c "body": the message body to return in the response
            - \c "close": (optional) set this key to @ref Qore::True "True" if the connection should be unconditionally closed when the handler returns
            - \c "hdr": (optional) set this key to a hash of extra header information to be returned with the response

            @note
            - this method has the following additional keys in the \a cx hash: \c resource_path, \c url_root, and \c isregex
            - the default implementation simply returns @ref nothing all requests; reimplement this method in a subclass to provide the required functionality
        */
        private *hash handleRequestImpl(reference $cx, hash $hdr, *data $body) {
        }

        #! renders the given template with the given argument; if the template doesn't exist, it is created from the path argument and rendered
        private hash renderTemplateFromFile(string $tname, string $path, hash $ctx, int $code = 200, *hash $hdr) {
            {
                $.rwl.readLock();
                on_exit $.rwl.readUnlock();

                my *hash $h = $.tryRender($tname, $ctx, $code, $hdr);
                if ($h)
                    return $h;
            }

            {
                $.rwl.writeLock();
                on_exit $.rwl.writeUnlock();

                # we have to check again in the write lock
                my *hash $h = $.tryRender($tname, $ctx, $code, $hdr);
                if ($h)
                    return $h;

                my ReadOnlyFile $f($path);
                $.add($tname, $f.read(-1));
                return $.render($tname, $ctx, $code, $hdr);
            }
        }
    }
}
