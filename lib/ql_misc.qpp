/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  ql_misc.qpp

  Qore Programming Language

  Copyright 2003 - 2013 David Nichols

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <qore/Qore.h>
#include <qore/intern/ql_misc.h>
#include <qore/intern/QoreSignal.h>
#include <qore/intern/QoreNamespaceIntern.h>

#include <string.h>
#include <time.h>
#include <errno.h>

static const QoreFunction *get_builtin_func(const QoreStringNode *str, ExceptionSink *xsink) {
   const qore_ns_private* ns;
   const QoreFunction *f = qore_root_ns_private::runtimeFindFunction(*(getRootNS()), str->getBuffer(), ns);
   if (f)
      return f;

   xsink->raiseException("NO-FUNCTION", "cannot find any builtin function '%s()'", str->getBuffer());
   return 0;
}

static const char *tlist[] = { "OPTION", "ALGORITHM", "FUNCTION" };

// signal constants - if they are not defined define them here
#ifndef SIGABRT
#define SIGABRT 0
#endif
#ifndef SIGALRM
#define SIGALRM 0
#endif
#ifndef SIGBUS
#define SIGBUS 0
#endif
#ifndef SIGCANCEL
#define SIGCANCEL 0
#endif
#ifndef SIGCHLD
#define SIGCHLD 0
#endif
#ifndef SIGCLD
#define SIGCLD 0
#endif
#ifndef SIGCONT
#define SIGCONT 0
#endif
#ifndef SIGEMT
#define SIGEMT 0
#endif
#ifndef SIGFPE
#define SIGFPE 0
#endif
#ifndef SIGFREEZE
#define SIGFREEZE 0
#endif
#ifndef SIGHUP
#define SIGHUP 0
#endif
#ifndef SIGILL
#define SIGILL 0
#endif
#ifndef SIGINFO
#define SIGINFO 0
#endif
#ifndef SIGINT
#define SIGINT 0
#endif
#ifndef SIGIO
#define SIGIO 0
#endif
#ifndef SIGIOT
#define SIGIOT 0
#endif
#ifndef SIGJVM1
#define SIGJVM1 0
#endif
#ifndef SIGJVM2
#define SIGJVM2 0
#endif
#ifndef SIGKILL
#define SIGKILL 0
#endif
#ifndef SIGLOST
#define SIGLOST 0
#endif
#ifndef SIGLWP
#define SIGLWP 0
#endif
#ifndef SIGPIPE
#define SIGPIPE 0
#endif
#ifndef SIGPOLL
#define SIGPOLL 0
#endif
#ifndef SIGPROF
#define SIGPROF 0
#endif
#ifndef SIGPWR
#define SIGPWR 0
#endif
#ifndef SIGQUIT
#define SIGQUIT 0
#endif
#ifndef SIGSEGV
#define SIGSEGV 0
#endif
#ifndef SIGSTKFLT
#define SIGSTKFLT 0
#endif
#ifndef SIGSTOP
#define SIGSTOP 0
#endif
#ifndef SIGSYS
#define SIGSYS 0
#endif
#ifndef SIGTERM
#define SIGTERM 0
#endif
#ifndef SIGTHAW
#define SIGTHAW 0
#endif
#ifndef SIGTRAP
#define SIGTRAP 0
#endif
#ifndef SIGTSTP
#define SIGTSTP 0
#endif
#ifndef SIGTTIN
#define SIGTTIN 0
#endif
#ifndef SIGTTOU
#define SIGTTOU 0
#endif
#ifndef SIGURG
#define SIGURG 0
#endif
#ifndef SIGUSR1
#define SIGUSR1 0
#endif
#ifndef SIGUSR2
#define SIGUSR2 0
#endif
#ifndef SIGVTALRM
#define SIGVTALRM 0
#endif
#ifndef SIGWAITING
#define SIGWAITING 0
#endif
#ifndef SIGWINCH
#define SIGWINCH 0
#endif
#ifndef SIGXCPU
#define SIGXCPU 0
#endif
#ifndef SIGXFSZ
#define SIGXFSZ 0
#endif
#ifndef SIGXRES
#define SIGXRES 0
#endif

/** @defgroup signal_constants Signal Constants
    Signal constants - if any of the constants in this section are not defined on the host; the constant's value will be 0
*/
//@{
//! SIGABRT
const SIGABRT = SIGABRT;
//! SIGALRM
const SIGALRM = SIGALRM;
//! SIGBUS
const SIGBUS = SIGBUS;
//! SIGCANCEL
const SIGCANCEL = SIGCANCEL;
//! SIGCHLD
const SIGCHLD = SIGCHLD;
//! SIGCLD
const SIGCLD = SIGCLD;
//! SIGCONT
const SIGCONT = SIGCONT;
//! SIGEMT
const SIGEMT = SIGEMT;
//! SIGFPE
const SIGFPE = SIGFPE;
//! SIGFREEZE
const SIGFREEZE = SIGFREEZE;
//! SIGHUP
const SIGHUP = SIGHUP;
//! SIGILL
const SIGILL = SIGILL;
//! SIGINFO
const SIGINFO = SIGINFO;
//! SIGINT
const SIGINT = SIGINT;
//! SIGIO
const SIGIO = SIGIO;
//! SIGIOT
const SIGIOT = SIGIOT;
//! SIGJVM1
const SIGJVM1 = SIGJVM1;
//! SIGJVM2
const SIGJVM2 = SIGJVM2;
//! SIGKILL
const SIGKILL = SIGKILL;
//! SIGLOST
const SIGLOST = SIGLOST;
//! SIGLWP
const SIGLWP = SIGLWP;
//! SIGPIPE
const SIGPIPE = SIGPIPE;
//! SIGPOLL
const SIGPOLL = SIGPOLL;
//! SIGPROF
const SIGPROF = SIGPROF;
//! SIGPWR
const SIGPWR = SIGPWR;
//! SIGQUIT
const SIGQUIT = SIGQUIT;
//! SIGSEGV
const SIGSEGV = SIGSEGV;
//! SIGSTKFLT
const SIGSTKFLT = SIGSTKFLT;
//! SIGSTOP
const SIGSTOP = SIGSTOP;
//! SIGSYS
const SIGSYS = SIGSYS;
//! SIGTERM
const SIGTERM = SIGTERM;
//! SIGTHAW
const SIGTHAW = SIGTHAW;
//! SIGTRAP
const SIGTRAP = SIGTRAP;
//! SIGTSTP
const SIGTSTP = SIGTSTP;
//! SIGTTIN
const SIGTTIN = SIGTTIN;
//! SIGTTOU
const SIGTTOU = SIGTTOU;
//! SIGURG
const SIGURG = SIGURG;
//! SIGUSR1
const SIGUSR1 = SIGUSR1;
//! SIGUSR2
const SIGUSR2 = SIGUSR2;
//! SIGVTALRM
const SIGVTALRM = SIGVTALRM;
//! SIGWAITING
const SIGWAITING = SIGWAITING;
//! SIGWINCH
const SIGWINCH = SIGWINCH;
//! SIGXCPU
const SIGXCPU = SIGXCPU;
//! SIGXFSZ
const SIGXFSZ = SIGXFSZ;
//! SIGXRES
const SIGXRES = SIGXRES;

//! maps signal names to signal values
const NameToSignal = (
   "SIGABRT": SIGABRT,
   "SIGALRM": SIGALRM,
   "SIGBUS": SIGBUS,
   "SIGCANCEL": SIGCANCEL,
   "SIGCHLD": SIGCHLD,
   "SIGCLD": SIGCLD,
   "SIGCONT": SIGCONT,
   "SIGEMT": SIGEMT,
   "SIGFPE": SIGFPE,
   "SIGFREEZE": SIGFREEZE,
   "SIGHUP": SIGHUP,
   "SIGILL": SIGILL,
   "SIGINFO": SIGINFO,
   "SIGINT": SIGINT,
   "SIGIO": SIGIO,
   "SIGIOT": SIGIOT,
   "SIGJVM1": SIGJVM1,
   "SIGJVM2": SIGJVM2,
   "SIGKILL": SIGKILL,
   "SIGLOST": SIGLOST,
   "SIGLWP": SIGLWP,
   "SIGPIPE": SIGPIPE,
   "SIGPOLL": SIGPOLL,
   "SIGPROF": SIGPROF,
   "SIGPWR": SIGPWR,
   "SIGQUIT": SIGQUIT,
   "SIGSEGV": SIGSEGV,
   "SIGSTKFLT": SIGSTKFLT,
   "SIGSTOP": SIGSTOP,
   "SIGSYS": SIGSYS,
   "SIGTERM": SIGTERM,
   "SIGTHAW": SIGTHAW,
   "SIGTRAP": SIGTRAP,
   "SIGTSTP": SIGTSTP,
   "SIGTTIN": SIGTTIN,
   "SIGTTOU": SIGTTOU,
   "SIGURG": SIGURG,
   "SIGUSR1": SIGUSR1,
   "SIGUSR2": SIGUSR2,
   "SIGVTALRM": SIGVTALRM,
   "SIGWAITING": SIGWAITING,
   "SIGWINCH": SIGWINCH,
   "SIGXCPU": SIGXCPU,
   "SIGXFSZ": SIGXFSZ,
   "SIGXRES": SIGXRES,
   );

//! maps signal numbers (as a string key) to the symbolic name for the signal
const SignalToName = (
   SIGABRT: "SIGABRT",
   SIGALRM: "SIGALRM",
   SIGBUS: "SIGBUS",
   SIGCANCEL: "SIGCANCEL",
   SIGCHLD: "SIGCHLD",
   SIGCONT: "SIGCONT",
   SIGEMT: "SIGEMT",
   SIGFPE: "SIGFPE",
   SIGFREEZE: "SIGFREEZE",
   SIGHUP: "SIGHUP",
   SIGILL: "SIGILL",
   SIGINFO: "SIGINFO",
   SIGINT: "SIGINT",
   SIGIO: "SIGIO",
   SIGIOT: "SIGIOT",
   SIGJVM1: "SIGJVM1",
   SIGJVM2: "SIGJVM2",
   SIGKILL: "SIGKILL",
   SIGLOST: "SIGLOST",
   SIGLWP: "SIGLWP",
   SIGPIPE: "SIGPIPE",
   SIGPOLL: "SIGPOLL",
   SIGPROF: "SIGPROF",
   SIGPWR: "SIGPWR",
   SIGQUIT: "SIGQUIT",
   SIGSEGV: "SIGSEGV",
   SIGSTKSZ: "SIGSTKSZ",
   SIGSTOP: "SIGSTOP",
   SIGSYS: "SIGSYS",
   SIGTERM: "SIGTERM",
   SIGTHAW: "SIGTHAW",
   SIGTRAP: "SIGTRAP",
   SIGTSTP: "SIGTSTP",
   SIGTTIN: "SIGTTIN",
   SIGTTOU: "SIGTTOU",
   SIGURG: "SIGURG",
   SIGUSR1: "SIGUSR1",
   SIGUSR2: "SIGUSR2",
   SIGVTALRM: "SIGVTALRM",
   SIGWAITING: "SIGWAITING",
   SIGWINCH: "SIGWINCH",
   SIGXCPU: "SIGXCPU",
   SIGXFSZ: "SIGXFSZ",
   SIGXRES: "SIGXRES",
   );
//@}

/** @defgroup signal_handling_functions Signal Handing Functions
    Signal handing functions
*/
//@{
//! Sets or replaces a signal handler according to the signal number and closure or call reference (function or object method reference) passed
/** @par Platform Availability:
    @ref Qore::Option::HAVE_SIGNAL_HANDLING

    By the time this function returns, changes to the signal handling thread have already been effected.

    When a signal is raised and the signal handler code is called, the signal number is passed as an integer argument to the signal handling code.

    @param signal The signal number to process, see @ref signal_constants for possible values
    @param f The code to execute when the signal is caught; this should accept an integer argument giving the signal number

    @par Example:
    @code
set_signal_handler(SIGINT, \signal_handler());
    @endcode

    @see @ref signal_handling for more information
*/
nothing set_signal_handler(softint signal, code f) [dom=PROCESS] {
#ifdef HAVE_SIGNAL_HANDLING
   if (!signal || signal > QORE_SIGNAL_MAX) {
      xsink->raiseException("SET-SIGNAL-HANDLER-ERROR", "%d is not a valid signal", signal);
      return 0;
   }

   QSM.setHandler(signal, f, xsink);
#else
   xsink->raiseException("MISSING-FEATURE-ERROR", "this platform does not support signal handling, therefore the set_signal_handler() and remove_signal_handler() functions are not available in Qore; for maximum portability, use the constant Option::HAVE_SIGNAL_HANDLING to check if this function is implemented before calling");
#endif
   return 0;
}

//! Removes a signal handler and returns the signal handling state to the default
/** 
    @par Platform Availability:
    @ref Qore::Option::HAVE_SIGNAL_HANDLING

    By the time this function returns, changes to the signal handling thread have already been effected.

    @param signal The signal number to process, see @ref signal_constants for possible values

    @par Example:
    @code
remove_signal_handler(SIGINT);
    @endcode

    @see @ref signal_handling for more information
*/
nothing remove_signal_handler(softint signal) [dom=PROCESS] {
#ifdef HAVE_SIGNAL_HANDLING
   if (!signal || signal > QORE_SIGNAL_MAX) {
      xsink->raiseException("REMOVE-SIGNAL-HANDLER-ERROR", "%d is not a valid signal", signal);
      return 0;
   }
   QSM.removeHandler(signal, xsink);
#else
   xsink->raiseException("MISSING-FEATURE-ERROR", "this platform does not support signal handling, therefore the set_signal_handler() and remove_signal_handler() functions are not available in Qore; for maximum portability, use the constant Option::HAVE_SIGNAL_HANDLING to check if this function is implemented before calling");
#endif
   return 0;
}
//@}

/** @defgroup misc_functions Miscellaneous Functions
    Miscellaneous functions
 */
//@{
//! Calls a function and returns the return value, passing the remaining arguments after the function name to the function
/** 
    @param name The name of the function to call
    @param ... Any optional arguments to the function

    @return The value returned by the called function

    @par Example:
    @code
my any $result = call_function("func_name", $arg1, $arg2);
    @endcode

    @throw INVALID-FUNCTION-ACCESS Parse options do not allow access to the function
    @throw NO-FUNCTION The function does not exist

    @note The function called could also throw other exceptions
*/
any call_function(string name, ...) {
   ReferenceHolder<QoreListNode> vargs(xsink);
   // if there are arguments to pass, create argument list by copying current list
   if (num_args(args) > 1)
      vargs = args->copyListFrom(1);

   return getProgram()->callFunction(name->getBuffer(), *vargs, xsink);
}

//! Calls the given @ref call_reference "call reference" or @ref closure "closure" and returns the result, passing the remaining arguments to the @ref call_reference "call reference" or @ref closure "closure"
/** 
    @param f The @ref call_reference "call reference" or @ref closure "closure"
    @param ... Any optional arguments to the @ref call_reference "call reference" or @ref closure "closure"

    @par Example:
    @code
my any $result = call_function($call_ref, $arg1, $arg2);
    @endcode

    @note The @ref call_reference "call reference" or @ref closure "closure" called could also throw other exceptions
*/
any call_function(code f, ...) {
   ReferenceHolder<QoreListNode> vargs(xsink);
   // if there are arguments to pass, create argument list by copying current list
   if (num_args(args) > 1)
      vargs = args->copyListFrom(1);

   return f->exec(*vargs, xsink);
}

//! Calls a function and returns the return value, using the optional second argument as a list of arguments for the function
/** 
    @param name The name of the function to call
    @param vargs Optionally a single argument to the function or a list of arguments to the function

    @return The value returned by the called function

    @par Example:
    @code
my any $result = call_function_args("func_name", ($arg1, $arg2));
    @endcode

    @throw INVALID-FUNCTION-ACCESS Parse options do not allow access to the function
    @throw NO-FUNCTION The function does not exist

    @note The function called could also throw other exceptions
*/
any call_function_args(string name, *softlist vargs) {
   return getProgram()->callFunction(name->getBuffer(), vargs, xsink);
}

//! Calls the given @ref call_reference "call reference" or @ref closure "closure" and returns the result, using the optional second argument as a list of arguments to the @ref call_reference "call reference" or @ref closure "closure"
/** 
    @param f The @ref call_reference "call reference" or @ref closure "closure"
    @param vargs Optionally a single argument to the @ref call_reference "call reference" or @ref closure "closure" or a list of arguments to the @ref call_reference "call reference" or @ref closure "closure"

    @par Example:
    @code
my any $result = call_function_args($call_ref, ($arg1, $arg2));
    @endcode

    @note The @ref call_reference "call reference" or @ref closure "closure" called could also throw other exceptions
*/
any call_function_args(code f, *softlist vargs) {
   return f->exec(vargs, xsink);
}

//! Calls a function and returns the return value, passing the remaining arguments after the function name to the builtin function
/** 
    @param name The name of the builtin function to call
    @param ... Any optional arguments to the function

    @return The value returned by the called function

    @par Example:
    @code
my any $result = call_builtin_function("func_name", $arg1, $arg2);
    @endcode

    @throw INVALID-FUNCTION-ACCESS Parse options do not allow access to the function
    @throw NO-FUNCTION The function does not exist

    @note The function called could also throw other exceptions

    @since 0.8.4 this function no longer restricts its search to builtin functions as as of Qore 0.8.4 builtin and user functions are stored identically internally; there is only one function implementation which can contain both builtin and user variants
*/
any call_builtin_function(string name, ...) {
   const QoreFunction *f = get_builtin_func(name, xsink);
   if (!f)
      return 0;

   ReferenceHolder<QoreListNode> vargs(xsink);
   // if there are arguments to pass, create argument list by copying current list
   if (num_args(args) > 1)
      vargs = args->copyListFrom(1);

   return f->evalDynamic(*vargs, xsink);
}

//! Calls a function and returns the return value, using the optional second argument as a list of arguments for the function
/** 
    @param name The name of the builtin function to call
    @param vargs Optionally a single argument to the function or a list of arguments to the function

    @return The value returned by the called function

    @par Example:
    @code
my any $result = call_builtin_function_args("func_name", ($arg1, $arg2));
    @endcode

    @throw INVALID-FUNCTION-ACCESS Parse options do not allow access to the function
    @throw NO-FUNCTION The function does not exist

    @note The function called could also throw other exceptions

    @since 0.8.4 this function no longer restricts its search to builtin functions as as of Qore 0.8.4 builtin and user functions are stored identically internally; there is only one function implementation which can contain both builtin and user variants
*/
any call_builtin_function_args(string name, *softlist vargs) {
   const QoreFunction *f = get_builtin_func(name, xsink);
   if (!f)
      return 0;

   return f->evalDynamic(vargs, xsink);
}

//! A function performing the same role as the @ref exists "exists operator"
/** @param ... if only a single argument is passed, then this function returns @ref True if the single argument exists, @ref False if not; otherwise is multiple arguments are passed to the function, it always returns @ref True; this is to emulate the behavior of the @ref exists "exists operator"

    @return if only a single argument is passed, then this function returns @ref True if the single argument exists, @ref False if not; otherwise is multiple arguments are passed to the function, it always returns @ref True; this is to emulate the behavior of the @ref exists "exists operator"

    @par Example:
    @code
my bool $b = exists($val);
    @endcode
*/
bool exists(...) [flags=CONSTANT] {
   // to emulate the exists operator, we must return True if more than one argument is passed
   // as this will appear to be a list to the exists operator, which is different from NOTHING
   return (num_args(args) <= 1) ? !is_nothing(get_param(args, 0)) : true;
}

//! Returns @ref True if the function exists in the current program's function name space
/** @param name the name of the function to check

    @return @ref True if the function exists in the current program's function name space, @ref False if not

    @par Example:
    @code
my bool $b = existsFunction("func_name");
    @endcode
*/
bool existsFunction(string name) [flags=CONSTANT] {
   const char *str = name->getBuffer();
   
   return getProgram()->existsFunction(str);
}

//! Always returns @ref True
/** This function variant is included for backwards-compatibility

    @param c a @ref call_reference "call reference" or @ref closure "closure":

    @return always returns @ref True
*/
bool existsFunction(code[doc] c) [flags=NOOP] {
   return true;
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing existsFunction() [flags=RUNTIME_NOOP] {
}

//! Returns \c "builtin" (for a builtin function), \c "user" (for a user function), or @ref nothing (if the function cannot be found) according to the function name passed
/** 
    @param name The function name to check
    @return \c "builtin" (for a builtin function), \c "user" (for a user function), or @ref nothing (if the function cannot be found) according to the function name passed

    @par Example:
    @code
my *string $type = functionType("print");
    @endcode
*/
*string functionType(string name) {
   const qore_ns_private* ns;
   const QoreFunction *f = qore_root_ns_private::runtimeFindFunction(*(getRootNS()), name->getBuffer(), ns);
   if (!f)
      return 0;

   return new QoreStringNode(f->hasBuiltin() ? "builtin" : "user");
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing functionType() [flags=RUNTIME_NOOP] {
}

//! Returns a string with characters needing HTML escaping translated to HTML escape codes
/** @param str the argument to process

    @return the string passed as an argument with characters needing HTML escaping translated to HTML escape codes

    @par Example:
    @code
my string $str = html_encode("<hello>"); # returns "&lt;hello&gt;"
    @endcode
*/
string html_encode(string str) [flags=CONSTANT] {
   QoreStringNode *ns = new QoreStringNode(str->getEncoding());
   ns->concatAndHTMLEncode(str->getBuffer());
   return ns;
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing html_encode() [flags=RUNTIME_NOOP] {
}

//! Returns a string with any HTML escape codes translated to the original characters
/** @param str the argument to decode

    @return the string passed as an argument with any HTML escape codes translated to the original characters

    @par Example:
    @code
my string $str = html_decode("&lt;hello&gt;"); # returns "<hello>"
    @endcode
*/
string html_decode(string str) [flags=CONSTANT] {
   QoreStringNode *ns = new QoreStringNode(str->getEncoding());
   ns->concatAndHTMLDecode(str);
   return ns;
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing html_decode() [flags=RUNTIME_NOOP] {
}

//! Returns the name of the @ref default_encoding "default character encoding"
/** @return the name of the @ref default_encoding "default character encoding"

    @par Example:
    @code
my string $encoding = get_default_encoding();
    @endcode
*/
string get_default_encoding() {
   return new QoreStringNode(QCS_DEFAULT->getCode());
}

//! Adds the text passed to the current program's code, tagged with the given label
/** 
    @param code the string of %Qore source code to parse; the parsed code will be added to the current program
    @param label a label identifying the code or the code's source
    @param warning_mask An optional warning mask; see @ref warning_constants for values to combine by binary-or; if this arguments is 0 or not given then no warnings will be checked or issued and the return value will always be @ref nothing
    @param source An optional source file name for the code being parsed; this is useful if sections of a file are parsed
    @param offset An optional line offset for use with the \a source parameter; this gives the line offset in the file to the code being parsed
    @param format_label If this argument is @ref Qore::True "True", then the label is formatted as \c "<run-time-loaded: label>"; if @ref Qore::False "False", then it is passed as-is

    @par Example:
    @code
parse($code, $filename);
    @endcode

    @note This function could throw many parse exceptions which are not enumerated here; any parse errors will result in an appropriate exception.

    @see
    - Qore::Program::parse()
    - Qore::Program::parsePending()

    @since %Qore 0.8.7 the optional \a warning_mask, \a source, \a offset, and \a format_label arguments were added; also label formatting was added;
    these changes were made to align the functionality of this function with the @ref Qore::Program::parse() "Program::parse()"
    and @ref Qore::Program::parsePending() "Program::parsePending()" methods
*/
*hash parse(string code, string label, *softint warning_mask, *string source, *softint offset, softbool format_label = True) [dom=EMBEDDED_LOGIC,IN_MODULE] {
   QoreStringMaker nlabel(label->getEncoding(), format_label ? "<run-time-loaded: %s>" : "%s", label->getBuffer());

   if (warning_mask) {
      ExceptionSink wsink;
      getProgram()->parse(code, &nlabel, xsink, &wsink, warning_mask, source, offset);
      if (!wsink.isException())
         return 0;

      QoreException *e = wsink.catchException();
      return e->makeExceptionObjectAndDelete(xsink);
   }

   getProgram()->parse(code, &nlabel, xsink, 0, 0, source, offset);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing parse() [flags=RUNTIME_NOOP;dom=EMBEDDED_LOGIC,IN_MODULE] {
}

//! Returns the class name of the object passed
/** 
    @param obj the object to get the class name of
    @return the class name of the object passed

    @par Example:
    @code
my string $name = getClassName($obj);
    @endcode
*/
string getClassName(object obj) {
   return new QoreStringNode(obj->getClass()->getName());
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing getClassName() [flags=RUNTIME_NOOP] {
}

//! Parses a URL string and returns a hash of the components; throws an exception if the string cannot be parsed as a URL
/** @param url the URL to parse (ex: \c "https://user:pass@host:8080/path"); either a hostname or path is required at a minimum or a \c PARSE-URL-ERROR exception is raised
    @param keep_brackets if this argument is true then if the hostname or address is enclosed in square brackets, then the brackets will be included in the \c "host" key output as well; square brackets are used by some %Qore methods to denote IPv6 addresses; for example see @ref Qore::Socket::connect() "Socket::connect()"

    @return a hash of the components of the URL with the following keys (if data in the URL is present; note that at least either the \c "host" or the \c "path" keys will always be returned if no \c PARSE-URL-ERROR is raised):
    - \c protocol: the scheme in the URL (ex: \c "http")
    - \c path: any path given in the URL; the path will be prefixed by \c "/" if a hostname is found in the URL argument string, otherwise it will not if it was not given as such in the argument string
    - \c username: any username given in the URL
    - \c password: any password given in the URL
    - \c host: any hostname given in the URL; note that this key will be given if no other information can be found in the URL argument and the URL argument string has no \c "/" characters; depending on the usage context for this function, this may actually be a filename
    - \c port: any port number given in the URL

    @par Example:
    @code
my hash $hash = parse_url($url_string);
    @endcode

    @throw PARSE-URL-ERROR The URL string given could not be parsed

    @see parseURL() for a version of this function that does not throw exceptions if the URL cannot be parsed
*/
hash parse_url(string url, bool keep_brackets = False) {
   QoreURL qurl(url, keep_brackets);
   if (!qurl.isValid()) {
      xsink->raiseException("PARSE-URL-ERROR", "URL '%s' cannot be parsed", url->getBuffer());
      return 0;
   }

   return qurl.getHash();
}

//! Parses a URL string and returns a hash of the components; if the URL cannot be parsed then @ref nothing is returned
/** @param url the URL to parse (ex: \c "https://user:pass@host:8080/path"); either a hostname or path is required at a minimum or the function will return @ref nothing
    @param keep_brackets if this argument is true then if the hostname or address is enclosed in square brackets, then the brackets will be included in the \c "host" key output as well; square brackets are used by some %Qore methods to denote IPv6 addresses; for example see @ref Qore::Socket::connect() "Socket::connect()"

    @return a hash of the components of the URL with the following keys (if data in the URL is present; note that at least either the \c "host" or the \c "path" keys will always be returned if a hash is returned):
    - \c protocol: the scheme in the URL (ex: \c "http")
    - \c path: any path given in the URL; the path will be prefixed by \c "/" if a hostname is found in the URL argument string, otherwise it will not if it was not given as such in the argument string
    - \c username: any username given in the URL
    - \c password: any password given in the URL
    - \c host: any hostname given in the URL; note that this key will be given if no other information can be found in the URL argument and the URL argument string has no \c "/" characters; depending on the usage context for this function, this may actually be a filename
    - \c port: any port number given in the URL

    @par Example:
    @code
my *hash $hash = parseURL($url_string);
    @endcode

    @see parse_url() for a version of this function that throws exceptions if the URL cannot be parsed
*/
*hash parseURL(string url, bool keep_brackets = False) {
   QoreURL qurl(url, keep_brackets);
   return qurl.isValid() ? qurl.getHash() : 0;
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing parseURL() [flags=RUNTIME_NOOP] {
}

//! Executes a process and returns a string of the output (stdout only)
/** 
    @param cmd The shell command to executed as a subprocess
    @param rc an optional reference to an integer to return the return code of the process
    
    @return The stdout of the shell command that was executed

    @par Example:
    @code
my int $rc;
my string $files = $files = backquote("ls", \$rc);
    @endcode

    @throw BACKQUOTE-ERROR An error occurred with the fork() or opening the stdout pipe

    @see
    - system()
    - @ref backquote_operator "the backquote operator"

    @since %Qore 0.8.8 the \a rc argument was added
*/
string backquote(string cmd, *reference rc) [dom=EXTERNAL_PROCESS] {
   int prc;
   SimpleRefHolder<QoreStringNode> str(backquoteEval(cmd->getBuffer(), prc, xsink));
   if (!*xsink && rc) {
      QoreTypeSafeReferenceHelper rh(rc, xsink);
      if (!rh)
         return 0;

      rh.assignBigInt(prc);
   }
   return str.release();
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing backquote() [flags=RUNTIME_NOOP;dom=EXTERNAL_PROCESS] {
}

//! Returns a base64-encoded representation of a string
/** Implementation based on <a href="http://www.ietf.org/rfc/rfc1421.txt">RFC-1421</a> and <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC-2045</a>

    @param str the string to encode
    @param maxlinelen the maximum length of a line in the resulting output string in bytes; if this value is > 0 then output lines will be separated by CRLF characters

    @return the base64-encoded string of the data passed

    @par Example:
    @code
my string $base64 = makeBase64String($data, 64);
    @endcode

    @since the maxlinelen parameter was added in %Qore 0.8.4

    @see
    - <string>::toBase64()
    - makeHexString(string)
*/
string makeBase64String(string str, softint maxlinelen = -1) [flags=CONSTANT] {
   QoreStringNode *rv = new QoreStringNode;
   rv->concatBase64(str, maxlinelen);
   return rv;
}

//! Returns a base64-encoded representation of a binary object
/** Implementation based on <a href="http://www.ietf.org/rfc/rfc1421.txt">RFC-1421</a> and <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC-2045</a>

    @param bin the data to encode
    @param maxlinelen the maximum length of a line in the resulting output string in bytes; if this value is > 0 then output lines will be separated by CRLF characters

    @return the base64-encoded string of the data passed

    @par Example:
    @code
my string $base64 = makeBase64String($data, 64);
    @endcode

    @since the maxlinelen parameter was added in %Qore 0.8.4

    @see
    - <binary>::toBase64()
    - makeHexString(binary)
*/
string makeBase64String(binary bin, softint maxlinelen = -1) [flags=CONSTANT] {
   return new QoreStringNode(bin, maxlinelen);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing makeBase64String() [flags=RUNTIME_NOOP] {
}

//! Parses a base64 encoded string and returns a binary object of the decoded data
/** Implementation based on <a href="http://www.ietf.org/rfc/rfc1421.txt">RFC-1421</a> and <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC-2045</a>

    @param str the base64-encoded input data to decode

    @return a binary object of the decoded data

    @par Example:
    @code
my binary $bin = parseBase64String($base64_string);
    @endcode

    @throw BASE64-PARSE-ERROR A syntax error occurred parsing the base64 string (invalid character, etc)

    @see parseHexString(), parseBase64StringToString()
*/
binary parseBase64String(string str) {
   return str->parseBase64(xsink);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing parseBase64String() [flags=RUNTIME_NOOP] {
}

//! Parses a base64 encoded string and returns a string of the decoded data
/** Implementation based on <a href="http://www.ietf.org/rfc/rfc1421.txt">RFC-1421</a> and <a href="http://www.ietf.org/rfc/rfc2045.txt">RFC-2045</a>

    @param str the base64-encoded input data to decode
    @param encoding the character encoding tag for the string return value; if not present, the @ref default_encoding "default character encoding" is assumed.

    @return a string of the decoded data tagged with the given encoding

    @par Example:
    @code
my string $str = parseBase64String($base64_string);
    @endcode

    @throw BASE64-PARSE-ERROR A syntax error occurred parsing the base64 string (invalid character, etc)

    @since the encoding parameter was added in %Qore 0.8.4

    @see parseBase64String()
*/
string parseBase64StringToString(string str, *string encoding) {
   const QoreEncoding *qe = encoding ? QEM.findCreate(encoding) : QCS_DEFAULT;
   return str->parseBase64ToString(qe, xsink);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing parseBase64StringToString() [flags=RUNTIME_NOOP] {
}

//! Returns a list of hashes describing the currently-loaded %Qore modules
/** @return a list of hashes describing the currently-loaded %Qore modules; each element in the list is a hash with the following keys:
    - \c filename: the path to the module
    - \c name: the name of the module
    - \c desc: the description of the module
    - \c version: the version of the module
    - \c author: the author of the module
    - \c api_major: the major number of the %Qore module API version the module support
    - \c api_minor: the minor number of the %Qore module API version the module support
    - \c url: the module's URL

    @par Example:
    @code
my list $list = getModuleList();
    @endcode

    @see getModuleHash()
*/
list getModuleList() [flags=CONSTANT] {
   return MM.getModuleList();
}

//! Returns a hash of hashes describing the currently-loaded %Qore modules; the top-level hash keys are the module names
/** @return a hash of hashes describing the currently-loaded %Qore modules; the top-level hash keys are the module names; the values are hashes with the following keys:
    - \c filename: the path to the module
    - \c name: the name of the module
    - \c desc: the description of the module
    - \c version: the version of the module
    - \c author: the author of the module
    - \c api_major: the major number of the %Qore module API version the module support
    - \c api_minor: the minor number of the %Qore module API version the module support
    - \c url: the module's URL

    @par Example:
    @code
my hash $mh = getModuleHash();
    @endcode

    @since %Qore 0.8.1
*/
hash getModuleHash() [flags=CONSTANT] {
   return MM.getModuleHash();
}

//! Returns a list of strings of the builtin and module-supplied features of Qore
/** @return a list of strings of the builtin and module-supplied features of Qore

    @par Example:
    @code
my list $list = getFeatureList();
    @endcode
*/
list getFeatureList() [flags=CONSTANT] {
   return getProgram()->getFeatureList();
}

//! Returns a list of all the values in the hash argument passed
/** @param h a hash to get all the values of

    @return a list of all the values in the hash argument passed

    @par Example:
    @code
my list $vl = hash_values($vl);
    @endcode

    @note equivalent to <hash>::values()

    @see <hash>::keys()
*/
list hash_values(hash h) [flags=CONSTANT] {
   QoreListNode *l = new QoreListNode;

   ConstHashIterator hi(h);
   while (hi.next())
      l->push(hi.getReferencedValue());

   return l;
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing hash_values() [flags=RUNTIME_NOOP] {
}

//! Returns @ref True if the given key exists in the hash (does not necessarily have to have a value assigned); exceptions are only raised if string encoding errors are encountered
/** 
    @param h the hash to check
    @param key the key name to check; this value will be converted to the @ref default_encoding "default character encoding" to check the hash

    @return @ref True if the given key exists in the hash (does not necessarily have to have a value assigned), @ref False if the key is not present at all

    @par Example:
    @code
my bool $b = has_key($hash, "key");
    @endcode

    @throw ENCODING-CONVERSION-ERROR this error is thrown if the given key cannot be converted to the @ref default_encoding "default character encoding"
*/
bool has_key(hash h, string key) {
   bool exists;
   h->getKeyValueExistence(key, exists, xsink);
   return exists;
}

//! Returns @ref True if the given key exists in the object (does not necessarily have to have a value assigned); exceptions are only raised if string encoding errors are encountered or in case of object access errors.
/** 
    @par Example:
    @code
my bool $b = has_key($obj, "key");
    @endcode

    @throw ENCODING-CONVERSION-ERROR this error is thrown if the given key cannot be converted to the @ref default_encoding "default character encoding"

    @note object access exceptions could also be raised
*/
bool has_key(object obj, string key) {
   AutoVLock vl(xsink);
   AbstractQoreNode **ptr = obj->getExistingValuePtr(key, &vl, xsink);
   return (bool)ptr;
}

//! Returns the byte value at the given byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** 
    @param str the string data to process
    @param offset the byte offset of the data to retrieve (the first value is at offset 0)

    @return the byte value at the given byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $byte = get_byte($str, 2); # returns the third byte of the string
    @endcode

    @note that for strings this function is not equivalent to the @ref list_element_operator "[] operator" for multi-byte character encodings, as this function works purely on bytes and the @ref list_element_operator "[] operator" operates on characters\n\n
    Furthermore this function is identical to getByte(), except this function has no @ref RUNTIME_NOOP variant
*/
*int get_byte(string str, softint offset = 0) [flags=CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= size || offset < 0)
      return 0;

   return new QoreBigIntNode(ptr[offset]);  
}

//! Returns the byte value at the given byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** 
    @param b the data to process
    @param offset the byte offset of the data to retrieve (the first value is at offset 0)

    @return the byte value at the given byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $byte = get_byte($bin, 2); # returns the third byte of the binary object
    @endcode

    @note this function is equivalent to the more efficient @ref list_element_operator "[] operator" when used with a binary argument\n\n
    Furthermore this function is identical to getByte(), except this function has no @ref RUNTIME_NOOP variant
*/
*int get_byte(binary b, softint offset = 0) [flags=CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= size || offset < 0)
      return 0;

   return new QoreBigIntNode(ptr[offset]);  
}

//! Returns the byte value at the given byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** 
    @param str the string data to process
    @param offset the byte offset of the data to retrieve (the first value is at offset 0)

    @return the byte value at the given byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $byte = get_byte($str, 2); # returns the third byte of the string
    @endcode

    @note that for strings this function is not equivalent to the @ref list_element_operator "[] operator" for multi-byte character encodings, as this function works purely on bytes and the @ref list_element_operator "[] operator" operates on characters\n\n
    Furthermore this function is identical to get_byte(), except this function has a @ref RUNTIME_NOOP variant

    @since %Qore 0.8.4 marked as deprecated; use the get_byte() function instead
*/
*int getByte(string str, softint offset = 0) [flags=CONSTANT,DEPRECATED] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= size || offset < 0)
      return 0;

   return new QoreBigIntNode(ptr[offset]);  
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing getByte() [flags=RUNTIME_NOOP,DEPRECATED] {
}

//! Returns the byte value at the given byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** 
    @param b the data to process
    @param offset the byte offset of the data to retrieve (the first value is at offset 0)

    @return the byte value at the given byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $byte = get_byte($bin, 2); # returns the third byte of the binary object
    @endcode

    @note this function is equivalent to the more efficient @ref list_element_operator "[] operator" when used with a binary argument\n\n
    Furthermore this function is identical to get_byte(), except this function has a @ref RUNTIME_NOOP variant

    @since %Qore 0.8.4 marked as deprecated; use the get_byte() function instead
*/
*int getByte(binary b, softint offset = 0) [flags=CONSTANT,DEPRECATED] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= size || offset < 0)
      return 0;

   return new QoreBigIntNode(ptr[offset]);  
}

//! Returns the 16-bit integer value at the given 2-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** This function assumes <a href="http://en.wikipedia.org/wiki/Most_significant_bit">MSB byte order</a> when retrieving the value from the data

    @param str the string data to process
    @param offset the 2-byte offset of the data to retrieve (the first value is at offset 0)

    @return the 16-bit integer value at the given 2-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $val = get_word_16($str, 2); # returns the third 2-byte (16-bit) value in the string
    @endcode

    @see get_word_16_lsb()
*/
*int get_word_16(string str, softint offset = 0) [flags=CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 1) || offset < 0)
      return 0;

   short val = ntohs(*((unsigned short *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! Returns the 16-bit integer value at the given 2-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** This function assumes <a href="http://en.wikipedia.org/wiki/Most_significant_bit">MSB byte order</a> when retrieving the value from the data

    @param b the data to process
    @param offset the 2-byte offset of the data to retrieve (the first value is at offset 0)

    @return the 16-bit integer value at the given 2-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $val = get_word_16($bin, 2); # returns the third 2-byte (16-bit) value in the binary object
    @endcode

    @see get_word_16_lsb()
*/
*int get_word_16(binary b, softint offset = 0) [flags=CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 1) || offset < 0)
      return 0;

   short val = ntohs(*((unsigned short *)&ptr[offset]));

   return new QoreBigIntNode(val);
}

//! Returns the 32-bit integer value at the given 4-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** This function assumes <a href="http://en.wikipedia.org/wiki/Most_significant_bit">MSB byte order</a> when retrieving the value from the data

    @param str the string data to process
    @param offset the 4-byte offset of the data to retrieve (the first value is at offset 0)

    @return the 32-bit integer value at the given 4-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $val = get_word_32($str, 4); # returns the third 4-byte (32-bit) value in the string
    @endcode

    @note This function is identical to getWord32(), except this function has no @ref RUNTIME_NOOP variant

    @see get_word_32_lsb()
*/
*int get_word_32(string str, softint offset = 0) [flags=CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = ntohl(*((unsigned int *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! Returns the 32-bit integer value at the given 4-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** This function assumes <a href="http://en.wikipedia.org/wiki/Most_significant_bit">MSB byte order</a> when retrieving the value from the data

    @param b the data to process
    @param offset the 4-byte offset of the data to retrieve (the first value is at offset 0)

    @return the 32-bit integer value at the given 4-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $val = get_word_32($bin, 2); # returns the third 4-byte (32-bit) value in the binary object
    @endcode

    @note This function is identical to getWord32(), except this function has no @ref RUNTIME_NOOP variant

    @see get_word_32_lsb()
*/
*int get_word_32(binary b, softint offset = 0) [flags=CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = ntohl(*((unsigned int *)&ptr[offset]));

   return new QoreBigIntNode(val);
}

//! Returns the 32-bit integer value at the given 4-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** This function assumes <a href="http://en.wikipedia.org/wiki/Most_significant_bit">MSB byte order</a> when retrieving the value from the data

    @param str the string data to process
    @param offset the 4-byte offset of the data to retrieve (the first value is at offset 0)

    @return the 32-bit integer value at the given 4-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $val = getWord32($str, 4); # returns the third 4-byte (32-bit) value in the string
    @endcode

    @note This function is identical to get_word_32(), except this function has a @ref RUNTIME_NOOP variant

    @since %Qore 0.8.4 marked as deprecated; use the get_word_32() function instead
*/
*int getWord32(string str, softint offset = 0) [flags=CONSTANT,DEPRECATED] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = ntohl(*((unsigned int *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! Returns the 32-bit integer value at the given 4-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** This function assumes <a href="http://en.wikipedia.org/wiki/Most_significant_bit">MSB byte order</a> when retrieving the value from the data

    @param b the data to process
    @param offset the 4-byte offset of the data to retrieve (the first value is at offset 0)

    @return the 32-bit integer value at the given 4-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $val = getWord32($bin, 2); # returns the third 4-byte (32-bit) value in the binary object
    @endcode

    @note This function is identical to get_word_32(), except this function has a @ref RUNTIME_NOOP variant

    @since %Qore 0.8.4 marked as deprecated; use the get_word_32() function instead
*/
*int getWord32(binary b, softint offset = 0) [flags=CONSTANT,DEPRECATED] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = ntohl(*((unsigned int *)&ptr[offset]));

   return new QoreBigIntNode(val);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing getWord32() [flags=RUNTIME_NOOP] {
}

//! Returns the 64-bit integer value at the given 8-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** This function assumes <a href="http://en.wikipedia.org/wiki/Most_significant_bit">MSB byte order</a> when retrieving the value from the data

    @param str the string data to process
    @param offset the 8-byte offset of the data to retrieve (the first value is at offset 0)

    @return the 64-bit integer value at the given 8-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $val = get_word_64($str, 4); # returns the third 8-byte (64-bit) value in the string
    @endcode

    @see get_word_64_lsb()
*/
*int get_word_64(string str, softint offset = 0) [flags=CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 7) || offset < 0)
      return 0;

   int64 val = MSBi8(*((int64 *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! Returns the 64-bit integer value at the given 8-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** This function assumes <a href="http://en.wikipedia.org/wiki/Most_significant_bit">MSB byte order</a> when retrieving the value from the data

    @param b the data to process
    @param offset the 8-byte offset of the data to retrieve (the first value is at offset 0)

    @return the 64-bit integer value at the given 8-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $val = get_word_64($bin, 2); # returns the third 8-byte (64-bit) value in the binary object
    @endcode

    @see get_word_64_lsb()
*/
*int get_word_64(binary b, softint offset = 0) [flags=CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 7) || offset < 0)
      return 0;

   int64 val = MSBi8(*((int64 *)&ptr[offset]));

   return new QoreBigIntNode(val);
}

//! Returns the 16-bit integer value at the given 2-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** This function assumes <a href="http://en.wikipedia.org/wiki/Least_significant_bit">LSB byte order</a> when retrieving the value from the data

    @param str the string data to process
    @param offset the 2-byte offset of the data to retrieve (the first value is at offset 0)

    @return the 16-bit integer value at the given 2-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $val = get_word_16_lsb($str, 2); # returns the third 2-byte (16-bit) value in the string
    @endcode

    @see get_word_16()
*/
*int get_word_16_lsb(string str, softint offset = 0) [flags=CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 1) || offset < 0)
      return 0;

   short val = LSBi2(*((unsigned short *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! Returns the 16-bit integer value at the given 2-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** This function assumes <a href="http://en.wikipedia.org/wiki/Least_significant_bit">LSB byte order</a> when retrieving the value from the data

    @param b the data to process
    @param offset the 2-byte offset of the data to retrieve (the first value is at offset 0)

    @return the 16-bit integer value at the given 2-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $val = get_word_16_lsb($bin, 2); # returns the third 2-byte (16-bit) value in the binary object
    @endcode

    @see get_word_16()
*/
*int get_word_16_lsb(binary b, softint offset = 0) [flags=CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 1) || offset < 0)
      return 0;

   short val = LSBi2(*((unsigned short *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! Returns the 32-bit integer value at the given 4-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** This function assumes <a href="http://en.wikipedia.org/wiki/Least_significant_bit">LSB byte order</a> when retrieving the value from the data

    @param str the string data to process
    @param offset the 4-byte offset of the data to retrieve (the first value is at offset 0)

    @return the 32-bit integer value at the given 4-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $val = get_word_32_lsb($str, 4); # returns the third 4-byte (32-bit) value in the string
    @endcode

    @note This function is identical to getWord32(), except this function has no @ref RUNTIME_NOOP variant

    @see get_word_32()
*/
*int get_word_32_lsb(string str, softint offset = 0) [flags=CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = LSBi4(*((unsigned int *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! Returns the 32-bit integer value at the given 4-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** This function assumes <a href="http://en.wikipedia.org/wiki/Least_significant_bit">LSB byte order</a> when retrieving the value from the data

    @param b the data to process
    @param offset the 4-byte offset of the data to retrieve (the first value is at offset 0)

    @return the 32-bit integer value at the given 4-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $val = get_word_32_lsb($bin, 2); # returns the third 4-byte (32-bit) value in the binary object
    @endcode

    @see get_word_32()
*/
*int get_word_32_lsb(binary b, softint offset = 0) [flags=CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 3) || offset < 0)
      return 0;

   int64 val = LSBi4(*((unsigned int *)&ptr[offset]));

   return new QoreBigIntNode(val);
}

//! Returns the 64-bit integer value at the given 8-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** This function assumes <a href="http://en.wikipedia.org/wiki/Least_significant_bit">LSB byte order</a> when retrieving the value from the data

    @param str the string data to process
    @param offset the 8-byte offset of the data to retrieve (the first value is at offset 0)

    @return the 64-bit integer value at the given 8-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $val = get_word_64_lsb($str, 4); # returns the third 8-byte (64-bit) value in the string
    @endcode

    @see get_word_64()
*/
*int get_word_64_lsb(string str, softint offset = 0) [flags=CONSTANT] {
   unsigned char *ptr = (unsigned char *)str->getBuffer();
   int size = str->strlen();

   if (offset >= (size - 7) || offset < 0)
      return 0;

   int64 val = LSBi8(*((int64 *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! Returns the 64-bit integer value at the given 8-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data
/** This function assumes <a href="http://en.wikipedia.org/wiki/Least_significant_bit">LSB byte order</a> when retrieving the value from the data

    @param b the data to process
    @param offset the 8-byte offset of the data to retrieve (the first value is at offset 0)

    @return the 64-bit integer value at the given 8-byte offset (the first value is at offset 0) or @ref nothing if the offset is not legal for the given data

    @par Example:
    @code
my *int $val = get_word_64_lsb($bin, 2); # returns the third 8-byte (64-bit) value in the binary object
    @endcode

    @see get_word_64()
*/
*int get_word_64_lsb(binary b, softint offset = 0) [flags=CONSTANT] {
   unsigned char *ptr = (unsigned char *)b->getPtr();
   int size = b->size();

   if (offset >= (size - 7) || offset < 0)
      return 0;

   int64 val = LSBi8(*((int64 *)&ptr[offset]));
   return new QoreBigIntNode(val);
}

//! This function always returns an empty string \c ""
/** This function variant is included for backwards-compatibility

    @param str no action is taken on the argument

    @return always returns an empty string \c ""
*/
string splice(string[doc] str) [flags=NOOP] {
   return new QoreStringNode;
}

//! Returns a string based on the argument string but with characters removed from a certain character index
/** An exception can only be thrown here if an invalid multi-byte encoding is found

    @param str the string to process
    @param start the character index (where the first character is 0) to start removing characters; if this value is negative, it gives the offset from the end of the string

    @return the processed string

    @par Example:
    @code
my string $str = splice($str2, 5);
    @endcode

    @see the @ref splice "splice operator"
*/
string splice(string str, softint start) {
   QoreStringNodeHolder pstr(str->copy());
   pstr->splice(start, xsink);
   return *xsink ? 0 : pstr.release();
}

//! Returns a string based on the argument string but optionally with characters removed and/or added from a certain character index
/** An exception can only be thrown here if an invalid multi-byte encoding is found

    @param str the string to process
    @param start the character index (where the first character is 0) to start removing (and/or adding) characters; if this value is negative, it gives the offset from the end of the string
    @param len the number of characters to remove; if this argument is 0 then no characters are removed; if this value is negative, then it gives an offset from the end of the string (ie -2 means remove all characters up to but not including the two last characters)
    @param nstr the optional string for inserting new characters

    @return the processed string with characters removed and/or added according to the arguments

    @par Example:
    @code
my string $str = splice($str2, 5, 7, "hello");
    @endcode

    @see the @ref splice "splice operator"
*/
string splice(string str, softint start, softint len, *string nstr) {
   QoreStringNodeHolder pstr(str->copy());
   pstr->splice(start, len, nstr, xsink);
   return *xsink ? 0 : pstr.release();
}

//! Returns a list based on the argument list but with elements removed from the given index to the end of the list
/** Exceptions can only be thrown here if objects are removed from the list and this causes them to go out of scope and an exception is thrown in one of the destructors

    @param l the list to process
    @param start the starting element (where the first element is 0) to start removing elements; if this value is negative, it gives the offset from the end of the list

    @par Example:
    @code
my list $l = splice($l2, 5);
    @endcode

    @see the @ref splice "splice operator"
*/
list splice(list l, softint start) {
   ReferenceHolder<QoreListNode> lst(l->copy(), xsink);
   lst->splice(start, xsink);
   return *xsink ? 0 : lst.release();
}

//! Returns a list based on the argument list but optionally with elements removed and/or added from a certain index
/** Exceptions can only be thrown here if objects are removed from the list and this causes them to go out of scope and an exception is thrown in one of the destructors

    @param l the list to process
    @param start the starting element (where the first element is 0) to start removing (and/or adding) elements; if this value is negative, it gives the offset from the end of the list
    @param len the number of list elements to remove; if this argument is 0 then no elements are removed; if this value is negative, then it gives an offset from the end of the list (ie -2 means remove all elements up to but not including the two last elements)
    @param nlist the optional list for inserting new elements

    @return the processed list with elements removed and/or added according to the arguments

    @par Example:
    @code
my list $l = splice($l2, 5, 7, "hello");
    @endcode

    @see the @ref splice "splice operator"
*/
list splice(list l, softint start, softint len, *softlist nlist) {
   ReferenceHolder<QoreListNode> lst(l->copy(), xsink);
   lst->splice(start, len, nlist, xsink);
   return *xsink ? 0 : lst.release();
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing splice() [flags=RUNTIME_NOOP] {
}

//! Returns a hex-encoded representation of a string
/** @param str the string to encode

    @return a string of hex digits repsenting the bytes of the argument passed

    @par Example:
    @code
my string $str = makeHexString($str2);
    @endcode

    @see
    - <string>::toHex()
    - makeBase64String(string)
    - parseHexString()
*/
string makeHexString(string str) [flags=CONSTANT] {
   QoreStringNode *rv = new QoreStringNode;
   rv->concatHex(str);
   return rv;
}

//! Returns a hex-encoded representation of a binary object
/** @param bin the binary object to encode

    @return a string of hex digits repsenting the bytes of the argument passed

    @par Example:
    @code
my string $str = makeHexString($bin);
    @endcode

    @see
    - <binary>::toHex()
    - makeBase64String(binary)
    - parseHexString()
*/
string makeHexString(binary bin) {
   QoreStringNode *str = new QoreStringNode;
   str->concatHex(bin);
   return str;
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing makeHexString() [flags=RUNTIME_NOOP] {
}

//! Parses a hex-encoded string and returns the binary object
/** @param hexstr a string of an even-number of only hexadecimal digits

    @return a binary object of the decoded data

    @par Example:
    @code
my binary $bin = parseHexString($hex_string);
    @endcode

    @throw PARSE-HEX-ERROR A syntax error occurred parsing the hex string (odd number of digits, invalid hex character, etc)

    @see parseBase64String()
    @see makeHexString();
*/
binary parseHexString(string hexstr) {
   return hexstr->parseHex(xsink);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing parseHexString() [flags=RUNTIME_NOOP] {
}

//! Returns an integer for a hexadecimal string value; throws an exception if non-hex digits are found
/** @param str a string of hexadecimal digits (like \c "6d4f84e0"; with or without leading \c "x" or \c "0x")

    @return the base-10 integer corresponding to the argument

    @par Example:
    @code
my int $i = hextoint("ab3d4e0f12");
    @endcode

    @throw PARSE-HEX-ERROR invalid hex digit found
*/
int hextoint(string str) {
   if (!str->strlen())
      return 0;

   int64 rc = 0;
   int64 pow = 0;
   const char *buf = str->getBuffer();
   qore_size_t len = str->size();
   if (*buf == '0' && *(buf + 1) == 'x') {
      buf += 2;
      len -= 2;
   }
   else if (*buf == 'x') {
      buf++;
      --len;
   }
   for (const char *p = buf + len - 1; p >= buf; p--) {
      int n = get_nibble(*p, xsink);
      if (xsink->isException())
	 return 0;
      if (!pow) {
	 rc = n;
	 pow = 16;
      }
      else {
	 rc += n * pow;
	 pow *= 16;
      }
   }
   return rc;
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing hextoint() [flags=RUNTIME_NOOP] {
}

//! parses a string representing a number in a configurable base and returns the integer
/** @param num a string representing a number
    @param base the base of the number
    
    @return the integer represented by the string and the base

    @par Example:
    @code
my int $i = strtoint("41", 8);
    @endcode
    
    @throw STRTOINT-ERROR cannot parse string; unsupported base, etc
*/
int strtoint(string num, softint base = 10) {
   errno = 0;
   int64 rv = strtoll(num->getBuffer(), 0, base);
   if (errno == EINVAL || errno == ERANGE)
      xsink->raiseException("STRTOINT-ERROR", "could not parse '%s' to an integer", num->getBuffer());
   return rv;
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing strtoint() [flags=RUNTIME_NOOP] {
}

//! Loads in a %Qore module at run-time
/** If a feature with the same name already exists, then this feature's code is imported into the current Program object if necessary and no further action is taken.

    Note that modules providing objects resolved at parse time (classes, constants, functions, etc) must be loaded with the @ref requires "%requires directive" instead, unless all references to the objects provided by the module will be made in code embedded in child Program objects.

    @param name either a feature name (a module will be searched with this feature name) or a path to a module to load

    @par Example:
    @code
load_module("mysql");
    @endcode

    @throw LOAD-MODULE-ERROR module cannot be loaded: API incompatibility, module defines symbols already defined in the target object, etc

    @see getModuleHash(), getFeatureList()

    @since %Qore 0.8.7 this function can also be used in user module code
*/
nothing load_module(string name) [dom=MODULES] {
   MM.runTimeLoadModule(name->getBuffer(), xsink);
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing load_module() [flags=RUNTIME_NOOP;dom=MODULES] {
}

//! Decodes percent numeric codes in a URL string and returns the decoded string
/** @param url a URL string with percent-encodings to decode

    @return the URL string with all percent-encodings decoded

    @par Example:
    @code
my string $decoded_url = decode_url($encoded_url);
    @endcode

    @see encode_url()
*/
string decode_url(string url) [flags=CONSTANT] {
   QoreStringNode *str = new QoreStringNode(url->getEncoding());
   str->concatDecodeUrl(url->getBuffer());
   return str;
}

//! This function variant does nothing at all; it is only included for backwards-compatibility with qore prior to version 0.8.0 for functions that would ignore type errors in arguments
/** 
 */
nothing decode_url() [flags=RUNTIME_NOOP] {
}

//! Encodes URLs by substituting \c '%' characters with \c '%25', spaces (\c ' ') with \c '%20', and non-ascii characters by percent-encoded representations
/** @param url a URL string to encode

    @return the URL string with encoded \c '%', spaces (\c ' '), and non-ascii characters

    @par Example:
    @code
my string $encoded_url = encode_url($url);
    @endcode

    @see decode_url()

    @since %Qore 0.8.9
*/
string encode_url(string url) [flags=CONSTANT] {
   QoreStringNodeHolder str(new QoreStringNode(url->getEncoding()));
   str->concatEncodeUrl(url, xsink);
   return *xsink ? 0 : str.release();
}

//! Returns the path (directory and filename) of the current script or @ref nothing if unknown (i.e. no parent script, script read from stdin, etc)
/** @return the path (directory and filename) of the current script or @ref nothing if unknown (i.e. no parent script, script read from stdin, etc)

    @par Example:
    @code
my *string $str = get_script_path();
    @endcode
*/
*string get_script_path() {
   return getProgram()->getScriptPath();
}

//! Returns the name of the directory from which the current script was executed or @ref nothing if unknown (i.e. no parent script, script read from stdin, etc)
/** @return the name of the directory from which the current script was executed or @ref nothing if unknown (i.e. no parent script, script read from stdin, etc)

    @par Example:
    @code
my *string $str = get_script_dir();
    @endcode
*/
*string get_script_dir() {
   return getProgram()->getScriptDir();
}

//! Returns the filename of the current script if known or @ref nothing if unknown (i.e. no parent script, script read from stdin, etc)
/** @return the filename of the current script if known or @ref nothing if unknown (i.e. no parent script, script read from stdin, etc)

    @par Example:
    @code
my *string $str = get_script_name();
    @endcode
*/
*string get_script_name() {
   return getProgram()->getScriptName();
}

//! Returns a list of hashes giving information about %Qore library options for the current build
/** @return a list of hashes giving information about %Qore library options for the current build; each hash will have the following keys:
    - \c option: The string description of the option
    - \c constant: A string giving the name of the constant that has the boolean value for this option
    - \c type: The type of option
    - \c value: The boolean value of the option

    @par Example:
    @code
my list $l = get_qore_option_list();
    @endcode

    @see get_qore_option_hash()
*/
list get_qore_option_list() [flags=CONSTANT] {
   QoreListNode *l = new QoreListNode;

   for (unsigned j = 0; j < qore_option_list_size; ++j) {
      QoreHashNode *h = new QoreHashNode;
      h->setKeyValue("option", new QoreStringNode(qore_option_list[j].option), xsink);
      h->setKeyValue("constant", new QoreStringNode(qore_option_list[j].constant), xsink);
      h->setKeyValue("type", new QoreStringNode(tlist[qore_option_list[j].type]), xsink);
      h->setKeyValue("value", get_bool_node(qore_option_list[j].value), xsink);
      l->push(h);
   }
   return l;
}

//! Returns a hash of hashes giving information about %Qore library options for the current build
/** @return a hash of hashes giving information about %Qore library options for the current build; the hash keys are the constant names and the values are hashes with the following keys:
    - \c option: The string description of the option
    - \c constant: A string giving the name of the constant that has the boolean value for this option (equal to the hash key name)
    - \c type: The type of option
    - \c value: The boolean value of the option

    @par Example:
    @code
my hash $h = get_qore_option_hash();
    @endcode

    @see get_qore_option_list()

    @since %Qore 0.8.4
*/
hash get_qore_option_hash() [flags=CONSTANT] {
   QoreHashNode *rv = new QoreHashNode;

   for (unsigned j = 0; j < qore_option_list_size; ++j) {
      QoreHashNode *h = new QoreHashNode;
      h->setKeyValue("option", new QoreStringNode(qore_option_list[j].option), xsink);
      h->setKeyValue("constant", new QoreStringNode(qore_option_list[j].constant), xsink);
      h->setKeyValue("type", new QoreStringNode(tlist[qore_option_list[j].type]), xsink);
      h->setKeyValue("value", get_bool_node(qore_option_list[j].value), xsink);

      rv->setKeyValue(qore_option_list[j].constant, h, 0);
   }
   return rv;
}

//! Returns a hash of library build and version info
/** @return a hash of library build and version info with the following keys:
    - \c PlatformOS: The operating system used to build the %Qore library
    - \c PlatformCPU: The CPU used as a target for the %Qore library build
    - \c VersionString: The full version string for this version of the %Qore library
    - \c VersionMajor: An integer giving the %Qore library's major version number
    - \c VersionMinor: An integer giving the %Qore library's minor version number
    - \c VersionSub: An integer giving the %Qore library's release version number
    - \c Build: An integer giving the %Qore library's subversion revision number
    - \c BuildHost: A string giving information about the host used to compile the %Qore library
    - \c Compiler: The compiler used to build the %Qore library
    - \c ModuleDir: The module directory assumed by default in the %Qore library
    - \c CFLAGS: The compiler flags used to compile the %Qore library
    - \c LDFLAGS: The linker flags used to link the %Qore library

    @par Example:
    @code
my hash $h = get_qore_library_info();
    @endcode
*/
hash get_qore_library_info() [flags=CONSTANT] {
   QoreHashNode *h = new QoreHashNode;

   h->setKeyValue("PlatformOS", new QoreStringNode(qore_target_os), xsink);
   h->setKeyValue("PlatformCPU", new QoreStringNode(qore_target_arch), xsink);
   h->setKeyValue("VersionString", new QoreStringNode(qore_version_string), xsink);   
   h->setKeyValue("VersionMajor", new QoreBigIntNode(qore_version_major), xsink);
   h->setKeyValue("VersionMinor", new QoreBigIntNode(qore_version_minor), xsink);
   h->setKeyValue("VersionSub", new QoreBigIntNode(qore_version_sub), xsink);
   h->setKeyValue("Build", new QoreStringNode(qore_build_number), xsink);
   h->setKeyValue("ModuleDir", new QoreStringNode(qore_module_dir), xsink);

   h->setKeyValue("BuildHost", new QoreStringNode(qore_build_host), xsink);
   h->setKeyValue("Compiler", new QoreStringNode(qore_cplusplus_compiler), xsink);
   h->setKeyValue("CFLAGS", new QoreStringNode(qore_cflags), xsink);
   h->setKeyValue("LDFLAGS", new QoreStringNode(qore_ldflags), xsink);

   return h;
}

//! returns the current @ref parse_options "parse options" for the current @ref Qore::Program "Program" object
/** @par Example:
    @code
my int $i = get_parse_options();
    @endcode

    @return the current @ref parse_options "parse options" for the current @ref Qore::Program "Program" object

    @since %Qore 0.8.7
 */
int get_parse_options() [flags=CONSTANT] {
   return runtime_get_parse_options();
}

//! returns a descriptive string for an exception location; the \c source and \c offset information will also be included in the string returned if present in the @ref exception_hash "exception hash" argument
/** @par Example:
    @code
try {
    throw "oops", sprintf("arg %y is invalid", $arg);
}
catch (hash $ex) {
    log("%s: %s: %s", get_ex_pos($ex), $ex.err, $ex.desc);
}
    @endcode

    @param ex an @ref exception_hash "exception hash"

    @return a string describing the exception location (ex: \c "sftp-poller.q:140")

    @since %Qore 0.8.7
 */
string get_ex_pos(hash ex) [flags=CONSTANT] {
   const AbstractQoreNode* n = ex->getKeyValue("file");
   QoreStringNode* str = new QoreStringNode(get_node_type(n) == NT_STRING ? reinterpret_cast<const QoreStringNode*>(n)->getBuffer() : "<unknown>");
   bool found = false;
   int ln = (int)ex->getKeyAsBigInt("line", found);
   str->sprintf(":%d", ln);
   n = ex->getKeyValue("source");
   if (get_node_type(n) == NT_STRING && !reinterpret_cast<const QoreStringNode*>(n)->empty()) {
      int offset = (int)ex->getKeyAsBigInt("offset", found);
      str->sprintf(" (source \"%s\":%d)", reinterpret_cast<const QoreStringNode*>(n)->getBuffer(), ln + offset);
   }

   return str;
}
//@}
