/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  Pseudo_QC_Nothing.qpp

  Qore Programming Language

  Copyright 2003 - 2012 David Nichols

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <qore/Qore.h>

//! Methods in this pseudo-class can be executed on @ref nothing
/** 
 */
qclass <nothing> [arg=const AbstractQoreNode* n;vparent=<value>];

//! Returns Qore::NT_NOTHING
/** 
    @return Qore::NT_NOTHING

    @par Example:
    @code
switch ($n.typeCode()) {
    case NT_NOTHING:
        printf("%y: no value\n", $n);
        break;
}
    @endcode
*/
int <nothing>::typeCode() [flags=CONSTANT] {
   return NT_NOTHING;
}

//! Returns 0
/**
    @return 0

    @par Example:
    @code
printf("iterating %d element%s\n", $val.lsize(), $val.lsize() == 1 ? "" : "s");
foreach my any $element in ($val) {
    do_something($element);
}
    @endcode
*/
int <nothing>::lsize() [flags=CONSTANT] {
   return 0;
}

//! Returns an empty @ref Qore::SingleValueIterator "SingleValueIterator" object
/** @return an empty @ref Qore::SingleValueIterator "SingleValueIterator" object

    @par Example:
    @code
map printf("+ %y\n", $1), get_hash_or_nothing().pairIterator();
    @endcode

    @since %Qore 0.8.6.2
 */
SingleValueIterator <nothing>::pairIterator() [flags=CONSTANT] {
   return new QoreObject(QC_SINGLEVALUEITERATOR, 0, new SingleValueIterator(0));
}

//! Returns an empty @ref Qore::SingleValueIterator "SingleValueIterator" object
/** @return an empty @ref Qore::SingleValueIterator "SingleValueIterator" object

    @par Example:
    @code
map printf("+ %y\n", $1), get_hash_or_nothing().keyIterator();
    @endcode

    @see <hash>::keyIterator()

    @since %Qore 0.8.6.2
 */
SingleValueIterator <nothing>::keyIterator() [flags=CONSTANT] {
   return new QoreObject(QC_SINGLEVALUEITERATOR, 0, new SingleValueIterator(0));
}

//! Returns an empty @ref Qore::SingleValueIterator "SingleValueIterator" object
/** @return an empty @ref Qore::SingleValueIterator "SingleValueIterator" object

    @par Example:
    @code
map printf("+ %y\n", $1), get_hash_or_nothing().contextIterator();
    @endcode

    @see <hash>::contextIterator()

    @since %Qore 0.8.6.2
 */
SingleValueIterator <nothing>::contextIterator() [flags=CONSTANT] {
   return new QoreObject(QC_SINGLEVALUEITERATOR, 0, new SingleValueIterator(0));
}

//! Returns an empty list
/**
    @return an empty list

    @par Example:
    @code
my *hash $h = hash_or_nothing();
my list $l = $h.keys();
    @endcode

    @see <hash>::keys()

    @since %Qore 0.8.7
 */
list <nothing>::keys() [flags=CONSTANT] {
   return new QoreListNode;
}

//! Returns an empty list
/**
    @return an empty list

    @par Example:
    @code
my *hash $h = hash_or_nothing();
my list $l = $h.values();
    @endcode

    @see <hash>::values()

    @since %Qore 0.8.7
 */
list <nothing>::values() [flags=CONSTANT] {
   return new QoreListNode;
}

//! Returns @ref nothing
/**
    @return @ref nothing

    @par Example:
    @code
my *hash $h = hash_or_nothing();
my *string $n = $h.firstKey();
    @endcode

    @see <hash>::firstKey()

    @since %Qore 0.8.7
 */
nothing <nothing>::firstKey() [flags=CONSTANT] {
}

//! Returns @ref nothing
/**
    @return @ref nothing

    @par Example:
    @code
my *hash $h = hash_or_nothing();
my any $n = $h.firstValue();
    @endcode

    @see <hash>::firstValue()

    @since %Qore 0.8.7
 */
nothing <nothing>::firstValue() [flags=CONSTANT] {
}

//! Returns @ref nothing
/**
    @return @ref nothing

    @par Example:
    @code
my *hash $h = hash_or_nothing();
my *string $n = $h.firstKey();
    @endcode

    @see <hash>::firstKey()

    @since %Qore 0.8.7
 */
nothing <nothing>::lastKey() [flags=CONSTANT] {
}

//! Returns @ref nothing
/**
    @return @ref nothing

    @par Example:
    @code
my *hash $h = hash_or_nothing();
my any $n = $h.firstValue();
    @endcode

    @see <hash>::lastValue()

    @since %Qore 0.8.7
 */
nothing <nothing>::lastValue() [flags=CONSTANT] {
}

//! Returns @ref True if the key exists in the hash (may or may not be assigned a value), @ref False if not
/**
    @param key the key name to check

    @return @ref True if the key exists in the hash (may or may not be assigned a value), @ref False if not

    @par Example:
    @code
my *hash $h = hash_or_nothing();
my bool $b = $h.hasKey($key);
    @endcode

    @see <hash>::hasKey(softstring)

    @since %Qore 0.8.7
 */
bool <nothing>::hasKey(softstring[doc] key) [flags=CONSTANT] {
   return false;
}

//! Returns @ref True if the key exists and is assigned to a value, @ref False if not
/**
    @param key the key name to check

    @return @ref True if the key exists and is assigned to a value, @ref False if not

    @par Example:
    @code
my *hash $h = hash_or_nothing();
my bool $b = $h.hasKeyValue($key);
    @endcode

    @see <hash>::hasKeyValue(softstring)

    @since %Qore 0.8.7
 */
bool <nothing>::hasKeyValue(softstring[doc] key) [flags=CONSTANT] {
   return false;
}

