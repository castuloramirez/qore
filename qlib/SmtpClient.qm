# -*- mode: qore; indent-tabs-mode nil -*-
# @file SmtpClient.qm SmtpClient module definition

/*  SmtpClient.qm Copyright 2012 Wolfgang Ritzinger, Marian Bonda, Pavol Potoncok

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# based on:
# http://james.apache.org/server/rfclist/smtp/rfc0821.txt
# http://www.faqs.org/rfcs/rfc0821.html
# http://www.faqs.org/rfcs/rfc2822.html

# mmimum qore version
%requires qore >= 0.8.4

# need mime definitions
%requires Mime >= 1.0

module SmtpClient {
    version = "1.0";
    desc = "SMTP client support module";
    author = "Wolfgang Ritzinger, Marian Bonda, Pavol Potoncok";
    url = "http://qore.org";
}

/*
 class SmtpClient::SmtpClient
    holds a configured connection to a smtp server
 class SmtpClient::Message
    holds a message to be send via smtp
 class SmtpClient::Attachment
    used for attach files to the message

 version 1.0, ritzinwo, 20090716
*/
 
public namespace SmtpClient {
    ###########################################################
    #
    # class for the message.
    #
    # my SmtpClient::Message $msg("sender", "subject");
    #   sender: a smtp string for sender eg: The User <theuser@somewhere.org>
    #
    # you can add recipients with
    #   addTO(), addCC() and addBCC() which all take a email like sender in constructor
    #
    # toString() and toLine() return info about the message either as multiline or
    # as single line (like %N or %n for objects)
    #
    # set the body text with setBody(string) or add a line to the body with addBody(string)
    #
    # additional header lines (eg: "X-SPAM-Status: No") can be added with addHeader(string) or
    # set with setHeader(string | list of string)
    # eg for setting the messageid:
    #   $m.addHeader("Message-ID: <20090712.123456789@mail.drei.at>");
    #
    # add attachments with attach(name, mime, attachment)
    # - name: the name string of the attachment (file.jpg)
    # - mime: the mimetype to be send (MimeTypeJpeg)
    # - attachment: either a string (eg from file.read(-1)) or a binary
    #
    # important([True/False]) will set the given importance and return the current setting
    # receiptDelivery([True/False]) will set the delivery receipt and return the setting
    # receiptRead([True/False]) will set the read receipt request and return the setting
    # these methods return the current setting if called without argument
    #
    #
    ###########################################################

    /** @defgroup MessageEncodings Smtp Message Encodings
     */
    #@{
    #! default content transfer encoding depending on attachment type
    public const EncDefault = "default";

    #! no content transfer encoding (not recommended as SMTP servers break up long lines automatically)
    public const EncNone = "none";

    #! base-64 content transfer encoding
    public const EncBase64 = "base64";

    #! "quoted-printable" content transfer encoding
    public const EncQuotedPrintable = "quoted-printable";

    #! a list of all known content encoding schemes encodings
    public const Encodings = (
	EncDefault,
	EncNone,
	EncBase64,
	EncQuotedPrintable,
	);       
    #@}

    #! 5 second read timeout
    public const ReadTimeout = 5s;

    public class Message {
	private {
	    # the sender
	    string $.from;
	    # subject is a header field
	    string $.subject;

	    # additional headers
	    list $.headers = (); # list for additional headers except the ones below
	    # message statuses
	    bool $.importance = False;
	    bool $.deliveryReceipt = False;
	    bool $.readReceipt = False;

	    # names
	    #$.from; # will be prefilled (and overwritten) with the sender
	    list $.to = (); # list of names for to (header only) will be prefilled (and overwritten) with the recipients
	    list $.cc = (); # list of cc's
	    list $.bcc = (); # list of bcc's

	    # message data itself
	    string $.messageData = "";

	    # message body content transfer encoding
	    string $.messageEncoding = EncDefault;

	    list $.attachments = ();
	    string $.sender;
	}

	public {}

	#! creates a Message to send in the SmtpClient
	/** Use the Message::addTo() method to add message recipients

	    @param sender the sender's email address; can be in the format "name@example.com <Full Name>"
	    @param subject the subject line for the email

	    @throw MESSAGE-CONSTRUCTOR-ERROR the sender's email address is not valid; the subject is empty
	 */
	constructor(string $sender, string $subject) {
	    my *string $se = Message::getEmailAddress($sender);
	    if (!exists $se)
		throw "MESSAGE-CONSTRUCTOR-ERROR", sprintf("cannot get email address out of: %n", $sender);

	    # subject
	    if ($subject.empty())
		throw "MESSAGE-CONSTRUCTOR-ERROR", "subject must be not empty string";

	    $.sender = $se;   # used for sending
	    $.from = $sender; # used for displaying
	    $.subject = $subject;
	}

	#! fetch the email address out of a sender/rcpt string
	static *string getEmailAddress(string $str) {
	    return ($str =~ x/([a-zA-Z0-9\-\._\+\ = ]+@[a-zA-Z0-9\-\._]+)/)[0];
	}

	#! returns True if the string contains an email address, False if not
	static bool checkEmailAddress(string $str) {
	    return !Message::getEmailAddress($str).empty();
	}

	#! add a recipient to the Message's recipient list
	/** @param recipient the email address to send the message to
	    @return the list of "To:" addresses

	    @throw MESSAGE-ADDTO-ERROR the recipient's email address is invalid
	*/
	list addTO(string $recipient) {
	    if (!Message::checkEmailAddress($recipient))
		throw "MESSAGE-ADDTO-ERROR", sprintf("cannot determine email address in %n", $recipient);

	    return $.to += $recipient;
	}
	
	#! add a recipient to the Message's cc list
	/** @param recipient the email address to send the message to (cc)
	    @return the list of "CC:" addresses

	    @throw MESSAGE-ADDCC-ERROR the recipient's email address is invalid
	*/
	list addCC(string $recipient) {
	    if (!Message::checkEmailAddress($recipient))
		throw "MESSAGE-ADDCC-ERROR", sprintf("cannot determine email address in %n", $recipient);

	    return $.cc += $recipient;
	}

	#! add a recipient to the Message's bcc list
	/** @param recipient the email address to send the message to (bcc)
	    @return the list of "BCC:" addresses

	    @throw MESSAGE-ADDBCC-ERROR the recipient's email address is invalid
	 */
	list addBCC(string $recipient) {
	    if (!Message::checkEmailAddress($recipient))
		throw "MESSAGE-ADDBCC-ERROR", sprintf("cannot determine email address in %n", $recipient);

	    return $.bcc += $recipient;
	}

	#! returns the sender's address in display format
	string getSender() {
	    return $.from;
	}

	#! returns the sender's email address
	string getFrom() {
	    return $.sender;
	}

	#! returns the list of "To:" addresses
	list getTO() {
	    return $.to;
	}

	#! returns the list of "CC:" addresses
	list getCC() {
	    return $.cc;
	}

	#! returns the list of "BCC:" addresses
	list getBCC() {
	    return $.bcc;
	}

	#! returns the subject of the Message
	string getSubject() {
	    return $.subject;
	}

	#! return all the email addresses the message will be sent to, a combination of the "To:", "CC:", and "BCC:" lists
	list getRecipients() {
	    my list $recpt = ();
	    foreach my string $e in ($.to + $.cc + $.bcc)
		$recpt += $.getEmailAddress($e);
	    return $recpt;
	}

	#! returns True if the message can be sent, False if not
	/** To be able to send a message, there must be at least one recipient in the "To:" or the "CC:" or the "BCC:" lists \
	    and there must be a message body 

	    @return True if the message can be sent, False if not
	 */
	bool sendPossible() {
	    if ($.to.empty() && $.cc.empty() && $.bcc.empty())
		return False;

	    return $.messageData.empty() ? False : True;
	}

	#! sets or replaces the Message body
	/** @param str the Message body to set
	    @param enc the encoding type for the message (see @ref MessageEncodings for possible values)

	    @throw UNKNOWN-ENCODING the message encoding value passed is unknown/unimplemented
	 */
	setBody(string $str, string $enc = EncDefault) {
	    $enc = SmtpClient::checkEncoding($str, $enc);
	    $.messageData = $str;
	    $.messageEncoding = SmtpClient::checkEncoding($str, $enc);
	}

	#! concatenates a string to the message body
	/** @param str the string to concatenate to the Message body
	 */
	addBody(string $str) {
	    $.messageData += $str;
	}

	#! returns the Message body
	string getBody() {
	    return $.messageData;
	}

	#! returns the transfer encoding for the mssage body (see @ref MessageEncodings for possible values)
	string getBodyTransferEncoding() {
	    return $.messageEncoding;
	}

	#! sets/replaces the list of Message headers
	/** @param hdr the list of Message headers to set
	    
	    @note headers for importance, delivery receipt and read receipt will be added automatically and should not be included here
         */
	setHeader(softlist $hdr) {
	    $.headers = $hdr;
	}

	#! adds a header to the Message
	/** @param $hdr a header to add to the Message
	    
	    @note headers for importance, delivery receipt and read receipt will be added automatically and should not be included here
	 */
	addHeader(string $hdr) {
	    push $.headers, $hdr;
	}

	#! returns the current user header list
	list getHeader() {
	    return $.headers;
	}

	#! returns the current importance setting
	/** if this is True, then the following headers will be sent:
	    - \c Importance: high
	    - \c X-Priority: 1
	    - \c Priority: Urgent
	 */
	bool important() {
	    return $.importance;
	}

	#! sets the importance setting
	/** if this is True, then the following headers will be sent:
	    - \c Importance: high
	    - \c X-Priority: 1
	    - \c Priority: Urgent
	 */
	important(softbool $i) {
	    $.importance = $i;
	}

	#! returns the current read delivery receipt setting
	/** if this is True, then the following header will be sent:
	    - \c Return-Receipt-To: <sender's email address>
	  */
	bool receiptRead() {
	    return $.deliveryReceipt;
	}

	#! sets the read delivery receipt setting
	/** if this is True, then the following header will be sent:
	    - \c Return-Receipt-To: <sender's email address>
	  */
	receiptRead(bool $arg) {
	    $.deliveryReceipt = $arg;
	}

	#! returns the delivery receipt setting
	/** if this is True, then the following header will be sent:
	    - \c Disposition-Notification-To: <sender's email address>
	  */
	bool receiptDelivery() {
	    return $.readReceipt;
	}

	#! sets the delivery receipt setting
	/** if this is True, then the following header will be sent:
	    - \c Disposition-Notification-To: <sender's email address>
	  */
	receiptDelivery(bool $arg) {
	    $.readReceipt = $arg;
	}

	#! creates an attachment for the Message
	/** @param name the name of the attachment to be displayed in the message, normally a file name without any path
	    @param mime the mime type for the message
	    @param att the attachment itself
	    @param enc the encoding type for the message (see @ref MessageEncodings for possible values)

	    @throw UNKNOWN-ENCODING the message encoding value passed is unknown/unimplemented
	    @throw INVALID-ENCODING the encoding given cannot be used with data given
	 */
	attach(string $name, string $mime, data $att, string $enc = EncDefault) {
	    $.attachments += new SmtpClient::Attachment($name, $mime, $att, $enc);
	}

	#! adds an Attachment to the Message
	/** @param att the Attachment to add to the Message
	  */
	attach(SmtpClient::Attachment $att) {
	    $.attachments += $att;
	}

	#! returns a list of Attachment objects for the Message
	list getAttachments() {
	    return $.attachments;
	}

	private list getEnvelopeList() {
	    my list $env = (sprintf("Sender: '%s'", $.from), sprintf("Subject: '%s'", $.subject));
	    # add To addresses
	    map $env += sprintf("To: %s", $1), $.to;
	    # add CC addresses
	    map $env += sprintf("CC: %s", $1), $.cc;
	    # add BCC addresses
	    map $env += sprintf("BCC: %s", $1), $.bcc;
	    return $env;
	}

	#! returns a multi-line string representing the Message
	/** @param body if True the Message body will be included in the string output
	 */
	string toString(bool $body = False) {
	    my list $attarr = ();
	    foreach my Attachment $att in ($.attachments)
		$attarr += sprintf("%s (%s,%d)", $att.getName(), $att.getMime(), $att.getData().size());

	    # sending envelope: from, to, subject
	    my list $env = $.getEnvelopeList();

	    # the main string
	    my string $str = sprintf("Message (%s)\n", $.sendPossible() ? "ok": "unfinished");

	    # from/to/subject
	    foreach my string $l in ($env)
		$str += "  " + trim($l) + "\n";

	    # important or not...
	    $str += sprintf("%s%s%s",
			    $.important() ? "  Important\n": "",
			    $.receiptDelivery() ? "  ReceiptDelivery\n": "",
			    $.receiptRead() ? "  ReceiptRead\n": "");

	    # add headers
	    foreach my string $l in ($.headers)
		$str += "  " + trim($l) + "\n";

	    # add attachments
	    if (elements $attarr) {
		$str += "  Attachments:\n";
		foreach my $l in ($attarr) {
		    $str += "    " + trim($l) + "\n";
		}
	    }
	    
	    # the user wants to see the body also...
	    if ($body)
		$str += "--\n" + trim($.messageData) + "\n";

	    return $str;
	}

	#! returns a single line string summarizing the Message
	/** @return a single line string summarizing the Message
	 */
	string toLine() {
	    # attachments
	    my list $attarr = ();
	    foreach my Attachment $att in ($.attachments)
		$attarr += sprintf("%s (%s,%d)", $att.getName(), $att.getMime(), $att.getData().size());

	    # sending envelope: from, to, subject
	    my list $env = $.getEnvelopeList();

	    # the main string
	    my string $str = sprintf("[Message (%s), %s, %simportant, %sdelivery, %sread",
			 $.sendPossible()? "ok": "unfinished",
			 join(", ", $env),
			 $.important()? "": "not ",
			 $.receiptDelivery()? "": "not ",
			 $.receiptRead()? "": "not "
		);
	    # add headers
	    if (elements $.headers)
		$str += sprintf(", %s", join(", ", $.headers));

	    # add attachments
	    if (elements $attarr)
		$str += sprintf(", %s", join(", ", $attarr));

	    $str += "]";

	    return $str;
	}
    }

    #! class representing an Attachment for the Message
    /** this class wraps all the data for the attachment, including:
        - the attachment's name; ie the file name which will be shown
	- the mime type which will be sent (ex: MimeTypeJpeg ie \c "image/jpeg")
	- the data for the attachment; either binary object or as str
	- the encoding type for the attachment

	@par Example:
	@code
my File $f();
$f.open2("file.jpg");
my Attachment $att("file.jpg", MimeTypeJpeg, $f.readBinary(-1));
$f.close();
$msg.addAttachment($att);
        @endcode
    */
    class Attachment {
	private {
	    string $.name;
	    string $.mime;
	    data $.data;
	    #! content-transfer encoding
	    string $.enc;
	}

	#! no public members
	public {}

	#! creates an Attachment object for a Message object
	/** @param name the name of the attachment to be displayed in the message, normally a file name without any path
	    @param mime the mime type for the message
	    @param data the attachment data itself
	    @param enc the encoding type for the message (see @ref MessageEncodings for possible values)

	    @throw UNKNOWN-ENCODING the message encoding value passed is unknown/unimplemented
	    @throw INVALID-ENCODING the encoding given cannot be used with data given
	 */
	constructor(string $name, string $mime, data $data, string $enc = EncDefault) {
	    $.name = $name;
	    $.mime = $mime;
	    $.data = $data;

	    $.enc = SmtpClient::checkEncoding($data, $enc);
	}

	#! returns the name of the Attachment
	string getName() {
	    return $.name;
	}

	#! returns the mime type of the Attachment
	string getMime() {
	    return $.mime;
	}

	#! returns the data of the Attachment
	data getData() {
	    return $.data;
	}

	#! returns the encoding of the Attachment
	string getEncoding() {
	    return $.enc;
	}

	#! serializes a string for sending the Attachment according to the encoding
	string encode() {
	    return SmtpClient::encodeData($.data, $.mime, sprintf("attachment; filename = %y", $.name), $.enc);
	}
    }

    #! the calss that's used to communicate with an SMTP server
    /** Examples:
        - create an SmtpClient object:
	  @code my SmtpClient::SmtpClient $smtp("hostname", port);@endcode
	- create a SmtpClient::Message and then send it:
	  @code $smtp.sendMessage($message);@endcode
     */
    public class SmtpClient {
	private {
	    Socket $.sock();

	    # connect string
	    string $.connect;

	    Mutex $.mutex();
	    
	    bool $.nosend = False;

	    # optional info log closure
	    *code $.log_info;

	    # optional debug log closure
	    *code $.log_debug;
	}

	public {
	    #! create a different multipart boundary string every time based on the current time
	    string $.mpboundary = replace(makeBase64String(string(now_us())), "=", "");

	    #! default SMTP port
	    const SmtpPort = 25;
	}

	#! creates the SmtpClient object
	/** @param host the hostname of the SMTP server (use [hostname] to explicitly specify an ipv6 connection)
	    @param port the port number of the SMTP server
	    @param log a closure for log messages
	    @param dbglog a closure for debugging/technical log messages
	 */
	constructor(string $host, softint $port, *code $log, *code $dbglog) {
	    $.log_info = $log;
	    $.log_debug = $dbglog;
	    $.connect = sprintf("%s:%d", $host, $port);
	}

	#! creates the SmtpClient object
	/** @param connect the hostname of the SMTP server or a hostname:port specification (use [hostname] or [address] for ipv6 connections)
	    @param log a closure for log messages
	    @param dbglog a closure for debugging/technical log messages
	 */
	constructor(string $connect, *code $log, *code $dbglog) {
	    $.log_info = $log;
	    $.log_debug = $dbglog;

	    # add default port if the connect string has no port number and:
	    # 1) is not a path (for a UNIX domain socket)
	    # 2) is not an ipv6 address enclosed in '[]' (ex '[2001:0db8:85a3:0000:0000:8a2e:0370:7334]')
	    if ($connect !~ /^\//) {
		my *softint $p = ($connect =~ x/:([0-9]+)$/)[0];
		if (!$p)
		    $connect += ":" + SmtpPort;
	    }
	    $.connect = $connect;
	    $.logDbg("SmtpClient connect: %y", $.connect);
	}

	#! disconnects if connected and destroys the object
  	destructor() {
	    try {
		$.disconnect();
	    }
	    catch (hash $ex) {
		$.logDbg("SmtpClient disconnect: %s: %s", $ex.err, $ex.desc);
	    }
  	}

	private log(string $msg) {
	    if ($.log_info.val())
		call_function($.log_info, trim(vsprintf($msg, $argv)));
	}

	private logDbg(string $msg) {
	    if ($.log_debug.val())
		call_function($.log_debug, trim(vsprintf($msg, $argv)));
	}

	#! sets or disables test mode; no connections are made in test mode
	test(bool $ns) {
	    $.nosend = $ns;
	}

	#! returns the test mode flag
	bool test() {
	    return $.nosend;
	}

	#! connect to the server
  	connect() {
	    $.sock.connect($.connect);
  	}
  	
	#! return connection status
  	bool isConnected() {
	    return ($.nosend || $.sock.isOpen());
  	}
  	
	#! disconnect from the server
  	disconnect() {
	    if ($.isConnected()) {
		$.sock.close();
		$.sock.shutdown();
	    }
  	}
  	
	# parse the server reply string to code and description
	private hash parseReply(string $str) {
	    my (*softint $code, *string $desc) = ($str =~ x/^([[:digit:]]{3}) (.*)$/);

	    my hash $rv;
	    if (!$code || !$desc.val())
		$rv = ('code': -1, 'desc': sprintf("error in parsing reply '%s'", $str));
	    else
		$rv = ('code': $code, 'desc': $desc);

	    $.logDbg("-> %n", $rv);
	    return $rv;
	}

	#! returns a string of message data according to the encoding passed
	static string encodeData(data $data, string $mime, string $disp, string $enc) {
	    my string $str = sprintf("Content-Type: %s\r\nContent-Disposition: %s\r\n", $mime, $disp);
	    switch ($enc) {
		case EncBase64: {
		    $str += "Content-Transfer-Encoding: base64\r\n\r\n";
		    $str += mime_encode_base64($data, 72);
		    $str += "\r\n";
		    break;
		}
		case EncNone: {
		    $str += "\r\n";
		    $str += $data;
		    $str += "\r\n";
		    break;
		}
		case EncQuotedPrintable: {
		    $str += sprintf("Content-Transfer-Encoding: quoted-printable\r\n\r\n");
		    $str += mime_encode_quoted_printable($data);
		    $str += "\r\n";
		    break;
		}
	    }

	    return $str;
	}

	#! checks the data against the encoding and returns the new encoding (if the encoding is EncDefault for example)
	/** @param data the data to be encoded
	    @param enc the encoding type for the data (see @ref MessageEncodings for possible values)

	    @return the new encoding to use in case the input data was EncDefault

	    @throw UNKNOWN-ENCODING the message encoding value passed is unknown/unimplemented
	    @throw INVALID-ENCODING the encoding given cannot be used with data given
	 */
	static string checkEncoding(data $data, string $enc) {
	    if ($enc = =  EncDefault)
		$enc = $data.typeCode() = =  NT_STRING ? EncNone : EncBase64; 
	    else if (!inlist($enc, Encodings))
		throw "UNKNOWN-ENCODING", sprintf("%y is not a known encoding; known encodings: %y", $enc, Encodings);

	    if ($data.typeCode() = =  NT_BINARY && $enc = =  EncNone)
		throw "INVALID-ENCODING", sprintf("%y cannot be used with binary data", $enc);

	    return $enc;
	}

	# send data over the socket
	private sendDataIntern(string $str) {
	    if (!$.isConnected()) {
		$.logDbg("SmtpClient sendData: not connected; not sending");
		throw "NOT-CONNECTED", "not connected in sendData()";
	    }

	    # send
	    $.sock.send($str);
	}

	# send data and log in the debug log if set
	private sendData(string $str) {
	    # format additional arguments if necessary
	    if (!$argv.empty())
		$str = vsprintf($str, $argv);

	    if ($.log_debug.val()) {
		my string $lstr = trim($str);
		if ($lstr.size() > 128) {
		    splice $lstr, 128;
		    $lstr += "...";
		}
		$.logDbg("SmtpClient sendData: %y", $lstr);
	    }

	    $.sendDataIntern($str);
	}

	# send a command over the socket and return the response
	private string sendCommand(string $str) {
	    # format additional arguments if necessary
	    if (!$argv.empty())
		$str = vsprintf($str, $argv);

	    trim $str;
	    $.logDbg("Smtp: sendCommand %y", $str);

	    # send data
	    $.sendDataIntern($str + "\r\n");

	    # read data
	    my string $rep = $.readLine(ReadTimeout);

	    $.logDbg("Smtp: sendCommand reply: %y", $rep);
	    return $rep;
	}

	# read a line from the socket (terminated with \n)
	private string readLine(softint $to) {
	    my string $str;
	    my int $c = 0;
	    do {
		$c = $.sock.recvu1($to);
		$str += chr($c);
	    } while ($c != 10);

	    return $str;
	}

	private hash sendMessageIntern(SmtpClient::Message $message) {
	    # open connection to server
	    $.connect();
	    my string $rep = $.readLine(ReadTimeout);
	    $.logDbg("connect reply: %n", trim($rep));
	    
	    # send helo string
	    $rep = $.sendCommand("HELO %s", gethostname());
	    my hash $rh = $.parseReply($rep);
	    if ($rh.code >= 500)
		throw "SMTP-DATA-EXCEPTION", sprintf("error on sending HELO command: %n", $rh);

	    my hash $reply.HELO = $rh;
	    
	    # send sender
	    $rep = $.sendCommand("MAIL FROM: %s", $message.getFrom());
	    $rh = $.parseReply($rep);
	    if ($rh.code >= 500)
		throw "SMTP-DATA-EXCEPTION", sprintf("error on sending FROM command: %n", $rh);
	    
	    # send receipient
	    foreach my string $rcpt in ($message.getRecipients()) {
		$rep = $.sendCommand("RCPT TO: %s", $rcpt);
		$rh = $.parseReply($rep);
		$reply.RCPT.$rcpt = $rh;
		if ($rh.code >= 500)
		    throw "SMTP-DATA-EXCEPTION", sprintf("error on sending RCPT command: %n", $rh);
	    }

	    # send data
	    $rep = $.sendCommand("DATA");
	    $rh = $.parseReply($rep);
	    if ($rh.code != 354)
		throw "SMTP-DATA-EXCEPTION", sprintf("error on sending DATA command (expected code 354): %n", $rh);

	    # From: (sender)
	    $.sendData("From: %s\r\n", $message.getSender());

	    # To:
	    foreach my string $l in ($message.getTO())
		$.sendData("To: %s\r\n", $l);

	    # CC:
	    foreach my string $l in ($message.getCC())
		$.sendData("CC: %s\r\n", $l);

	    # BCC:
	    foreach my $l in ($message.getBCC())
		$.sendData("BCC: %s\r\n", $l);

	    # add the subject - use "QP" encoding to ensure correct transmission & display of special characters through all SMTP servers
	    $.sendData("Subject: %s\r\n", Mime::mime_encode_header_word_q($message.getSubject()));

	    # importance
	    if ($message.important()) {
		$.sendData("Importance: high\r\n");
		$.sendData("X-Priority: 1\r\n");
		$.sendData("Priority: Urgent\r\n");
	    }

	    if ($message.receiptRead())
		$.sendData("Return-Receipt-To: %s\r\n", $message.getSender());

	    if ($message.receiptDelivery())
		$.sendData("Disposition-Notification-To: %s\r\n", $message.getSender());

	    # additional headers
	    foreach my string $hdr in ($message.getHeader())
		$.sendData(trim($hdr)+"\r\n");

	    return $reply;
	}

	#! send a Message to the server
	/** @param message the Message to send

	    @return a hash of data returned by the SMTP server (the return structure hashes described below are made up of the following keys: \c "code": the return code, \c "desc": the string description):
	    - \c HELO: a hash of the reply received from the HELO command
	    - \c RCPT: hash keyed by email address with hash return structures values for the RCPT TO command   
	    - \c MSGID: return structure after the send; generally contains message id
	    - \c QUIT: the server response of the disconnect command
	 */

	hash sendMessage(SmtpClient::Message $message) {
	    if (!$message.sendPossible())
		throw "ARGUMENT-EXCEPTION", "Message is not ready to be sent";

	    if ($.log_debug.val())
		$.logDbg("SmtpClient sendMessage: %s", $message.toLine());
	    
	    # lock for sending
	    my AutoLock $am($.mutex);

	    my hash $reply;
	    my $rep;
	    try {
		$reply = $.sendMessageIntern($message);

		my list $atts = $message.getAttachments();

		# multipart message?
		if (!$atts.empty()) {
		    $.sendData("MIME-Version: 1.0\r\n");
		    $.sendData("Content-Type: multipart/mixed;boundary=\"%s\"\r\n", $.mpboundary);
		    $.sendData("Content-Disposition: inline\r\n");
		    $.sendData("\r\n");
		}

		# body and attachments
		$.sendData("\r\n");

		# rest of data (the body)
		
		my string $be = $message.getBodyTransferEncoding();
		if (!$atts.empty() || $be != SmtpClient::EncNone) {
		    $.sendData(sprintf("--%s\r\n", $.mpboundary));
		    $.sendData(SmtpClient::encodeData($message.getBody(), sprintf("%s;charset=utf-8", MimeTypeText), "inline", $be));
		}
		else 
		    $.sendData($message.getBody()+"\r\n");

		# send attachments
		if (!$atts.empty()) {
		    foreach my SmtpClient::Attachment $att in ($atts) {
			$.sendData(sprintf("--%s\r\n", $.mpboundary));
			$.sendData($att.encode());
		    }
		    $.sendData(sprintf("--%s--\r\n", $.mpboundary));
		    $.sendData("\r\n");
		}

		# end of data
		$rep = $.sendCommand(".");
		$rep = $.parseReply($rep);
		$reply.MSGID = $rep;

		# quit
		$rep = $.sendCommand("QUIT");
		$rep = $.parseReply($rep);
		$reply.QUIT = $rep;
	    }
	    catch($ex) {
		$.logDbg("SmtpClient sendMessage error: %s: %s", $ex.err, $ex.desc);
		$.forceDisconnect();
		rethrow;
	    }
	    # close connection
	    $.forceDisconnect();

	    return $reply;
	}

	########################################################
	# send a message object - MHT email
	# - no attachments, resources are included directly in the mail page and referenced by relative links
	hash sendMHTMessage(SmtpClient::Message $message) {
	    if (!$message.sendPossible())
		throw "ARGUMENT-EXCEPTION", "Message is not ready to be sent";

	    if ($.log_debug.val())
		$.logDbg("SmtpClient sendMHTMessage: %s", $message.toLine());
	    
	    # lock for sending
	    my AutoLock $am($.mutex);

	    my hash $reply;
	    my $rep;
	    try {
		$reply = $.sendMessageIntern($message);
		
		# entire MHT body 
		$.sendData($message.getBody());
		$.sendData("\r\n");

		# send end of data
		$rep = $.sendCommand(".");
		$rep = $.parseReply($rep);
		$reply.'MSGID' = $rep;

		# quit
		$rep = $.sendCommand("QUIT");
		$rep = $.parseReply($rep);
		$reply.'QUIT' = $rep;
	    }
	    catch($ex) {
		$.logDbg("SmtpClient sendMHTMessage error: %s: %s", $ex.err, $ex.desc);
		$.forceDisconnect();
		rethrow;
	    }
	    # close connection
	    $.forceDisconnect();

	    return $reply;
	}

	# force disconnect of socket without error
	forceDisconnect() {
	    if ($.isConnected()) {
		try {
		    $.disconnect();
		}
		catch($ex) {
		    # ignore
		}
	    }
	}

    } # class
} # namespace

# END

