/** @page qore_modules Module Description

    @tableofcontents

    @section mod_overview Module Overview
    
    %Qore modules allow the %Qore language to be extended at run-time.

    To load a module at parse time (normally required for most modules), use the @ref requires "%requires" or @ref try-module "%try-module" parse directive. If the named feature is not already present in %Qore, %Qore looks for a module with this name in the directories listed in the \c QORE_MODULE_DIR environment variable (see @ref environment_variables).

    Use the load_module() function to load %Qore modules at run-time; however, note that any module providing parse support (classes, constants, functions, etc) must be loaded at parse time using the @ref requires "%requires" or @ref try-module "%try-module" parse directive.

    From %Qore 0.7.1 onwards, you can specify a comparison operator (one of < <=, =, >=, or >) and version information after the module name as well. Version numbers are compared via integer comparisons of each element, where elements are separated by a '.'. If one of the versions does not have as many elements as another, the missing elements are assumed to be '0' (i.e. version \c "1.0" compared with version \c "1.0.1" will be extended to \c "1.0.0").

    Also note that DBI drivers are loaded on demand by the @ref Qore::SQL::Datasource and @ref Qore::SQL::DatasourcePool classes.

    There are two types of modules: @ref binary_modules and @ref user_modules.

    At the time of writing this documentation, the following modules exist for %Qore:

    <b>%Qore Modules</b>
    |!Type|!Module|!Description
    |user|<a href="../../modules/CsvUtil/html/index.html">CsvUtil</a>|Provides code to help parse CSV or other structured text files
    |user|<a href="../../modules/HttpServer/html/index.html">HttpServer</a>|Provides a multi-threaded HTTP server
    |user|<a href="../../modules/MailMessage/html/index.html">MailMessage</a>|Provides supporting classes for the <a href="../../modules/Pop3Client/html/index.html">Pop3Client</a> and <a href="../../modules/SmtpClient/html/index.html">SmtpClient</a> modules
    |user|<a href="../../modules/Mime/html/index.html">Mime</a>|Provides MIME definitions and functions
    |user|<a href="../../modules/Pop3Client/html/index.html">Pop3Client</a>|Provides POP3 client functionality
    |user|<a href="../../modules/RestHandler/html/index.html">RestHandler</a>|Provides an easy interface to the Qore <a href="../../modules/HttpServer/html/index.html">HttpServer</a> module for implementing <a href="http://en.wikipedia.org/wiki/Representational_state_transfer">REST</a> services
    |user|<a href="../../modules/SmtpClient/html/index.html">SmtpClient</a>|Provides SMTP client functionality
    |user|<a href="../../modules/SqlUtil/html/index.html">SqlUtil</a>|Provides a high-level DB-independent API for working with database objects
    |user|<a href="../../modules/TelnetClient/html/index.html">TelnetClient</a>|Provides Telnet client functionality
    |builtin|<a href="http://qore.org/modules-mainmenu-31/23-asn1-module/66-asn1-module-info">asn1</a>|Provides ASN.1 functionality
    |builtin|<a href="http://qore.org/modules-mainmenu-31/42-db2-module">db2</a>|Provides an IBM DB2 driver
    |builtin|<a href="http://qore.org/modules-mainmenu-31/17-sybase-and-freetds-modules/61-sybase-freetds-info">freetds</a>|Provides a FreeTDS-based DBI driver
    |builtin|<a href="http://qore.org/modules-mainmenu-31/25-glut-module">glut</a>|Provides GLUT functionality
    |builtin|<a href="http://qore.org/modules-mainmenu-31/41-json-module">json</a>|Provides JSON functionality
    |builtin|<a href="http://qore.org/modules-mainmenu-31/16-mysql-module">mysql</a>|Provides a MySQL DBI driver
    |builtin|<a href="http://qore.org/modules-mainmenu-31/26-ncurses-module">ncurses</a>|Provides curses APIs
    |builtin|<a href="http://qore.org/modules-mainmenu-31/14-oracle-module">oracle</a>|Provides an Oracle DBI driver
    |builtin|<a href="http://qore.org/modules-mainmenu-31/24-opengl-module">opengl</a>|Provides an OpenGL API
    |builtin|<a href="http://qore.org/modules-mainmenu-31/15-pgsql-module">pgsql</a>|Provides a PostgreSQL DBI driver
    |builtin|<a href="http://qore.org/modules-mainmenu-31/36-qt4-module">qt4</a>|Provides Nokia (formerly Trolltech) QT4 APIs for GUI development
    |builtin|<a href="http://qore.org/modules-mainmenu-31/35-sqlite3-module">sqlite3</a>|Provides a SQLite3 DBI driver
    |builtin|<a href="http://qore.org/modules-mainmenu-31/37-ssh2-module">ssh2</a>|Provides SSH2 and SFTP functionality
    |builtin|<a href="http://qore.org/modules-mainmenu-31/17-sybase-and-freetds-modules/61-sybase-freetds-info">sybase</a>|Provides a Sybase DBI driver
    |builtin|<a href="http://qore.org/modules-mainmenu-31/19-tibae-module">tibae</a>|Provides TIBCO ActiveEnterprise(TM) (TIBCO, Inc) functionality
    |builtin|<a href="http://qore.org/modules-mainmenu-31/18-tibrv-module">tibrv</a>|Provides TIBCO Rendezvous(R) (TIBCO, Inc) functionality
    |builtin|<a href="http://qore.org/modules-mainmenu-31/20-tuxedo-module/65-tuxedo-module-info">tuxedo</a>|Provides Oracle (ex Bea) Tuxedo functionality
    |builtin|<a href="http://qore.org/modules-mainmenu-31/39-uuid-module">uuid</a>|Provices an API for generating UUIDs
    |builtin|<a href="http://qore.org/modules-mainmenu-31/40-xml-module">xml</a>|Provides XML, XPath, etc functionality
    |builtin|<a href="http://qore.org/modules-mainmenu-31/22-xmlsec-module">xmlsec</a>|Provides xmldsig and xmlenc functionality
    |builtin|<a href="http://qore.org/modules-mainmenu-31/38-yaml-module">yaml</a>|Provides YAML functionality

    @section binary_modules Binary Modules

    Binary modules are written in C++ and delivered in binary form. They must conform to the %Qore Module API and have the file extension \c "*.qmod". Binary modules normally depend on other shared libraries and therefore can only be loaded if the libraries they require are present on the system and can be found in the library path.
    
    Binary modules are merged into @ref Qore::Program "Program" objects in the same way as the static system namespace objects are imported.  It is possible to import a binary module and be able to use only part of its functionality, for example, if the importing @ref Qore::Program "Program" cannot access the filesystem, and the module has functions that access the filesystem, only the functions that access the filesystem will not be available.  In user modules, the functional domain is set on the module level and not on the individual function or method level as with builtin objects, so user modules are either completely imported or not at all.

    Please note that as of version 0.7.0 onwards, the source code for binary modules has been split from the main %Qore library source code into separate projects; see <a href="http://www.qore.org">%Qore's home page</a> for more information.

    @section user_modules User Modules

    User modules are written in %Qore and delivered in source form.  They must have the extension \c "*.qm".

    User modules will have their own dedicated @ref Qore::Program "Program" object; the @ref Qore::Program "Program" object is created automatically when the module is loaded and initialized.  The module's @ref Qore::Program "Program" object is created with locked parse options as follows:
    - @ref Qore::PO_NO_TOP_LEVEL_STATEMENTS "PO_NO_TOP_LEVEL_STATEMENTS": modules provide API services and are not designed to be executed at the top-level.  Put any initialization code in the module's \c init closure
    - @ref Qore::PO_REQUIRE_PROTOTYPES "PO_REQUIRE_PROTOTYPES": to ensure that module's APIs are transparent, all method and function declarations must include parameter and return types
    - @ref Qore::PO_REQUIRE_OUR "PO_REQUIRE_OUR": this parse option is meant to ensure that typos in variable names are caught at parse time and to ensure transparency of variable types in the module's source code
    - @ref Qore::PO_IN_MODULE "PO_IN_MODULE": this parse option is set so that module code is recognized by the system when parsing modules

    When parsing module code, the default warning mask is set to @ref Qore::WARN_MODULES "WARN_MODULES", and any warnings are treated as errors.   Furthermore, any restrictions that the importing @ref Qore::Program "Program" object has will be added to the module's @ref Qore::Program "Program" object.

    Any @ref qore_namespaces "namespaces", @ref qore_classes "classes", @ref constants "constants", @ref qore_functions "functions", and @ref global_variables "global variables" declared as @ref mod_public "public" will be exported into the importing @ref Qore::Program "Program" object; all other declarations will be private to the module's @ref Qore::Program "Program" object.  Note that the root namespace of a module @ref Qore::Program "Program" is always @ref mod_public "public" by default.

    Note that global variables exported from a module's @ref Qore::Program "Program" object are exported as references; each global variable declared in a module is unique, and they reside in the module's @ref Qore::Program "Program" object.

    Furthermore, when using an environment with multiple @ref Qore::Program "Program" objects, if a user module has already been loaded and initialized, then it's functional domain mask is compared against any importing @ref Qore::Program "Program" object's restrictions; if the module uses functionality that is not allowed in the importing @ref Qore::Program "Program" object, then an exception is raised and the module is not imported.

    Also note that the @ref Qore::Program::constructor() applies a mask to the parse option mask option when @ref Qore::Program "Program" objects are created in a user module; in this case the parse options passed to the child @ref Qore::Program "Program" object are masked with the current parse options in the user module, and they are locked so that they cannot be made less restrictive.  This is to prevent user modules from circumventing functional restrictions imposed by parse options.

    @subsection user_module_declarations User Module Declarations

    User modules are declared with a special syntax in %Qore:
    
    <b>User Module Declaration Syntax</b>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<b><tt>module</tt></b> <i>name</i> <tt>{</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt><b>version</b> = &quot;</tt><i>version string</i><tt>&quot;;</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt><b>desc</b> = &quot;</tt><i>description string</i><tt>&quot;;</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt><b>author</b> = &quot;</tt><i>author string</i><tt>&quot;;</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>[<b>url</b> = &quot;</tt><i>URL string</i><tt>&quot;;]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>[<b>init</b> = </tt><i>@ref closure "initialization closure"</i><tt>;]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>[<b>del</b> = </tt><i>@ref closure "deletion closure"</i><tt>;]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>}</tt>

    Module properties are as follows:
    - \c version: (required) must be assigned to a string giving the version of the module
    - \c desc: (required) must be assigned to a string giving a text description of the module
    - \c author: (required) must be assigned to a string giving the module's author's name
    - \c url: (optional) if present, must be a string giving the URL or the module
    - \c init: (optional) if present, must be a closure that will be executed when the module is loaded; this can be used to initialize the module, for example
    - \c del: (optional) if present, must be a closure that will be executed when the module is unloaded; this can be used to stop running services or free resources managed and still allocated by the module, for example

    @note
    - any unhandled exceptions in the \c init closure will cause the module to fail to load
    - unhandled exceptions in the \c init and \c del closures are displayed on @ref Qore::stdout "stdout"

    @subsection mod_public The "public" Keyword

    Only objects defined with the <b><tt>public</tt></b> keyword are made available in @ref Qore::Program "Program" objects importing the user module.  All other declarations and definitions are private to the module.

    The <b><tt>public</tt></b> keyword also affects inheritance in child @ref Qore::Program "Program" objects as well as controlling exported symbols from user modules.

    The <b><tt>public</tt></b> keyword must be used with the following declarations in the module to export them:
    - @ref qore_namespaces "namespaces": namespaces themselves must be declared <b><tt>public</tt></b> in order for any of their contents also to be exported (it is an error to try to declare public members of a module-private namespace). ex: @code
public namespace MyNamespace { ... }@endcode
    - @ref qore_classes "classes": classes not declared <b><tt>public</tt></b> will not be exported; there is no way to export part of a class; either the entire class is exported or it is not. ex: @code
public MyNamespace {
    public MyClass { ... }
}@endcode
    - @ref constants "constants": constants must be declared <b><tt>public</tt></b> to be exported; ex: @code
public namespace MyNamespace {
    public const MyConst = 100;
}@endcode
    - @ref qore_functions "functions": function variants must be declared <b><tt>public</tt></b> in order to be exported. ex: @code
public MyNamespace {
    public int sub my_func() { ... }
}@endcode
    - @ref global_variables "global variables": only global variables declared <b><tt>public</tt></b> will be exported. ex: @code
public namespace MyNamespace {
    public our int $OurInt;
}@endcode

    @note Global variable declarations in a namespace declaration cannot be initialized at the point they are declared, also, since @ref Qore::PO_NO_TOP_LEVEL_STATEMENTS is set for user module @ref Qore::Program "Program" objects, global variables also cannot be initialized at the top-level.  Use the \c init closure to initialize the module and any global variables requiring initialization.

    User modules are only imported into a @ref Qore::Program "Program" if the importing @ref Qore::Program "Program" can use all of the capabilities used in the user module.  It is not possible to partially import a user module (in contrast with @ref binary_modules "binary modules", which can be imported even if they expose functionality not allowed in the importing @ref Qore::Program "Program", however that functionality will not be available in that case).  User module @ref Qore::Program "Program" objects have a functional domain attribute set on the @ref Qore::Program "Program" level, so either a user module is imported in its entirety or not at all.

    @subsection User Module Example

    Here is an example declaring user module \c "foo" version \c "1.0":
    @code
module foo {
    version = "1.0";
    desc = "test module";
    author = "Foobar Industries, inc";
    url = "http://example.com";

    init = sub () {
        Foo::initialized = True;
	Bar::OurBool = False;
    };

    del = sub () {
        print("goodbye, cruel world!\n");
    }
}

# do not use "$", assume local scope for variables
%new-style

# nothing in namespace ::Foo is exported
namespace Foo {
    # inline global variable declarations cannot be initialized when declared
    our bool initialized;

    class SuperClass {
    }
    class NotSoGreatClass {
    }
    class UnstableClass {
    }
}

# public members of namespace ::Bar are exported
public namespace Bar {
    # Bar::SomeClass is exported
    public class SomeClass {
    }

    # Bar::add(int, int) is exported
    public int sub add(int x, int y) { return x + y; }

    # Bar::OurBool is exported
    public our bool OurBool;

    # Bar::PrivateClass is not exported
    class PrivateClass {
    }
}@endcode

    @since %Qore 0.8.4 user modules are supported

    @subsection user_module_program_scope Program Scope in Object-Oriented Programs Using User Modules Providing Their Own Threads

    When using the @ref exec-class "%exec-class" parse directive, the application object will go out of scope as soon as the
    constructor terminates (unless there are valid scope-extending references to the application object, such as making an
    assignment of <tt>$self</tt> to a global variable in the contructor).

    Therefore when using a module that provides services in its own threads (such as, for example, the
    <a href="../../modules/HttpServer/html/index.html">HttpServer</a> module), it's important to make sure that the application
    object does not go out of scope while non-static method call references to the application object are needed by active threads
    inthe user module (for example, non-static method call references passed as callbacks to the 
    <a href="../../modules/HttpServer/html/index.html">HttpServer</a> module, etc).

    This also applies to call references to non-static methods passed to set_signal_handler().

    If a module thread tries to use a callback or closure in a @ref Qore::Program "Program" that has already gone out of scope,
    an \c OBJECT-ALREADY-DELETED exception (\c "attempt to access member of an already-deleted object") is thrown.

    Therefore in such cases it's best to wait for all threads in any modules to terminate before allowing the application object's
    constructor to terminate.

    For an example of this, see the example program <tt>examples/httpserver.q</tt> where the main @ref Qore::Program "Program"
    calls HttpServer::waitStop() before exiting the application object's constructor for this reason.
*/
