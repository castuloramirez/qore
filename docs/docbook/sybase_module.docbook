<?xml version="1.0" encoding="UTF-8" ?>
  <sect1 id="sybase_Module">
    <title>sybase Module</title>
    
    <para>The sybase module provides a Qore DBI driver allowing Qore programs to access Sybase databases through the <link linkend="Qore::SQL::Datasource_Class">Datasource</link> and <link linkend="DatasourcePool_Class">DatasourcePool</link> classes.</para>

    <para>Example of creating a Sybase Datasource:</para>

    <programlisting>$db = new Datasource(SQL::DSSybase, $user, $pass, $db, $charset);</programlisting>

    <para>This driver is linked with Sybase's ct-lib.  For Sybase connectivity with a freely-available library, see the <link linkend="mssql_Module">mssql</link> driver, providing connectivity to Sybase and MS SQL Server databases.</para>

    <para>This driver supports the following <link linkend="DBI_Capability_Constants">DBI capabilities</link>: <code>DBI_CAP_TRANSACTION_MANAGEMENT, DBI_CAP_STORED_PROCEDURES, DBI_CAP_CHARSET_SUPPORT, DBI_CAP_LOB_SUPPORT, DBI_CAP_BIND_BY_VALUE, DBI_CAP_BIND_BY_PLACEHOLDER</code>.</para>

    <para>Transaction management is supported by enabling chained transaction mode on each connection.  In autocommit mode, Qore executes a commit after every request to the server.</para>

    <para>The transaction isolation level is left at the default, 1, &quot;read committed&quot;, which is the default for all Qore drivers as well.</para>

    <para>Sybase's <code>DATETIME</code> and <code>TIME</code> data types have a resolution of 1/300th of a second.  Qore uses floating-point operations to convert to or from milliseconds when binding and retrieving data and rounds to the nearest integer to minimize conversion errors.</para>

    <para>This driver allows all types of statements to be executed through <link linkend="Qore::SQL::Datasource::select">Datasource::select()</link>, <link linkend="Qore::SQL::Datasource::selectRows">Datasource::selectRows()</link>, and <link linkend="Qore::SQL::Datasource::exec">Datasource::exec()</link> (and related methods), however rules about <link linkend="datasource_transaction_lock">Datasource locking</link> or <link linkend="datasourcepool_allocations">DatasourcePool allocations</link> still apply as usual.  If a stored procedure is executed with <link linkend="Qore::SQL::Datasource::selectRows">Datasource::selectRows()</link> , then any query results returned will be returned in either a hash format (if only one row was returned), or as a list of hashes (for multiple rows).</para>

    <para>Sybase stored procedure execution is supported, the following is an example of a stored procedure call with output parameters:</para>

    <programlisting>create procedure get_values @string varchar(80) output, @int int output
as 
select @string = 'hello there'
select @int = 150
commit -- to maintain transaction count</programlisting>

    <para>Qore code to call this procedure:</para>

    <programlisting># note that if the output parameters are declared as @string and @int, the driver cannot
# return the parameter result hash with key names corresponding to the param names.
# ":string" and ":int" is qore placeholder syntax, consistent with other Qore DBI
# driver placeholder syntax

my $result = $db.exec("declare @string varchar(40), @int int
exec get_values :string output, :int output");</programlisting>

    <para>Unlike many other Qore DBI drivers, this driver allows and can return results from multiple select statements issued with a single call.  Additionally, it's possible for a stored procedure to return output paramters as well as one or more result sets from select statements.  The output format for commands like this differs from standard Qore DBI formats as follows:</para>

    <table>
      <title>Sybase Multiple Result Format</title>
      <tgroup cols='2' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Query Type</para></entry>
	    <entry><para>Result Format</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para>Multiple Selects</para></entry>
	    <entry><para>A hash is returned with a key giving the results from each select statement.  The key names have the format &quot;query#&quot;, where # is an increasing integer starting with 0.</para></entry>
	  </row>
	  <row>
	    <entry><para>Return Parameters Only</para></entry>
	    <entry><para>A hash is returned with keys giving the output parameter values, as long as the placeholder format (:name) was used for the output parameters, otherwise the key names in the output will be an increasing integer starting with 0 (i.e. &quot;0&quot;, &quot;1&quot;, etc).  If a count of affected rows is available, it's returned in the &quot;rowcount&quot; key.</para></entry>
	  </row>
	  <row>
	    <entry><para>Return Parameters and Result Set(s)</para></entry>
	    <entry><para>As above, but with an addition key &quot;query&quot;, giving the result set.  If multiple result sets are returned, then the &quot;query&quot; key will be a hash with &quot;query#&quot; keys giving the results for each query in order.</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>


    <table>
      <title>Sybase to Qore Type Mappings</title>
      <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Sybase Type</para></entry>
	    <entry><para>Qore Type</para></entry>
	    <entry><para>Notes</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><code>TINYINT</code></para></entry>
	    <entry><para><link linkend="Integer"><code>Type::Int</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>SMALLINT</code></para></entry>
	    <entry><para><link linkend="Integer"><code>Type::Int</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>INT</code></para></entry>
	    <entry><para><link linkend="Integer"><code>Type::Int</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>DECIMAL, NUMERIC</code></para></entry>
	    <entry><para><link linkend="String"><code>Type::String</code></link></para></entry>
	    <entry><para>conversion to string to avoid losing information</para></entry>
	  </row>
	  <row>
	    <entry><para><code>FLOAT</code></para></entry>
	    <entry><para><link linkend="Float"><code>Type::Float</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>REAL</code></para></entry>
	    <entry><para><link linkend="Float"><code>Type::Float</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>MONEY</code></para></entry>
	    <entry><para><link linkend="Float"><code>Type::Float</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>SMALLMONEY</code></para></entry>
	    <entry><para><link linkend="Float"><code>Type::Float</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>DATETIME</code></para></entry>
	    <entry><para><link linkend="Date"><code>Type::Date</code></link></para></entry>
	    <entry><para>Sybase 1/300 second values are converted and rounded to the nearest millisecond</para></entry>
	  </row>
	  <row>
	    <entry><para><code>SMALLDATETIME</code></para></entry>
	    <entry><para><link linkend="Date"><code>Type::Date</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>DATE</code></para></entry>
	    <entry><para><link linkend="Date"><code>Type::Date</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>TIME</code></para></entry>
	    <entry><para><link linkend="Date"><code>Type::Date</code></link></para></entry>
	    <entry><para>Date portion is set to '1970-01-01'; Sybase 1/300 second values are converted and rounded to the nearest millisecond</para></entry>
	  </row>
	  <row>
	    <entry><para><code>CHAR</code></para></entry>
	    <entry><para><link linkend="String"><code>Type::String</code></link></para></entry>
	    <entry><para>trailing blanks are removed</para></entry>
	  </row>
	  <row>
	    <entry><para><code>VARCHAR</code></para></entry>
	    <entry><para><link linkend="String"><code>Type::String</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>UNICHAR</code></para></entry>
	    <entry><para><link linkend="String"><code>Type::String</code></link></para></entry>
	    <entry><para>trailing blanks are removed</para></entry>
	  </row>
	  <row>
	    <entry><para><code>UNIVARCHAR</code></para></entry>
	    <entry><para><link linkend="String"><code>Type::String</code></link></para></entry>
	    <entry><para>trailing blanks are removed</para></entry>
	  </row>
	  <row>
	    <entry><para><code>TEXT</code></para></entry>
	    <entry><para><link linkend="String"><code>Type::String</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>UNITEXT</code></para></entry>
	    <entry><para><link linkend="Binary"><code>Type::Binary</code></link></para></entry>
	    <entry><para>this data is returned as type <code>IMAGE</code> from the dataserver, so a binary object is returned by the driver</para></entry>
	  </row>
	  <row>
	    <entry><para><code>BINARY</code></para></entry>
	    <entry><para><link linkend="Binary"><code>Type::Binary</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>VARBINARY</code></para></entry>
	    <entry><para><link linkend="Binary"><code>Type::Binary</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>IMAGE</code></para></entry>
	    <entry><para><link linkend="Binary"><code>Type::Binary</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <table>
      <title>Qore to Sybase Open Client Type Mappings When Binding</title>
      <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Qore Type</para></entry>
	    <entry><para>Sybase Type</para></entry>
	    <entry><para>Notes</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><link linkend="Integer"><code>Type::Int</code></link></para></entry>
	    <entry><para><code>CS_BIGINT_TYPE</code></para></entry>
	    <entry><para>Sybase's integer type is only 32-bits, integers greater than 2147483647 bound to an <code>INT</code> column will only have their lower 32 bits saved to Sybase.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Float"><code>Type::Float</code></link></para></entry>
	    <entry><para><code>CS_FLOAT_TYPE</code></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Boolean"><code>Type::Boolean</code></link></para></entry>
	    <entry><para><code>CS_BIT_TYPE</code></para></entry>
	    <entry><para>True = 1, False = 0</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="String"><code>Type::String</code></link></para></entry>
	    <entry><para><code>CS_CHAR_TYPE</code></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Date"><code>Type::Date</code></link></para></entry>
	    <entry><para><code>CS_DATETIME_TYPE</code></para></entry>
	    <entry><para>milliseconds are rounded to 1/300 second values</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Binary"><code>Type::Binary</code></link></para></entry>
	    <entry><para><code>CS_BINARY_TYPE</code></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

  </sect1>

