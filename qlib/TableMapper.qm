# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file TableMapper.qm provides mapping functionality to a Table target 

/*  TableMapper.qm Copyright 2014 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.9 or better
%requires qore >= 0.8.9

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

# requires the Mapper module
%requires Mapper
# requires the SqlUtil module
%requires SqlUtil

module TableMapper {
    version = "1.0";
    desc = "user module providing data mapping infrastructure to an SQL Table target";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
}

/*  Version History
    * 2014-01-03 v1.0: David Nichols <david@qore.org>
      + the initial version of the TableMapper module
*/

/** @mainpage TableMapper Module

    @tableofcontents

    @section tablemapperintro TableMapper Module Introduction

    Classes provided by this module:
    - @ref TableMapper::TableMapper

    @section mapperrelnotes Release Notes

    @subsection tablemapperv1_0 TableMapper v1.0

    Initial release.
*/

#! the TableMapper namespace contains all the definitions in the TableMapper module
public namespace TableMapper {
    #! provides an inbound data mapper to a Table target
    public class InboundTableMapper inherits Mapper::Mapper {
        # no public members
        public {
        }

        private {
            #! the target table object
            SqlUtil::AbstractTable $.table;

            #! the target Database object in case sequence value need to be acquired
            SqlUtil::AbstractDatabase $.db;
        }

        #! builds the object based on a hash providing field mappings, data constraints, and optionally custom mapping logic
        /** @param table the target table object
            @param map a hash providing field mappings; each hash key is the name of the output field; each value is either @ref Qore::True "True" (meaning no translations are done; the data is copied 1:1) or a hash with the following fields providing information about how the input records should be translated (all fields are optional):
            - \c name: the value of this key gives the name of the input field; only use this if the input record name is different than the output field name
            - \c struct: the value of this key gives the location of the input field in an input hash in dot notation, ex: \c "element.name" would ook for the field's value in the \c "name" key of the \c "element" hash in the input record
            - \c code: a closure or call reference to process the field data
            - \c maxlen: an integer giving the maximum field length in bytes
            - \c trunc: assign to boolean @ref Qore::True "True" if the field should be truncated if over the maximum field length; this key can only be set to @ref Qore::True "True" if the \c "maxlen" key is also given
            - \c mand: assign to boolean @ref Qore::True "True" if the field is mandatory and an exception should be thrown if no input data is supplied
            - \c type: this gives the field type, can be:
              - \c "number": field accepts only numeric values (any non-numeric values on input will cause an exception to be thrown when mapping) 
              - \c "date": date field
            - \c sequence: the name of a sequence to populate the field value from
            @param opts an optional hash of options for the mapper; accepted options are:
              - \c "enc": the output character encoding; if not present then \c "UTF-8" is assumed
              - \c "name": the name of the mapper for use in logging and error strings; note that if not given the table's name will be used automatically
              - \c "trunc": an optional @ref closure "closure" or @ref call_reference "call reference" for a callback for field truncation warnings; must accept a single string giving the warning text
              - \c "input_log": an optional input data logging callback; must accept a hash giving the input data hash
              - \c "output_log": an optional output data logging callback; must accept a hash giving the output data hash

            @throw MAP-ERROR the map hash has a logical error (ex: \c "trunc" key given without \c "maxlen", invalid map key)
        */
        constructor(SqlUtil::Table $table, hash $map, *hash $opts) {
            $.table = $table.getTable();
            $.setup($map, $opts);

            # check map for logical errors
            $.checkMap();            
        }

        #! builds the object based on a hash providing field mappings, data constraints, and optionally custom mapping logic
        /** @param map a hash providing field mappings; each hash key is the name of the output field; each value is either @ref Qore::True "True" (meaning no translations are done; the data is copied 1:1) or a hash with the following fields providing information about how the input records should be translated (all fields are optional):
            - \c name: the value of this key gives the name of the input field; only use this if the input record name is different than the output field name
            - \c struct: the value of this key gives the location of the input field in an input hash in dot notation, ex: \c "element.name" would ook for the field's value in the \c "name" key of the \c "element" hash in the input record
            - \c code: a closure or call reference to process the field data
            - \c maxlen: an integer giving the maximum field length in bytes
            - \c trunc: assign to boolean @ref Qore::True "True" if the field should be truncated if over the maximum field length; this key can only be set to @ref Qore::True "True" if the \c "maxlen" key is also given
            - \c mand: assign to boolean @ref Qore::True "True" if the field is mandatory and an exception should be thrown if no input data is supplied
            - \c type: this gives the field type, can be:
              - \c "number": field accepts only numeric values (any non-numeric values on input will cause an exception to be thrown when mapping) 
              - \c "date": date field
            - \c sequence: the name of a sequence to populate the field value from
            @param opts an optional hash of options for the mapper; accepted options are:
              - \c "enc": the output character encoding; if not present then \c "UTF-8" is assumed
              - \c "name": the name of the mapper for use in logging and error strings; note that if not given the table's name will be used automatically
              - \c "trunc": an optional @ref closure "closure" or @ref call_reference "call reference" for a callback for field truncation warnings; must accept a single string giving the warning text
              - \c "input_log": an optional input data logging callback; must accept a hash giving the input data hash
              - \c "output_log": an optional output data logging callback; must accept a hash giving the output data hash

            @throw MAP-ERROR the map hash has a logical error (ex: \c "trunc" key given without \c "maxlen", invalid map key)
        */
        constructor(SqlUtil::AbstractTable $table, hash $map, *hash $opts) {
            $.table = $table;
            $.setup($map, $opts);

            # check map for logical errors
            $.checkMap();            
        }

        #! verifies the input map in the constructor
        private checkMap() {
            my Columns $cols = $.table.describe();

            # ensure there are no unknown mappings
            foreach my string $k in ($.map.keyIterator()) {
                if (!$cols.hasKey($k))
                    $.error("mapper specifies field '%s' that does not exist in the target table '%s'", $.getFieldName($k), $.table.getSqlName());                
            }

            # update output field definitions from real table description
            foreach my AbstractColumn $col in ($cols.iterator()) {
                my string $cn = $col.name.lwr();
                my reference $ch = \$.map.$cn;
                my int $t = $ch.typeCode();
                if ($t != NT_HASH)
                    $.convertToHash($t, $cn, \$ch);
                switch ($col.qore_type) {
                    case "string": $ch += ("maxlen": $col.size, "trunc": $.trunc_all); break;
                    case "number": $ch.type = "number"; break;
                    case "integer": $ch.type = "integer"; break;
                    case "date": $ch.type = "date"; break;
                    default: throw "TABLE-ERROR", sprintf("column %s.%s has unknown native type %y", $.table.getSqlName(), $cn, $col.native_type);
                }
                if (!$col.nullable && !exists $col.def_val)
                    $ch.mand = True;
            }

            map $.checkMapField($1, \$.map.$1, ("cols": $cols)), $.map.keyIterator();
        }

        #! performs type handling
        private mapFieldType(string $key, hash $m, reference $v, hash $rec) {
            if ($m.sequence)
                $v = $.db.getNextSequenceValue($m.sequence);
            Mapper::$.mapFieldType($key, $m, \$v, $rec);
        }

        #! returns @ref Qore::True "True" if the field has a mapping, @ref Qore::False "False" if not
        private bool hasMapping(hash $fh) {
            return $fh.name || $fh.struct || $fh.code || $fh.sequence;
        }

        #! perform per-field pre-processing on the passed map in the constructor
        /** @param k the field name
            @param fh a reference to the field's value in the map
        */
        private checkMapField(string $k, reference $fh, hash $th) {
            if ($fh.sequence) {
                if ($fh.sequence.typeCode() != NT_STRING)
                    $.error("field '%s' has a sequence key assigned to type '%s' (%y)", $.getFieldName($k), $fh.sequence.type(), $fh.sequence);
                if (!$.db)
                    $.db = AbstractDatabase::getDatabase($.table.getDatasource());

                if ($fh.type) {
                    if ($fh.type != "number" && $fh.type != "integer")
                        $.error("field '%s' has a 'sequence' key, but the type is '%s'", $.getFieldName($k), $fh.type);
                }
                else
                    $fh.type = "number";
            }

            Mapper::$.checkMapField($k, \$fh);
        }

        #! returns a list of valid field keys for this class (can be overridden in subclasses)
        /** @return a list of valid field keys for this class (can be overridden in subclasses)
        */
        hash validKeys() {
            return Mapper::ValidKeys + (
                "sequence": True,
                );
        }

        #! returns a list of valid constructor options for this class (can be overridden in subclasses)
        /** @return a list of valid constructor options for this class (can be overridden in subclasses)
        */
        hash optionKeys() {
            return OptionKeys + (
                "table": True,
                );
        }

        #! inserts a row into the target table based on a mapped input record; does not commit the transaction
        /** @param $rec the input record

            @return a hash of the row values inserted (row name: value)

            @throw MISSING-INPUT a field marked mandatory is missing
            @throw STRING-TOO-LONG a field value exceeds the maximum value and the 'trunc' key is not set
            @throw INVALID-NUMBER the field is marked as numeric but the input value contains non-numeric data        
        */
        hash insertRowNoCommit(hash $rec) {
            my hash $h = $.mapData($rec + $.crec);
            $.table.insert($h);
            return $h;
        }

        #! inserts a row into the target table based on a mapped input record; commits the transaction
        /** @param $rec the input record

            @return a hash of the row values inserted (column: value), not including the extra values

            @throw MISSING-INPUT a field marked mandatory is missing
            @throw STRING-TOO-LONG a field value exceeds the maximum value and the 'trunc' key is not set
            @throw INVALID-NUMBER the field is marked as numeric but the input value contains non-numeric data        
        */
        hash insertRow(hash $rec) {
            on_success $.table.commit();
            on_error $.table.rollback();

            return $.insertRowNoCommit($rec);
        }

        #! commits the transaction
        nothing commit() {
            $.table.commit();
        }

        #! rolls back the transaction
        nothing rollback() {
            $.table.rollback();
        }

        #! returns the table name
        string getTableName() {
            return $.table.getSqlName();
        }
    }

    #! provides a hash iterator based on a @ref TableMapper::InboundTableMapper "InboundTableMapper" object and an iterator input source; for each iteration the iterted row is inserted into the @ref SqlUtil::Table "Table" target
    public class InboundTableMapperIterator inherits Mapper::AbstractMapperIterator {
        public {
        }

        private {
            #! data mapper
            TableMapper::InboundTableMapper $.map;

            #! row commit limit (<= 0 for no commits)
            int $.commit_limit;

            #! row count for commit
            int $.cnt = 0;
        }

        #! creates the iterator from the arguments passed
        /** @param i input iterator; @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()" must return a hash
            @param table the target table object
            @param map a hash providing field mappings; each hash key is the name of the output field; each value is either @ref Qore::True "True" (meaning no translations are done; the data is copied 1:1) or a hash with the following fields providing information about how the input records should be translated (all fields are optional):
            - \c name: the value of this key gives the name of the input field; only use this if the input record name is different than the output field name
            - \c struct: the value of this key gives the location of the input field in an input hash in dot notation, ex: \c "element.name" would ook for the field's value in the \c "name" key of the \c "element" hash in the input record
            - \c code: a closure or call reference to process the field data
            - \c maxlen: an integer giving the maximum field length in bytes
            - \c trunc: assign to boolean @ref Qore::True "True" if the field should be truncated if over the maximum field length; this key can only be set to @ref Qore::True "True" if the \c "maxlen" key is also given
            - \c mand: assign to boolean @ref Qore::True "True" if the field is mandatory and an exception should be thrown if no input data is supplied
            - \c type: this gives the field type, can be:
              - \c "number": field accepts only numeric values (any non-numeric values on input will cause an exception to be thrown when mapping) 
              - \c "date": date field
            - \c sequence: the name of a sequence to populate the field value from
            @param opts an optional hash of options for the mapper; accepted options are:
              - \c "enc": the output character encoding; if not present then \c "UTF-8" is assumed
              - \c "name": the name of the mapper for use in logging and error strings; note that if not given the table's name will be used automatically
              - \c "trunc": an optional @ref closure "closure" or @ref call_reference "call reference" for a callback for field truncation warnings; must accept a single string giving the warning text
              - \c "input_log": an optional input data logging callback; must accept a hash giving the input data hash
              - \c "output_log": an optional output data logging callback; must accept a hash giving the output data hash
            @param commit_limit row count before a commit is made; if <= 0 then no commits are made by this object, otherwise a commit is made for each \a commit_limit rows processed by this object, commits are made in calls to @ref next()
        */
        constructor(Qore::AbstractIterator $i, SqlUtil::Table $table, hash $map, *hash $opts, int $commit_limit = 0) : Mapper::AbstractMapperIterator($i) {
            $.map = new TableMapper::InboundTableMapper($table, $map, $opts);
            $.commit_limit = $commit_limit > 0 ? $.commit_limit : 0;
        }

        #! creates the iterator from the arguments passed
        /** @param i input iterator; @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()" must return a hash
            @param table the target table object
            @param map a hash providing field mappings; each hash key is the name of the output field; each value is either @ref Qore::True "True" (meaning no translations are done; the data is copied 1:1) or a hash with the following fields providing information about how the input records should be translated (all fields are optional):
            - \c name: the value of this key gives the name of the input field; only use this if the input record name is different than the output field name
            - \c struct: the value of this key gives the location of the input field in an input hash in dot notation, ex: \c "element.name" would ook for the field's value in the \c "name" key of the \c "element" hash in the input record
            - \c code: a closure or call reference to process the field data
            - \c maxlen: an integer giving the maximum field length in bytes
            - \c trunc: assign to boolean @ref Qore::True "True" if the field should be truncated if over the maximum field length; this key can only be set to @ref Qore::True "True" if the \c "maxlen" key is also given
            - \c mand: assign to boolean @ref Qore::True "True" if the field is mandatory and an exception should be thrown if no input data is supplied
            - \c type: this gives the field type, can be:
              - \c "number": field accepts only numeric values (any non-numeric values on input will cause an exception to be thrown when mapping) 
              - \c "date": date field
            - \c sequence: the name of a sequence to populate the field value from
            @param opts an optional hash of options for the mapper; accepted options are:
              - \c "enc": the output character encoding; if not present then \c "UTF-8" is assumed
              - \c "name": the name of the mapper for use in logging and error strings; note that if not given the table's name will be used automatically
              - \c "trunc": an optional @ref closure "closure" or @ref call_reference "call reference" for a callback for field truncation warnings; must accept a single string giving the warning text
              - \c "input_log": an optional input data logging callback; must accept a hash giving the input data hash
              - \c "output_log": an optional output data logging callback; must accept a hash giving the output data hash
            @param commit_limit row count before a commit is made; if <= 0 then no commits are made by this object, otherwise a commit is made for each \a commit_limit rows processed by this object, commits are made in calls to @ref next()
        */
        constructor(Qore::AbstractIterator $i, SqlUtil::AbstractTable $table, hash $map, *hash $opts, int $commit_limit = 0) : Mapper::AbstractMapperIterator($i) {
            $.map = new TableMapper::InboundTableMapper($table, $map, $opts);
            $.commit_limit = $commit_limit > 0 ? $.commit_limit : 0;
        }

        #! creates the iterator from the arguments passed
        /** @param i input iterator; @ref Qore::AbstractIterator::getValue() "AbstractIterator::getValue()" must return a hash
            @param map the mapper to transform the data
            @param commit_limit row count before a commit is made; if <= 0 then no commits are made by this object, otherwise a commit is made for each \a commit_limit rows processed by this object, commits are made in calls to @ref next()
        */
        constructor(Qore::AbstractIterator $i, TableMapper::InboundTableMapper $map, int $commit_limit = 0) : Mapper::AbstractMapperIterator($i) {
            $.map = $map;
            $.commit_limit = $commit_limit > 0 ? $.commit_limit : 0;
        }

        #! returns the current row transformed with the mapper
        hash getValue() {
            my hash $h = $.map.mapData($.i.getValue());

            return $h;
        }

        #! Moves the current position of the input iterator to the next element; returns @ref Qore::False "False" if there are no more elements otherwise inserts the row in the target table and returns @ref Qore::True "True"
        /** if \a commit_limit is > 0 then @ref TableMapper::InboundTableMapper::commit() is called for every \a commit_limit rows according to the internal row count

            @return @ref Qore::False "False" if there are no more elements, in this case if there is an uncommitted transaction according to the internal row count, then @ref TableMapper::InboundTableMapper::commit() is called as well
        */
        bool next() {
            my bool $rv = $.i.next();

            if ($rv)
                $.map.insertRowNoCommit($.i.getValue());

            # commit transaction if necessary
            if ($.commit_limit && (($rv && (++$.cnt == $.commit_limit)) || (!$rv && $.cnt))) {
                $.map.commit();
                $.cnt = 0;
            }

            return $rv;
        }

        #! commits the transaction
        nothing commit() {
            $.map.commit();
        }

        #! rolls back the transaction
        nothing rollback() {
            $.map.rollback();
        }

        #! returns the table name
        string getTableName() {
            return $.map.getTableName();
        }
    }
}
