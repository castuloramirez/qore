# -*- mode: qore; indent-tabs-mode: nil -*-
# @file OracleSqlUtil.qm Qore user module for working with Oracle SQL data

/*  OracleSqlUtil.qm Copyright 2013 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.8 or better
%requires qore >= 0.8.8

# requires the SqlUtil module
%requires SqlUtil >= 1.0

# requires the Util module
%requires Util >= 1.0

# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module OracleSqlUtil {
    version = "1.0";
    desc = "user module for working with Oracle SQL data";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
}

/*  Version History
    * 2013-xx-xx v1.0: David Nichols <david@qore.org>
      + the initial version of the OracleSqlUtil module
*/

/** @mainpage OracleSqlUtil Module

    The %OracleSqlUtil module provides a high level API for working with Oracle database objects.

    Usually this module is loaded on demand from the SqlUtil module, however to use this module
    directly, use \c "%requires OracleSqlUtil" in your code.
    
    All the public symbols in the module are defined in the OracleSqlUtil namespace
*/

#! the OracleSqlUtil namespace contains all the objects in the OracleSqlUtil module
public namespace OracleSqlUtil {
    public OracleTable sub get_table(AbstractDatasource nds, string nname, *hash opts) {
	return new OracleTable(nds, nname, opts);
    }

    public OracleDatabase sub get_database(AbstractDatasource nds, *hash opts) {
	return new OracleDatabase(nds, opts);
    }

    public class OracleColumn inherits AbstractColumn {
        public {
            #! the column uses character semantics
            bool char_used;
            #! byte size of the column
            int byte_size;
        }

        constructor(string n, string nt, *string qt, int sz, bool nul, *string dv, *string cm, bool is_char = False, bool cu = False, int bs) : AbstractColumn(n, nt, qt, sz, nul, dv, cm) {
            # only set "char_used" if we are dealing with a char column
            char_used = is_char && cu;
            byte_size = bs;
        }

        #! returns the string describing the native type that can be used in SQL (for example to add the colunn to a table or when creating the table)
        string getNativeTypeString() {
            if (char_used)
                return sprintf("%s(%d char)", native_type, size);
            return AbstractColumn::getNativeTypeString();
        }

        #! returns a list of sql strings that can be used to add the column to an existing table
        /** @par Example:
            @code
my list $l = $col.getCreateSql($t);
            @endcode

            @param t the AbstractTable object to modify
         */
        list getCreateSql(AbstractTable t) {
	    list l += sprintf("alter table %s add %s", t.getSqlName(), getCreateSql());	    
	    if (comment)
		l += sprintf("comment on column %s.%s is %s", t.getSqlName(), name, t.getSqlValue(comment));
            return l;
        }

        #! returns a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $col.getModifySql($t, $newcol);
            @endcode

            The column names are assumed to be equal

            @param t the AbstractTable object to modify
            @param c the new column definition
         */
        list getModifySql(AbstractTable t, AbstractColumn col) {
            list l = ();
            OracleColumn c = col;

            bool modified;
            string sql = sprintf("alter table %s modify %s", t.getSqlName(), name);

            # get new native type declaration string
            string nts = c.getNativeTypeString();
            if (getNativeTypeString() != nts) {
                sql += sprintf(" %s", nts);
                modified = True;
            }

            if (def_val != c.def_val) {
                sql += sprintf(" default %s", exists c.def_val ? c.def_val : "null");
                modified = True;
            }

            if (nullable != c.nullable) {
                sql += sprintf(" %snull", c.nullable ? "" : "not ");
                modified = True;
            }
            if (modified)
                l += sql;

            # to remove a comment we set it to the empty string ('')
            # http://docs.oracle.com/cd/B28359_01/server.111/b28286/statements_4009.htm
            if (c.comment != comment)
		l += sprintf("comment on column %s.%s is %s", t.getSqlName(), name, c.comment ? t.getSqlValue(c.comment) : "''");
            return l;
        }

        #! returns a string that can be used to rename the column
        /** @par Example:
            @code
my string $str = $col.getRenameSql($t, "new_name");
            @endcode

            @param t the AbstractTable object to modify
            @param new_name the new name for the column

            @return a string that can be used to rename the column
        */
        string getRenameSql(AbstractTable t, string new_name) {
            return sprintf("alter table %s rename column %s to %s", t.getSqlName(), name, new_name);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equalImpl(AbstractColumn c) {
            return char_used == cast<OracleColumn>(c).char_used;
        }
    }

    public class OracleNumberColumn inherits OracleColumn, NumericColumnInfo {
        constructor(string n, string nt, *string qt, int sz, bool nul, *string dv, *string cm, bool cu = False, int bs, int n_scale = 0) :
            OracleColumn(n, nt, qt, sz, nul, dv, cm, False, cu, bs), NumericColumnInfo(n_scale) {
        }

        string getNativeTypeString() {
            return NumericColumnInfo::getNativeTypeString(native_type, size);
        }
    }

    public class OracleIndex inherits AbstractIndex {
        public {
            #! the native type of the index (if supported)
            string native_type;

            #! the tablespace name of the index (if supported)
            *string tablespace;
        }

        #! creates the object from the arguments
        constructor(string n, bool u, hash c, string nt, *string t) : AbstractIndex(n, u, c) {
            native_type = nt;
            tablespace = t;
        }

        #! returns a string that can be used to create the index in the database
        string getCreateSql(string table_name, *hash opt) {
            string sql = sprintf("create %sindex %s on %s (%s)", unique ? "unique " : "", name, table_name, (foldl $1 + ", " + $2, columns.keyIterator()));

            *string ts = opt.index_tablespace ? opt.index_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            if (opt.compute_statistics)
                sql += " compute statistics";

            return sql;
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current index, @ref Qore::False "False" if not
        bool equalImpl(AbstractIndex ix) {
            return True;
        }

        #! returns a string that can be used to rename the index in the database
        string getRenameSql(string table_name, string new_name) {
            return sprintf("alter index %s rename to %s", name, new_name);
        }
    }

    public class OracleForeignConstraint inherits AbstractForeignConstraint {
        public {
            #! @ref Qore::True "True" if the constraint is enabled, @ref Qore::False "False" if not
            bool enabled;
        }

        constructor(string n, Columns c, ForeignConstraintTarget t, bool e) : AbstractForeignConstraint(n, c, t) {
            enabled = e;
        }

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s foreign key (%s) references %s (%s)", table_name, name, (foldl $1 + ", " + $2, columns.keys()), target.table, (foldl $1 + ", " + $2, target.columns.keys()));
        }

        string getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }
    }

    public class OracleCheckConstraint inherits AbstractCheckConstraint {
        public {
            #! @ref Qore::True "True" if the constraint is enabled, @ref Qore::False "False" if not
            bool enabled;
        }

        constructor(string n, string n_src, bool e = True) : AbstractCheckConstraint(n, n_src) {
            enabled = e;
        }        

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s check (%s)", table_name, name, src);
        }

        string getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }
    }

    public class OracleUniqueConstraint inherits AbstractUniqueConstraint {
        public {
            #! @ref Qore::True "True" if the constraint is enabled, @ref Qore::False "False" if not
            bool enabled;

            #! any tablespace for the unique key index
            *string tablespace;

            #! index the constraint is based on
            *string index;
        }

        constructor(string n, hash n_cols, bool e = True, *string ts) : AbstractUniqueConstraint(n, n_cols) {
            enabled = e;
            tablespace = ts;
        }

        bool setIndexBase(string ix) {
            if (index && index != ix)
                return False;
            index = ix;
            delete tablespace;
            return True;
        }

        string getCreateSql(string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s unique (%s)", table_name, name, (foldl $1 + ", " + $2, keyIterator()));
            *string ix = opts.index ? opts.index : index;
            if (ix)
                sql += sprintf(" using index %s", ix);
            else {
                *string ts = opts.index_tablespace ? opts.index_tablespace : tablespace;
                if (ts) {
                    sql += sprintf(" using index tablespace %s", ts);
                    if (opts.compute_statistics)
                        sql += " compute statistics";
                }
            }

            return sql;
        }

        string getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }
    }

    public class OraclePrimaryKey inherits AbstractPrimaryKey {
        public {
            #! any tablespace for the primary key index
            *string tablespace;

            #! index the constraint is based on
            *string index;
        }

        constructor(string n, *hash c, *string ts) : AbstractPrimaryKey(n, c) {
            tablespace = ts;
        }

        bool setIndexBase(string ix) {
            if (index && index != ix)
                return False;
            index = ix;
            delete tablespace;
            return True;
        }

        string getCreateSql(string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s primary key (%s)", table_name, name, (foldl $1 + ", " + $2, keyIterator()));
            *string ix = opts.index ? opts.index : index;
            if (ix)
                sql += sprintf(" using index %s", ix);
            else {
                *string ts = opts.index_tablespace ? opts.index_tablespace : tablespace;
                if (ts) {
                    sql += sprintf(" using index tablespace %s", ts);
                    if (opts.compute_statistics)
                        sql += " compute statistics";
                }
            }

            return sql;
        }

        string getRenameSql(string table_name, string new_name) {
            return sprintf("alter table %s rename constraint %s to %s", table_name, name, new_name);
        }
    }

    public class OracleTrigger inherits AbstractTrigger {
        public {
            #! @ref Qore::True "True" if the trigger is enabled, @ref Qore::False "False" if not
            bool enabled;
        }

        constructor(string n, string n_src, bool en = True) : AbstractTrigger(n, n_src) {
            enabled = en;
        }

        softlist getCreateSql(string table_name, *hash opt) {
            return sprintf("create%s trigger %s %s", opt.replace ? " or replace" : "", name, src);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equalImpl(AbstractFunctionBase t) {
            return enabled == cast<OracleTrigger>(t).enabled;
        }
    }

    public class OracleFunctionBase inherits AbstractFunction {
        #! creates the object from the arguments passed
        /** @param n the name of the object
            @param n_type the type of object
            @param n_src the source of the object
         */
        constructor(string n, string n_type, string n_src) : AbstractFunction(n, n_type, n_src) {
        }

        #! returns a string that can be used to create the object in the database
        softlist getCreateSql(*hash opt) {
            return sprintf("create%s %s", opt.replace ? " or replace" : "", src);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equalImpl(AbstractFunctionBase t) {
            return True;
        }
    }

    public class OracleFunction inherits OracleFunctionBase {
        #! creates the object from the arguments passed
        /** @param n the name of the function
            @param n_src the source of the function
         */
        constructor(string n, string n_src) : OracleFunctionBase(n, "function", n_src) {
        }
    }

    public class OracleProcedure inherits OracleFunctionBase {
        #! creates the object from the arguments passed
        /** @param n the name of the function
            @param n_src the source of the function
         */
        constructor(string n, string n_src) : OracleFunctionBase(n, "procedure", n_src) {
        }
    }

    public class OraclePackage inherits OracleFunctionBase {
        private {
            #! package body source
            string body_src;
        }

        #! creates the object from the arguments passed
        /** @param n the name of the package
            @param n_src the source of the package declaration
            @param n_body_src the package body source
         */
        constructor(string n, string n_src, string n_body_src) : OracleFunctionBase(n, "package", n_src) {
            body_src = n_body_src;
        }

        #! returns a string that can be used to create the package in the database
        list getCreateSql(*hash opt) {
            list l = ();
            # package declaration
            l += sprintf("create%s %s", opt.replace ? " or replace" : "", src);
            # package body
            l += sprintf("create%s body %s", opt.replace ? " or replace" : "", body_src);
            return l;
        }
    }

    public class OracleDatabase inherits AbstractDatabase {
        constructor(AbstractDatasource nds, *hash opts) : AbstractDatabase(nds, opts) {
        }

        OracleFunction makeFunctionImpl(string name, string src, *hash opts) {
            return new OracleFunction(name, src);
        }

        OracleProcedure makeProcedureImpl(string name, string src, *hash opts) {
            return new OracleProcedure(name, src);
        }

        OraclePackage makePackage(string name, string src, string body, *hash opts) {
            return new OraclePackage(name, src, body);
        }

        *OracleFunction getFunctionImpl(string name) {
            *list l = ds.select("select text from user_source where type = 'FUNCTION' and name = %v order by line", name.upr()).text;
            if (!l)
                return;
            string src = foldl $1 + $2, l;
            return new OracleFunction(name, src);
        }

        *OracleProcedure getProcedureImpl(string name) {
            *list l = ds.select("select text from user_source where type = 'PROCEDURE' and name = %v order by line", name.upr()).text;
            if (!l)
                return;
            string src = foldl $1 + $2, l;

            return new OracleProcedure(name, src);
        }

        OraclePackage getPackage(string name) {
            *list l = ds.select("select text from user_source where type = 'PACKAGE' and name = %v order by line", name.upr()).text;
            if (!l)
                throw "PACKAGE-ERROR", sprintf("cannot find any package %y", name);
            string src = foldl $1 + $2, l;

            l = ds.select("select text from user_source where type = 'PACKAGE BODY' and name = %v order by line", name.upr()).text;
            if (!l)
                throw "PACKAGE-ERROR", sprintf("cannot find body for package %y", name);
            string body_src = foldl $1 + $2, l;

            return new OraclePackage(name, src, body_src);
        }

        #! returns a list of string synonym names in the database
        list listSynonyms() {
            return listSynonymsImpl();
        }
        
        #! returns an iterator listing the string synonym names in the database
        ListIterator synonymIterator() {
            return listSynonymsImpl().iterator();            
        }

        list listTablesImpl() {
            return getListIntern(ds.select("select table_name from all_tables").table_name);
        }

        list listFunctionsImpl() {
            return getListIntern(ds.select("select object_name from user_objects where object_type = 'FUNCTION'").object_name);
        }

        list listProceduresImpl() {
            return getListIntern(ds.select("select object_name from user_objects where object_type = 'PROCEDURE'").object_name);
        }

        list listSynonymsImpl() {
            return getListIntern(ds.select("select object_name from user_objects where object_type = 'SYNONYM'").object_name);
        }

        list listSequencesImpl() {
            return getListIntern(ds.select("select object_name from user_objects where object_type = 'SEQUENCE'").object_name);
        }

        list listViewsImpl() {
            return getListIntern(ds.select("select object_name from user_objects where object_type = 'VIEW'").object_name);
        }

        private list getListIntern(list l) {
            return native_case ? l : (map $1.lwr(), l);
        }
    }

    public class OracleTable inherits AbstractTable {
        public {
            const OraTypeMap = (
                "number": ("qore": Type::Number, "size": SZ_NUM, "size_range": (1, 38), "scale_range": (-84, 127)),
                "varchar2": ("qore": Type::String, "size": SZ_MAND, "size_range": (1, 4000), "is_char": True),
                "char": ("qore": Type::String, "size": SZ_MAND, "size_range": (1, 4000), "is_char": True),
                "date": ("qore": Type::Date,),
		"timestamp": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 9)),
		"timestamp with time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 9)),
		"timestamp with local time zone": ("qore": Type::Date, "size": SZ_OPT, "size_range": (0, 9)),
                "timestamp(0)": ("qore": Type::Date,),
                "timestamp(1)": ("qore": Type::Date,),
                "timestamp(2)": ("qore": Type::Date,),
                "timestamp(3)": ("qore": Type::Date,),
                "timestamp(4)": ("qore": Type::Date,),
                "timestamp(5)": ("qore": Type::Date,),
                "timestamp(6)": ("qore": Type::Date,),
                "timestamp(7)": ("qore": Type::Date,),
                "timestamp(8)": ("qore": Type::Date,),
                "timestamp(9)": ("qore": Type::Date,),
                "timestamp(0) with time zone": ("qore": Type::Date,),
                "timestamp(1) with time zone": ("qore": Type::Date,),
                "timestamp(2) with time zone": ("qore": Type::Date,),
                "timestamp(3) with time zone": ("qore": Type::Date,),
                "timestamp(4) with time zone": ("qore": Type::Date,),
                "timestamp(5) with time zone": ("qore": Type::Date,),
                "timestamp(6) with time zone": ("qore": Type::Date,),
                "timestamp(7) with time zone": ("qore": Type::Date,),
                "timestamp(8) with time zone": ("qore": Type::Date,),
                "timestamp(9) with time zone": ("qore": Type::Date,),
                "timestamp(0) with local time zone": ("qore": Type::Date,),
                "timestamp(1) with local time zone": ("qore": Type::Date,),
                "timestamp(2) with local time zone": ("qore": Type::Date,),
                "timestamp(3) with local time zone": ("qore": Type::Date,),
                "timestamp(4) with local time zone": ("qore": Type::Date,),
                "timestamp(5) with local time zone": ("qore": Type::Date,),
                "timestamp(6) with local time zone": ("qore": Type::Date,),
                "timestamp(7) with local time zone": ("qore": Type::Date,),
                "timestamp(8) with local time zone": ("qore": Type::Date,),
                "timestamp(9) with local time zone": ("qore": Type::Date,),
                "interval year(0) to month": ("qore": Type::Date,),
                "interval year(1) to month": ("qore": Type::Date,),
                "interval year(2) to month": ("qore": Type::Date,),
                "interval year(3) to month": ("qore": Type::Date,),
                "interval year(4) to month": ("qore": Type::Date,),
                "interval year(5) to month": ("qore": Type::Date,),
                "interval year(6) to month": ("qore": Type::Date,),
                "interval year(7) to month": ("qore": Type::Date,),
                "interval year(8) to month": ("qore": Type::Date,),
                "interval year(9) to month": ("qore": Type::Date,),
                "interval day(0) to second(0)": ("qore": Type::Date,),
                "interval day(0) to second(1)": ("qore": Type::Date,),
                "interval day(0) to second(2)": ("qore": Type::Date,),
                "interval day(0) to second(3)": ("qore": Type::Date,),
                "interval day(0) to second(4)": ("qore": Type::Date,),
                "interval day(0) to second(5)": ("qore": Type::Date,),
                "interval day(0) to second(6)": ("qore": Type::Date,),
                "interval day(0) to second(7)": ("qore": Type::Date,),
                "interval day(0) to second(8)": ("qore": Type::Date,),
                "interval day(0) to second(9)": ("qore": Type::Date,),
                "interval day(1) to second(0)": ("qore": Type::Date,),
                "interval day(1) to second(1)": ("qore": Type::Date,),
                "interval day(1) to second(2)": ("qore": Type::Date,),
                "interval day(1) to second(3)": ("qore": Type::Date,),
                "interval day(1) to second(4)": ("qore": Type::Date,),
                "interval day(1) to second(5)": ("qore": Type::Date,),
                "interval day(1) to second(6)": ("qore": Type::Date,),
                "interval day(1) to second(7)": ("qore": Type::Date,),
                "interval day(1) to second(8)": ("qore": Type::Date,),
                "interval day(1) to second(9)": ("qore": Type::Date,),
                "interval day(2) to second(0)": ("qore": Type::Date,),
                "interval day(2) to second(1)": ("qore": Type::Date,),
                "interval day(2) to second(2)": ("qore": Type::Date,),
                "interval day(2) to second(3)": ("qore": Type::Date,),
                "interval day(2) to second(4)": ("qore": Type::Date,),
                "interval day(2) to second(5)": ("qore": Type::Date,),
                "interval day(2) to second(6)": ("qore": Type::Date,),
                "interval day(2) to second(7)": ("qore": Type::Date,),
                "interval day(2) to second(8)": ("qore": Type::Date,),
                "interval day(2) to second(9)": ("qore": Type::Date,),
                "clob": ("qore": Type::String,),
                "blob": ("qore": Type::Binary,),
                "long": ("qore": Type::Binary,),
                "raw": ("qore": Type::Binary, "size": SZ_MAND, "size_range": (1, 2000)),
                "bfile": ("qore": Type::Binary,),
                "binary_float": ("qore": Type::Float,),
                "binary_double": ("qore": Type::Float,),
                "rowid": ("qore": Type::String,),
                "urowid": ("qore": Type::String, "size": SZ_OPT, "size_range": (1, 4000)),
                );

            const QoreTypeMap = (
                "integer": "number",
                "float": "number",
                "number": "number",
                "string": "varchar2",
                "date": "timestamp(6)",
                "binary": "blob",
                SqlUtil::CHAR: "char",
                SqlUtil::CLOB: "clob",
                SqlUtil::BLOB: "blob",
                );

            const OraColumnOptions = AbstractTable::ColumnOptions + (
                "character_semantics": Type::Boolean,
                );

            const OracleIndexOptions = AbstractTable::IndexOptions + (
                "compute_statistics": Type::Boolean,
                );

            const OracleConstraintOptions = OracleIndexOptions + (
                "index": Type::String,
                );

            #! Oracle table creation options
            const OracleTableCreationOptions = AbstractTable::TableCreationOptions + OracleConstraintOptions;

            const OracleAlignTableOptions = AbstractTable::AlignTableOptions + OracleTableCreationOptions;
        }

        private {
	    # schema name
            string schema;

	    # tablespace name
            string tablespace;

	    # is the table read only?
            bool readonly;
	    
	    # table comment
            *string comment;

            #! does the current oracle driver support long values?
            bool has_long;
        }

        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
            # see if there is a schema in the name
            *string sstr = (nname =~ x/^(\w+)\.\w+/)[0];
            if (sstr) {
                schema = sstr;
                splice nname, 0, schema.size() + 1;
                name = nname;
            }
            else
		schema = ds.getUserName();

            # the oracle driver >= 3.0 supports selecting from LONG columns
            has_long = compare_version("3.0", getModuleHash().oracle.version) >= 0;
        }

        private bool checkExistenceImpl() {
            if (schema.lwr() == ds.getUserName().lwr()) {
                try {
                    setTable();
                }
                catch (hash ex) {
                    if (ex.err == "TABLE-ERROR")
                        return False;
                    rethrow;
                }
                return True;
            }

            *hash row = ds.selectRow("select * from all_tables where owner = %v and table_name = %v", schema.upr(), name.upr());
            return row ? True : False;
        }

	private setTableInfoIntern() {
	    hash row = (schema.lwr() == ds.getUserName().lwr()) ? setTable() : setSchemaTable();

            tablespace = row.tablespace_name;
            readonly = row.read_only == "YES";
            if (!native_case)
                tablespace = tablespace.lwr();

            # get any comment
            any cm = ds.selectRow("select * from all_tab_comments where owner = %v and table_name = %v", schema.upr(), name.upr()).comments;
            comment = cm ? cm : NOTHING;

	    inDb = True;
	}

        string getSqlName() {
            return sprintf("%s.%s", schema, name);
        }

        private hash setSchemaTable() {
            # get the table information if possible
            *hash row = ds.selectRow("select * from all_tables where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (!row)
                throw "TABLE-ERROR", sprintf("table %y.%y does not exist or is not accessible to this user (%s)", schema, name, getDBString());
            return row;
        }

        private hash setTable() {
            # see if the current user has the table
            *hash row = ds.selectRow("select * from user_tables where table_name = %v", name.upr());
            if (row) {
                schema = getUserSchema();
                return row;
            }

            bool pub = False;
            # see if there is a user synonym with this name
            row = ds.selectRow("select * from user_synonyms where synonym_name = %v", name.upr());
            if (!row) {
                # see if there is a public synonym with this name
                row = ds.selectRow("select * from all_synonyms where owner = 'PUBLIC' and synonym_name = %v", name.upr());
                if (!row)
                    throw "TABLE-ERROR", sprintf("table %y or synonym %y does not exist or is not accessible to this user (%s)", name, name, getDBString());
                pub = True;
            }
            
            # update the table name if necessary
            string orig_name = name;
            if (name.upr() != row.table_name) {
                name = row.table_name;
                if (!native_case)
                    name = name.lwr();
            }
            
            schema = row.table_owner;
            if (!native_case)
                schema = schema.lwr();
            
            # get the table information if possible
            row = ds.selectRow("select * from all_tables where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (!row)
                throw "TABLE-ERROR", sprintf("%y is a %ssynonym pointing to table %y.%y which does not exist or is not accessible to this user (%s)", orig_name, pub ? "public " : "", schema, name, getDBString());
            return row;
        }

        private string getUserSchema() {
            string rv = ds.getUserName();
            if (native_case)
                rv = rv.upr();
            return rv;
        }

        private string getDBString() {
            return sprintf("%s@%s", ds.getUserName(), ds.getDBName());
        }

        string getSchemaName() {
            return schema;
        }

        *string getTablespaceName() {
            return tablespace;
        }

        *string getComment() {
            return comment;
        }

        bool readOnly() {
            return readonly;
        }

        private hash getColumnOptions() {
            return OraColumnOptions;
        }

        private Columns describeImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            # get column descriptions
            *hash qh = ds.select("select col.column_name, data_type, data_length, data_precision, data_scale, nullable, data_default, char_length, char_used, comments from all_tab_columns col, all_col_comments com where col.owner = %v and col.table_name = %v and com.owner = col.owner and com.table_name = col.table_name and com.column_name = col.column_name order by column_id", schema.upr(), name.upr());
            if (!qh.column_name)
                throw "TABLE-ERROR", sprintf("cannot retrieve table information for table %y in %y", name, dsdesc);

            hash rv;
            foreach hash row in (qh.contextIterator()) {
                *hash th = OraTypeMap.(row.data_type.lwr());
                int size = row.data_type == "NUMBER" && row.data_precision ? row.data_precision : row.data_length;
                switch (row.data_type) {
                    case "ROWID":
                    case "UROWID":
                    case "DATE":
                    case "BINARY_FLOAT":
                    case "BINARY_DOUBLE":
                    case =~ /^TIMESTAMP/:
                    case =~ /^INTERVAL/:
                    case "BFILE":
                    case "BLOB":
                    case "CLOB": size = 0; break;
                }
                if (!native_case) {
                    row.column_name = row.column_name.lwr();
                    row.data_type = row.data_type.lwr();
                }
                trim row.data_default;

                OracleColumn c;
                if (row.data_precision) 
                    c = new OracleNumberColumn(row.column_name, row.data_type, th.qore, row.data_precision, row.nullable == "Y", row.data_default ? row.data_default : NOTHING, row.comments ? row.comments : NOTHING, row.char_used == "C", row.data_length, row.data_scale);
                else
                    c = new OracleColumn(row.column_name, row.data_type, th.qore, size, row.nullable == "Y", row.data_default ? row.data_default : NOTHING, row.comments ? row.comments : NOTHING, th.is_char, row.char_used == "C", row.data_length);

                rv.(row.column_name) = c;
            }

            return new Columns(rv);
        }

        private *OraclePrimaryKey getPrimaryKeyImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            hash rv;

            # get primary key description
            *hash qh = ds.select("select cons.constraint_name, cols.column_name, cols.position, cons.status, cons.owner from all_constraints cons, all_cons_columns cols where cols.owner = %v and cols.table_name = %v and cons.constraint_type = 'P' and cons.owner = %v and cons.constraint_name = cols.constraint_name order by cols.position", schema.upr(), name.upr(), schema.upr());
            if (!qh.constraint_name)
                return;

            foreach string col in (qh.column_name) {
                string cn = native_case ? col : col.lwr();
                rv{cn} = columns{cn};
            }

            string pkname = qh.constraint_name[0];
            if (!native_case)
                pkname = pkname.lwr();
            return new OraclePrimaryKey(pkname, rv);
        }

        private Indexes getIndexesImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            hash rv;

            # get index description
            *hash qh = ds.select("select index_name, index_type, uniqueness, tablespace_name from all_indexes where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (qh.index_name) {
                hash ih;

                # get column info for all indexes in 1 query
                *hash iqh = ds.select("select c.index_name, c.column_name, e.column_expression from all_ind_columns c left join all_ind_expressions e on (c.table_owner = e.index_owner and c.index_name = e.index_name and c.table_name = e.table_name) where c.table_owner = %v and c.table_name = %v order by c.index_name, c.column_position", schema.upr(), name.upr());
                foreach hash row in (iqh.contextIterator()) {
                    if (!native_case)
                        map row.$1 = row.$1.lwr(), ("index_name", "column_name", "column_expression"), row.$1;
                    # process function indexes
                    if (row.column_expression) {
                        row.column_expression =~ s/"//g;
                        ih{row.index_name}{row.column_expression} = hash();
                    }
                    else
                        ih{row.index_name}{row.column_name} = columns{row.column_name};
                }
                
                foreach hash row in (qh.contextIterator()) {
                    if (!native_case) {
                        row.index_name = row.index_name.lwr();
                        row.tablespace_name = row.tablespace_name.lwr();
                    }
                    # skip system indexes
                    if (!ih{row.index_name})
                        continue;
                    rv.(row.index_name) = new OracleIndex(row.index_name, row.uniqueness == "UNIQUE", ih{row.index_name}, row.index_type, row.tablespace_name);
                }

            }

            return new Indexes(rv);
        }

        private ForeignConstraints getForeignConstraintsImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            hash ch;

            # get foreign referential constraints
            *hash qh = ds.select("select constraint_name, status from user_constraints where owner = %v and table_name = %v and constraint_type = 'R'", schema.upr(), name.upr());
            if (qh.status) {
                hash rv;
                foreach hash row in (qh.contextIterator()) {
                    if (!native_case)
                        row.constraint_name = row.constraint_name.lwr();
                    rv.(row.constraint_name) = (
                        "enabled": row.status == "ENABLED",
                        );
                }
                qh = ds.select("select c.constraint_name, status, cols1.column_name source_column, cols1.position, cols2.table_name target_table, cols2.column_name target_column from all_constraints c, all_cons_columns cols1, all_cons_columns cols2 where c.owner = %v and c.table_name = %v and c.constraint_name = cols1.constraint_name and constraint_type = 'R' and c.r_constraint_name = cols2.constraint_name and cols1.position = cols2.position and cols1.owner = c.owner and cols2.owner = c.owner order by cols1.position", schema.upr(), name.upr());
                foreach hash row in (qh.contextIterator()) {
                    if (!native_case) {
                        row.constraint_name = row.constraint_name.lwr();
                        row.source_column = row.source_column.lwr();
                        row.target_column = row.target_column.lwr();
                        row.target_table = row.target_table.lwr();
                    }
                    reference c = \rv.(row.constraint_name);
                    c.columns.(row.source_column) = columns{row.source_column};
                    c.target.table = row.target_table;
                    c.target.columns.(row.target_column) = True;
                }

                # temporary foreign table buffer hash
                hash fth;
                foreach hash c in (rv.pairIterator()) {
                    # get a description of the target table for the target column descriptions
                    if (!fth{c.value.target.table})
                        fth{c.value.target.table} = new OracleTable(ds, c.value.target.table, opts);
                    ForeignConstraintTarget fct(c.value.target.table, fth{c.value.target.table}.describe().subset(c.value.target.columns.keys()));
                    ch.(c.key) = new OracleForeignConstraint(c.key, new Columns(c.value.columns), fct, c.value.enabled);
                }
            }

            return new ForeignConstraints(ch);
        }

        private Constraints getConstraintsImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            # if we cannot select "long" values then skip this: all_constraints.search_condition is a LONG for example
            if (!has_long)
                return new Constraints();

            # get only user check constraints
            *hash qh = ds.select("select constraint_name, search_condition, status from all_constraints where owner = %v and table_name = %v and constraint_type = 'C' and generated != 'GENERATED NAME'", schema.upr(), name.upr());
            hash rv;
            foreach hash row in (qh.contextIterator()) {
                if (!native_case)
                    row.constraint_name = row.constraint_name.lwr();
                rv.(row.constraint_name) = new OracleCheckConstraint(row.constraint_name, row.search_condition, row.status == "ENABLED");
            }
            
            Constraints c(rv);

            # now get unique constraints
            qh = ds.select("select c.constraint_name, status, cols.column_name, cols.position, status from all_constraints c, all_cons_columns cols where c.owner = %v and c.table_name = %v and c.constraint_name = cols.constraint_name and constraint_type = 'U' and cols.owner = c.owner and generated != 'GENERATED NAME' order by cols.position", schema.upr(), name.upr());
            delete rv;
            foreach hash row in (qh.contextIterator()) {
                if (!native_case)
                    map row.$1 = row.$1.lwr(), ("constraint_name", "column_name");
                reference ch = \rv.(row.constraint_name);
                if (!ch)
                    ch = new OracleUniqueConstraint(row.constraint_name, hash(), row.status == "ENABLED");
                ch.add(row.column_name, columns{row.column_name});
            }
            
            # add unique constraints to constraint hash
            map c.add($1.key, $1.value), rv.pairIterator();

            return c;
        }

        private Triggers getTriggersImpl() {
	    if (!tablespace)
		setTableInfoIntern();

            hash rv;

            # get trigger description
            *hash qh = ds.select("select * from all_triggers where owner = %v and table_name = %v", schema.upr(), name.upr());
            foreach hash row in (qh.contextIterator()) {
                if (!native_case)
                    map row.$1 = row.$1.lwr(), ("trigger_name", "trigger_type", "triggering_event", "referencing_names");
                #printf("%y: %s\n", row.trigger_name, row.description);

                # replace newlines with spaces
                row.description =~ s/\n/ /g;
                trim row.description;

                # remove trigger name from description line
                splice row.description, 0, row.trigger_name.size() + 1;
                rv{row.trigger_name} = new OracleTrigger(row.trigger_name, row.description + "\n" + row.trigger_body, row.status == "ENABLED");
            }
            
            return new Triggers(rv);
        }

        string getCreateTableSqlImpl(*hash opt) {
            string sql = sprintf("create%s table %s (\n", opt.replace ? " or replace" : "", name);

            sql += foldl $1 + ",\n" + $2, (map "  " + $1.getCreateSql(), columns.iterator());
            sql += "\n)";

            *string ts = opt.data_tablespace ? opt.data_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            return sql;
        }

        *list getCreateIndexesSqlImpl(*hash opt) {
            return map $1.getCreateSql(name, opt), indexes.iterator();
        }

        *string getCreatePrimaryKeySqlImpl(*hash opt) {
            return primaryKey.getCreateSql(name, opt);
        }

        *list getCreateForeignConstraintsSqlImpl(*hash opt) {
            return map $1.getCreateSql(name, opt), foreignConstraints.iterator();
        }

        *list getCreateConstraintsSqlImpl(*hash opt) {
            return map $1.getCreateSql(name, opt), constraints.iterator();
        }

        *list getCreateMiscSqlImpl(*hash opt, bool cache) {
	    if (cache)
		getColumnsUnlocked();
            return map sprintf("comment on column %s.%s is '%s'", name, $1.name, $1.comment), columns.iterator(), $1.comment;
        }

        *list getCreateTriggersSqlImpl(*hash opt) {
            list l = ();
            map l += $1.getCreateSql(name, opt), triggers.iterator();
            return l;
        }

        string getCreateSqlImpl(list l) {
            return !l ? "" : foldl $1 + "\n" + $2, (map sprintf("%s%s", $1, $1 =~ /;$/ ? "\n/" : ";"), l);
        }

        string getRenameSqlImpl(string new_name) {
            return sprintf("alter table %s rename to %s", getSqlName(), new_name);
        }

        private AbstractColumn addColumnImpl(string cname, hash opt, bool nullable = True) {
            if (opt.precision)
                return new OracleNumberColumn(cname, opt.native_type, opt.qore_type, opt.precision, nullable, opt.default_value, opt.comment, opt.character_semantics, 0, opt.scale);
            return new OracleColumn(cname, opt.native_type, opt.qore_type, opt.size, nullable, opt.default_value, opt.comment, opt.local_def.is_char, opt.character_semantics, 0);
        }

        private AbstractPrimaryKey addPrimaryKeyImpl(string cname, hash ch, *hash opt) {
            return new OraclePrimaryKey(cname, ch, opt.index_tablespace);
        }

        private AbstractIndex addIndexImpl(string iname, bool enabled, hash ch, *hash opt) {
            return new OracleIndex(iname, enabled, ch, "normal", opt.index_tablespace);
        }

        private AbstractForeignConstraint addForeignConstraintImpl(string cname, hash ch, string table, hash tch, *hash opt) {
            ForeignConstraintTarget fct(table, new Columns(tch));
            return new OracleForeignConstraint(cname, new Columns(ch), fct, True);
        }

        private AbstractCheckConstraint addCheckConstraintImpl(string cname, string src, *hash opt) {
            return new OracleCheckConstraint(cname, src);
        }

        private AbstractUniqueConstraint addUniqueConstraintImpl(string cname, hash ch, *hash opt) {
            return new OracleUniqueConstraint(cname, ch, True, opt.index_tablespace);
        }

        private AbstractTrigger addTriggerImpl(string tname, string src, *hash opt) {
            return new OracleTrigger(tname, src);
        }

        private *list getAlignSqlImpl(AbstractTable t, *hash opt) {
        }

        private hash getQoreTypeMapImpl() {
            return QoreTypeMap;
        }

        private hash getTypeMapImpl() {
            return OraTypeMap;
        }

        private hash getIndexOptions() {
            return OracleIndexOptions;
        }

        private hash getConstraintOptions() {
            return OracleConstraintOptions;
        }

        private hash getTableCreationOptions() {
            return OracleTableCreationOptions;
        }

        private hash getAlignTableOptions() {
            return OracleAlignTableOptions;
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument; returns NOTHING if the type cannot be converted to an SQL string
        private *string getSqlValueImpl(any v) {
            switch (v.typeCode()) {
                case NT_FLOAT:
                case NT_INT: return v.toStr();

                case NT_NUMBER: return string(v);

                # double any single quotes in strings
                case NT_STRING: v =~ s/'/''/g; return "'" + v + "'";

                case NT_NULL:
                case NT_NOTHING: return "null";

                case NT_BOOLEAN: return v ? "1" : "0";

                case NT_DATE: return sprintf("to_date('%s', 'YYYYMMDDHH24MISS')", v.format("YYYYMMDDHHmmSS"));
            }
        }

        private bool emptyImpl() {
            return True;
        }

        private setupTableImpl(hash desc, *hash opt) {
        }
    }
}
