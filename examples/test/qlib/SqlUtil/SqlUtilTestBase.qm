#!/usr/bin/env qore
# -*- mode: qore; indent-tabs-mode: nil -*-

%new-style
%enable-all-warnings
%require-types
%strict-args

module SqlUtilTestBase {
    version = "0.1";
    desc = "SqlUtil test base module";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

%requires ../../../../qlib/QUnit.qm
%requires ../../../../qlib/SqlUtil.qm
%requires ../../../../qlib/BulkSqlUtil.qm
%requires ../../../../qlib/Schema.qm

public class SqlUtilTestSchema inherits AbstractSchema {
    constructor(AbstractDatasource ds, *string dts, *string its) : AbstractSchema(ds, dts, its) {
    }

    log(string fmt) {
        delete argv;
    }

    logpf(string fmt) {
        delete argv;
    }

    logProgress(string fmt) {
        delete argv;
    }
}

public class SqlTestBase inherits QUnit::Test {
    private {
        AbstractSchema schema;
        AbstractTable table;

        const MyOpts = Opts + (
            "connstr": "c,conn=s",
            );

        const OptionColumn = 22;

        hash expect_data;

        list insert_data;
        list upsert_data;
    }

    constructor(string testName, string testVer, any args, *hash mopts) : Test(testName, testVer, \args, mopts) {
        addTestCase("Insert", \insertTest());
        addTestCase("Select", \selectTest());
        addTestCase("Update", \updateTest());
        addTestCase("Upsert", \upsertTest());
        addTestCase("BulkInsert", \bulkInsertTest());
        addTestCase("BulkUpsert", \bulkUpsertTest());
    }

    globalTearDown() {
        # drop the test schema
        if (schema)
            schema.drop(False, m_options.verbose);
    }

    insertTest() {
        if (!table)
            testSkip("no DB connection");

        on_success table.commit();
        on_error table.rollback();

        foreach hash data in (insert_data)
            assertEq(NOTHING, table.insert(data));
    }

    selectTest() {
        if (!table)
            testSkip("no DB connection");

        on_success table.commit();
        on_error table.rollback();

        *list rows = table.selectRows();
        assertEq (2, rows.size());

        foreach hash e in (expect_data.pairIterator()) {
            # printf("* %s\n", e.key);
            # printf("  I: %s: %N\n", insert_data[0]{e.key}.type(), insert_data[0]{e.key});
            # printf("  R: %s: %N\n", rows[0]{e.key}.type(), rows[0]{e.key});
            if (e.value === NOTHING)
                continue; # skipping assertion
            assertEq (e.value, rows[0]{e.key}, "checking data in column " + e.key);
        }
    }

    updateTest() {
        if (!table)
            testSkip("no DB connection");

        on_success table.commit();
        on_error table.rollback();

        map assertEq(1, table.update($1 - "id", ("id": $1.id))), insert_data;
    }

    upsertTest() {
        if (!table)
            testSkip("no DB connection");

        on_success table.commit();
        on_error table.rollback();

        code upsert = table.getUpsertClosure(upsert_data[0]);
        assertEq(AbstractTable::UR_Verified, upsert(upsert_data[0]));
        # upsert can return UR_Verified even when rows are upserted when there is an optimized upsert implementation used in the driver-specific SqlUtil module
        assertEq(True, inlist(upsert(upsert_data[1]), (AbstractTable::UR_Inserted, AbstractTable::UR_Verified)));
    }

    bulkInsertTest() {
        if (!table)
            testSkip("no DB connection");

        on_success table.commit();
        on_error table.rollback();

        table.del();

        BulkInsertOperation insert(table);
        on_success insert.flush();
        on_error insert.discard();

        foreach hash data in (insert_data)
            assertEq(NOTHING, insert.queueData(data));
    }

    bulkUpsertTest() {
        if (!table)
            testSkip("no DB connection");

        on_success table.commit();
        on_error table.rollback();

        table.del();

        BulkUpsertOperation insert(table);
        on_success insert.flush();
        on_error insert.discard();

        foreach hash data in (upsert_data)
            assertEq(NOTHING, insert.queueData(data));
    }

    static string getColumnName(string n) {
        n =~ s/ //g;
        return n + "_f";
    }

    init_test_data (hash custom_columns) {
        hash row;

        foreach hash h in (custom_columns.pairIterator()) {
            string cn = getColumnName(h.key);
            row{cn} = h.value.bind ?? h.value.value ?? h.value;

            if (h.value.typeCode() == NT_HASH && h.value.hasKey('expect'))
                expect_data{cn} = h.value.expect;
            else
                expect_data{cn} = h.value.bind.'^value^' ?? h.value.value ?? h.value;
        }
        insert_data = (("id": 1,) + row, ("id": 2,) + row,);
        upsert_data = (("id": 2,) + row, ("id": 3,) + row,);
    }
}
