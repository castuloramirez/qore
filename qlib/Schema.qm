# -*- mode: qore; indent-tabs-mode: nil -*-
# @file Schema.qm Qore user module for working with SQL data

/*  Schema.qm Copyright 2014 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.10 or better
%requires qore >= 0.8.10

# requires the SqlUtil module
%requires SqlUtil >= 1.1

# requires the Util module
%requires Util >= 1.0

# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module Schema {
    version = "1.0";
    desc = "user module for working with SQL schemas";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
}

/** @mainpage Schema Module

    @tableofcontents

    @section schemaintro Introduction to the Schema Module

    The %Schema module provides a high level database-independent API for working with database schemas.

    To use this module, use \c "%requires Schema" in your code.
    
    All the public symbols in the module are defined in the Schema namespace
*/

public namespace Schema {
    #! Schema class
    public class Schema {
	private {
            string name;
            string version;
            
            hash schema;

	    *hash index_options;
	    *hash creation_options;
	    *hash column_options;
	    *hash all_options;

	    AbstractDatasource ds;
	    string drv;

            Database db;

            hash pure_callback_opts;
            hash callback_opts;

            code info_callback;

            #! explicit data tablespace name
            *string data_ts;

            #! explicit index tablespace name
            *string index_ts;
	}

	constructor(AbstractDatasource n_ds, string n, string v, *string dts, *string its) {
	    ds = n_ds;
            name = n;
            version = v;
            data_ts = dts;
            index_ts = its;

	    drv = ds.getDriverName();

	    db = new Database(ds);

	    index_options = getIndexOptions();
	    creation_options = getCreationOptions();
	    column_options = getColumnOptions();

	    all_options = Schema::combineOptions(creation_options, column_options);

            schema = (
                "tables": getTables(),
                "sequences": getSequences(),
                "types": getTypes(),
                "functions": getFunctions(),
                "procedures": getProcedures(),
                "packages": getPackages(),
                "materialized_views": getMaterializedViews(),
                );
	}

        string getName() {
            return name;
        }

        string getVersion() {
            return version;
        }

        logpf(string fmt) {
            printf("%s: %s\n", db.getDatasourceDesc(), vsprintf(fmt, argv));
        }

        log(string fmt) {
            vprintf(fmt + "\n", argv);
            flush();
        }

        logProgress(string str) {
            printf(str);
            flush();
        }

	int align(bool force = False, int verbose = 0) {
            int change_count = 0;
            int dot_count = 0;
            list sql_cache = ();

            info_callback = sub (string str, int ac, *string type, *string name, *string table, *string new_name, *string info) {
                # verbosity threadhold
                int t = 0;
                if (ac != AbstractDatabase::AC_Unchanged)
                    ++change_count;
                else
                    t = 1;
                if (verbose > t) {
                    if (dot_count) {
                        logProgress("\n");
                        dot_count = 0;
                    }
                    log("%s %s", t ? "+++" : "***", str);
                }
                else {
                    ++dot_count;
                    logProgress(AbstractDatabase::ActionLetterMap{ac});
                }
            };

            code sql_callback = sub (string str) {
                sql_cache += str;
                if (verbose > 1)
                    log("%s", str);
                ds.execRaw(str);
            };

            pure_callback_opts = (
                "info_callback": info_callback,
                "sql_callback": sql_callback,
                "sql_callback_executed": True,
                );

            callback_opts = all_options + pure_callback_opts;

	    bool first_time_install = checkFirstTimeInstall();

            *hash initial_schema_info;

            if (first_time_install)
                logpf("creating %s schema %s", name, version);
            else {
                if (!checkUpdateSchema(force, \initial_schema_info))
                    return 0;
                sql_cache = ();
            }

            on_success ds.commit();
            on_error ds.rollback();

            Tables table_cache();

%ifndef QoreDebug
            db.getAlignSql(schema, callback_opts, table_cache);
%else
            list al = db.getAlignSql(schema, callback_opts, table_cache);

            if (al.size() != sql_cache.size()) {
                printf("callback had %d lines, getAlignSql() had %d lines\n", sql_cache.size(), al.size());

                # make a hash of the sqlcache
                if (al.size() > sql_cache.size()) {
                    hash sch;
                    map sch.$1 = True, sql_cache;
                    
                    foreach string sql in (al) {
                        if (!sch{sql})
                            printf("MISSING IN CALLBACK %d: %s\n", $#, sql);
                    }
                }
                else {
                    hash sch;
                    map sch.$1 = True, al;

                    foreach string sql in (sql_cache) {
                        if (!sch{sql})
                            printf("MISSING IN ALIGN %d: %s\n", $#, sql);
                    }
                }

                exit(1);
            }
%endif

            if (dot_count)
                logProgress("\n");
            if (change_count)
                log("%d change%s made; schema is now at version %s", change_count, change_count == 1 ? "" : "s", version);
            else
                log("no changes made to schema version %s", version);

            doPostAlignment(table_cache, first_time_install, initial_schema_info);

            *hash strict_data = getStrictReferenceDataHash();
            *hash ref_data = getReferenceDataHash();
            *hash insert_only_data = getInsertOnlyReferenceData();
            *hash co_data = getCreateOnlyReferenceData();

            # change summary hash
            hash sh;

            if (strict_data || ref_data || co_data || insert_only_data) {
                log("verifying reference data");

                int upsert_strategy = getUpsertStrategy(first_time_install);

                # install "strict reference data", where there can be no other rows in the table
                if (strict_data)
                    map Schema::doTable(table_cache{$1.key}, $1.value, upsert_strategy, True, verbose, \sh), strict_data.pairIterator();

                # ensure that "normal" reference data is in place
                if (ref_data)
                    map Schema::doTable(table_cache{$1.key}, $1.value, upsert_strategy, False, verbose, \sh), ref_data.pairIterator();

                # do "insert-only" data
                if (insert_only_data)
                    map Schema::doTable(table_cache{$1.key}, $1.value, AbstractTable::UpsertInsertOnly, False, verbose, \sh), insert_only_data.pairIterator();

                if (co_data && first_time_install)
                    map Schema::doTable(table_cache{$1.key}, $1.value, upsert_strategy, False, verbose, \sh), co_data.pairIterator();

                postDataActions(first_time_install);

                if (!verbose)
                    logProgress("\n");
                
                if (!sh)
                    log("reference data: OK (no changes)");
                else
                    log("reference data: %s", (foldl $1 + ", " + $2, (map sprintf("%s: %d", $1.key, $1.value), sh.pairIterator())));
            }

            return change_count + sh.size();
	}

        drop(bool force = False, int verbose = 0) {
            int drop_count = 0;
            int dot_count = 0;
            list sql_cache = ();

            info_callback = sub (string str, int ac, *string type, *string name, *string table, *string new_name, *string info) {
                # verbosity threadhold
                int t = 0;
                if (ac != AbstractDatabase::AC_NotFound)
                    ++drop_count;
                else
                    t = 1;
                if (verbose > t) {
                    if (dot_count) {
                        logProgress("\n");
                        dot_count = 0;
                    }
                    log("%s %s", t ? "+++" : "***", str);
                }
                else {
                    ++dot_count;
                    logProgress(AbstractDatabase::ActionLetterMap{ac});
                }
            };

            code sql_callback = sub (string str) {
                sql_cache += str;
                if (verbose > 1)
                    log("%s", str);
                ds.execRaw(str);
            };

            int error_count = 0;
            code sql_force_callback = sub (string str) {
                sql_cache += str;
                if (verbose > 1)
                    log("%s", str);
                try {
                    db.tryExecRaw(str);
                }
                catch (hash ex) {
                    log("%s: %s: %s", get_ex_pos(ex), ex.err, ex.desc);
                    ++error_count;
                }
            };

            callback_opts = (
                "info_callback": info_callback,
                "sql_callback": force ? sql_force_callback : sql_callback,
                "sql_callback_executed": True,
                );

            if (!checkExistence()) {
                if (!force) {
                    logpf("schema appears to be empty: use -f to force the drop");
                    return;
                }
                logpf("schema appears to be empty: drop forced");
            }
            else {
                if (!checkDropSchema(force))
                    return;
                sql_cache = ();
            }

            on_success ds.commit();
            on_error ds.rollback();

%ifndef QoreDebug
            db.getDropSchemaSql(schema, callback_opts);
%else
            list al = db.getDropSchemaSql(schema, callback_opts);

            if (al.size() != sql_cache.size()) {
                printf("callback had %d lines, getDropSchemaSql() had %d lines\n", sql_cache.size(), al.size());

                # make a hash of each
                hash sch;
                map sch.$1 = True, sql_cache;

                foreach string sql in (al) {
                    if (!sch{sql})
                        printf("MISSING IN CALLBACK %d: %s\n", $#, sql);
                }
                exit(1);
            }
%endif

            if (dot_count)
                logProgress("\n");
            log("%d object%s dropped (%d error%s); schema has been dropped", drop_count, drop_count == 1 ? "" : "s", error_count, error_count == 1 ? "" : "s");
        }

        private bool checkDropSchema(bool force) {
            logpf("dropping schema version %s", version);
            return True;
        }

        private bool checkUpdateSchema(bool force, reference initial_schema_info) {
            logpf("verifying/aligning schema version %s", version);
            return True;
        }

        private postDataActions(bool first_time_install) {
        }

        private int getUpsertStrategy(bool first_time_install) {
            return first_time_install ? AbstractTable::UpsertInsertFirst : AbstractTable::UpsertUpdateFirst;
        }

        private doPostAlignment(Tables table_cache, bool first_time_install, *hash initial_schema_info) {
        }

        private doTable(AbstractTable table, list rows, int upsert_strategy, bool delete_others, int verbose, reference sh) {
            # if we are reporting the status, then change to "UpsertSelectFirst" so that we can only report updated rows
            if (verbose) {
                upsert_strategy = AbstractTable::UpsertSelectFirst;
                log("checking table %s", table.getName());
            }

            bool dot = False;

            hash tsh;
            code cb = sub (string table_name, hash row, int result) { 
                if (result == AbstractTable::UR_Unchanged) {
                    if (verbose > 1) {
                        logProgress(".");
                        dot = True;
                    }
                    return;
                }
                string change = AbstractTable::UpsertResultMap{result};
                # increment table change
                ++tsh{change};
                # increment global change
                ++sh{change};
                if (verbose <= 1)
                    logProgress(AbstractTable::UpsertResultLetterMap{result});
                else if (verbose > 1) {
                    if (dot) {
                        dot = False;
                        logProgress("\n");
                    }
                    log("* reference data %s: %y: %s", table_name, row, change);
                    log("checking table %s", table_name); 
                }
            };
            
            table.upsertFromIteratorNoCommit(Schema::getRows(rows).iterator(), upsert_strategy, ("delete_others": delete_others, "info_callback": cb));

            # show table summary if verbose = 1
            if (verbose) {
                if (tsh) {
                    if (verbose == 1 || dot)
                        logProgress("\n");
                    log("** reference data %s: %s", table.getName(), (foldl $1 + ", " + $2, (map sprintf("%s: %d", $1.key, $1.value), tsh.pairIterator())));
                }
                else {
                    if (verbose > 1) {
                        if (dot)
                            logProgress("\n");
                        logProgress("** ");
                    }
                    log("OK (%d row%s verified)", (rows.size() - 1), (rows.size() - 1) == 1 ? "" : "s");
                }
            }
        }

	*hash getIndexOptionsImpl() {
        }

	*hash getColumnOptionsImpl() {
	}

        *hash getGenericOptionsImpl() {
        }

	*hash getTables() {
	}

	*hash getSequences() {
	}

	*hash getTypes() {
	}

	*hash getFunctions() {
	}
	
	*hash getProcedures() {
	}
	
	*hash getPackages() {
	}

	*hash getMaterializedViews() {
	}

	*hash getIndexOptions() {
            *hash h = getIndexOptionsImpl();
            if (index_ts && !h.index_tablespace)
                h.index_tablespace = index_ts;
            return h;
	}

	*hash getCreationOptions() {
            *hash h = combineOptions(getGenericOptionsImpl(), getIndexOptionsImpl());
            if (data_ts && !h.data_tablespace)
                h.data_tablespace = data_ts;
            if (index_ts && !h.index_tablespace)
                h.index_tablespace = index_ts;
            return h;
	}

	*hash getColumnOptions() {
            return getColumnOptionsImpl();
	}

	#! returns a hash of "strict reference data", describing the only data that can appear in the target table
	*hash getStrictReferenceDataHash() {
	}

	#! returns a hash of "normal reference data", describing data that must appear in the target table, however additional rows are also acceptable
	*hash getReferenceDataHash() {
	}

	#! returns a hash of "create-only reference data", describing data that is written to the table when the table is created
	*hash getCreateOnlyReferenceData() {
	}

	#! returns a hash of "create-only reference data", describing data that will only be inserted if missing, otherwise existing rows with changed data are left unchanged
	*hash getInsertOnlyReferenceData() {
	}

        private bool checkExistence() {
	    if (schema.tables)
		return db.getTable(schema.tables.firstKey()) ? True : False;
            if (schema.sequences)
		return db.getSequence(schema.sequences.firstKey()) ? True : False;
            if (schema.functions)
		return db.getFunction(schema.functions.firstKey()) ? True : False;
            if (schema.procedures)
		return db.getProcedure(schema.procedures.firstKey()) ? True : False;
            return False;
        }

	private bool checkFirstTimeInstall() {
            return !checkExistence();
	}

	static list getRows(*softlist l) {
	    list ql = ();
	    *softlist hdr = shift l;

	    foreach softlist data in (l) {
		hash h;
		map h.$1 = data[$#], hdr;
		ql += h;
	    }

	    return ql;
	}

	static hash combineOptions(*hash h) {
	    foreach hash h1 in (argv) {
		map h{$1} = Schema::combineOptions(h{$1}, remove h1{$1}), h.keyIterator(), h1.hasKey($1);
		h += h1;
	    }
	    return h;
	}
    }

    public class VersionedSchema inherits Schema {
        private {
            string version_table;
            string version_column;
            hash version_where;
        }

        constructor(AbstractDatasource ds, string n, string v, string vt, string vc, hash vw, *string dts, *string its) : Schema(ds, n, v, dts, its) {
            version_table = vt;
            version_column = vc;
            version_where = vw;
        }

        private *softstring getSchemaVersion() {
            Table vt(ds, version_table);
            if (!vt.checkExistence())
                return;

            return vt.selectRow(("columns": version_column, "where": version_where)){version_column};
        }

        private bool checkDropSchema(bool force) {
            *string current_version = getSchemaVersion();
            if (!current_version) {
                if (!force) {
                    logpf("schema is corrupt: force option not set; not executing schema drop");
                    return False;
                }
                logpf("schema is corrupt: forcing schema drop");
                return True;
            }

            if (!compare_version(current_version, version)) {
                logpf("dropping schema %y", version);
                return True;
            }

            if (force) {
                logpf("schema is at unexpected version %y (executing with %y): forcing drop", current_version, version);
                return True;
            }
            logpf("schema is at unexpected version %y (executing with %y): force option not set; not executing schema drop", current_version, version);
            return False;
        }

        private bool checkUpdateSchema(bool force, reference initial_schema_info) {
            *string current_version = getSchemaVersion();
            if (!current_version) {
                logpf("schema is corrupt; aligning to schema template");
                return True;
            }

            initial_schema_info.current_version = current_version;

            switch (compare_version(current_version, version)) {
                case < 0: {
                    logpf("schema is at version %y targeting %y: running schema alignment", current_version, version);
                    checkUpgrade(current_version);
                    return True;
                }
                case 0: {
                    if (force) {
                        logpf("schema is already at target version %y: forcing check", version);
                        return True;
                    }
                    logpf("schema is already at target version %y: no alignment necessary", version);
                    return False;
                }
                case > 0: {
                    if (force) {
                        logpf("schema is at later version %y targeting %y: forcing check", current_version, version);
                        checkDowngrade(current_version);
                        return True;
                    }
                    logpf("schema is at later version %y targeting %y: force option not set; not executing schema alignment to earlier schema version", current_version, version);
                    return False;
                }
            }
        }

        private checkUpgrade(string current_version) {
        }

        private checkDowngrade(string current_version) {
        }
    }
}
