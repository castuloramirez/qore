# -*- mode: qore; indent-tabs-mode: nil -*-
# @file SmtpClient.qm SmtpClient module definition

/*  SmtpClient.qm Copyright 2012 Wolfgang Ritzinger, Marian Bonda, Pavol Potoncok

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum qore version
%requires qore >= 0.8.4

# need mime definitions
%requires Mime >= 1.0

# need MailMessage classes
%requires MailMessage >= 1.0

module SmtpClient {
    version = "1.1";
    desc = "SMTP client support module";
    author = "Wolfgang Ritzinger <aargon@rat.at>, Marian Bonda <marian_bonda@users.sourceforge.net>, Pavol Potoncok <ppotancok@gmail.com>";
    url = "http://qore.org";
}

/*  Version History
    * 2012-06-14 v1.1: David Nichols <david@qore.org>: removed the Message and Attachment classes to the MailMessage module to be reused in the Pop3Client module
    * 2012-05-21 v1.0: David Nichols <david@qore.org>: updated to a user module, added initial rudimentary ESMTP handling, STARTTLS and quoted-printable encoding support + the bane of all developers: documentation :)

    ritzinwo, 20090716

    based on:
    - http://james.apache.org/server/rfclist/smtp/rfc0821.txt
    - http://tools.ietf.org/html/rfc821: initial SMTP protocol spec
    - http://tools.ietf.org/html/rfc1521: quoted printable & base 64 transfer encodings
    - http://tools.ietf.org/html/rfc2045: mime headers, content types, etc
    - http://tools.ietf.org/html/rfc2047: "Q" and "B" encoded words (implemented by the Mime module)
    - http://tools.ietf.org/html/rfc2822: message structure, headers, body, etc
*/

/** @mainpage SmtpClient Module

    The %SmtpClient module provides a set of classes that can be used for easy communication with SMTP servers for sending emails, with or without TLS/SSL encryption.

    To use this module, use \c "%requires SmtpClient" in your code.  See examples/email.q for an example program using this module
    
    All the public symbols in the module are defined in the SmtpClient namespace

    The main class is: @ref SmtpClient::SmtpClient "SmtpClient": manages a connection to an SMTP server

    The following supporting classes are provided by the MailMessage module:
    - MailMessage::Message: wraps a message to be sent via an @ref SmtpClient::SmtpClient "SmtpClient" object
    - MailMessage::Attachment: used to attach files to a MailMessage::Message object

    @par Example:
    @code
%requires SmtpClient
%requires Mime

my MailMessage::Message $msg("The Sender <sender@email.com>", "My Subject");
$msg.setBody($body);
$msg.addTO("My Best Friend <you@friend.com>");
$msg.attach($filename, Mime::MimeTypeText, $data);

my code $log = sub (string str) {printf("%y: %s\n", now_us(), str);}
my SmtpClient::SmtpClient $smtp("smtp.example.com", $log, $log);
$smtp.sendMessage($msg);@endcode
 */

#! the %SmtpClient namespace holds all public definitions in the %SmtpClient module
/** This includes:
    - SmtpClient: manages a connection to an SMTP server

    Note that the MailMessage module ("required" above) implements the following classes:
    - Message: wraps a message to be sent via an SmtpClient object
    - Attachment: used to attach files to a Message
*/
public namespace SmtpClient {
    #! 15 second read timeout
    public const DefaultReadTimeout = 15s;

    #! 30 second connect timeout
    public const DefaultConnectTimeout = 30s;

    #! for backwards-compatibility and convenience
    public class Message inherits MailMessage::Message {
	#! creates a Message object from the arguments given; this variant of the constructor is designed to be used to create a Message object for sending with the SmtpClient class
	/** Use the Message::addTo() method to add message recipients

	    @param sender the sender's email address; can be in the format \c "Full Display Name <name@example.com>"
	    @param subject the subject line for the email; the subject will be encoded with <a href="http://tools.ietf.org/html/rfc2047">"Q" encoding</a>

	    @throw MESSAGE-CONSTRUCTOR-ERROR the sender's email address is not valid; the subject is empty
	 */
	constructor(string $sender, string $subject) : MailMessage::Message($sender, $subject) {
        }
    }

    #! for backwards-compatibility only
    public class Attachment inherits MailMessage::Attachment {
    }

    #! the class that's used to communicate with an SMTP server and supports optional TLS/SSL encryption
    /** This class uses a Mutex lock in each SmtpClient object to ensure thread serialization to the underlying socket and its internal configuration, 
        so it is safe to access in a multithreaded context.
     */
    public class SmtpClient {
        #! @cond nodoc
	private {
	    Socket $.sock();

	    # connect string
	    string $.connect;

	    # ensures exclusive access to the object
	    Mutex $.mutex();
	    
	    bool $.nosend = False;

	    # optional info log closure
	    *code $.log_info;

	    # optional debug log closure
	    *code $.log_debug;

	    # tls flag
	    bool $.tls = False;

	    # esmtp flag
	    bool $.esmtp;

	    # authentication credentials
	    *string $.user;
	    *string $.pass;

	    # logged in flag
	    bool $.logged_in = False;

            # read timeout in milliseconds
            timeout $.readTimeout = DefaultReadTimeout;

            # connect timeout in milliseconds
            timeout $.connectTimeout = DefaultConnectTimeout;

            const MaxDebugLine = 2048;
	}
        #! @endcond

	public {
	    #! create a different multipart boundary string every time based on the current time
	    string $.mpboundary = replace(makeBase64String(string(now_us())), "=", "");

	    #! default SMTP port
	    const SmtpPort = 25;
	}

	#! creates the SmtpClient object
	/** @param host the hostname of the SMTP server (use \c "[hostname]" to explicitly specify an ipv6 connection)
	    @param port the port number of the SMTP server
	    @param log a closure for log messages
	    @param dbglog a closure for debugging/technical log messages
	 */
	constructor(string $host, softint $port, *code $log, *code $dbglog) {
	    $.log_info = $log;
	    $.log_debug = $dbglog;

	    $.connect = sprintf("%s:%d", $host, $port);
	    $.logDbg("SmtpClient server: %y", $.connect);
	}

	#! creates the SmtpClient object
	/** @param connect the hostname of the SMTP server or a hostname:port specification (use \c "[hostname]" or \c "[address]" for ipv6 connections); if no port is given for non-UNIX sockets, then SmtpPort is used as the default port number
	    @param log an optional closure or call reference for log messages
	    @param dbglog an optional closure or call reference for debugging/technical log messages
	 */
	constructor(string $connect, *code $log, *code $dbglog) {
	    $.log_info = $log;
	    $.log_debug = $dbglog;

	    # add default port if the connect string has no port number and:
	    # 1) is not a path (for a UNIX domain socket)
	    # 2) is not an ipv6 address enclosed in '[]' (ex '[2001:0db8:85a3:0000:0000:8a2e:0370:7334]')
	    if ($connect !~ /^\//) {
		my *softint $p = ($connect =~ x/:([0-9]+)$/)[0];
		if (!$p)
		    $connect += ":" + SmtpPort;
	    }

	    $.connect = $connect;
	    $.logDbg("SmtpClient server: %y", $.connect);
	}

	#! disconnects if connected and destroys the object
        /** if any exceptions occur during the disconnection, they are sent to the debug log closure/call reference
         */
  	destructor() {
	    try {
		$.disconnect();
	    }
	    catch (hash $ex) {
		$.logDbg("SmtpClient disconnect: %s: %s", $ex.err, $ex.desc);
	    }
  	}

        #! sets the TLS/SSL flag
        /** @param tls if @ref Qore::True "True" then use TLS/SSL; if the TLS/SSL flag is set then the client will issue a STARTTLS command after connecting and negotiate a secure TLS/SSL connection to the server
         */
	tls(bool $tls) {
	    $.tls = $tls;
	}

        #! returns the TLS/SSL flag
	bool tls() {
	    return $.tls;
	}

        #! sets the username and password for authenticated connections
        /** @param user the username to set for authentication
            @param pass the password to set for authentication
            
            @note
            - Currently this class only knows how to do AUTH PLAIN authentication
            - This method is subject to thread serialization
         */
	setUserPass(string $user, string $pass) {
	    my AutoLock $am($.mutex);
	    $.user = $user;
	    $.pass = $pass;
	}

	#! sets or disables test mode; no connections are made in test mode
	test(bool $ns) {
	    $.nosend = $ns;
	}

	#! returns the test mode flag
	bool test() {
	    return $.nosend;
	}

	#! Connect to the server with the connection parameters set in the @ref constructor()
        /** @note
            - For possible exceptions, see %Qore's @ref Qore::Socket::connect() "Socket::connect()" method
            - This method is subject to thread serialization
         */
  	connect() {
	    my AutoLock $am($.mutex);
            $.connectIntern();
        }

	#! return connection status
  	bool isConnected() {
	    return ($.nosend || $.sock.isOpen());
  	}
  	
	#! disconnect from the server
        /** @note This method is subject to thread serialization
         */
  	disconnect() {
	    my AutoLock $am($.mutex);
            $.disconnectIntern();
  	}

        #! sets the read timeout
        setReadTimeout(timeout $to) {
            $.readTimeout = $to;
        }

        #! returns the read timeout as an integer giving milliseconds
        int getReadTimeoutMs() {
            return $.readTimeout;
        }
        
        #! returns the read timeout as a relative time value
        date getReadTimeoutDate() {
            return milliseconds($.readTimeout);
        }

        #! sets the connect timeout
        setConnectTimeout(timeout $to) {
            $.connectTimeout = $to;
        }

        #! returns the connect timeout as an integer giving milliseconds
        int getConnectTimeoutMs() {
            return $.connectTimeout;
        }
        
        #! returns the connect timeout as a relative time value
        date getConnectTimeoutDate() {
            return milliseconds($.connectTimeout);
        }

	#! send a Message to the server
	/** @param message the Message to send

	    @return a hash of data returned by the SMTP server (the return structure hashes described below are made up of the following keys: \c "code": the return code, \c "desc": the string description):
	    - \c HELO or \c EHLO: a hash of the reply received from the \c HELO or \c EHLO command
	    - \c RCPT: hash keyed by email address with hash return structures values for the RCPT TO command   
	    - \c MSGID: return structure after the send; generally contains message id
	    - \c QUIT: the server response of the disconnect command

            @note This method is subject to thread serialization
	 */
	hash sendMessage(MailMessage::Message $message) {
	    if (!$message.sendPossible())
		throw "ARGUMENT-EXCEPTION", "Message is not ready to be sent";

	    if ($.log_debug.val())
		$.logDbg("message: %s", $message.toLine());
	    
	    # lock for sending
	    my AutoLock $am($.mutex);

	    my hash $reply;
	    try {
		$reply = $.sendMessageHeaderIntern($message);

		my list $atts = $message.getAttachments();

                # get message body transfer encoding
		my string $be = $message.getBodyTransferEncoding();

                # is this a multipart msg?
                my bool $multipart = !$atts.empty();

		# see if we need to send a MIME msg: multipart message or need body encoding
                my bool $mime = $multipart || $be != MailMessage::EncNone;

                if ($mime) {
                    my MultiPartMixedMessage $mpm($.mpboundary);

                    if ($be == MailMessage::EncNone)
                        $be = ContentTransEnc7Bit;

                    # add the message body
                    $mpm.addEncodePart($message.getBody(), $be, MimeTypeText, "inline");
                   
                    # add attachments
                    foreach my MailMessage::Attachment $att in ($atts)
                        $att.add($mpm);

                    $.sendData($mpm.serialize());
                    $.sendData("\r\n");
                }
		else 
		    $.sendData($message.getBody() + "\r\n");

		# end of data
		my hash $rh = $.sendCommand(".");
		$reply.MSGID = $rh;

		# quit
		$rh = $.sendCommand("QUIT");
		$reply.QUIT = $rh;
	    }
	    catch($ex) {
		$.logDbg("send error: %s:%d: %s: %s", $ex.file, $ex.line, $ex.err, $ex.desc);
		$.forceDisconnectIntern();
		rethrow;
	    }
	    # close connection
	    $.forceDisconnectIntern();

	    return $reply;
	}

	#! force disconnect of socket without error
        /** @note This method is subject to thread serialization
         */
        forceDisconnect() {
	    my AutoLock $am($.mutex);
            $.forceDisconnectIntern();
	}

        #! @cond nodoc
        # don't reimplement this method; fix/enhance it in the module
        final private disconnectIntern() {
	    if ($.isConnected()) {
		$.sock.close();
		$.sock.shutdown();
	    }
        }
  	
	private log(string $msg) {
	    if ($.log_info.val())
		call_function($.log_info, "SmtpClient: " + trim(vsprintf($msg, $argv)));
	}

	private logDbg(string $msg) {
	    if ($.log_debug.val())
		call_function($.log_debug, "SmtpClient: " + trim(vsprintf($msg, $argv)));
	}

        private connectIntern() {
	    $.sock.connect($.connect, $.connectTimeout);
  	}
  	
	# send data over the socket
	private sendDataIntern(data $str) {
	    if (!$.isConnected()) {
		$.logDbg("send: not connected; not sending");
		throw "NOT-CONNECTED", "not connected in sendDataIntern()";
	    }

	    # send
	    $.sock.send($str);
	}

	# send data and log in the debug log if set
	private sendData(string $str) {
	    # format additional arguments if necessary
	    if (!$argv.empty())
		$str = vsprintf($str, $argv);

	    if ($.log_debug.val()) {
		my string $lstr = trim($str);
		if ($lstr.size() > MaxDebugLine) {
		    splice $lstr, MaxDebugLine;
		    $lstr += "...";
		}
		$.logDbg("data: %y", $lstr);
	    }

	    $.sendDataIntern($str);
	}

	# send data and log in the debug log if set
	private sendData(binary $b) {
            $.logDbg("binary data: %d bytes", $b.size());
	    $.sendDataIntern($b);
	}

	# send a command over the socket and return the response as a hash
        # don't reimplement this method; fix/enhance it in the module
	final private hash sendCommand(string $str) {
	    # format additional arguments if necessary
	    if (!$argv.empty())
		$str = vsprintf($str, $argv);

	    trim $str;
	    $.logDbg("send %y", $str);

	    # send data
	    $.sendDataIntern($str + "\r\n");

	    # read data
	    my string $rep;

	    my softint $code;
	    my string $desc;

	    # process multi-line responses
	    while (True) {
		my string $l = $.readLine($.readTimeout);
		trim $l;
		$.logDbg("reply: %y", $l);

		# if a continuation is signaled from the server, then keep reading
		if ($l =~ /^[0-9]{3}-/) {
		    if (!$code)
			$code = int($l);
		    # assume it's the same code every time
		    if (!$desc.empty())
			$desc += "\n";
		    $desc += extract $l, 4;
		    continue;
		}
		else {
		    if ($l !~ /^[0-9]{3} /) {
			$.log("cannot parse reply: %s\n", $l);
			$desc += $l;
			$code = -1;
			break;
		    }
		    if (!$code)
			$code = int($l);
		    # assume it's the same code every time
		    if (!$desc.empty())
			$desc += "\n";
		    $desc += extract $l, 4;
		    break;
		}
	    }

	    return ("code": $code, "desc": $desc);
	}

	# read a line from the socket (terminated with \n)
	private string readLine(timeout $to) {
	    my string $str;
	    my int $c = 0;
	    do {
		$c = $.sock.recvu1($to);
		$str += chr($c);
	    } while ($c != 10);

	    return $str;
	}

        # sends the message header (without body & attachments) to the SMTP server
        # don't reimplement this method; fix/enhance it in the module
        final private hash sendMessageHeaderIntern(MailMessage::Message $message) {
	    # open connection to server
	    if (!$.isConnected()) {
		$.connectIntern();
		my string $rep = $.readLine($.readTimeout);
		$.logDbg("connect reply: %y", trim($rep));
		$.esmtp = ($rep =~ /ESMTP/);
	    }

	    # send HELO/EHLO string
	    my string $hello = $.esmtp ? "EHLO" : "HELO";
	    my hash $rh = $.sendCommand($hello + "  %s", gethostname());
	    if ($rh.code >= 500)
		throw "SMTP-DATA-EXCEPTION", sprintf("error sending %s command: %y", $hello, $rh);

	    my hash $reply.$hello = $rh;

	    # issue STARTTLS and upgrade to a TLS connection if the tls flag is set and we are not already secure
	    if ($.tls && !$.sock.isSecure()) {
		$rh = $.sendCommand("STARTTLS");
		if ($rh.code >= 500)
		    throw "SMTP-DATA-EXCEPTION", sprintf("error sending STARTTLS command: %y", $rh);

		$.sock.upgradeClientToSSL();
		$.logDbg("upgrade to TLS/SSL connection %s %s", $.sock.getSSLCipherName(), $.sock.getSSLCipherVersion());
	    }
	    
	    # issue login if credentials supplied and we have not already logged in
	    if (!$.logged_in && !$.user.empty()) {
		$rh = $.sendCommand("AUTH PLAIN %s", makeBase64String(binary($.user) + <00> + binary($.user) + <00> + binary($.pass)));
		if ($rh.code != 235)
		    throw "SMTP-DATA-EXCEPTION", sprintf("login failed: %y", $rh);
	    }

	    $rh = $.sendCommand("MAIL FROM: <%s>", $message.getFrom());
	    if ($rh.code >= 500)
		throw "SMTP-DATA-EXCEPTION", sprintf("error sending FROM command: %y", $rh);

	    # send recipient
	    foreach my string $rcpt in ($message.getRecipients()) {
		$rh = $.sendCommand("RCPT TO: <%s>", $rcpt);
		$reply.RCPT.$rcpt = $rh;
		if ($rh.code >= 500)
		    throw "SMTP-DATA-EXCEPTION", sprintf("error sending RCPT command: %y", $rh);
	    }

	    # send data
	    $rh = $.sendCommand("DATA");
	    if ($rh.code != 354)
		throw "SMTP-DATA-EXCEPTION", sprintf("error sending DATA command (expected code 354): %y", $rh);

            $.sendData($message.getHeaderString());

	    return $reply;
	}

	private forceDisconnectIntern() {
	    if ($.isConnected()) {
		try {
		    $.disconnectIntern();
		}
		catch($ex) {
		    # ignore
		}
	    }
	}
        #! @endcond
    }
}

