/** @mainpage Programming with the Qore Library

    @section introduction Introduction to the Qore Library

    The Qore library is designed to facilitate dynamic embedding of code in applications.  The Qore library is thread-safe, and Qore code taking advantage of Qore's threading facilities is highly scalable on SMP machines.

    Qore data is generally atomically referenced counted (with some exceptions for performance and memory usage reasons), and the library supports some constructors in order to reduce the number of atomic operations and avoid evaluations wherever possible.

    @note The Qore library currently does not throw C++ exceptions; Qore-language exceptions are managed via the ExceptionSink class.

    @section embedding Embedding Qore Code

    All code using the qore library should include the header file Qore.h as follows:

    @code
    #include <qore/Qore.h>
    @endcode

    @subsection initializing_and_closing_library Initializing and Closing the Qore Library

    The first step is to initialize the library.  To do this, call qore_init() as follows (note that this function can only be called once and must be called before any other functionality of the Qore library is used):

    @code
    // qore_init() optionally takes several arguments as well
    qore_init();
    @endcode

    When your program terminates, you should call qore_cleanup() as follows:

    @code
    qore_cleanup();
    @endcode

    @subsection parsing_and_running Parsing and Running Qore Code
    
    First you should declare a variable of type ExceptionSink to capture and manage Qore exceptions (declare an additional variable if you want to capture and manage warnings when parsing Qore code):

    @code
    ExceptionSink xsink, wsink;
    @endcode

    Then you can use the QoreProgramHelper class to manage QoreProgram objects.  The QoreProgramHelper class contains a QoreProgram object and calls QoreProgram::waitForTerminationAndDeref() in the destructor.  The constructor takes a pointer to an ExceptionSink object, so make sure that the ExceptionSink object has at least as long a scope as the QoreProgramHelper object, as follows:

    @code
    ExceptionSink xsink, wsink;
    {
       // creates and manages a QoreProgram object
       QoreProgramHelper pgm(&xsink);
       // ... rest of code here
    }
    @endcode

    Then the QoreProgramHelper object can be used like a QoreProgram object.  For example, to parse a file named "test.q" and run it, do the following:

    @code
    ExceptionSink xsink, wsink;
    {
       // creates and manages a QoreProgram object
       QoreProgramHelper pgm(&xsink);

       pgm->parseFile("test.q", &xsink, &wsink, QP_WARN_ALL);

       // display any warnings immediately
       wsink.handleWarnings();

       // execute program if there were no parse exceptions
       if (!xsink)
          pgm->run(&xsink);
    }
    // display any exceptions on stdout
    xsink.handleExceptions();
    @endcode

    There are many functions for parsing and running Qore code; see the QoreProgram class documentation for more information.

    @section module_dev Qore Module development

    @subsection module_header Module Header Info

    To develop a Qore module, several functions and several global variables must be declared in the module with public visibility so the module can be initialized and used by the Qore library.

    The global variables are as follows:
    - char \c qore_module_name[] - must give the name of the feature provided by the module.
    - char \c qore_module_version[] - must give the version of the module
    - char \c qore_module_description[] - a description of the module
    - char \c qore_module_author[] - the author of the module
    - char \c qore_module_url[] - a URL for the module
    - int \c qore_module_api_major - must be assigned to \ref QORE_MODULE_API_MAJOR
    - int \c qore_module_api_minor - must be assigned to \ref QORE_MODULE_API_MINOR

    The functions are as follows:
    - \ref qore_module_init_t \c qore_module_init - the module initialization function
    - \ref qore_module_ns_init_t \c qore_module_ns_init - the module namespace delta functions
    - \ref qore_module_delete_t \c qore_module_delete - the module deletion function

    @note All variables and all functions are required, even if the functions are empty.

    Here is an example:
    @code
    DLLEXPORT char qore_module_name[] = "ncurses";
    DLLEXPORT char qore_module_version[] = "0.1";
    DLLEXPORT char qore_module_description[] = "ncurses class module";
    DLLEXPORT char qore_module_author[] = "David Nichols";
    DLLEXPORT char qore_module_url[] = "http://qore.sourceforge.net";
    DLLEXPORT int qore_module_api_major = QORE_MODULE_API_MAJOR;
    DLLEXPORT int qore_module_api_minor = QORE_MODULE_API_MINOR;

    DLLEXPORT qore_module_init_t qore_module_init = ncurses_module_init;
    DLLEXPORT qore_module_ns_init_t qore_module_ns_init = ncurses_module_ns_init;
    DLLEXPORT qore_module_delete_t qore_module_delete = ncurses_module_delete;
    @endcode

    Note that the module name (or the module's feature name) as given by \c qore_module_name is used to uniquely identify the feature provided by the module.  Therefore if a module is loaded that provides feature "widget" and another module also claims to provided feature "widget", the second module cannot be loaded in the Qore library after the first has been loaded due to the duplicate feature name.

    The \c qore_module_api_major and \c qore_module_api_minor variables are used to determine if the module corresponds to the API (and ABI) of the Qore library trying to load it.

    @subsection module_functions Module Functions

    The module initialization function \c qore_module_init() will be run when the module is loaded by the Qore library.  If any errors occur when initializing the module, a description should be returned as a QoreString pointer (the library will own the pointer and delete it later).  If a non-zero pointer is returned by the \c qore_module_init() function, the feature will not be added to the Qore library and the module load will fail.

    If the module provides any namespaces, classes or constants, they will be added on demand to QoreProgram objects by calling the module's \c qore_module_ns_init() function.  In this case, the namespace additions should be initialized in the \c qore_module_init() function and copies should be provisioned in the \c qore_module_ns_init() function.  In particular classes must not be created more than once, because a Qore class gets a unique ID assigned when it is created, and this ID must be unique in the entire Qore library.

    Here are example functions from the ncurses module:

    @code
    // this is the reference namespace for the ncurses module
    static QoreNamespace NCNS("NCurses");

    // this function is called when the module is loaded
    QoreStringNode *ncurses_module_init()
    {
       // the NCurses reference namespace is set up here
       NCNS.addSystemClass(initWindowClass());
       NCNS.addSystemClass(initPanelClass());

       init_constants(&NCNS); // here constants are added to the NCurses namespace
    
       builtinFunctions.add("initscr",          f_initscr, QDOM_TERMINAL_IO);
       builtinFunctions.add("printw",           f_printw, QDOM_TERMINAL_IO);
       builtinFunctions.add("refresh",          f_refresh, QDOM_TERMINAL_IO);
       //... more builtin functions are added

       return 0;
    }

    // this function is called when the Qore library needs to provision the NCurses namespace 
    // to a new QoreProgram object (or to a QoreProgram object that existed before the module
    // was loaded by another QoreProgram object and then later requests the feature "ncurses")
    void ncurses_module_ns_init(QoreNamespace *rns, QoreNamespace *qns)
    {
       // add the NCurses namespace as a subnamespace to the Qore namespace
       qns->addInitialNamespace(NCNS.copy());
    }

    // this function is called when the module is deleted (when the qore library is closed)
    // it should free all resources allocated in the module's initilization function
    void ncurses_module_delete()
    {
       // calls endwin() if necessary
       q_nc_init.close();
    }
    @endcode

    @section builtin_functions Qore Builtin Functions

    To add a builtin function to the library, you have to call BuiltinFunctionList::add().  The BuiltinFunctionList class only contains static functions, but it can also be accessed through the global \c builtinFunctions object.

    Builtin functions must have the following signature:

    @code
    // "testfunction()" ignores all arguments and returns the string "testing"
    AbstractQoreNode *f_testfunction(const QoreListNode *params, ExceptionSink *xsink)
    {
       return new QoreStringNode("testing");
    }
    @endcode

    Then the function can be added to the library's builtin function list with the following command:
    @code
    builtinFunctions.add("testfunction", f_testfunction);
    @endcode

    @subsection handling_function_arguments Handling Function Arguments

    Use the inline functions in params.h to access function arguments.  These are:
    - num_params() - returns the number of arguments passed to the function
    - get_param() - returns the argument in the position given or 0 if there is none

    The following inline functions provide arguments of a specific type:
    - test_binary_param() - returns a const BinaryNode pointer or 0
    - test_string_param() - returns a const QoreStringNode pointer or 0
    - test_object_param() - returns a QoreObject pointer or 0
    - test_date_param() - returns a const DateTimeNode pointer or 0
    - test_hash_param() - returns a const QoreHashNode pointer or 0
    - test_list_param() - returns a const QoreListNode pointer or 0
    - test_funcref_param() - returns a const ResolvedFunctionReferenceNode pointer or 0
    - test_reference_param() - returns a const ReferenceNode pointer or 0
    - test_nothing_param() - returns true if there is no value at the given position

    Note that there are no functions for the integer (\ref NT_INT) and floating-point (\ref NT_FLOAT) types.  These values should be acquired as necessary using the AbstractQoreNode::getAsInt(), AbstractQoreNode::getAsBigInt(), and AbstractQoreNode::getAsFloat() functions to allow for transparent type conversion from other data types.

    Here are some examples:

    @code
    AbstractQoreNode *f_testfunction(const QoreListNode *params, ExceptionSink *xsink)
    {
       // get the first integer argument
       const AbstractQoreNode *p = get_param(params, 0);
       int64 i = p ? p->getAsBigInt() : 0;
       
       // get the second floating-point argument
       p = get_param(params, 1);
       double f = p ? p->getAsFloat() : 0.0;

       int64 rc = do_something(i, f);

       // returns an integer value
       return new QoreBigIntNode(rc);
    }
    @endcode

    To use a string value, but accept conversion from other data types, use the QoreStringValueHelper class.  This class is best for getting QoreString values or simply getting a "char *" for the converted value.  The QoreStringValueHelper class also provides a constructor that allows the target character encoding to be specified (there is an example in the class documentation).  If you need a QoreStringNode (\ref NT_STRING) value, then use the QoreStringNodeValueHelper class instead.

    Here is an example of interpreting a function argument as a string value using the QoreStringValueHelper class:

    @code
    AbstractQoreNode *f_testfunction(const QoreListNode *params, ExceptionSink *xsink)
    {
       // get a pointer to the first argument
       const AbstractQoreNode *p = get_param(params, 0);
       
       // this will convert p to a string if necessary
       QoreStringValueHelper str(p);

       // call a function with the "const char *" to the string buffer of str
       do_something(str->getBuffer());

       return 0;
    }
    @endcode

    To process arguments meant to be timeout values (or meant to specify a period of time) where an integer implies certain units (such as milliseconds or seconds) but also allow relative DateTimeNode (\ref NT_DATE) values to be processed, use the following functions:
    - getSecZeroInt(const AbstractQoreNode *a)
    - getSecZeroBigInt(const AbstractQoreNode *a)
    - getSecMinusOneInt(const AbstractQoreNode *a)
    - getSecMinusOneBigInt(const AbstractQoreNode *a)
    - getMsZeroInt(const AbstractQoreNode *a)
    - getMsZeroBigInt(const AbstractQoreNode *a)
    - getMsMinusOneInt(const AbstractQoreNode *a)
    - getMsMinusOneBigInt(const AbstractQoreNode *a)
    - getMicroSecZeroInt(const AbstractQoreNode *a)

    Each of the above functions returns an integer, assuming a certain unit for non DateTimeNode values, and also returns a default value if no argument was present (either 0 or -1). 

    The following is an example of using getMsZeroInt():

    @code
    static AbstractQoreNode *MUTEX_lock(QoreObject *self, SmartMutex *m, const QoreListNode *params, ExceptionSink *xsink)
    {
       // the the first argument
       const AbstractQoreNode *p = get_param(params, 0);

       // we only return a return value if we have a timeout, otherwise we save allocating a QoreBigIntNode
       if (!is_nothing(p)) {
          // get the timeout value in milliseconds from the argument
          int timeout_ms = getMsZeroInt(p);
	  // grab the lock with a timeout value
	  int rc = m->grab(xsink, timeout_ms);
	  // return the return code if there was no exception
	  if (!*xsink)
	     return new QoreBigIntNode(rc);
       }
       else // grab the lock unconditionally (without a timeout)
          m->grab(xsink); 

       return 0;
    }
    @endcode

    @subsection function_return_value Function Return Value

    Each Qore function should return a pointer to an AbstractQoreNode giving the return value of the function.  If the function does not return a value, then it should simply return 0 as follows:

    @code
    // "testfunction()" ignores all arguments and returns no value
    AbstractQoreNode *f_testfunction(const QoreListNode *params, ExceptionSink *xsink)
    {
       return 0;
    }
    @endcode

    Otherwise, the pointer's reference count will be owned by the caller of builtin function, so returning a descendent of AbstractQoreNode created with the C++ new operator is OK, otherwise you have to make sure that the value returned by the builtin function is referenced for the return.  In other words, returning AbstractQoreNode descendents that have an incremented reference count is OK, but, for example, to return an argument of the function as the return value of the function, you have to increment the reference count manually -- the easiest way to do this is to call AbstractQoreNode::refSelf() on the value to be returned, as in the following example:

    @code
    static AbstractQoreNode *f_return_first_argument(const QoreListNode *params, ExceptionSink *xsink)
    {
       const AbstractQoreNode *p = get_param(params, 0);
       return p ? p->refSelf() : 0;
    }
    @endcode

    See the section below on Handling Qore Data for more information.
    
    @subsection function_raising_exceptions Raising Exceptions in a Function

    If your function raises an exception, then you must call ExceptionSink::raiseException() against the ExceptionSink argument to the function.  In the case that your function raises a Qore-language exception, the function must \b always return 0 as a return value.  The following is an example:

    @code
    static AbstractQoreNode *f_remove_signal_handler(const QoreListNode *params, ExceptionSink *xsink)
    {
       const AbstractQoreNode *p0 = get_param(params, 0);
       int signal = p0 ? p0->getAsInt() : 0;
       if (!signal || signal > QORE_SIGNAL_MAX) {
          xsink->raiseException("REMOVE-SIGNAL-HANDLER-ERROR", "%d is not a valid signal", signal);
	  return 0;
       }
       QoreSignalManager::removeHandler(signal, xsink);
       return 0;
    }
    @endcode

    @section handling_data Handling Qore Data

    All data value in Qore (and, in fact, all elements of Qore parse trees) are descended from AbstractQoreNode.

    The following are the basic data types in Qore, implemented as C++ classes descended from AbstractQoreNode, and their type codes, accessed via AbstractQoreNode::getType():
    - QoreBoolNode (\ref NT_BOOLEAN) for the boolean data type
    - QoreBigIntNode (\ref NT_INT) for the 64-bit integer data type
    - QoreFloatNode (\ref NT_FLOAT) for the double-precision floating-point type
    - QoreStringNode (\ref NT_STRING) for the string data type
    - DateTimeNode (\ref NT_DATE) for the date/time data type
    - BinaryNode (\ref NT_BINARY) for the opaque binary data type
    - QoreNothingNode (\ref NT_NOTHING) for a type signifying no value (also equivalent to 0!)
    - QoreNullNode (\ref NT_NULL) for the SQL NULL data type
    - QoreHashNode (\ref NT_HASH) for an associative array or hash data type
    - QoreListNode (\ref NT_LIST) for a list or array data type
    - QoreObject (\ref NT_OBJECT) for the data type representing the instantiation of a Qore class (QoreClass)

    Additionally, the following classes are exposed in the library:
    - ReferenceNode (\ref NT_REFERENCE)
    - AbstractFunctionReferenceNode (\ref NT_FUNCREF)

    @see node_types.h for a complete list of all type codes.

    @subsection simple_value_types Simple Value Types: QoreBigIntNode, QoreFloatNode, QoreStringNode, DateTimeNode, BinaryNode

    The QoreBigIntNode, QoreFloatNode, QoreStringNode, DateTimeNode, BinaryNode and classes are reference counted and can only be dynamically allocated.

    They are all descendents of SimpleQoreNode, meaning that dereferencing their objects cannot cause a Qore-language exception to be thrown, therefore the SimpleRefHolder class can be used to manage temporary references to objects of these types.

    For example:

    @code
    {
       // here a QoreBigIntNode value is returned with an incremented reference count
       SimpleRefHolder<QoreBigIntNode> qint(getQoreBigIntNode());
       printf("the result is: %lld\n", qint->val);
       // when qint goes out of scope, the reference count is decremented
    }
    @endcode

    @subsection unique_value_types Unique Value Types: QoreBoolNode, QoreNullNode, QoreNothingNode

    None of these classes can be directly instantiated with the new operator.  They are all represented by single objects managed directly by the Qore library.  Each of these classes represents a type that has only one value, therefore as a memory and performance optimization, reference counting is disabled for these objects.  Actually in the case of QoreBoolNode the subclasses QoreBoolTrueNode and QoreBoolFalseNode have actual instantiations.

    For the QoreBoolNode class, you can use these objects by referring to the global \ref True and \ref False objects, or by calling get_bool_node() as follows in the example function:

    @code
    static AbstractQoreNode *f_convert_first_argument_to_bool(const QoreListNode *params, ExceptionSink *xsink)
    {
       const AbstractQoreNode *p = get_param(params, 0);
       return get_bool_node(p ? p->getAsBool() : false);
    }
    @endcode

    Or, some even simpler functions:

    @code
    static AbstractQoreNode *f_return_true(const QoreListNode *params, ExceptionSink *xsink)
    {
       return &True; // QoreBoolNode objects are not reference counted (reference counting operations are ignored)
    }

    static AbstractQoreNode *f_return_false(const QoreListNode *params, ExceptionSink *xsink)
    {
       return &False; // QoreBoolNode objects are not reference counted (reference counting operations are ignored)
    }
    @endcode

    Similarly, for QoreNullNode there is the global \ref Null object or the inline function null() that returns a pointer to this object.

    QoreNothingNode has the gobal \ref Nothing object and the inline function nothing() that returns a pointer to it as well.

    @note that in Qore a C++ null pointer (0) is the same as \c NOTHING, therefore the inline function is_nothing() should always be used to test for \c NOTHING.

    @subsection container_types Container Value Types: QoreHashNode, QoreListNode, QoreObject

    The QoreHashNode, QoreListNode, and QoreObject classes define container types in Qore.  QoreObject objects in particular could throw an exception when dereferenced (if the object goes out of scope and its destructor is run, the destructor could throw an exception).  Because container types can hold any type, when they are deferenced it could cause a QoreObject to go out of scope, and therefore the possibility that a Qore-language exception could be thrown must be taken into consideration.  Therefore, to dereference these objects a pointer to an ExceptionSink object must be passed to AbstractQoreNode::deref().
    
    The ReferenceHolder class can be used to manage temporary reference counts as follows:

    @code
    {
       // here a QoreHashNode value is returned with an incremented reference count
       // note that xsink must be "ExceptionSink *"
       ReferenceHolder<QoreHashNode> qhash(getQoreHashNode(), xsink);
       printf("there are %ld elements in the hash\n", qhash->size());
       // when qhash goes out of scope, the reference count is decremented
    }
    @endcode


*/
