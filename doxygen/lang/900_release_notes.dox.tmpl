/** @page release_notes Release Notes

    @section qore_084 Qore 0.8.4

    <b>Release Summary</b>
    Major new features and changes that can affect backwards-compatibility, plus 40 bug fixes

    @subsection qore_084_compatibility Changes That Can Affect Backwards-Compatibility

    @par Namespace Changes
    Qore's internal namespace handling was nearly completely rewritten for %Qore 0.8.4.  This is because the old code was inefficient and applied namespaces inconsistently to @ref Qore::Program "Program" objects.\n\n
    The main change that can cause backwards-compatibility issues is that now functions are full namespace members.  If no namespace is explicitly given in a function definition, the function is a member of the unnamed root namespace.\n\n
    Also the distinction between builtin and user functions was removed.  Internally, there is only one kind of function object, which can contain both builtin and user function variants (overloaded variants of the same function with the same name but different arguments).\n\n
    All %Qore builtin functions were moved to the Qore namespace.\n\n
    Other namespace changes:
    - loading namespaces provided by builtin modules into a @ref Qore::Program "Program" object is now an atomic operation that may fail, if, for example, objects have already been defined in the target @ref Qore::Program "Program" with the same name as objects provided by the builtin module.  Previously this could cause undefined behavior.
    - namespace lookups are now truly breadth-first as documented; previously the algorithm was depth-first (contrary to the documentation)
    - namespace lookups are now done (both at parse time and runtime) with the help of symbol lookup tables for fast lookups; tables are maintained for both committed and temporary uncomitted parse symbols; this leads to up to 3x faster parsing for %Qore code
    - global variables are also now full namespace members, however this does not cause problems with backwards-compatibility

    @subsection qore_084_new_features New Features in Qore
    @par User Modules
    It is now possible to develop user modules in %Qore; several user modules are now included in the %Qore distribution, forming %Qore-language components of %Qore's runtime library.\n\n
    User modules delivered with %Qore 0.8.4:
    - <a href="../../modules/HttpServer/html/index.html">HttpServer</a>: a multi-threaded HTTP server implementation
    - <a href="../../modules/SmtpClient/html/index.html">SmtpClient</a>: an SMTP client library
    - <a href="../../modules/TelnetClient/html/index.html">TelnetClient</a>: a TELNET client implementation
    - <a href="../../modules/Mime/html/index.html">Mime</a>: a set of MIME definitions and functions for manipulating MIME data
    .
    There are also new example programs for the above modules in the examples/ directory.\n\n
    User modules are subject to %Qore's functional restriction framework.

    @par Namespace Changes
    As listed above:\n
    - global variables and functions are now full namespace members
    - all builtin functions are now in the Qore namespace
    - real depth-first searches are used for namespace symbols
    - symbols are resolved first in the current namespace when parsing declarations/code in a namespace

    @par The <b><tt>final</tt></b> Keyword
    Classes and methods can now be declared "final" to prevent subclassing or overriding in a subclass

    @par Pseudo Methods
    Pseudo-methods are class methods that can be implemented on any value; they are also part of class hierarchy.  The methods that can be executed on the value depend on the value's type, and all "pseudo-classes" inherit methods from a common base class.\n\n
    For example:
    @code
"string".strlen()
<abf05da3>.size()
500.typeCode()
    @endcode
    Are examples of pseudo-methods on literal values.\n\n
    Some expensive operations such as getting the first or last key (or value) of a hash are now cheap using pseudo-methods, for example:
    @code
$hash.firstKey()
$hash.lastValue()
    @endcode

    @par New Doxygen-Based Documentation
    The %Qore reference documentation is now generated by Doxygen, and is generated directly from the %Qore sources.  In fact, a new preprocessor known as "qpp" was developed for %Qore 0.8.4 to facilitate and enforce doxygen documentation on %Qore's runtime library (as well as abstract the relatively complex APIs used to bind C++ code to the %Qore runtime library from the C++ programmer).\n\n
    The documentation is more comprehensive, and corresponds much closer to the actual internal implementation since the documentation is now also contained in and directly generated from the internal C++ implementation of %Qore.\n\n
    For example, there is the <value>::val() method.  This method is implemented in the base pseudo class and is reimplemented in other pseudo-classes for other runtime data types as necessary.  This method returns @ref Qore::True "True" if the value has a value in the same sense as Perl's boolean context evaluation.  For example, if the value is a hash with no keys, it returns @ref Qore::False "False"; if it is a hash with keys, it returns @ref Qore::True "True"; if it is an empty string, it returns @ref Qore::False "False";
if it is a non-empty string, it returns @ref Qore::True "True", etc.

   @par LValue Handling Changes
   lvalue handling was rewritten as the old implementation was ugly and subject to deadlocks (in rare corner cases).\n\n
   Furthermore, medium-term, an architectural goal of %Qore is to store all ints, floats, and bools internally as the basic C++ type instead of using a class wrapper for each value, which needs dynamic allocation and destruction, which takes up more memory and negatively affects execution speed.\n\n
   With %Qore 0.8.4, all local and global variables are stored using optimized C++ types when declared with the appropriate type restrictions; for example:
   @code
my int $i0;
our int $i1;
   @endcode
   These declares local and global variables that can only be assigned integer values; in %Qore 0.8.4 the value internally will be stored as an "int64" value (and not a dynamically-allocated QoreBigIntNode object).\n\n
   The same holds for:
   - @ref int_type "int"
   - @ref softint_type "softint"
   - @ref float_type "float"
   - @ref softfloat_type "softfloat"
   - @ref bool_type "bool"
   - @ref softbool_type "softbool"
   .
   Note that the optimized lvalue handling has not yet been applied to all lvalues, in particular non-static object members with declared types are not yet implemented with optimized storage; to do this requires a rewrite of %Qore's API and ABI (will happen in the next major release of %Qore).\n\n
   This change leads to improved integer and floating-point performance and a smaller runtime memory footprint.

   @par Runtime Optimizations
   In addition to the up to 3x faster parsing (as decribed in the namespace changes above), %Qore 0.8.4 contains many runtime optimizations designed to reduce the number of dynamic memory allocations performed at runtime.\n\n
   The optimizations included in this version of %Qore are only a half-measure compared to future changes that will necessitate a new binary %Qore API.

   @par Per-Thread Initialization
   the new set_thread_init() function allows a call reference or closure to be set which will be automatically executed when new threads are started (or a new thread accesses a @ref Qore::Program "Program" object) which can be used to transparently initialize thread-local data.

   @par More Control Over Thread Resource Exceptions
   new functions:
   - throw_thread_resource_exceptions_to_mark()
   - mark_thread_resources()
   .
   Allow for only thread resouces created after a certain point to be processed (for example only thread resources left after some embedded code was called)

   @par New Socket Methods
   new methods:
   - Qore::Socket::upgradeClientToSSL()
   - Qore::Socket::upgradeServerToSSL()
   .
   Allow upgrading an already-existing socket connection to SSL

   @par Better Socket Error Messages
   More information has been added to socket exceptions to provide better feedback when errors occur.

   @par New Socket Event Fields
   - added \c "type" and \c "typename" keys to the @ref EVENT_HOSTNAME_RESOLVED event
   - added \c "type", \c "typename", and \c "address" keys to the @ref EVENT_CONNECTING event

   @par Support For Blocking Writes in the Queue Class
   @ref Qore::Thread::Queue "Queue" objects can now be used as a blocking message channel (similar to a Go channel); if a maximum size is given to the @ref Qore::Thread::Queue "Queue" constructor, then trying to write data to the @ref Qore::Thread::Queue "Queue" when it is full will block until the @ref Qore::Thread::Queue "Queue"'s size goes below the maximum size; optional timeout parameters have been added to @ref Qore::Thread::Queue "Queue" methods that write to the @ref Qore::Thread::Queue "Queue".

   @par New Queue::clear() Method
   Does just what you think it does :)

   @par date(string, string) Improvement
   added the possibility to specify microseconds when parsing dates against a mask with the date() function

   @par New Support For ++ And -- Operators With Floating-Point Lvalues
   previously this would either convert the lvalue to an int or throw an exception if the lvalue could not be converted to an int due to type restrictions

   @par Class Recognition/Compatibility Between Program Objects
   The problem is that a user class created from the same source code in two different @ref Qore::Program "Program" objects would be recognized as a different class with parameter and variable type restrictions - ie you could not declare a variable or parameter with a class type restrictions and assign it an object created from the same class source code but created in another @ref Qore::Program "Program" object.\n\n
   This problem is analogous to a similar problem with java in that classes built from the same source but from different classloaders are also recognized as different classes.\n\n
   In %Qore 0.8.4 a class signature is created of all public and private objects, and an SHA1 hash is maintained of the class signature, and if the class names and signatures match, then the classes are assumed to be identical, even if they have different internal class IDs (because they were created in different @ref Qore::Program "Program" objects, for example).

   @par New TimeZone::date(string) Method
   to support creating arbitrary dates in a given @ref Qore::TimeZone "TimeZone"

   @par New GetOpt::parse3() method
   This method will display any errors on @ref Qore::stderr "stderr" and exit the program (which is the most typical way of handling command line errors anyway)

   @par += Operator Optimization For object += hash
   this operation is faster in this release

   @par New Parse Option PO_NO_MODULES
   Using this option disables module loading

   @par New Parse Option PO_NO_EMBEDDED_LOGIC
   Using this option disables all dynamic parsing

   @par New Parse Directives
   - @ref assume-global "%assume-global": the opposite of @ref assume-local "%assume-local"
   - @ref old-style "%old-style": the opposite of @ref new-style "%new-style"
   - @ref require-dollar "%require-dollar": the opposite of @ref allow-bare-refs "%allow-bare-refs"
   - @ref push-parse-options "%push-parse-options": allows parse options to be saved and restored when the current file is done parsing; very useful for %include files

   @par New Context Functions
   - cx_value(): returns the value of the given key
   - cx_first(): returns @ref Qore::True "True" if iterating the first row
   - cx_last(): returns @ref Qore::True "True" if iterating the last row
   - cx_pos(): returns the current row number (starting from 0)
   - cx_total(): returns the total number of rows in the set

   @par SOCKET-HTTP-ERROR Exception Enhancement
   The invalid header info received is reported in the exception's \c "arg" key

   @par Improved Parse Error Messages
   Improved some parse error messages dealing with namespace and class declaration errors

   @par Added NT_CLOSURE Constant
   type code for runtime closure values

    @subsection qore_084_bug_fixes Bug Fixes in Qore
    - fixed a race condition with @ref Qore::Program "Program" objects when a signal handler is left active and the @ref Qore::Program "Program" terminates
    - fixed a bug in the @ref Qore::File "File" class where the encoding given in the constructor was ignored; if no encoding was given in the File::open*() method then the @ref Qore::File "File"'s encoding would always be set to the default encoding, now it's set to the encoding given in the constructor (as documented)
    - runtime checks have been implemented so that references to local variables cannot be passed to a closure; this would cause a runtime crash
    - a fix has been made to the @ref delete "delete" and @ref remove "remove" operators; lists will not be extended when trying to remove/delete list elements that do not exist
    - fixed some bugs showing the error location with bugs in the second stage of parsing (symbol resolution)
    - apply type filters to blocks with a designated return type but no @ref return "return statement"
    - fixed crashing bugs on some 32bit platforms where size_t was assumed to be 64 bits
    - fixed a crashing bug parsing invalid @ref requires "%requires" directives in the scanner
    - fixed a bug in usleep() with relative date/time values (added a new usleep() variant to support this)
    - fixed a typo in the command-line help for the qore binary with unknown parse options	  
    - fixed @ref Qore::Option::HAVE_SIGNAL_HANDLING "HAVE_SIGNAL_HANDLING" to be @ref Qore::False "False" if signal handling is disabled on platforms where signal handling is otherwise available
    - fixed a scanner bug parsing out of line class definitions with a root-justified namespace path (ex: \c "class ::X::ClassName ...")
    - merging code from binary modules at parse time and at runtime is now transaction-safe (before it would cause memory errors and/or a crash), now if errors are detected then an exception is raised and changes are not applied.
    - fixed a crashing bug in the C++ API function QoreHashNode::setKeyValue() when the value is 0 and an exception occurs or is already active before the call is made
    - fixed a bug in date parsing with a format string - off by one with integer months - added a regression test for this case
    - fixed a memory error with the @ref rethrow "rethrow statement" in enclosing but nested try-catch blocks
    - fixed a crashing bug where qore would try to instantiate a class for a type that did not represent a class (ex: \c "my int $i();")
    - fixed a memory leak in the @ref softlist_type "softlist" and @ref softlist_or_nothing_type "*softlist" type implementation
    - make sure and raise a \c SOCKET-CLOSED error when reading a HTTP header if no data is received
    - make sure and convert encodings with @ref Qore::index() "index()" and @ref Qore::rindex() "rindex()" functions if the encodings don't match
    - build fix: only use a lib64 directory if the directory exists already
    - raise a parse exception in the scanner if a numeric overflow occurs in literal integer values
    - fixed a bug in @ref Qore::Thread::AbstractSmartLock::lockTID() "AbstractSmartLock::lockTID()"
    - fixed a major crashing error in the C++ API function QoreStringNode::createAndConvertEncoding(); this function is used by the xml module when parsing XML-RPC sent in a non-UTF-8 character encoding
    - fixed Qore::File::getchar() to always retrieve 1 character (even for multi-byte character encodings)
    - fixed string evaluation in a boolean context to return @ref Qore::True "True" with floating-point numbers between -1.0 and 1.0 exclusive
    - printf formatting fix: output YAML-style \c "null" for @ref nothing with %%y
    - scanner fix: accept \r as whitespace to allow better parsing of sources with Windows EOL markers
    - fixed parse-time type processing/checks for the keys, + and * operators
    - foreach statement fix: unconditionally evaluate the hash when iterating as otherwise it could change during iteration which could cause a crash
    - fixed another parse-time variant matching bug where the variant-matching algorithm was too aggressive and excluded possible matches at parse time which could result in a false parse-time definitive match even though a better match could be available at runtime
    - fixed a static memory leak when signal handlers are left registered when the qore library terminates
    - fixed static memory leaks and 1 dynamic memory leak in strmul()
    - fixed a crashing bug in handling recursive constant references
    - fixed a bug in the C++ API function HashIterator::deleteKey() when the node's value is NULL
    - fixed time zone/DST calculations for time zone regions with DST with dates before the epoch but after the last DST transition before the epoch
    - fixed a memory error where invalid source expressions referenced in a regular expression substitution expression would cause a crash (ex: @verbatim str =~ s/public (name)/$2/g @endverbatim
    - fixed a memory error in regular expression substitution where the unconverted string (if not given in UTF-8 encoding) was used when copying source expressions to the target string
    - fixed a bug where a recursive class inheritance tree would cause a crash
    - fixed a bug where a static class method could not access private members of the class
*/
