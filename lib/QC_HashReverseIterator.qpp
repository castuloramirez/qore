/* -*- mode: c++; indent-tabs-mode: nil -*- */
/** @file QC_HashReverseIterator.qpp HashReverseIterator class definition */
/*
  Qore Programming Language

  Copyright 2003 - 2012 David Nichols

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <qore/Qore.h>

// the c++ object
class QoreHashReverseIterator : public QoreIteratorBase, public ReverseConstHashIterator {
protected:
   DLLLOCAL virtual ~QoreHashReverseIterator() {
   }

   DLLLOCAL int checkPtr(ExceptionSink* xsink) const {
      if (!ptr) {
         xsink->raiseException("ITERATOR-ERROR", "the HashReverseIterator is not pointing at a valid element; make sure HashReverseIterator::next() returns True before calling this method");
         return -1;
      }
      return 0;
   }

public:
   DLLLOCAL QoreHashReverseIterator(const QoreHashNode* h) : ReverseConstHashIterator(h->hashRefSelf()) {
   }

   using QoreIteratorBase::deref;
   DLLLOCAL virtual void deref(ExceptionSink* xsink) {
      if (ROdereference()) {
         const_cast<QoreHashNode*>(h)->deref(xsink);
         delete this;
      }
   }

   DLLLOCAL AbstractQoreNode* getReferencedValue(ExceptionSink* xsink) const {
      if (checkPtr(xsink))
         return 0;
      return ConstHashIterator::getReferencedValue();
   }

   DLLLOCAL QoreStringNode* getKey(ExceptionSink* xsink) const {
      if (checkPtr(xsink))
         return 0;
      return new QoreStringNode(ConstHashIterator::getKey());
   }

   DLLLOCAL virtual const char* getName() const { return "HashReverseIterator"; }
};

//! This class an iterator class for hashes
/** Call HashReverseIterator::next() to iterate through the hash in reverse order; do not use the iterator if HashReverseIterator::next() returns @ref False.
    A hash can be iterated in reverse order by calling HashReverseIterator::prev() instead of HashReverseIterator::next()

    @note
    - In general, the HashReverseIterator class is not safe to access from multiple threads; it was created without locking for
      fast and efficient use when used from a single thread.  For methods that would be unsafe to use in another thread, any use of
      such methods will cause an \c ITERATOR-THREAD-ERROR to be thrown.
    - HashReverseIterator is functionally equivalent to HashIterator, but the effect of HashReverseIterator::next() and HashReverseIterator::prev()
      are the opposite of HashIterator::next() and HashIterator::prev(); that is HashReverseIterator::next() will
      iterate through the hash in reverse order, while HashReverseIterator::prev() iterates in forward order.
      Additionally the meanings of the return values for HashReverseIterator::first() and HashReverseIterator::last()
      are swapped in respect to HashIterator::first() and HashIterator::last().

    @see HashIterator
 */
qclass HashReverseIterator [arg=QoreHashReverseIterator* i; ns=Qore; vparent=AbstractBidirectionalIterator];

//! Creates the hash iterator object
/** @param h the hash to iterate

    @par Example:
    @code
HashReverseIterator hi($h);
    @endcode
 */
HashReverseIterator::constructor(hash h) {
   self->setPrivate(CID_HASHREVERSEITERATOR, new QoreHashReverseIterator(h));
}

//! Moves the current position to the previous element in the hash; returns @ref False if there are no more elements; if the iterator is not pointing at a valid element before this call, the iterator will be positioned on the last element in the hash if the hash is not empty
/** This method will return @ref True again after it returns @ref False once if the hash is not empty, otherwise it will always return @ref False.
    The iterator object should not be used after this method returns @ref False

    @return @ref False if there are no more elements in the hash (in which case the iterator object is invalid and should not be used); @ref True if successful (meaning that the iterator object is valid)

    @par Example:
    @code
while ($i.prev()) {
    printf(" + %y\n", $i.getValue());
}
    @endcode

    @note HashReverseIterator::next() is the opposite of HashIterator::next(); it is functionally equivalent to HashIterator::prev();
    HashReverseIterator::next() iterates through the hash in reverse order

    @throw ITERATOR-THREAD-ERROR this exception is thrown if this method is called from any thread other than the thread that created the object
 */
bool HashReverseIterator::next() {
   if (i->check(xsink))
      return false;
   return i->next();
}

//! Moves the current position to the next element in the hash; returns @ref False if there are no more elements; if the iterator is not pointing at a valid element before this call, the iterator will be positioned on the first element in the hash if the hash is not empty
/** This method will return @ref True again after it returns @ref False once if hash is not empty, otherwise it will always return @ref False.
    The iterator object should not be used after this method returns @ref False

    @return @ref False if there are no more elements in the hash (in which case the iterator object is invalid and should not be used); @ref True if successful (meaning that the iterator object is valid)

    @par Example:
    @code
while ($i.next()) {
    printf(" + %y\n", $i.getValue());
}
    @endcode

    @note HashReverseIterator::prev() is the opposite of HashIterator::prev(); it is functionally equivalent to HashIterator::next();
    HashReverseIterator::prev() iterates through the hash in forward order

    @throw ITERATOR-THREAD-ERROR this exception is thrown if this method is called from any thread other than the thread that created the object
 */
bool HashReverseIterator::prev() {
   if (i->check(xsink))
      return false;
   return i->prev();
}

//! returns @ref True if the hash is empty; @ref False if not
/** @return @ref True if the hash is empty; @ref False if not

    @par Example:
    @code
if ($i.empty())
    printf("the hash is empty\n");
    @endcode
 */
bool HashReverseIterator::empty() [flags=CONSTANT] {
   return i->empty();
}

//! returns @ref True if on the last element of the hash
/** @return @ref True if on the last element of the hash

    @par Example:
    @code
while ($i.next()) {
    if ($i.first())
        printf("START:\n");
}
    @endcode
 */
bool HashReverseIterator::first() [flags=CONSTANT] {
   return i->first();
}

//! returns @ref True if on the first element of the hash
/** @return @ref True if on the first element of the hash

    @par Example:
    @code
while ($i.next()) {
    if ($i.last())
        printf("END.\n");
}
    @endcode
 */
bool HashReverseIterator::last() [flags=CONSTANT] {
   return i->last();
}

//! returns the current value or throws an \c INVALID-ITERATOR exception if the iterator is invalid
/** @return the current value or throws an \c INVALID-ITERATOR exception if the iterator is invalid

    @par Example:
    @code
while ($i.next()) {
    printf("+ %y\n", $i.getValue());
}
    @endcode

    @throw INVALID-ITERATOR the iterator is not pointing at a valid element
    @throw ITERATOR-THREAD-ERROR this exception is thrown if this method is called from any thread other than the thread that created the object
 */
any HashReverseIterator::getValue() [flags=RET_VALUE_ONLY] {
   if (i->check(xsink))
      return 0;
   return i->getReferencedValue(xsink);
}

//! returns the current value or throws an \c INVALID-ITERATOR exception if the iterator is invalid
/** @return the current value or throws an \c INVALID-ITERATOR exception if the iterator is invalid

    @par Example:
    @code
while ($i.next()) {
    printf("+ %y\n", $i.getValue());
}
    @endcode

    @throw INVALID-ITERATOR the iterator is not pointing at a valid element
    @throw ITERATOR-THREAD-ERROR this exception is thrown if this method is called from any thread other than the thread that created the object
 */
string HashReverseIterator::getKey() [flags=RET_VALUE_ONLY] {
   if (i->check(xsink))
      return 0;
   return i->getKey(xsink);
}
