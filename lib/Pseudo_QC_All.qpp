/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  Pseudo_QC_All.qpp

  Qore Programming Language

  Copyright 2003 - 2012 David Nichols

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <qore/Qore.h>

//! Methods in this pseudo-class are available to be executed on any value type (even @ref nothing); this is the root class for all pseudo-classes
/** 
 */
qclass <value> [arg=AbstractQoreNode* node];

//! Returns the type code for the value
/** This method is recommended over <value>::type() or the type(any) or typename(any) functions for comparing data types as it is much faster and more efficient than the other alternatives (which work with string values instead of integer codes).

    @return the type code for the value; see @ref type_code_constants for possible return values for each type

    @par Example:
    @code
switch ($v.typeCode()) {
    case NT_INT:
        printf("%y: is an integer\n", $v);
	break;

    case NT_DATE:
        printf("%y: is a date\n", $v);
	break;

    default:
        printf("%y: is something else entirely\n", $v);
	break;
}
    @endcode    
 */
int <value>::typeCode() [flags=CONSTANT] {
   return get_node_type(node);
}

//! Returns the string type for the value
/** 
    @return the string type for the value; see @ref string_type_constants for possible return values for each type

    @par Example:
    @code
my string $t = $n.type();
    @endcode

    @note It is faster and more efficient to use <value>::typeCode() for comparing data types
*/
string <value>::type() [flags=CONSTANT] {
   return new QoreStringNode(node ? node->getTypeName() : "nothing");
}

//! Returns @ref True; this method will be reimplemented in container types where it may return @ref False
/** This pseudo-method will return @ref False in all non-container types; use <value>::val() to check if a generic
    expression that might not be a container type has a value instead.

    @return @ref True; this method will be reimplemented in container types where it may return @ref False

    @par Example:
    @code
my int $i = 100;
if ($i.empty())
    printf("%y: is empty (probably because it's a value of type %y)\n", $i, $i.type());
    @endcode

    @see <value>::val()
*/
bool <value>::empty() [flags=CONSTANT] {
   return true;
}

//! Returns zero; this method will be reimplemented in container types where it may return a non-zero value
/** This pseudo-method will return 0 in all non-container types; use <value>::val() to check if a generic
    expression that might not be a container type has a value instead.

    @return zero; this method will be reimplemented in container types where it may return a non-zero value

    @par Example:
    @code
my int $i = 100;
if (!$i.size())
    printf("%y: has size 0 (probably because it's a value of type %y)\n", $i, $i.type());
    @endcode

    @see <value>::val()
*/
int <value>::size() [flags=CONSTANT] {
   return 0;
}

//! Returns @ref False; this method is reimplemented in other types and will return @ref True if the given expression has a value
/** This pseudo-method can be used to mimic perl's boolean evaluation; unfortunately it was a design error in Qore to
    implement strict mathematical boolean evaluation (where any value must evaluate to a non-zero integer or floating-point
    value to be @ref True), however this pseudo-method solves the problem in an intuitive manner.

    @return @ref False; this method is reimplemented in other types and will return @ref True if the given expression has a value

    @par Example:
    @code
if ($n.val())
    printf("%y: has a value\n", $n);
    @endcode
*/
bool <value>::val() [flags=CONSTANT] {
   return false;
}

//! Returns @ref False; this method is reimplemented in other types and will return @ref True if the given expression can be converted to an integer
/**
    @return @ref False; this method is reimplemented in other types and will return @ref True if the given expression can be converted to an integer

    @par Example:
    @code
if ($n.intp())
    printf("%y: can be converted to an integer: %d\n", $n, int($n));
    @endcode

    @see <string>::intp() for an example of an implementation of this method where the result depends on the value and not the type
*/
bool <value>::intp() [flags=CONSTANT] {
   return false;
}

//! Returns @ref False; this method is reimplemented in other types and will return @ref True if the given expression can be converted to a string
/**
    @return @ref False; this method is reimplemented in other types and will return @ref True if the given expression can be converted to a string

    @par Example:
    @code
if ($n.strp())
    printf("%y: can be converted to a string: '%s'\n", $n, string($n));
    @endcode
*/
bool <value>::strp() [flags=CONSTANT] {
   return false;
}
