# -*- mode: qore; indent-tabs-mode: nil -*-
# @file SmtpClient.qm SmtpClient module definition

/*  SmtpClient.qm Copyright 2012 Wolfgang Ritzinger, Marian Bonda, Pavol Potoncok

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum qore version
%requires qore >= 0.8.4

# need mime definitions
%requires Mime >= 1.0

module SmtpClient {
    version = "1.0";
    desc = "SMTP client support module";
    author = "Wolfgang Ritzinger <aargon@rat.at>, Marian Bonda <marian_bonda@users.sourceforge.net>, Pavol Potoncok <ppotancok@gmail.com>";
    url = "http://qore.org";
}

/*  Version History
    * 1.0: David Nichols <david@qore.org>: updated to a user module, added initial rudimentary ESMTP handling, STARTTLS and quoted-printable encoding support + the bane of all developers: documentation :)
    ritzinwo, 20090716

    based on:
    - http://james.apache.org/server/rfclist/smtp/rfc0821.txt
    - http://tools.ietf.org/html/rfc821: initial SMTP protocol spec
    - http://tools.ietf.org/html/rfc1521: quoted printable & base 64 transfer encodings
    - http://tools.ietf.org/html/rfc2045: mime headers, content types, etc
    - http://tools.ietf.org/html/rfc2047: "Q" and "B" encoded words (implemented by the Mime module)
    - http://tools.ietf.org/html/rfc2822: message structure, headers, body, etc
*/

/** @mainpage SmtpClient Module

    The %SmtpClient module provides a set of classes that can be used for easy communication with SMTP servers for sending emails.

    To use this module, use \c "%requires SmtpClient" in your code.  See examples/email.q for an example program using this module
    
    All the public symbols in the module are defined in the %SmtpClient namespace

    The main classes are:
    - @ref SmtpClient::SmtpClient "SmtpClient": manages a connection to an SMTP server
    - @ref SmtpClient::Message "Message": wraps a message to be sent via an @ref SmtpClient::SmtpClient "SmtpClient" object
    - @ref SmtpClient::Attachment "Attachment": used to attach files to a @ref SmtpClient::Message "Message"

    @par Example:
    @code
my SmtpClient::Message $msg("The Sender <sender@email.com>", "My Subject");
$msg.setBody($body);
$msg.addTO("My Best Friend <you@friend.com>");
$msg.attach($filename, MimeTypeText, $data);

my code $log = sub (string str) {printf("%y: %s\n", now_us(), str);}
my SmtpClient::SmtpClient $smtp("smtp.example.com", $log, $log);
$smtp.sendMessage($msg);@endcode
 */

#! the %SmtpClient namespace holds all public definitions in the %SmtpClient module
/** This includes:
    - SmtpClient: manages a connection to an SMTP server
    - Message: wraps a message to be sent via an SmtpClient object
    - Attachment: used to attach files to a Message
*/
public namespace SmtpClient {
    /** @defgroup MessageEncodings Smtp Message Encodings
     */
    #@{
    #! default content transfer encoding depending on attachment type
    public const EncDefault = "default";

    #! no content transfer encoding (not recommended as SMTP servers break up long lines automatically)
    public const EncNone = "none";

    #! base-64 content transfer encoding
    public const EncBase64 = "base64";

    #! "quoted-printable" content transfer encoding
    public const EncQuotedPrintable = "quoted-printable";

    #! a list of all known content encoding schemes encodings
    public const Encodings = (
	EncDefault,
	EncNone,
	EncBase64,
	EncQuotedPrintable,
	);       
    #@}

    #! 15 second read timeout
    public const DefaultReadTimeout = 15s;

    #! 30 second connect timeout
    public const DefaultConnectTimeout = 30s;

    #! The %Message class holds the information for a single email %Message to be sent via an SmtpClient object
    /** @par Example:
        @code
my SmtpClient::Message $msg("The Sender <sender@email.com>", "My Subject");
$msg.setBody($body);
$msg.addTO("My Best Friend <you@friend.com>");
@endcode

        Each message must have a body and at least one destination address before it can be sent.

        Set the body text with:
        - Message::setBody(): set/replace the message body
        - Message::addBody(): or add a line to the body with 
 
        Add recipients with:
        - Message::addTO()
        - Message::addCC()
        - Message::addBCC()

        Each of the above methods takes email addresses like the sender address in Message::constructor()

        To get a text summary of the Message; try:
        - Message::toString(): returns a multi-line summary of the message for display purposes
        - Message::toLine(): returns a single line summary of the message for display purposes
        
        Additional header lines (eg: \c "X-SPAM-Status: No") can be added with addHeader(string) or
        set with setHeader()

        For example, to set the messageid:
        @code
$m.addHeader("Message-ID: <20090712.123456789@mail.drei.at>");@endcode

        Other useful methods:
        - attach(): add attachments
        - important(): sets the given importance or returns the current setting (depending on the variant used)
        - receiptDelivery(): sets the delivery receipt or returns the current setting (depending on the variant used)
        - receiptRead(): sets the read receipt request or returns the setting (depending on the variant used)
    */
    public class Message {
	private {
	    # the sender
	    string $.from;
	    # subject is a header field
	    string $.subject;

	    # additional headers
	    list $.headers = (); # list for additional headers except the ones below
	    # message statuses
	    bool $.importance = False;
	    bool $.deliveryReceipt = False;
	    bool $.readReceipt = False;

	    # names
	    #$.from; # will be prefilled (and overwritten) with the sender
	    list $.to = (); # list of names for to (header only) will be prefilled (and overwritten) with the recipients
	    list $.cc = (); # list of cc's
	    list $.bcc = (); # list of bcc's

	    # message data itself
	    string $.messageData = "";

	    # message body content transfer encoding
	    string $.messageEncoding = EncDefault;

	    list $.attachments = ();
	    string $.sender;
	}

	public {}

	#! creates a Message to send in the SmtpClient
	/** Use the Message::addTo() method to add message recipients

	    @param sender the sender's email address; can be in the format \c "Full Display Name <name@example.com>"
	    @param subject the subject line for the email; the subject will be encoded with <a href="http://tools.ietf.org/html/rfc2047">"Q" encoding</a>

	    @throw MESSAGE-CONSTRUCTOR-ERROR the sender's email address is not valid; the subject is empty
	 */
	constructor(string $sender, string $subject) {
	    my *string $se = Message::getEmailAddress($sender);
	    if (!exists $se)
		throw "MESSAGE-CONSTRUCTOR-ERROR", sprintf("cannot get email address out of: %y", $sender);

	    # subject
	    if ($subject.empty())
		throw "MESSAGE-CONSTRUCTOR-ERROR", "subject must be not empty string";

	    $.sender = $se;   # used for sending
	    $.from = $sender; # used for displaying
	    $.subject = $subject;
	}

	#! fetch the email address out of a sender/rcpt string
	static *string getEmailAddress(string $str) {
	    return ($str =~ x/([a-zA-Z0-9\-\._\+\ = ]+@[a-zA-Z0-9\-\._]+)/)[0];
	}

	#! returns True if the string contains an email address, False if not
	static bool checkEmailAddress(string $str) {
	    return !Message::getEmailAddress($str).empty();
	}

	#! add a recipient to the Message's recipient list
	/** @param recipient the email address to send the message to
	    @return the list of "To:" addresses

	    @throw MESSAGE-ADDTO-ERROR the recipient's email address is invalid
	*/
	list addTO(string $recipient) {
	    if (!Message::checkEmailAddress($recipient))
		throw "MESSAGE-ADDTO-ERROR", sprintf("cannot determine email address in %y", $recipient);

	    return $.to += $recipient;
	}
	
	#! add a recipient to the Message's cc list
	/** @param recipient the email address to send the message to (cc)
	    @return the list of "CC:" addresses

	    @throw MESSAGE-ADDCC-ERROR the recipient's email address is invalid
	*/
	list addCC(string $recipient) {
	    if (!Message::checkEmailAddress($recipient))
		throw "MESSAGE-ADDCC-ERROR", sprintf("cannot determine email address in %y", $recipient);

	    return $.cc += $recipient;
	}

	#! add a recipient to the Message's bcc list
	/** @param recipient the email address to send the message to (bcc)
	    @return the list of "BCC:" addresses

	    @throw MESSAGE-ADDBCC-ERROR the recipient's email address is invalid
	 */
	list addBCC(string $recipient) {
	    if (!Message::checkEmailAddress($recipient))
		throw "MESSAGE-ADDBCC-ERROR", sprintf("cannot determine email address in %y", $recipient);

	    return $.bcc += $recipient;
	}

	#! returns the sender's address in display format
	string getSender() {
	    return $.from;
	}

	#! returns the sender's email address
	string getFrom() {
	    return $.sender;
	}

	#! returns the list of "To:" addresses
	list getTO() {
	    return $.to;
	}

	#! returns the list of "CC:" addresses
	list getCC() {
	    return $.cc;
	}

	#! returns the list of "BCC:" addresses
	list getBCC() {
	    return $.bcc;
	}

	#! returns the subject of the Message
	string getSubject() {
	    return $.subject;
	}

	#! return all the email addresses the message will be sent to, a combination of the "To:", "CC:", and "BCC:" lists
	list getRecipients() {
	    my list $recpt = ();
	    foreach my string $e in ($.to + $.cc + $.bcc)
		$recpt += $.getEmailAddress($e);
	    return $recpt;
	}

	#! returns True if the message can be sent, False if not
	/** To be able to send a message, there must be at least one recipient in the "To:" or the "CC:" or the "BCC:" lists \
	    and there must be a message body 

	    @return True if the message can be sent, False if not
	 */
	bool sendPossible() {
	    if ($.to.empty() && $.cc.empty() && $.bcc.empty())
		return False;

	    return $.messageData.empty() ? False : True;
	}

	#! throw a MESSAGE-ERROR exception if the Message cannot be sent
	checkSendPossible() {
	    if ($.to.empty() && $.cc.empty() && $.bcc.empty())
		throw "MESSAGE-ERROR", "the Message cannot be sent because there is no target address";
	    
	    if ($.messageData.empty())
		throw "MESSAGE-ERROR", "the Message cannot be sent because there is no message body set";
	}

	#! sets or replaces the Message body
	/** @param str the Message body to set
	    @param enc the encoding type for the message (see @ref MessageEncodings for possible values)

	    @throw UNKNOWN-ENCODING the message encoding value passed is unknown/unimplemented
	 */
	setBody(string $str, string $enc = EncDefault) {
	    $enc = SmtpClient::checkEncoding($str, $enc);
	    $.messageData = $str;
	    $.messageEncoding = SmtpClient::checkEncoding($str, $enc);
	}

	#! concatenates a string to the message body
	/** @param str the string to concatenate to the Message body
	 */
	addBody(string $str) {
	    $.messageData += $str;
	}

	#! returns the Message body
	string getBody() {
	    return $.messageData;
	}

	#! returns the transfer encoding for the mssage body (see @ref MessageEncodings for possible values)
	string getBodyTransferEncoding() {
	    return $.messageEncoding;
	}

	#! sets/replaces the list of Message headers
	/** @param hdr the list of Message headers to set
	    
	    @note headers for importance, delivery receipt and read receipt will be added automatically and should not be included here
         */
	setHeader(softlist $hdr) {
	    $.headers = $hdr;
	}

	#! adds a header to the Message
	/** @param hdr a header to add to the Message
	    
	    @note headers for importance, delivery receipt and read receipt will be added automatically and should not be included here
	 */
	addHeader(string $hdr) {
	    push $.headers, $hdr;
	}

	#! returns the current user header list
	list getHeader() {
	    return $.headers;
	}

	#! returns the current importance setting
	/** if this is True, then the following headers will be sent:
	    - \c Importance: high
	    - \c X-Priority: 1
	    - \c Priority: Urgent
	 */
	bool important() {
	    return $.importance;
	}

	#! sets the importance setting
	/** if this is True, then the following headers will be sent:
	    - \c Importance: high
	    - \c X-Priority: 1
	    - \c Priority: Urgent
	 */
	important(softbool $i) {
	    $.importance = $i;
	}

	#! returns the current read delivery receipt setting
	/** if this is True, then the following header will be sent:
	    - \c Return-Receipt-To: <sender's email address>
	  */
	bool receiptRead() {
	    return $.deliveryReceipt;
	}

	#! sets the read delivery receipt setting
	/** if this is True, then the following header will be sent:
	    - \c Return-Receipt-To: <sender's email address>
	  */
	receiptRead(bool $arg) {
	    $.deliveryReceipt = $arg;
	}

	#! returns the delivery receipt setting
	/** if this is True, then the following header will be sent:
	    - \c Disposition-Notification-To: <sender's email address>
	  */
	bool receiptDelivery() {
	    return $.readReceipt;
	}

	#! sets the delivery receipt setting
	/** if this is True, then the following header will be sent:
	    - \c Disposition-Notification-To: <sender's email address>
	  */
	receiptDelivery(bool $arg) {
	    $.readReceipt = $arg;
	}

	#! creates an attachment for the Message
	/** @param name the name of the attachment to be displayed in the message, normally a file name without any path
	    @param mime the mime type for the message
	    @param att the attachment itself
	    @param enc the encoding type for the message (see @ref MessageEncodings for possible values)

	    @throw UNKNOWN-ENCODING the message encoding value passed is unknown/unimplemented
	    @throw INVALID-ENCODING the encoding given cannot be used with data given
	 */
	attach(string $name, string $mime, data $att, string $enc = EncDefault) {
	    $.attachments += new SmtpClient::Attachment($name, $mime, $att, $enc);
	}

	#! adds an Attachment to the Message
	/** @param att the Attachment to add to the Message
	  */
	attach(Attachment $att) {
	    $.attachments += $att;
	}

	#! returns a list of Attachment objects for the Message
	list getAttachments() {
	    return $.attachments;
	}

	private list getEnvelopeList() {
	    my list $env = (sprintf("Sender: '%s'", $.from), sprintf("Subject: '%s'", $.subject));
	    # add To addresses
	    map $env += sprintf("To: %s", $1), $.to;
	    # add CC addresses
	    map $env += sprintf("CC: %s", $1), $.cc;
	    # add BCC addresses
	    map $env += sprintf("BCC: %s", $1), $.bcc;
	    return $env;
	}

	#! returns a multi-line string representing the Message
	/** @param body if True the Message body will be included in the string output
	 */
	string toString(bool $body = False) {
	    my list $attarr = ();
	    foreach my Attachment $att in ($.attachments)
		$attarr += sprintf("%s (%s,%d)", $att.getName(), $att.getMime(), $att.getData().size());

	    # sending envelope: from, to, subject
	    my list $env = $.getEnvelopeList();

	    # the main string
	    my string $str = sprintf("Message (%s)\n", $.sendPossible() ? "ok": "unfinished");

	    # from/to/subject
	    foreach my string $l in ($env)
		$str += "  " + trim($l) + "\n";

	    # important or not...
	    $str += sprintf("%s%s%s",
			    $.important() ? "  Important\n": "",
			    $.receiptDelivery() ? "  ReceiptDelivery\n": "",
			    $.receiptRead() ? "  ReceiptRead\n": "");

	    # add headers
	    foreach my string $l in ($.headers)
		$str += "  " + trim($l) + "\n";

	    # add attachments
	    if (elements $attarr) {
		$str += "  Attachments:\n";
		foreach my $l in ($attarr) {
		    $str += "    " + trim($l) + "\n";
		}
	    }
	    
	    # the user wants to see the body also...
	    if ($body)
		$str += "--\n" + trim($.messageData) + "\n";

	    return $str;
	}

	#! returns a single line string summarizing the Message
	/** @return a single line string summarizing the Message
	 */
	string toLine() {
	    # attachments
	    my list $attarr = ();
	    foreach my Attachment $att in ($.attachments)
		$attarr += sprintf("%s (%s,%d)", $att.getName(), $att.getMime(), $att.getData().size());

	    # sending envelope: from, to, subject
	    my list $env = $.getEnvelopeList();

	    # the main string
	    my string $str = sprintf("[Message (%s), %s, %simportant, %sdelivery, %sread",
			 $.sendPossible()? "ok": "unfinished",
			 join(", ", $env),
			 $.important()? "": "not ",
			 $.receiptDelivery()? "": "not ",
			 $.receiptRead()? "": "not "
		);
	    # add headers
	    if (elements $.headers)
		$str += sprintf(", %s", join(", ", $.headers));

	    # add attachments
	    if (elements $attarr)
		$str += sprintf(", %s", join(", ", $attarr));

	    $str += "]";

	    return $str;
	}
    }

    #! class representing an Attachment for the Message
    /** this class wraps all the data for the attachment, including:
        - the attachment's name; ie the file name which will be shown
	- the mime type which will be sent (ex: MimeTypeJpeg ie \c "image/jpeg")
	- the data for the attachment; either binary object or as str
	- the encoding type for the attachment

	@par Example:
	@code
my File $f();
$f.open2("file.jpg");
my Attachment $att("file.jpg", MimeTypeJpeg, $f.readBinary(-1));
$f.close();
$msg.addAttachment($att);
        @endcode
    */
    class Attachment {
	private {
	    string $.name;
	    string $.mime;
	    data $.data;
	    #! content-transfer encoding
	    string $.enc;
	}

	#! no public members
	public {}

	#! creates an Attachment object for a Message object
	/** @param name the name of the attachment to be displayed in the message, normally a file name without any path
	    @param mime the mime type for the message
	    @param data the attachment data itself
	    @param enc the encoding type for the message (see @ref MessageEncodings for possible values)

	    @throw UNKNOWN-ENCODING the message encoding value passed is unknown/unimplemented
	    @throw INVALID-ENCODING the encoding given cannot be used with data given
	 */
	constructor(string $name, string $mime, data $data, string $enc = EncDefault) {
	    $.name = $name;
	    $.mime = $mime;
	    $.data = $data;

	    $.enc = SmtpClient::checkEncoding($data, $enc);
	}

	#! returns the name of the Attachment
	string getName() {
	    return $.name;
	}

	#! returns the mime type of the Attachment
	string getMime() {
	    return $.mime;
	}

	#! returns the data of the Attachment
	data getData() {
	    return $.data;
	}

	#! returns the encoding of the Attachment
	string getEncoding() {
	    return $.enc;
	}

	#! serializes a string for sending the Attachment according to the encoding
	string encode() {
	    return SmtpClient::encodeData($.data, $.mime, sprintf("attachment; filename=%y", $.name), $.enc);
	}
    }

    #! the class that's used to communicate with an SMTP server
    public class SmtpClient {
	private {
	    Socket $.sock();

	    # connect string
	    string $.connect;

	    # ensures exclusive access to the object
	    Mutex $.mutex();
	    
	    bool $.nosend = False;

	    # optional info log closure
	    *code $.log_info;

	    # optional debug log closure
	    *code $.log_debug;

	    # tls flag
	    bool $.tls = False;

	    # esmtp flag
	    bool $.esmtp;

	    # authentication credentials
	    *string $.user;
	    *string $.pass;

	    # logged in flag
	    bool $.logged_in = False;

            # read timeout in milliseconds
            timeout $.readTimeout = DefaultReadTimeout;

            # connect timeout in milliseconds
            timeout $.connectTimeout = DefaultConnectTimeout;
	}

	public {
	    #! create a different multipart boundary string every time based on the current time
	    string $.mpboundary = replace(makeBase64String(string(now_us())), "=", "");

	    #! default SMTP port
	    const SmtpPort = 25;
	}

	#! creates the SmtpClient object
	/** @param host the hostname of the SMTP server (use \c "[hostname]" to explicitly specify an ipv6 connection)
	    @param port the port number of the SMTP server
	    @param log a closure for log messages
	    @param dbglog a closure for debugging/technical log messages
	 */
	constructor(string $host, softint $port, *code $log, *code $dbglog) {
	    $.log_info = $log;
	    $.log_debug = $dbglog;

	    $.connect = sprintf("%s:%d", $host, $port);
	    $.logDbg("SmtpClient server: %y", $.connect);
	}

	#! creates the SmtpClient object
	/** @param connect the hostname of the SMTP server or a hostname:port specification (use \c "[hostname]" or \c "[address]" for ipv6 connections); if no port is given for non-UNIX sockets, then SmtpPort is used as the default port number
	    @param log an optional closure or call reference for log messages
	    @param dbglog an optional closure or call reference for debugging/technical log messages
	 */
	constructor(string $connect, *code $log, *code $dbglog) {
	    $.log_info = $log;
	    $.log_debug = $dbglog;

	    # add default port if the connect string has no port number and:
	    # 1) is not a path (for a UNIX domain socket)
	    # 2) is not an ipv6 address enclosed in '[]' (ex '[2001:0db8:85a3:0000:0000:8a2e:0370:7334]')
	    if ($connect !~ /^\//) {
		my *softint $p = ($connect =~ x/:([0-9]+)$/)[0];
		if (!$p)
		    $connect += ":" + SmtpPort;
	    }

	    $.connect = $connect;
	    $.logDbg("SmtpClient server: %y", $.connect);
	}

	#! disconnects if connected and destroys the object
        /** if any exceptions occur during the disconnection, they are sent to the debug log closure/call reference
         */
  	destructor() {
	    try {
		$.disconnect();
	    }
	    catch (hash $ex) {
		$.logDbg("SmtpClient disconnect: %s: %s", $ex.err, $ex.desc);
	    }
  	}

        #! sets the TLS/SSL flag
        /** @param tls if @ref Qore::True "True" then use TLS/SSL; if the TLS/SSL flag is set then the client will issue a STARTTLS command after connecting and negotiate a secure TLS/SSL connection to the server
         */
	tls(bool $tls) {
	    $.tls = $tls;
	}

        #! returns the TLS/SSL flag
	bool tls() {
	    return $.tls;
	}

        #! sets the username and password for authenticated connections
        /** This method is protected by the object's Mutex lock
            @note currently this class only knows how to do AUTH PLAIN authentication
         */
	setUserPass(string $user, string $pass) {
	    my AutoLock $am($.mutex);
	    $.user = $user;
	    $.pass = $pass;
	}

	private log(string $msg) {
	    if ($.log_info.val())
		call_function($.log_info, "SmtpClient: " + trim(vsprintf($msg, $argv)));
	}

	private logDbg(string $msg) {
	    if ($.log_debug.val())
		call_function($.log_debug, "SmtpClient: " + trim(vsprintf($msg, $argv)));
	}

	#! sets or disables test mode; no connections are made in test mode
	test(bool $ns) {
	    $.nosend = $ns;
	}

	#! returns the test mode flag
	bool test() {
	    return $.nosend;
	}

	#! connect to the server
        /** This method is protected by the object's Mutex lock

            @note for possible exceptions, see %Qore's @ref Qore::Socket::connect() "Socket::connect()" method
         */
  	connect() {
	    my AutoLock $am($.mutex);
            $.connectIntern();
        }

        private connectIntern() {
	    $.sock.connect($.connect, $.connectTimeout);
  	}
  	
	#! return connection status
  	bool isConnected() {
	    return ($.nosend || $.sock.isOpen());
  	}
  	
	#! disconnect from the server
        /** This method is protected by the object's Mutex lock
         */
  	disconnect() {
	    my AutoLock $am($.mutex);
            $.disconnectIntern();
  	}

        private disconnectIntern() {
	    if ($.isConnected()) {
		$.sock.close();
		$.sock.shutdown();
	    }
        }
  	
        #! sets the read timeout
        setReadTimeout(timeout $to) {
            $.readTimeout = $to;
        }

        #! returns the read timeout as an integer giving milliseconds
        int getReadTimeoutMs() {
            return $.readTimeout;
        }
        
        #! returns the read timeout as a relative time value
        date getReadTimeoutDate() {
            return milliseconds($.readTimeout);
        }

        #! sets the connect timeout
        setConnectTimeout(timeout $to) {
            $.connectTimeout = $to;
        }

        #! returns the connect timeout as an integer giving milliseconds
        int getConnectTimeoutMs() {
            return $.connectTimeout;
        }
        
        #! returns the connect timeout as a relative time value
        date getConnectTimeoutDate() {
            return milliseconds($.connectTimeout);
        }

	#! returns a string of message data according to the encoding passed
	static string encodeData(data $data, string $mime, string $disp, string $enc) {
	    my string $str = sprintf("Content-Type: %s\r\nContent-Disposition: %s\r\n", $mime, $disp);
	    switch ($enc) {
		case EncBase64: {
		    $str += "Content-Transfer-Encoding: base64\r\n\r\n";
		    $str += mime_encode_base64($data, 72);
		    $str += "\r\n";
		    break;
		}
		case EncNone: {
		    $str += "\r\n";
		    $str += $data;
		    $str += "\r\n";
		    break;
		}
		case EncQuotedPrintable: {
		    $str += sprintf("Content-Transfer-Encoding: quoted-printable\r\n\r\n");
		    $str += mime_encode_quoted_printable($data);
		    $str += "\r\n";
		    break;
		}
	    }

	    return $str;
	}

	#! checks the data against the encoding and returns the new encoding (if the encoding is EncDefault for example)
	/** @param data the data to be encoded
	    @param enc the encoding type for the data (see @ref MessageEncodings for possible values)

	    @return the new encoding to use in case the input data was EncDefault

	    @throw UNKNOWN-ENCODING the message encoding value passed is unknown/unimplemented
	    @throw INVALID-ENCODING the encoding given cannot be used with data given
	 */
	static string checkEncoding(data $data, string $enc) {
	    if ($enc == EncDefault)
		$enc = $data.typeCode() == NT_STRING ? EncQuotedPrintable : EncBase64; 
	    else if (!inlist($enc, Encodings))
		throw "UNKNOWN-ENCODING", sprintf("%y is not a known encoding; known encodings: %y", $enc, Encodings);

	    if ($data.typeCode() == NT_BINARY && $enc == EncNone)
		throw "INVALID-ENCODING", sprintf("%y cannot be used with binary data", $enc);

	    return $enc;
	}

	# send data over the socket
	private sendDataIntern(string $str) {
	    if (!$.isConnected()) {
		$.logDbg("send: not connected; not sending");
		throw "NOT-CONNECTED", "not connected in sendDataIntern()";
	    }

	    # send
	    $.sock.send($str);
	}

	# send data and log in the debug log if set
	private sendData(string $str) {
	    # format additional arguments if necessary
	    if (!$argv.empty())
		$str = vsprintf($str, $argv);

	    if ($.log_debug.val()) {
		my string $lstr = trim($str);
		if ($lstr.size() > 128) {
		    splice $lstr, 128;
		    $lstr += "...";
		}
		$.logDbg("data: %y", $lstr);
	    }

	    $.sendDataIntern($str);
	}

	# send a command over the socket and return the response as a hash
	private hash sendCommand(string $str) {
	    # format additional arguments if necessary
	    if (!$argv.empty())
		$str = vsprintf($str, $argv);

	    trim $str;
	    $.logDbg("send %y", $str);

	    # send data
	    $.sendDataIntern($str + "\r\n");

	    # read data
	    my string $rep;

	    my softint $code;
	    my string $desc;

	    # process multi-line responses
	    while (True) {
		my string $l = $.readLine($.readTimeout);
		trim $l;
		$.logDbg("reply: %y", $l);

		# if a continuation is signaled from the server, then keep reading
		if ($l =~ /^[0-9]{3}-/) {
		    if (!$code)
			$code = int($l);
		    # assume it's the same code every time
		    if (!$desc.empty())
			$desc += "\n";
		    $desc += extract $l, 4;
		    continue;
		}
		else {
		    if ($l !~ /^[0-9]{3} /) {
			$.log("cannot parse reply: %s\n", $l);
			$desc += $l;
			$code = -1;
			break;
		    }
		    if (!$code)
			$code = int($l);
		    # assume it's the same code every time
		    if (!$desc.empty())
			$desc += "\n";
		    $desc += extract $l, 4;
		    break;
		}
	    }

	    return ("code": $code, "desc": $desc);
	}

	# read a line from the socket (terminated with \n)
	private string readLine(timeout $to) {
	    my string $str;
	    my int $c = 0;
	    do {
		$c = $.sock.recvu1($to);
		$str += chr($c);
	    } while ($c != 10);

	    return $str;
	}

        # sends the message header (without body & attachments) to the SMTP server
	private hash sendMessageHeaderIntern(SmtpClient::Message $message) {
	    # open connection to server
	    if (!$.isConnected()) {
		$.connectIntern();
		my string $rep = $.readLine($.readTimeout);
		$.logDbg("connect reply: %y", trim($rep));
		$.esmtp = ($rep =~ /ESMTP/);
	    }

	    # send HELO/EHLO string
	    my string $hello = $.esmtp ? "EHLO" : "HELO";
	    my hash $rh = $.sendCommand($hello + "  %s", gethostname());
	    if ($rh.code >= 500)
		throw "SMTP-DATA-EXCEPTION", sprintf("error sending %s command: %y", $hello, $rh);

	    my hash $reply.$hello = $rh;

	    # issue STARTTLS and upgrade to a TLS connection if the tls flag is set and we are not already secure
	    if ($.tls && !$.sock.isSecure()) {
		$rh = $.sendCommand("STARTTLS");
		if ($rh.code >= 500)
		    throw "SMTP-DATA-EXCEPTION", sprintf("error sending STARTTLS command: %y", $rh);

		$.sock.upgradeClientToSSL();
		$.logDbg("upgrade to TLS/SSL connection %s %s", $.sock.getSSLCipherName(), $.sock.getSSLCipherVersion());
	    }
	    
	    # issue login if credentials supplied and we have not already logged in
	    if (!$.logged_in && !$.user.empty()) {
		$rh = $.sendCommand("AUTH PLAIN %s", makeBase64String(binary($.user) + <00> + binary($.user) + <00> + binary($.pass)));
		if ($rh.code != 235)
		    throw "SMTP-DATA-EXCEPTION", sprintf("login failed: %y", $rh);
	    }

	    $rh = $.sendCommand("MAIL FROM: <%s>", $message.getFrom());
	    if ($rh.code >= 500)
		throw "SMTP-DATA-EXCEPTION", sprintf("error sending FROM command: %y", $rh);

	    # send receipient
	    foreach my string $rcpt in ($message.getRecipients()) {
		$rh = $.sendCommand("RCPT TO: <%s>", $rcpt);
		$reply.RCPT.$rcpt = $rh;
		if ($rh.code >= 500)
		    throw "SMTP-DATA-EXCEPTION", sprintf("error sending RCPT command: %y", $rh);
	    }

	    # send data
	    $rh = $.sendCommand("DATA");
	    if ($rh.code != 354)
		throw "SMTP-DATA-EXCEPTION", sprintf("error sending DATA command (expected code 354): %y", $rh);

	    # From: (sender)
	    $.sendData("From: %s\r\n", $message.getSender());

	    # To:
	    foreach my string $l in ($message.getTO())
		$.sendData("To: %s\r\n", $l);

	    # CC:
	    foreach my string $l in ($message.getCC())
		$.sendData("CC: %s\r\n", $l);

	    # BCC:
	    foreach my $l in ($message.getBCC())
		$.sendData("BCC: %s\r\n", $l);

	    # add the subject - use "QP" encoding to ensure correct transmission & display of special characters through all SMTP servers
	    $.sendData("Subject: %s\r\n", Mime::mime_encode_header_word_q($message.getSubject()));

	    # importance
	    if ($message.important()) {
		$.sendData("Importance: high\r\n");
		$.sendData("X-Priority: 1\r\n");
		$.sendData("Priority: Urgent\r\n");
	    }

	    if ($message.receiptRead())
		$.sendData("Return-Receipt-To: %s\r\n", $message.getSender());

	    if ($message.receiptDelivery())
		$.sendData("Disposition-Notification-To: %s\r\n", $message.getSender());

	    # additional headers
	    foreach my string $hdr in ($message.getHeader())
		$.sendData(trim($hdr)+"\r\n");

	    return $reply;
	}

	#! send a Message to the server
	/** @param message the Message to send

	    @return a hash of data returned by the SMTP server (the return structure hashes described below are made up of the following keys: \c "code": the return code, \c "desc": the string description):
	    - \c HELO or \c EHLO: a hash of the reply received from the \c HELO or \c EHLO command
	    - \c RCPT: hash keyed by email address with hash return structures values for the RCPT TO command   
	    - \c MSGID: return structure after the send; generally contains message id
	    - \c QUIT: the server response of the disconnect command
	 */
	hash sendMessage(SmtpClient::Message $message) {
	    if (!$message.sendPossible())
		throw "ARGUMENT-EXCEPTION", "Message is not ready to be sent";

	    if ($.log_debug.val())
		$.logDbg("message: %s", $message.toLine());
	    
	    # lock for sending
	    my AutoLock $am($.mutex);

	    my hash $reply;
	    try {
		$reply = $.sendMessageHeaderIntern($message);

		my list $atts = $message.getAttachments();

		# multipart message?
                $.sendData("MIME-Version: 1.0\r\n");
                $.sendData("Content-Type: multipart/mixed;boundary=\"%s\"\r\n", $.mpboundary);
                $.sendData("Content-Disposition: inline\r\n");

                $.sendData("\r\n");

		# body and attachments
		$.sendData("\r\n");

		# rest of data (the body)
		
		my string $be = $message.getBodyTransferEncoding();
                $.sendData("--%s\r\n", $.mpboundary);
		if (!$atts.empty() || $be != SmtpClient::EncNone) {
                    my string $body = $message.getBody();
		    $.sendData(SmtpClient::encodeData($body, sprintf("%s; charset=%s", MimeTypeText, get_encoding($body)), "inline", $be));
		}
		else 
		    $.sendData($message.getBody()+"\r\n");

		# send attachments
		if (!$atts.empty()) {
		    foreach my SmtpClient::Attachment $att in ($atts) {
			$.sendData(sprintf("--%s\r\n", $.mpboundary));
			$.sendData($att.encode());
		    }
		    $.sendData(sprintf("--%s--\r\n", $.mpboundary));
		    $.sendData("\r\n");
		}

		# end of data
		my hash $rh = $.sendCommand(".");
		$reply.MSGID = $rh;

		# quit
		$rh = $.sendCommand("QUIT");
		$reply.QUIT = $rh;
	    }
	    catch($ex) {
		$.logDbg("send error: %s:%d: %s: %s", $ex.file, $ex.line, $ex.err, $ex.desc);
		$.forceDisconnectIntern();
		rethrow;
	    }
	    # close connection
	    $.forceDisconnectIntern();

	    return $reply;
	}

	#! force disconnect of socket without error
        forceDisconnect() {
	    my AutoLock $am($.mutex);
            $.forceDisconnectIntern();
	}
    
	private forceDisconnectIntern() {
	    if ($.isConnected()) {
		try {
		    $.disconnectIntern();
		}
		catch($ex) {
		    # ignore
		}
	    }
	}

    } # class
} # namespace

# END

