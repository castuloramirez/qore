# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file DebugUtil.qm Debug common code

/*  DebugUtil.qm Copyright 2013 - 2017 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# minimum required Qore version
%requires qore >= 0.8.13
%requires linenoise

%require-types
%enable-all-warnings
%new-style
%allow-debugging

module DebugUtil {
    version = "0.1";
    desc = "user module providing common debug stuff";
    author = "Tomas Mandys <tomas.mandys@qore.org>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage DebugUtil Module

    @tableofcontents

    @section debugutilintro Introduction to the DebugUtil Module

    The %DebugUtil module provides common functionality for implementing debugger utilities (client, server, ...)

    @subsection du_v0_1 v0.1
    - the initial version of the DebugUtil module
*/

#! the WebSocketUtil namespace contains all the definitions in the WebSocketUtil module
public namespace DebugUtil {

    /**
        When implementing a wrapper which executes program whose name is passed at command line then we can divide
        arguments usually into 3 groups, internal wrapper arguments, target program filename and program arguments.
        The class support argument parsing for such a case.

		Examples:
            (   # GetOpt options
    		    'help': 'h,help',
    	    	'verbose': 'v,verbose',
                'listen': 'l,listen=s@',
            );
		    wrapper-prog -v -l xxx xxx -v -l    #the second xxx is target program name
		    wrapper-prog -v -h xxx xxx          #the first xxx is target program name
		    wrapper-prog -v --listen=xxx xxx    #the second xxx is target program name
		    wrapper-prog -v --listen xxx xxx    #the second xxx is target program name
        **/
    public class WrapperGetOpt inherits GetOpt {
        public constructor(hash options): GetOpt(options) {
        }
        /**
            Parses input arguments till a standalone argument is found.

            @param args @ref list of arguments passed to wrapper, typically ARGV
            @param wrp_args returns list of wrapper arguments
            @param pgm_name returns target program filename. "" is considered as special file name (stdin), NOTHING when no name provided
            @param pgm_args return @list of target program arguments

            @code{.py}
            hash opts = (
    		    'help': 'h,help',
    	    	'verbose': 'v,verbose',
                'listen': 'l,listen=s@',
            );
    		WrapperGetOpt g(opts);
		    list dargs;
    		hash opt;
            *string fileName;
		    g.split(ARGV, \dargs, \fileName, \ARGV);

            try {
                opt = g.parse2(\dargs);
            } catch (hash ex) {
                stderr.printf("%s: %s\n", ex.err, ex.desc);
                help(-1);
            }

            if (exists fileName) {
                stderr.print("No input file\n");
                exit(-1);
            }

            @endcode
        **/
        public split(list args, reference wrp_args, reference pgm_name, reference pgm_args) {
            pgm_name = NOTHING;
            wrp_args = ();
            pgm_args = ();
            while (args) {
                string s = shift args;
                push wrp_args, s;
                if (s !~ /^\-/ ) {
                    list a = wrp_args;
                    parse(\a);
                    if (a) {
                        # last arg is filename
                        pgm_name = s;
                        pop wrp_args;
                        break;
                    }
                } else if (s == '--') {
                    pgm_name = '';
                    pop wrp_args;
                    break;
                }
            }
            pgm_args = args;
        }
    }


    public const DUV_NONE = 0;
    public const DUV_INFO = 1;
    public const DUV_DEBUG = 2;

    public class DebugLogger {
        public {
            int verbose = DUV_NONE;
        }
        constructor() {}

        #! implement logging
        /**
          @param verbosity use DPC_xxx constants
        */
	    public log(int verbosity, string fmt) {
            if (verbose >= verbosity)
                if (argv) {
                    stdout.vprintf(fmt+"\n", argv);
                } else {
        	        stdout.print(fmt+"\n");
                }
        }
    }

    public class DebugCommandLine {
        public {
            DebugLogger logger;
            string ln_prompt = 'qdbg> ';
            hash cx;
        }

        private {
            Qore::Thread::RWLock rwlContext();

            hash commands = (
                '>': (
                    'help': (
                        '**': (
                            'desc': 'help/*',
                            'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                shift path;
                                if (path[0] == 'help') return ();
#                            printf("--152>%y, %y\r\n", path, args);
                                *hash cmd = dcl.findCmd(path + args, True);
#            printf("%N\r\n", cmd);
                                if (!cmd.variants) return ();
                                return keys cmd.variants;
                            },
                            'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                shift path; # remove help arg
                                *hash cmd = dcl.findCmd(path + args, True);
                                if (cmd.cmd) {
                                    printf("%s: %s\n", (path+args).join(' '), cmd.cmd.desc);
                                }
                                cmd = dcl.findCmd(path + args + (''), True);
                                if (cmd.variants.typeCode()==NT_HASH) {
                                    printf("\nSubcommand list: %s\n", sort(keys cmd.variants ?? ()).join(' '));
                                }
                            },
                        ),
                        'desc': 'get help about command',
                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                            shift path; # remove help arg
                            *hash cmd = dcl.findCmd(list('') , True);
                            printf("Command root list: %s\n", sort(keys cmd.variants ?? ()).join(' '));
                        },
                    ),
                    'version': (
                        'desc': 'get version info',
                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                            hash res.client = (
                                'class': dcl.className(),
                            );
                            try {
                                hash data.cmd = 'version';
                                res.host = dcl.doCommandImpl(data).result;
                            } catch (hash ex) {
                            }
                            dcl.printData(res);
                        },
                    ),
                    'history': (
                        '>': (
                            'load': (
                                'desc': 'load history from file',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    *string fn = shift args;
                                    if (exists fn) {
                                        dcl.logger.log(DUV_INFO, "load history: %y", fn);
                                        Linenoise::history_load(fn);
                                    }
                                },
                            ),
                            'save': (
                                'desc': 'save history to file',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    *string fn = shift args;
                                    if (exists fn) {
                                        dcl.logger.log(DUV_INFO, "save history: %y", fn);
                                        Linenoise::history_save(fn);
                                    }
                                },
                            ),

                        ),
                        'desc': 'load or save history to file',
                    ),
                    'quit': (
                        'desc': 'quit debugger',
                        'action': bool sub(DebugCommandLine dcl, softlist path, softlist args) {
                            return True;
                        },
                    ),

                    'state': (
                        'desc': 'get list of stopped threads and programs',
                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                            hash data.cmd = 'state';
                            dcl.doCommand(data);
                        },
                    ),

                    'pgm': (
                        '>': (
                            'load': (
                                'desc': 'load and run script, filename [args..]',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program//create';
                                    data.filename = shift args;
                                    if (!exists data.filename)
                                        throw "DEBUG-COMMAND", "Missing file name";
                                    data.args = args;
                                    dcl.logger.log(DUV_INFO, "load: %y", data);
                                    dcl.doCommand(data);
                                },
                            ),
                            'list': (
                                'desc': 'list programs',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program//list';
                                    dcl.logger.log(DUV_INFO, "list: %y", data);
                                    dcl.doCommand(data);
                                },
                            ),
                            'current': (
                                '*': (
                                    'desc': 'set current program, arg: programId',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+pop path+'/list';
                                        *hash sd = dcl.doCommandImpl(data);
                                        if (sd.result) {
                                            return keys sd.result;
                                        } else {
                                            return ();
                                        }
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        dcl.setContextValue('programId', pop path);
                                    },
                                ),
                                'desc': 'get current program',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    dcl.printData(dcl.getContextValue('programId'));
                                },
                            ),
                            'add': (
                                'desc': 'add current program for debugging',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/add';
                                    dcl.doCommand(data);
                                },
                            ),
                            'remove': (
                                'desc': 'remove current program from debugging',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/remove';
                                    dcl.doCommand(data);
                                },
                            ),
                            'stop': (
                                'desc': 'stop current program, args: [threadId] to stop particular thread',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId();
                                    if (exists args[0]) {
                                        data.cmd += '/thread/'+args[0];
                                    }
                                    data.cmd += '/stop';
                                    dcl.doCommand(data);
                                },
                            ),
                            'global': (

                                '*': (
                                    'desc': 'get/set global variable',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/global/'+pop path+'/list';
                                        *hash sd = dcl.doCommandImpl(data);
                                        return sd.result ?? ();
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/global/'+pop path+'/';
                                        if (args) {
                                            data.cmd += 'set';
                                            data.value = dcl.parseValue(args);
                                        } else {
                                            data.cmd += 'get';
                                        }
                                        dcl.doCommand(data);
                                    },
                                ),
                                'desc': 'get/set global variable',
                            ),
                            'define': (

                                '*': (
                                    'desc': 'get defines',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/define/'+pop path+'/list';
                                        *hash sd = dcl.doCommandImpl(data);
                                        return keys sd.result ?? ();
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/define/'+pop path+'/get';
                                        dcl.doCommand(data);
                                    },
                                ),
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/define//list';
                                    dcl.doCommand(data);
                                },
                                'desc': 'get defines',
                            ),
                            'options': (
                                'desc': 'list parse options',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/options';
                                    dcl.doCommand(data);
                                },
                            ),
                        ),
                        'desc': 'program related commands',
                    ),
                    'bkpt': (
                        '>': (
                            'list': (
                                'desc': 'list breakpoints',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint//list';
                                    dcl.doCommand(data);
                                },
                            ),
                            'create': (
                                'desc': 'create breakpoint',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint//create';
                                    dcl.doCommand(data);
                                },
                            ),
                            'delete': (
                                '*': (
                                    'desc': 'delete breakpoint',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint/'+pop path+'/delete';
                                        dcl.doCommand(data);
                                    },
                                ),
                                'desc': 'get breakpoint',
                            ),
                            'enable': (
                                '*': (
                                    'desc': 'enable breakpoint',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint/'+pop path+'/enable';
                                        dcl.doCommand(data);
                                    },
                                ),
                                'desc': 'enable breakpoint',
                            ),
                            'disable': (
                                '*': (
                                    'desc': 'disable breakpoint',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint/'+pop path+'/disable';
                                        dcl.doCommand(data);
                                    },
                                ),
                                'desc': 'disable breakpoint',
                            ),
                            'policy': (
                                '*': (
                                    'desc': 'get breakpoint policy',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    '*': (
                                        'desc': 'set breakpoint policy',
                                        'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                            return DebugCommandLine::enumFilter(keys DebugProgramControl::policyStrings, pop path);
                                        },
                                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                            hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint/'+path[path.size()-2]+'/policy/set';
                                            data.value = pop path;
                                            dcl.doCommand(data);
                                        },
                                    ),
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint/'+pop path+'/policy/get';
                                        dcl.doCommand(data);
                                    },
                                ),
                                'desc': 'breakpoint policy',
                            ),
                            'thread': (
                                '*': (
                                    'desc': 'get/set threads assigned to breakpoint, args: "+"/"-" threadId | threadId ..',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {

                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint/'+pop path+'/thread/';

                                        if (args) {
                                            string a = shift args;
                                            if (a == '+') {
                                                data.cmd += 'add';
                                                data.value = int(shift args);
                                            } else if (a == '-') {
                                                data.cmd += 'remove';
                                                data.value = int(shift args);
                                            } else {
                                                data.value = ();
                                                push data.value, int(a);
                                                map (push data.value, int($1)), args;
                                                data.cmd += 'set';
                                            }
                                        } else {
                                            data.cmd += 'get';
                                        }
                                        dcl.doCommand(data);
                                    },
                                ),
                                'desc': 'get thread handled by breakpoint',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint/'+pop path+'/thread/get';
                                        dcl.doCommand(data);
                                },
                            ),
                            'statement': (
                                '*': (
                                    'desc': 'get statement list assigned to breakpoint',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint/'+pop path+'/statement/list';
                                        dcl.doCommand(data);
                                    },
                                ),
                                'desc': 'statement stuff',
                            ),
                        ),
                        'desc': 'breakpoint related commands',
                    ),
                    'statement': (
                        '>': (
                            'list': (
                                'desc': 'list statements', # duplicate to breakpoint/statement
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint/'+pop path+'/statement/list';
                                    dcl.doCommand(data);
                                },
                            ),
                            'assign': (
                                '*': (
                                    'desc': 'assign statement to breakpoint, args: breakpoint [function([args, ...]] | [file] lineno',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint/'+pop path+'/statement/assign';
                                        data.value = dcl.getStatementValue(args);
                                        dcl.doCommand(data);
                                    },
                                ),
                                'desc': 'assign statement to breakpoint, args: breakpoint [function([args, ...]] | [file] lineno',
                            ),
                            'unassign': (
                                '*': (
                                    'desc': 'unassign statement from breakpoint, args: breakpoint [function([args, ...]] | [file] lineno',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        return DebugCommandLine::enumBreakpointId(dcl, path, args);
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint/'+pop path+'/statement/unassign';
                                        data.value = dcl.getStatementValue(args);
                                        dcl.doCommand(data);
                                    },
                                ),
                                'desc': 'unassign statement from breakpoint, args: breakpoint [function([args, ...]] | [file] lineno',
                            ),
                        ),
                        'desc': 'statement related commands',
                    ),

                    'thread': (
                        '>': (
                            'current': (
                                '*': (
                                    'desc': 'set current thread, arg: threadId',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'status';
                                        *hash sd = dcl.doCommandImpl(data);
                                        if (sd.result) {
                                            list tids;
                                            map (push tids, $1.tid), sd.result;
                                            return tids;
                                        } else {
                                            return ();
                                        }
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        dcl.setContextValue('threadId', int(pop path));
                                    },
                                ),
                                'desc': 'get current thread',
                                'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                    dcl.printData(dcl.getContextValue('threadId'));
                                },
                            ),
                            'local': (
                                '*': (
                                    'desc': 'get/set local variable',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'thread/local/'+pop path+'/list';
                                        data.tid = dcl.checkThreadId();
                                        *hash sd = dcl.doCommandImpl(data);
                                        return sd.result ?? ();
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'thread/local/'+pop path+'/';
                                        data.tid = dcl.checkThreadId();
                                        if (args) {
                                            data.cmd += 'set';
                                            data.value = dcl.parseValue(args);
                                        } else {
                                            data.cmd += 'get';
                                        }
                                        dcl.doCommand(data);
                                    },
                                ),
                                'desc': 'get/set global variable',
                            ),
                            'debug': (
                                '*': (
                                    'desc': 'get/set special debug variable',
                                    'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'thread/debug/'+pop path+'/list';
                                        data.tid = dcl.checkThreadId();
                                        *hash sd = dcl.doCommandImpl(data);
                                        return sd.result ?? ();
                                    },
                                    'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                        hash data.cmd = 'thread/debug/'+pop path+'/';
                                        data.tid = dcl.checkThreadId();
                                        if (args) {
                                            data.cmd += 'set';
                                            data.value = dcl.parseValue(args);
                                        } else {
                                            data.cmd += 'get';
                                        }
                                        dcl.doCommand(data);
                                    },
                                ),
                                'desc': 'get/set special debug variable',
                            ),
                        ),
                        'desc': 'thread related commands',
                    ),
                    'stack': (
                        'desc': 'get stack for current thread',
                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                            hash data.cmd = 'thread/stack';
                            data.tid = dcl.checkThreadId();
                            dcl.doCommand(data);
                        },
                    ),
                    'go': (
                        '*': (
                            'desc': 'go thread with specified runstate, arg: runstate',
                            'enum': list sub(DebugCommandLine dcl, softlist path, softlist args) {
                                return DebugCommandLine::enumFilter(keys DebugProgramControl::runStateStrings, pop path);
                            },
                            'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                                hash data.cmd = 'thread/go/'+pop path;
                                data.tid = dcl.checkThreadId();
                                dcl.doCommand(data);
                            },
                        ),
                        'desc': 'go thread with default runstate',
                        'action': sub(DebugCommandLine dcl, softlist path, softlist args) {
                            hash data.cmd = 'thread/go';
                            data.tid = dcl.checkThreadId();
                            dcl.doCommand(data);
                        },
                    ),
                ),
            );

        }

        constructor() {
        }

        #! To be implemented to execute remote (via websocket) or local command (via @ref DebugControlProgram)
        abstract public *hash doCommandImpl(hash data);

        public doCommand(hash data) {
            *hash ret = doCommandImpl(data);
            if (ret) {
                printData(ret);
            }
        }

        public any parseValue(softlist args) {
            # TODO parse as qore type
            return shift args;
        }

        public any getContextValue(string key) {
            rwlContext.readLock();
            on_exit rwlContext.readUnlock();
            return cx{key};
        }

        public setContextValue(string key, any value) {
            rwlContext.writeLock();
            on_exit rwlContext.writeUnlock();
            cx{key} = value;
        }

        public hash getStatementValue(list args) {
            if (!args)
                throw "DEBUG-PROGRAM-HELPER", sprintf("Statement prescription is missing");
            string s;
            s = trim(shift args);
            if (s =~ /^[0-9]+$/) {
                return ('file': '', 'lineno': int(s));
            }
            *list l = s =~ x/^(.+)\((.*)\)$/;
            if (l) {
                l[1] =~ tr/ //;
                return ('function': l[0], 'args': split(',', l[1]));
            }
            if (args[0] =~ /^[0-9]+$/) {
                return ('file': s, 'lineno': int(args[0]));
            }
            return ('id': s);
        }

        private list splitCmd(string line) {
            list ret = ();
            int i = 0;
            int q = 0;
            string s = '';
            while (i < line.size()) {
                switch (line[i]) {
                case ' ':
                    if (q == 0) {
                        if (s != '') {
                            push ret, s;
                            s = '';
                        }
                    } else {
                        s += line[i];
                    }
                    break;
                case "'":
                    if (q == 0) {
                        q = 1;
                    } else if (q == 1) {
                        q = 0;
                    } else {
                        s += line[i];
                    }
                    break;
                case '"':
                    if (q == 0) {
                        q = 2;
                    } else if (q == 2) {
                        q = 0;
                    } else {
                        s += line[i];
                    }
                    break;
                case '\':
                    i++;
                    switch (line[i]) {
                    case 'n':
                        s += "\n";
                        break;
                    case 'r':
                        s += "\r";
                        break;
                    case 't':
                        s += "\t";
                        break;
                    case '0':
                        s += "\0";
                        break;
                    default:
                        s += line[i];
                    }
                    break;
                default:
                    s += line[i];
                }
                i++;
            }
            if (q != 0)
                throw "DEBUG-PROGRAM-HELPER", sprintf("Unmatched quotes in %y", line);
            if (s != '') {
                push ret, s;
            }
            return ret;
        }

        public *hash findCmd(list args, bool findHelp = False) {  /* public because it is needed from closure */
            hash result;
            result.path = ();
#printf("findcmd(%N)\n", args);
            hash c = commands;
            while (args.size() > 0) {
                if (findHelp && exists c."*") {
                    # skip
                    c = c."*";
                } else if (exists c.">") {
                    # static enum
                    if (args.size() == 1) {
                        foreach string k in (keys c.">") {
                            if (k.substr(0, args[0].size()) == args[0]) {
                                result.variants{k} = c.">"{k};
                            }
                        }
                    }
                    if (exists c.">"{args[0]}) {
#printf("args[0]:%y, c.>:%y\n", args[0], c.">"{args[0]});
                        #remove result.cmd.">";
                        c = c.">"{args[0]};
                        result.cmd = c;
                        push result.path, shift args;
                    } else {
                        if (exists result.variants) {
                            push result.path, shift args;
                        }
                        break;
                    }
                } else if (exists c."*") {
                    # dynamically enumerated
                    c = c."*";
                    if (args.size() == 1 && exists c.enum) {
                        result.variants = c.enum;
                    }
                    push result.path, shift args;
                    result.cmd = c;
                } else if (exists c."**") {
                    c = c."**";
                    if (exists c.enum) {
                        result.variants = c.enum;
                    }
                    push result.path, shift args;
                    result.cmd = c;
                    break;
                } else
                    break;
            }
            result.args = args;
#printf("findcmd()->%N\n", result);
            return result;
        }

        private list ln_callback(string line) {
            list args = splitCmd(line);
            if (line =~ / $/ || line == '') {
                args += '';
            } else {
                # strip last args
                while (line != '' && line[line.size()-1] != ' ') {
                    line = splice(line, -1);
                }
            }
            *hash cmd = findCmd(args);
#printf(" cmd-362:%y\n", cmd);

            if (cmd.variants) {
                *list v;
                switch (cmd.variants.typeCode()) {
                case NT_CLOSURE:
                case NT_CALLREF:
                    try {
                        v = cmd.variants(self, cmd.path, cmd.args);
                    } catch (hash ex) {
                    }
                    break;
                default:
                    v = keys cmd.variants;
                }
                return map line+$1, sort(v);
            } else {
                return ();
            }
        }

        public runCmdLine() {
            # Linenoise::history_load('history.txt');
            # Linenoise::history_set_max_len(256);
            Linenoise::set_callback(\ln_callback());
Linenoise::history_add('history load filename');
            string lastLine = '';
            while (True) {
                my *string line = Linenoise::line(ln_prompt);
                if (!exists line) {
                    printf("^C signal caught. Exiting.\n");
                        break;
                }
                if (line != '') {
                    if (line !~ /^ /) {
                        Linenoise::history_add(line);
                    }
                    lastLine = line;
                } else {
                    line = lastLine;
                }
                *hash cmd = findCmd(splitCmd(line));
                if (cmd.cmd) {
#                    printf("line:%y\n", line);

                    if (cmd.cmd.action) {
#                    printf("exec:%y\n", cmd);
                        try {
                            any rc = cmd.cmd.action(self, cmd.path, cmd.args);
                            if (rc) break;
                        } catch (hash ex) {
                            printf("%s: %s\n", ex.err, ex.desc);
                        }
                    }
#                    printf("%y\n", cmd);
                } else {
                    printf("Unknown command\n");
                }
            }
            # Linenoise::history_save('history.txt');

        }

        public printData(any data) {
            string outs;
            if (data.typeCode() == NT_HASH) {
                switch (data.type) {
                case 'response':
                    switch (data.result.typeCode()) {
                    case NT_HASH:
                    case NT_LIST:
                        outs = sprintf("%N", data.result);
                        break;
                    default:
                        outs = sprintf("%y", data.result);
                    }
                    break;
                case 'event':
                    if (data.cmd == 'interrupt') {
                        if (!exists getContextValue('programId')) {
                            setContextValue('programId', data.pgmid);
                        }
                        if (!exists getContextValue('threadId')) {
                            setContextValue('threadId', data.tid);
                        }
                    }
                    break;
                }
                if (!exists outs)
                    outs = sprintf("%N", data);
            } else {
                outs = sprintf("%y", data);
            }
            if (exists outs) {
                # linenoise terminal has somehow redefined CRLF so force \r (TODO: what is Qore line delimiter on Windows ?)
                list l = outs.split("\n");
                foreach my string line in (l) {
                    stdout.print(line+"\r\n");
                }
                # TODO: how refresh linenoise command line ?
            }
        }

        public int checkProgramId() {
            *int pgmId = getContextValue('programId');
            if (!exists pgmId) {
                throw "DEBUG-COMMAND", "Program is not set";
            }
            return pgmId;
        }

        public int checkThreadId() {
            *int threadId = getContextValue('threadId');
            if (!exists threadId) {
                throw "DEBUG-COMMAND", "Thread context is not set";
            }
            return threadId;
        }

        static public list enumBreakpointId(DebugCommandLine dcl, softlist path, softlist args) {
            hash data.cmd = 'program/'+dcl.checkProgramId()+'/breakpoint/'+pop path+'/list';
            *hash sd = dcl.doCommandImpl(data);
            if (sd.result) {
                list res;
                map (push res, $1.id), sd.result;
                return res;
            } else {
                return ();
            }
        }

        static public list enumFilter(softlist items, *string path) {
            if (path.size() == 0) {
                return items;
            }
            list res = ();
            map (push res, $1), items, bindex($1, path) == 0;
            return res;
        }

    }

    #! Class to implement @ref DebugProgram control using commands
    public class DebugProgramControl inherits DebugProgram {
        private {
            #!data pool related to suspended thread, key is threadId
            hash ctxThread;
            #! data pool for data related to cx.id
            hash ctxConnection;
            #! lock for @ref ctxThread access
            Qore::Thread::RWLock rwlThread();
            #! lock for @ref ctxConnection access
            Qore::Thread::RWLock rwlConnection();

            const frameOffset = 2;
        }
        public {
            const runStateStrings = ('detach': DebugDetach, 'run': DebugRun, 'step': DebugStep, 'stepover': DebugStepOver, 'untilreturn': DebugUntilReturn);
            const flowStrings = ('none': 0, 'return': DebugFlowReturn, 'break': DebugFlowBreak, 'continue': DebugFlowContinue);
            const boolStrings = ('false': False, 'true': True);
            const policyStrings = ('none': BreakpointPolicyNone, 'accept': BreakpointPolicyAccept, 'reject': BreakpointPolicyReject);
            DebugLogger logger;
        }
        constructor() : DebugProgram() {
        }

        #! register context for new connection
        public registerConnection(hash cx) {
            rwlConnection.writeLock();
            on_exit rwlConnection.writeUnlock();
            ctxConnection{cx.id} = ();
        }

        public unregisterConnection(hash cx) {
            rwlConnection.writeLock();
            on_exit rwlConnection.writeUnlock();
            delete ctxConnection{cx.id};
            # if (!ctxConnection)  run stopped programs ?
        }

        private updateConnectionContext(hash cx, any cx_data) {
        }

        #! send data to particular client
        abstract public sendDataImpl(hash cx, any data);
        #! send data to all clients
        abstract public broadcastDataImpl(any data);

        #! Create new program
        public Program createProgram(string fileName, *hash opts, list args, *string script) {
            logger.log(DUV_DEBUG, "create program: %y", fileName);
			Program pgm = new Program(PO_ALLOW_DEBUGGING); # PO_NO_INHERIT_USER_CLASSES to avoid importing DebugWrapper, but what about classes from modules ?
			# restore default options
			pgm.disableParseOptions(PO_NO_TOP_LEVEL_STATEMENTS | PO_NEW_STYLE);
            if (exists opts.parse_option) {
                hash poops = Qore::ParseOptionCmdStringMap;
                int oo = 0;
                foreach string o in (opts.parse_option) {
                    if (!exists poops{o}) {
                        throw "DEBUG-CREATE-PROGRAM", sprintf("Unknown parse option %y", o);
                    }
                    oo |= poops{o};
                }
                pgm.setParseOptions(oo);
            }
            if (opts.define) {
                foreach string d in (opts.define) {
                    int i = bindex(d, "=");
                    if (i >= 0) {
                        pgm.define(substr(d, 0, i), substr(d, i+1));
                    } else {
                        pgm.define(d);
                    }
                }
            }
            if (exists opts.time_zone) {
                # TODO: parse exact shifts
                pgm.setTimeZoneRegion(opts.time_zone);
            }
			# update arguments without debug options
			pgm.setGlobalVarValue('ARGV', args);
			pgm.define('Q_DEBUGGING', 1);
            logger.log(DUV_DEBUG, "add program");
			addProgram(pgm);

#script = "%new-style\nprintf(\"ARGV-PGM:%N\n\", ARGV);";
            if ((script ?? '') == '') {
                if (fileName == '/dev/stdin') {  # is exception needed ??
                    logger.log(DUV_DEBUG, "read stdin");
                    script = stdin.read(-1, 0);
                    logger.log(DUV_DEBUG, "%s", script);
                } else {
                    logger.log(DUV_DEBUG, "read file: %y", fileName);
                    script = ReadOnlyFile::readTextFile(fileName);
                }
            }
			pgm.setScriptPath(fileName);
			logger.log(DUV_DEBUG, "parse code");
			*hash wh = pgm.parse(script, fileName, WARN_DEFAULT, NOTHING, NOTHING, False);
			if (wh) {
				logger.log(DUV_INFO, "warning: %N", wh);
			}
            return pgm;
        }

        #! process message in debugging thread, if message is related to debugged thread then put it in particular queue
        public *hash processCommand(hash cx, hash receiveData) {
            logger.log(DUV_INFO, "processCommand: %y", receiveData);
            hash sendData;
            any result;
            try {
                list cmd = receiveData.cmd.split('/');
                logger.log(DUV_DEBUG, "command: %y", cmd);

                switch (shift cmd) {
                case 'help':
                    result = list('TODO: help text');
                    break;
                case 'version':
                    result = ('class': self.className());
                    break;
                case 'program':
                    Program pgm;
                    *string pgmName = shift cmd;
                    switch (cmd[0]) {
                    case 'list':
                    case 'create':
                        break;
                    default:
                        pgm = Program::resolveProgramId(int(pgmName));
                    }
                    logger.log(DUV_DEBUG, "program / %y", cmd);
                    switch (shift cmd) {
                    case 'stop':
                        # no locking
                        breakProgram(pgm);
                        result = 'ok';
                        break;

                    case 'thread':
                        softint tid = shift cmd;
                        switch (shift cmd) {
                        case 'stop':
                            breakProgramThread(pgm, tid);
                            result = 'ok';
                            break;
                        }
                        break;

                    case 'list':
                        foreach my Program p in (Program::getAllPrograms()) {
                            string pgmId = string(p.getProgramId());
                            if (pgmName.size() == 0 || bindex(pgmId, pgmName) == 0) {
                                result{pgmId}.scriptPath = p.getScriptPath();
                            }
                        }
#                        map result{$1.getProgramId()}.scriptPath = $1.getScriptPath(), Program::getAllPrograms();
                        map result{$1.getProgramId()}.debug = True, getAllPrograms(), exists result{$1.getProgramId()};
                        {
                            rwlThread.readLock();
                            on_exit rwlThread.readUnlock();
                            foreach softint tid in (keys ctxThread) {
                                if (exists ctxThread{tid}.pgmId) {
                                    result{ctxThread{tid}.pgmId}.interrupted += list(tid);
                                }
                            }
                        }
                        break;
                    case 'create':
                        pgm = createProgram(receiveData.filename, NOTHING, receiveData.args);
                        break;
                    case 'add':
                        addProgram(pgm);
                        result = 'ok';
                        break;

                    case 'remove':
                         removeProgram(pgm);
                        result = 'ok';
                        break;

                    case 'global':
                        string varName = shift cmd;
                        switch (shift cmd) {
                        case 'set':
                            pgm.setGlobalVarValue(varName, receiveData.value);
                            result = 'ok';
                            break;

                        case 'get':
                            bool existF;
                            any v = pgm.getGlobalVariable(varName, \existF);
                            if (existF) {
                                result = v;
                            }
                            break;

                        case 'list':
                            softlist l  = keys pgm.getGlobalVars();
                            foreach my string s in (\l) {
                                s =~ s/^Qore:://;
                            }
                            result = DebugCommandLine::enumFilter(l, varName);
                            break;
                        }
                        break;

                    case 'define':
                        string defName = shift cmd;
                        switch (shift cmd) {

                        case 'get':
                            if (pgm.isDefined(defName)) {
                                result = pgm.getDefine(defName);
                            }
                            bool existF;
                            any v = pgm.getGlobalVariable(defName, \existF);
                            if (existF) {
                                result = v;
                            }
                            break;

                        case 'list':
                            *hash defs = pgm.getAllDefines();
                            list dd = DebugCommandLine::enumFilter(keys defs, defName);
                            result = hash();
                            map result{$1} = defs{$1}, dd;
                            break;
                        }
                        break;

                    case 'options':
                        int opts = pgm.getParseOptions();
                        result = ();
                        foreach string o in (keys ParseOptionCodeMap) {
                            softint oo = o;
                            if (oo != 0 && (oo & opts) == oo) {
                                push result, ParseOptionCodeMap{o};
                            }
                        }
                        break;

                    case 'breakpoint':
                        Breakpoint b;
                        string bkptName = shift cmd;
                        switch (cmd[0]) {
                        case 'list':
                            break;
                        case 'create':
                            b = new Breakpoint();
                            break;
                        default:
                            b = Breakpoint::resolveBreakpointId(int(bkptName));
                            break;
                        }
                        switch (shift cmd) {
                        case 'list':
                            list bkpts = pgm.getBreakpoints();
                            result = ();
                            foreach Breakpoint b2 in (bkpts) {
                                if (bkptName.size() == 0 || bindex(b2.getBreakpointId(), bkptName)==0) {
                                    hash binfo.id = b2.getBreakpointId();
                                    binfo.enabled = encodeValue('enabled', b2.getEnabled(), boolStrings);
                                    binfo.threads = b2.getThreadIds();
                                    binfo.policy = encodeValue('policy', b2.getPolicy(), policyStrings);
                                    binfo.statements = ();
                                    foreach int sid in (b2.getStatementIds()) {
                                        push binfo.statements, ('id': sid) + pgm.getStatementIdInfo(sid);
                                    }
                                    if (!binfo.threads)
                                        remove binfo.threads;
                                    if (!binfo.statements)
                                        remove binfo.statements;
                                    push result, binfo;
                                }
                            }
                            break;

                        case 'create':
                            b.assignProgram(pgm);
                            result = b.getBreakpointId();
                            break;

                        case 'delete':
                            # TODO: if (b.getProgram().getProgramId() != pgm.getProgramId()
                            #  throw DEBUG-HANDLER-ERROR, "Program mismatch";
                            b.unassignProgram();
                            b.clearThreadIds();
                            list sl = b.getStatementIds();
                            foreach int s in (sl) {
                                b.unassignStatement(s);
                            }
                            # delete b;   ??
                            result = 'ok';
                            break;

                        case 'enable':
                            b.setEnabled(True);
                            result = 'ok';
                            break;

                        case 'disable':
                            b.setEnabled(False);
                            result = 'ok';
                            break;

                        case 'statement':
                            switch (shift cmd) {
                            case 'list':
                                result = hash();
                                foreach int sid in (b.getStatementIds()) {
                                    result{sid} = pgm.getStatementIdInfo(sid);
                                }
                                break;

                            case 'assign':
                                b.assignStatement(resolveStatement(pgm, receiveData.value));
                                result = 'ok';
                                break;

                            case 'unassign':
                                b.unassignStatement(resolveStatement(pgm, receiveData.value));
                                result = 'ok';
                                break;
                            }
                            break;

                        case 'thread':
                            switch (shift cmd) {
                            case 'add':
                                b.addThreadId(receiveData.value);
                                result = 'ok';
                                break;
                            case 'remove':
                                b.removeThreadId(receiveData.value);
                                result = 'ok';
                                break;
                            case 'get':
                                result = b.getThreadIds();
                                break;
                            case 'set':
                                *softlist sl = receiveData.value;
                                b.setThreadIds(sl);
                                result = 'ok';
                                break;
                            }
                            break;

                        case 'policy':
                            switch (shift cmd) {
                            case 'get':
                                result = encodeValue('policy', string(b.getPolicy()), policyStrings);
                                break;
                            case 'set':
                                b.setPolicy(resolveValue('policy', receiveData.value, policyStrings, b.getPolicy()));
                                result = 'ok';
                                break;
                            }
                            break;
                        }
                        break;
                    }
                    break;

                case 'state':
                    {
                        rwlThread.readLock();
                        on_exit rwlThread.readUnlock();
                        result = ();
                        foreach my string tid in (keys ctxThread) {
                            push result, (
                                'tid': tid,
                                'pgmId': ctxThread{tid}{'pgmId'},
                            );
                        }
                    }
                    break;

                case 'thread':

                default:
                    if (exists receiveData.tid) {
                        rwlThread.readLock();
                        on_exit rwlThread.readUnlock();
                        if (ctxThread{receiveData.tid}) {
                            ctxThread{receiveData.tid}.queue.push(('cx': cx, 'data': receiveData));
                            sendData.type = 'thread';
                            sendData.tid = receiveData.tid;
                        } else {
                            throw "DEBUG-HANDLER-ERROR", sprintf("threadId %y is not stopped", receiveData.tid);
                        }
                    } else {
                        throw "DEBUG-HANDLER-ERROR", sprintf("cannot process command %y", receiveData.cmd);
                    }
                }
                if (exists result) {
                    sendData.type = 'response';
                }
            } catch (hash ex) {
                logger.log(DUV_DEBUG, "exception: %y", ex);
                sendData.type = 'error';
                result.err = ex.err;
                result.desc = ex.desc;
            }
            if (sendData) {
                sendData.uid = receiveData.uid;
                sendData.cmd = receiveData.cmd;
                sendData.stamp = now_us();
                sendData.result = result;
                return sendData;
            }
        }

        private any resolveValue(string name, *string val, hash strings, any defVal) {
            if (exists val) {
                if (!exists strings{val}) {
                    throw "DEBUG-HANDLER-ERROR", sprintf("%y value %y is not found in %y", name, val, keys strings);
                }
                return strings{val};
            } else {
                return defVal;
            }
        }

        private string encodeValue(string name, any val, hash strings) {
            foreach string k in (keys strings) {
                if (strings{k} == val) {
                    return k;
                }
            }
            throw "DEBUG-HANDLER-ERROR", sprintf("Cannot encode %y value %y", name, val);
        }

        private int resolveStatement(Program pgm, *hash value) {
            if (exists value.id) {
                return value.id;
            }
            if (exists value.function) {
                return pgm.findFunctionStatementId(value.function, value.args);
            }
            if (exists value.lineno) {
                return pgm.findStatementId(value.file ?? '', value.lineno);
            }
            throw "DEBUG-HANDLER-ERROR", sprintf("Cannot resolve statement from %y", value);
        }

        private *hash handleInterrupt(string func, Program pgm, reference runState, *int statementId, *string refName, *reference refValue, *hash except) {
            # serialize data, send to all websockets, break/suspend thread
            int tid = gettid();
            hash ctx.queue = new Thread::Queue();
            ctx.pgmId = pgm.getProgramId();
            {
                rwlThread.writeLock();
                on_exit rwlThread.writeUnlock();
             #   assert(!exists ctxThread{tid});
                ctxThread{tid} = ctx;
            }
            hash sendData1 = (
              'type': 'event',
              'cmd': 'interrupt',
              'pgmid': ctx.pgmId,
              'tid': tid,
              'stamp': now_us(),
              'func': func,
              'runstate': encodeValue('runState', runState, runStateStrings),
              'frame': 0,
#'localvars0': keys get_local_vars(0),
#'localvars1': keys get_local_vars(1),
'localvars2': get_local_vars(2),
'localvars3': get_local_vars(3),
'localvars4': get_local_vars(4),
'localvars5': keys get_local_vars(5),
'localvars6': keys get_local_vars(6),
'localvars7': keys get_local_vars(7),
'localvars8': keys get_local_vars(8),
'localvars9': keys get_local_vars(9),
'localvars10': keys get_local_vars(10),
            );
            if (exists statementId) {
                hash location = pgm.getStatementIdInfo(statementId);
                sendData1.file = location.file;
                sendData1.line = location.start_line;
                #sendData1.statement = location;
            }
            if (exists except) {
                sendData1.exception = except;
            }
            if (exists refName) {
                sendData1{refName} = refValue;
            }
            broadcastDataImpl(sendData1);

            hash ctxCT;
            {
                rwlConnection.writeLock();
                on_exit rwlConnection.writeUnlock();
                # default values
                ctxCT{refName} = refValue;
                ctxCT.frameId = 0;
                ctxConnection{ctx.id}.thread{tid} = ctxCT;
            }

            # wait to process command passed as marshalled call from websocket thread
            bool ret = False;
            while (!ret) {
                any qrd = ctx.queue.get();
                {
                    any result;
                    hash sd;
                    hash cx;
                    hash rd;
                    try {
                        rd = qrd.data;
                        cx = qrd.cx;
                        list cmd = rd.cmd.split('/');
                        shift cmd;  # remove thread
                        switch (shift cmd) {
                        case 'go':
                            runState = resolveValue('runState', shift cmd, runStateStrings, runState);
                            if (exists refName) {
                                refValue = ctxCT{refName};
                            }
                            ret = True;
                            break;

                        case 'local':
                            string varName = shift cmd;
                            switch (shift cmd) {
                            case 'get':
                                hash lv = get_local_vars(ctxCT.frameId + frameOffset);
                                if (exists lv{varName}) {
                                    result = lv{varName};
                                }
                                break;
                            case 'set':
                                set_local_var_value(varName, rd.value);
                                break;
                            case 'list':
                                softlist l  = keys get_local_vars(ctxCT.frameId + frameOffset);
                                result = DebugCommandLine::enumFilter(l, varName);
                                break;
                            }
                            break;

                        case 'debug':
                            string varName = shift cmd;
                            switch (shift cmd) {
                            case 'get':
                                if (varName == refName) {
                                    switch (varName) {
                                    case 'flow':
                                        result = encodeValue(varName, ctxCT{varName}, flowStrings);
                                        break;

                                    case 'dismiss':
                                        result = encodeValue(varName, ctxCT{varName}, boolStrings);
                                        break;

                                    case 'result':
                                        result = ctxCT{varName};
                                        break;
                                    }
                                } else {
                                    switch (varName) {
                                    case 'frame':
                                        result = ctxCT.frameId;
                                        break;
                                    case 'event':
                                        result = sendData1;
                                        break;
                                    }
                                }
                                break;
                            case 'set':
                                if (varName == refName) {
                                    switch (varName) {
                                    case 'flow':
                                        ctxCT{varName} = resolveValue(varName, rd.value, flowStrings, ctxCT{rd.name});
                                        break;

                                    case 'dismiss':
                                        ctxCT{varName} = resolveValue(varName, rd.value, boolStrings, ctxCT{rd.name});
                                        break;

                                    case 'result':
                                        ctxCT{varName} = rd.value;
                                        break;
                                    }
                                } else {
                                    switch (varName) {
                                    case 'frame':
                                        if (rd.value <= 0) {
                                            ctxCT.frameId = 0;
                                        } else {
                                            ctxCT.frameId = int(rd.value);
                                        }
                                        break;
                                    }
                                }
                                break;
                            case 'list':
                                list l  = list('frame', 'event');
                                if (refName) {
                                    l += refName;
                                }
                                result = DebugCommandLine::enumFilter(l, varName);
                                break;
                            }
                            break;

                        case 'stack':
                            list stack = get_thread_call_stack();
                            int i = frameOffset;
                            while (i > 0) {
                                shift stack;
                                i--;
                            }
                            result = stack;
                            break;

                        case 'breakpoint':

                            break;
                        }

                        if (exists result) {
                            sd.type = 'response';
                        }

                    } catch (hash ex) {
                        sd.type = 'error';
                        result.err = ex.err;
                        result.desc = ex.desc;
                    }
                    if (exists result) {
                        sd.tid = tid;
                        sd.stamp = now_us();
                        sd.cmd = rd.cmd;
                        sd.uid = rd.uid;
                        sd.result = result;
                        try {
                            sendDataImpl(cx, sd);
                        } catch (hash ex) {
                        }
                    }
                }
            }
            {
                rwlThread.writeLock();
                on_exit rwlThread.writeUnlock();
                remove ctxThread{tid};
            }
            # notify program is running again
            hash sd = (
              'type': 'event',
              'cmd': 'run',
              'pgmid': ctx.pgmId,
              'tid': tid,
              'stamp': now_us(),
              'runstate': encodeValue('runState', runState, runStateStrings),
            );
            broadcastDataImpl(sd);
        }

        onAttach(Program pgm, reference rs) {
            handleInterrupt("attach", pgm, \rs);
          }

        onDetach(Program pgm, reference rs) {
            handleInterrupt("detach", pgm, \rs);
        }

        onStep(Program pgm, int blockStatementId, *int statementId, reference flow, reference rs) {
            handleInterrupt(statementId ? 'step' : 'block', pgm, \rs, statementId ?? blockStatementId, "flow", \flow);
        }

        onFunctionEnter(Program pgm, int statementId, reference rs) {
            handleInterrupt('funcEnter', pgm, \rs, statementId);
        }

        onFunctionExit(Program pgm, int statementId, reference result, reference rs) {
            handleInterrupt('funcExit', pgm, \rs, statementId, "result", \result);
        }

        onException(Program pgm, int statementId, hash ex, reference dismiss, reference rs) {
            handleInterrupt('exception', pgm, \rs, statementId, "dismiss", \dismiss, ex);
        }
    }

}

