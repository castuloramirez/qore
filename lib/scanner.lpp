%{
/*
  scanner.ll

  Qore Programming Language

  Copyright 2003 - 2012 David Nichols

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA

  Flex scanner: 
    no string length limits, 
    no include file depth limits, 
    thread-safe

  requires flex 2.5.31 or better (2.5.35 recommended, 2.5.4 will not work) 
  so a thread-safe scanner can be generated

  see: http://flex.sourceforge.net/
*/

#include <qore/Qore.h>
#include <qore/intern/ParserSupport.h>
#include <qore/intern/qore_program_private.h>

#include "parser.h"

#include <stdio.h>
#include <string.h>
#include <stdlib.h>
#include <sys/types.h>
#include <sys/stat.h>
#include <unistd.h>
#include <ctype.h>
#include <limits.h>

QoreParserLocation::QoreParserLocation() : explicit_first(false), first_line(0) {
}

void QoreParserLocation::updatePosition(int f) {
   if (!explicit_first) {
      first_line = f;
      update_parse_location(f, f);
   }
   else {
      update_parse_location(first_line, f);
      explicit_first = false;
   }
   last_line = f;
}

#define YY_USER_ACTION { yylloc->updatePosition(yylineno); }

int yyparse(yyscan_t yyscanner);

// the return value of this function must be freed if non-0
static char *trim(const char *str) {
   while ((*str) == ' ' || (*str) == '\t')
      str++;
   // duplicate string
   char *n = strdup(str);
   // find end of string
   unsigned l = (unsigned)strlen(n);
   if (l) {
      char *e = n + l - 1;
      while ((*e) == ' ' || (*e) == '\t')
	 *(e--) = '\0';
   }
   if (!n[0]) {
      free(n);
      n = 0;
   }
   return n;
}

// edits the string (even though it's a 'const char*') and returns a pointer to a string with leading and trailing whitespace removed
static const char *trim_inplace(const char *str) {
   while ((*str) == ' ' || (*str) == '\t')
      str++;
   // find end of string
   unsigned l = (unsigned)strlen(str);
   if (l) {
      const char *e = str + l - 1;
      while ((*e) == ' ' || (*e) == '\t')
	 *((char *)(e--)) = '\0';
   }
   return str[0] ? str : 0;
}

static QoreString *getIncludeFileName(char *file) {
#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
   // convert UNIX-style '/' character to '\'
   for (char *p = file; *p; ++p)
      if (*p == '/')
	 *p = '\\';
#endif

   //printd(5, "getIncludeFileName(%s)\n", file);
   // FIXME: UNIX-specific - need to check for drive name on windows
   if (file[0] == QORE_DIR_SEP)
      return new QoreString(file);

   QoreString *rv;

   // check in current directory of script first
   const char *sp = getProgram()->parseGetScriptDir();
   if (sp) {
      rv = findFileInPath(file, sp);
      if (rv)
	 return rv;
   }

   rv = findFileInEnvPath(file, "QORE_INCLUDE_DIR");
   if (!rv) {
       const char *pp = getProgram()->parseGetIncludePath();
       if (pp) 
	   rv = findFileInPath(file, pp);
       if (!rv)
	   rv = new QoreString(file);
   }

   return rv;
}

// sets the time zone at parse time
void parse_set_time_zone(const char *zone) {
   zone = trim_inplace(zone);
   if (!zone) {
      parse_error("empty argument to %set-time-zone");
      return;
   }

   getProgram()->parseSetTimeZone(zone);
}

void setIncludePath(const char *path) {
    char *ip = trim(path);
    if (!ip)
	return;

    QoreString npath; // for new path

    // scan through paths and:
    // 1: do environment variable substitution
    // 2: remove the paths that don't exist
    char *lp, *p;
    p = lp = ip;
    
    while (true) {
#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
       // do not assume ':' separates paths on windows if it's the second character in a path
       if ((*p == ':' && p != lp + 1) || !*p) {
#else
       if (*p == ':' || !*p) {
#endif
	    // skip if at beginning of new path
	    if (p != lp) {
		QoreString tpath;
		tpath.concat(lp, p - lp);
		const char *sp = tpath.getBuffer();
		//printd(5, "got path string: '%s'\n", sp);

		const char *i, *spt;
		spt = sp;

		while ((i = strchr(spt, '$'))) {
		    // find end of environment variable
		    char *ep = (char *)++i;
		    while (*ep && (*ep == '_' || isalnum(*ep)))
			++ep;
		    spt = i + 1;
		    // perform variable substitution
		    if (ep != i) {
			char save = *ep;
			*ep = '\0';
			TempString val(SystemEnvironment::get(i));
			//printd(5, "setIncludePath() found variable '$%s' = %s\n", i, val->getBuffer());			
			*ep = save;
			if (val && val->strlen()) {
			   // see if environment value ends in the directory separator char, if so, and the
			   // rest of the string starts with the directory separator char, then make sure the
			   // character is not doubled (can cause problems on windows)
			   if (val->getBuffer()[val->strlen() - 1] == QORE_DIR_SEP
			       && *ep == QORE_DIR_SEP)
			      ++ep;

			   // replace with value
			   int pos = (int)(i - sp);			    
			   //printd(5, "got $%s = '%s' (replacing %d char(s))\n", i, val->getBuffer(), ep - i + 1);
			   tpath.replace(pos - 1, ep - i + 1, *val);			    
			   // re-assign sp in case it's changed
			   int diff = (int)(pos + val->strlen());
			   sp = tpath.getBuffer();
			   spt = sp + diff;
			   //printd(5, "new string = '%s' ('%s')\n", sp, spt);
			}
		    }
		}
		struct stat sb;
	    
		//printd(5, "setIncludePath() trying '%s'\n", sp);
		// add to path list if the directory exists
		if (!stat(sp, &sb)) {
		    //printd(5, "OK: adding '%s' to path list\n", sp);
		    if (npath.strlen()) 
			npath.concat(':');
		    npath.concat(&tpath);
		}

		if (!*p)
		    break;
	    }
	    lp = ++p;
	    continue;
	}
#if (defined _WIN32 || defined __WIN32__) && ! defined __CYGWIN__
	// transform '/ characters to '\' characters
	if (*p == '/')
	   *p = '\\';
#endif

	++p;
    }
    
    //printd(5, "setting include path: '%s'\n", npath.getBuffer());
    getProgram()->parseSetIncludePath(npath.getBuffer());

    free(ip);
}

static inline char *remove_quotes(char *str) {
   str[strlen(str) - 1] = '\0';
   return str + 1;
}

static inline DateTimeNode *makeYears(int years) {
   return new DateTimeNode(years, 0, 0, 0, 0, 0, 0, true);
}

static inline DateTimeNode *makeMonths(int months) {
   return new DateTimeNode(0, months, 0, 0, 0, 0, 0, true);
}

static inline DateTimeNode *makeDays(int days) {
   return new DateTimeNode(0, 0, days, 0, 0, 0, 0, true);
}

static inline DateTimeNode *makeHours(int hours) {
   return new DateTimeNode(0, 0, 0, hours, 0, 0, 0, true);
}

static inline DateTimeNode *makeMinutes(int minutes) {
   return new DateTimeNode(0, 0, 0, 0, minutes, 0, 0, true);
}

static inline DateTimeNode *makeSeconds(int seconds) {
   return new DateTimeNode(0, 0, 0, 0, 0, seconds, 0, true);
}

static inline DateTimeNode *makeMilliseconds(int ms) {
   return new DateTimeNode(0, 0, 0, 0, 0, 0, ms, true);
}

static inline DateTimeNode *makeMicroseconds(int us) {
   return DateTimeNode::makeRelative(0, 0, 0, 0, 0, 0, us);
}

static int64 parse_get_integer(const char *str) {
   errno = 0;
   int64 rv = strtoll(str, 0, 10);
   if (errno == ERANGE)
      parse_error("numeric overflow in integer '%s': cannot represent in a 64-bit signed number; please use a floating-point number instead (integers must be in the range "QLLD" to "QLLD")", str, LLONG_MIN, LLONG_MAX);
   return rv;
}

static inline int get_int_2(const char *&p) {
   int rv = (*p - '0') * 10;
   ++p;
   rv += (*p - '0');
   ++p;
   return rv;
}

static inline int get_int_4(const char *&p) {
   int rv = (*p - '0') * 1000;
   ++p;
   rv += (*p - '0') * 100;
   ++p;
   rv += (*p - '0') * 10;
   ++p;
   rv += (*p - '0');
   ++p;
   return rv;
}

static void parse_time(const char *&p, int &hour, int &minute, int &second, int &us) {
   assert(!hour && !minute && !second && !us);

   // get hour
   hour = get_int_2(p);
   ++p;

   // get minute
   minute = get_int_2(p);

   if ((*p) == ':') {
      ++p;
      // get second
      second = get_int_2(p);

      // get milliseconds or microseconds if present
      if ((*p) == '.') {
	 ++p;

	 // read all digits
	 int len = 0;
	 while (isdigit(*p)) {
	    us *= 10;
	    us += *p - '0';
	    ++len;
	    ++p;
	 }
	 
	 // adjust to microseconds
	 while (len < 6) {
	    us *= 10;
	    ++len;
	 }
	 while (len > 6) {
	    us /= 10;
	    --len;
	 }
      }
   }
}

static DateTimeNode *makeDateTime(char *str, bool has_time) {
   const char *p = str;

   // get year
   int year = get_int_4(p);
   ++p;

   // get month
   int month = get_int_2(p);
   ++p;

   // get day
   int day = get_int_2(p);

   int hour = 0, minute = 0, second = 0, us = 0;

   // parse time, if any
   if (*p == 'T' || (*p == '-' && has_time)) {
      ++p;
      parse_time(p, hour, minute, second, us);
   }

   // get zone if present, otherwise assume local zone
   const AbstractQoreZoneInfo *zone;
   if ((*p) == '+' || (*p) == '-')
      zone = QTZM.findCreateOffsetZone(p);
   else if ((*p) == 'Z')
      zone = 0;
   else
      zone = currentTZ();

   return DateTimeNode::makeAbsolute(zone, year, month, day, hour, minute, second, us);
}

static inline DateTimeNode *makeTime(char *str) {
   const char *p = str;

   int hour = 0, minute = 0, second = 0, us = 0;
   parse_time(p, hour, minute, second, us);

   // get zone if present, otherwise assume local zone
   const AbstractQoreZoneInfo *zone;
   if ((*p) == '+' || (*p) == '-')
      zone = QTZM.findCreateOffsetZone(p);
   else if ((*p) == 'Z')
      zone = 0;
   else
      zone = currentTZ();

   return DateTimeNode::makeAbsolute(zone, 1970, 01, 01, hour, minute, second, us);
}

static inline DateTimeNode *makeRelativeDateTime(char *str) {
   const char *p = str;

   // get year
   int year = get_int_4(p);
   ++p;

   // get month
   int month = get_int_2(p);
   ++p;

   // get day
   int day = get_int_2(p);

   int hour = 0, minute = 0, second = 0, us = 0;
   if (*p) {
      ++p;
      parse_time(p, hour, minute, second, us);
   }

   return DateTimeNode::makeRelative(year, month, day, hour, minute, second, us);
}

static inline DateTimeNode *makeRelativeTime(char *str) {
   const char *p = str;

   int hour = 0, minute = 0, second = 0, us = 0;
   parse_time(p, hour, minute, second, us);

   return DateTimeNode::makeRelative(0, 0, 0, hour, minute, second, us);
}

static inline bool isRegexModifier(QoreRegexNode *qr, int c) {
   if (c == 'i')
      qr->setCaseInsensitive();
   else if (c == 's')
      qr->setDotAll();
   else if (c == 'x')
      qr->setExtended();
   else if (c == 'm')
      qr->setMultiline();
   else
      return false;
   return true;
}

static inline bool isRegexSubstModifier(RegexSubstNode *qr, int c) {
   if (c == 'g')
      qr->setGlobal();
   else if (c == 'i')
      qr->setCaseInsensitive();
   else if (c == 's')
      qr->setDotAll();
   else if (c == 'x')
      qr->setExtended();
   else if (c == 'm')
      qr->setMultiline();
   else
      return false;
   return true;
}

static char *make_cast(const char *s) {
   QoreString str(s + 5);
   str.trim_trailing('>');
   str.trim();
   return str.giveBuffer();
}

static void qore_parse_define(const char *pstr) {
   QoreString str(pstr);
   // trim trailing and leading whitespace
   str.trim();
   const char *p = strchr(str.getBuffer(), ' ');
   QoreString arg;
   if (p) {
      // copy arg to arg string
      arg.set(p + 1);
      // trim leading whitespace, if any
      arg.trim_leading();
      // remove argument from define string
      str.terminate(p - str.getBuffer());
   }
   // check define string
   if (str.empty()) {
      parse_error("missing argument to %%define");
      return;
   }

   AbstractQoreNode *v = 0;
   if (!arg.empty()) {
      bool ok;
      v = qore_parse_get_define_value(str.getBuffer(), arg, ok);
      if (!ok)
	 return;
   }
 
   qore_program_private::parseDefine(getProgram(), QoreProgramLocation(), str.getBuffer(), v);
}

bool parse_is_defined(const char *pstr, bool def = true) {
   QoreString str(pstr);
   str.trim();
   if (str.empty()) {
      parse_error("missing argument to %%if%sdef", def ? "" : "n");
      return false;
   }
   return qore_program_private::parseIsDefined(getProgram(), str.getBuffer());
}

#define DO_DOT_KW_IDENTIFIER(kw) { yylval->String = new QoreStringNode(kw); qore_size_t pos = yylval->String->size() + 1; if (yytext[pos]) unput(yytext[pos]); return DOT_KW_IDENTIFIER; }

#define QORE_FLEX_DO_EOF { /* delete current buffer */ yy_delete_buffer(YY_CURRENT_BUFFER, yyscanner); \
      /* get last parse state */ YY_BUFFER_STATE yybs = (YY_BUFFER_STATE)endParsing(); \
      if (yybs) { /* need to close file and switch to previous buffer */ \
	 fclose(yyin); if (yybs) yy_switch_to_buffer(yybs, yyscanner);	\
      } else yyterminate(); }

%}

%option noyywrap nomain noyy_top_state warn
%option reentrant bison-bridge bison-locations
%option stack
%option yylineno
%option noyy_push_state
%option noyy_pop_state

%x str_state regex_state incl p_def p_ifdef p_ifndef p_skip_to_endif p_skip_to_endif_or_else case_state regex_googleplex regex_negative_universe regex_subst1 regex_subst2 line_comment exec_class_state requires regex_trans1 regex_trans2 regex_extract_state disable_warning enable_warning append_path_state module_cmd set_zone

HEX_DIGIT       [0-9A-Fa-f]
HEX_CONST       0x{HEX_DIGIT}+
OCTAL_CONST     \\[0-7]{1,3}
DIGIT		[0-9]
WORD		[a-zA-Z][a-zA-Z0-9_]*
WS		[ \t\r]
WSNL		[ \t\r\n]
YEAR            [0-9]{4}
MONTH           (0[1-9])|(1[012])
DAY             ((0[1-9])|([12][0-9])|(3[01]))
HOUR            ([01][0-9])|(2[0-3])
MSEC            [0-5][0-9]
US              [0-9]{1,6}
D2              [0-9]{2}
BINARY          <({HEX_DIGIT}{HEX_DIGIT})+>
TZ              (Z|([+-][01][0-9](:{MSEC}(:{MSEC})?)?))
RDATE           P(-?[0-9]+[YMDHSu])+
RDATETIME       P(-?[0-9]+[YMD])+T(-?[0-9]+[HMSu])+
RTIME           PT(-?[0-9]+[HMSu])+

%%
^%no-global-vars{WS}*$                  getProgram()->parseSetParseOptions(PO_NO_GLOBAL_VARS);
^%no-subroutine-defs{WS}*$              getProgram()->parseSetParseOptions(PO_NO_SUBROUTINE_DEFS);
^%no-threads{WS}*$                      getProgram()->parseSetParseOptions(PO_NO_THREADS);
^%no-thread-classes{WS}*$               getProgram()->parseSetParseOptions(PO_NO_THREAD_CLASSES);
^%no-thread-control{WS}*$               getProgram()->parseSetParseOptions(PO_NO_THREAD_CONTROL);
^%no-thread-info{WS}*$                  getProgram()->parseSetParseOptions(PO_NO_THREAD_INFO);
^%no-top-level{WS}*$                    getProgram()->parseSetParseOptions(PO_NO_TOP_LEVEL_STATEMENTS);
^%no-class-defs{WS}*$                   getProgram()->parseSetParseOptions(PO_NO_CLASS_DEFS);
^%no-namespace-defs{WS}*$               getProgram()->parseSetParseOptions(PO_NO_NAMESPACE_DEFS);
^%no-external-process{WS}*$             getProgram()->parseSetParseOptions(PO_NO_EXTERNAL_PROCESS);
^%no-external-info{WS}*$                getProgram()->parseSetParseOptions(PO_NO_EXTERNAL_INFO);
^%no-filesystem{WS}*$                   getProgram()->parseSetParseOptions(PO_NO_FILESYSTEM);
^%lock-options{WS}*$                    getProgram()->lockOptions();
^%lock-warnings{WS}*$                   getProgram()->parseSetParseOptions(PO_LOCK_WARNINGS);
^%no-locale-control{WS}*$               getProgram()->parseSetParseOptions(PO_NO_LOCALE_CONTROL);
^%no-process-control{WS}*$              getProgram()->parseSetParseOptions(PO_NO_PROCESS_CONTROL);
^%no-constant-defs{WS}*$                getProgram()->parseSetParseOptions(PO_NO_CONSTANT_DEFS);
^%no-new{WS}*$                          getProgram()->parseSetParseOptions(PO_NO_NEW);
^%no-network{WS}*$                      getProgram()->parseSetParseOptions(PO_NO_NETWORK);
^%no-child-restrictions{WS}*$           getProgram()->parseSetParseOptions(PO_NO_CHILD_PO_RESTRICTIONS);
^%no-database{WS}*$                     getProgram()->parseSetParseOptions(PO_NO_DATABASE);
^%no-gui{WS}*$                          getProgram()->parseSetParseOptions(PO_NO_GUI);
^%no-terminal-io{WS}*$                  getProgram()->parseSetParseOptions(PO_NO_TERMINAL_IO);
^%require-our{WS}*$                     getProgram()->parseSetParseOptions(PO_REQUIRE_OUR);
^%require-types{WS}*$                   getProgram()->parseSetParseOptions(PO_REQUIRE_TYPES);
^%require-prototypes{WS}*$              getProgram()->parseSetParseOptions(PO_REQUIRE_PROTOTYPES);
^%strict-args{WS}*$                     getProgram()->parseSetParseOptions(PO_STRICT_ARGS);
^%allow-bare-refs{WS}*$                 getProgram()->parseSetParseOptions(PO_ALLOW_BARE_REFS);
^%assume-local{WS}*$                    getProgram()->parseSetParseOptions(PO_ASSUME_LOCAL);
^%new-style{WS}*$                       getProgram()->parseSetParseOptions(PO_NEW_STYLE);
^%append-include-path{WS}+              BEGIN(append_path_state);
<append_path_state>[^\t\n\r]+           {
					   setIncludePath(yytext);
					   BEGIN(INITIAL);
                                        }
^%set-time-zone{WS}+                    BEGIN(set_zone);
<set_zone>[^\t\n\r]+                    {
					   parse_set_time_zone(yytext);
					   BEGIN(INITIAL);
                                        }
^%enable-all-warnings{WS}*$             { 
                                           if (getProgram()->setWarningMask(-1))
					      getProgram()->makeParseWarning(QP_WARN_WARNING_MASK_UNCHANGED, "CANNOT-UPDATE-WARNING-MASK", "this program has its warning mask locked; cannot enable all warnings");
			                }
^%disable-all-warnings{WS}*$            { 
                                           if (getProgram()->setWarningMask(0))
					      getProgram()->makeParseWarning(QP_WARN_WARNING_MASK_UNCHANGED, "CANNOT-UPDATE-WARNING-MASK", "this program has its warning mask locked; cannot disable all warnings");
			                }
^%disable-warning{WS}*$                 { parse_error("missing argument to %%disable-warning"); }
^%disable-warning{WS}+                  BEGIN(disable_warning);
<disable_warning>[^\t\n\r]+             {
                                           char *cn = trim(yytext);
					   //printd(5, "scanner: disable warning '%s'\n", cn);
					   int code = get_warning_code(cn);
					   if (!code)
					      getProgram()->makeParseWarning(QP_WARN_UNKNOWN_WARNING, "UNKNOWN-WARNING", "cannot disable unknown warning '%s'", cn);
					   else if (getProgram()->disableWarning(code))
					      getProgram()->makeParseWarning(QP_WARN_WARNING_MASK_UNCHANGED, "CANNOT-UPDATE-WARNING-MASK", "this program has its warning mask locked; cannot disable warning '%s'", cn);
					   //printd(5, "scanner: disable warning '%s' code=%d\n", cn, code);
					   free(cn);
					   BEGIN(INITIAL);
                                        }
^%ensable-warning{WS}*$                 { parse_error("missing argument to %%enable-warning"); }
^%enable-warning{WS}+                   BEGIN(enable_warning);
<enable_warning>[^\t\n\r]+              {
                                           char *cn = trim(yytext);
					   //printd(5, "scanner: enable warning '%s'\n", cn);
					   int code = get_warning_code(cn);
					   if (!code)
					      getProgram()->makeParseWarning(QP_WARN_UNKNOWN_WARNING, "UNKNOWN-WARNING", "cannot enable unknown warning '%s'", cn);
					   else if (getProgram()->enableWarning(code))
					      getProgram()->makeParseWarning(QP_WARN_WARNING_MASK_UNCHANGED, "CANNOT-UPDATE-WARNING-MASK", "this program has its warning mask locked; cannot enable warning '%s'", cn);
					   free(cn);
					   BEGIN(INITIAL);
                                        }
^%exec-class{WS}*$                      { parse_error("missing argument to %%exec-class"); }
^%exec-class{WS}*                       BEGIN(exec_class_state);
^%requires                              BEGIN(requires);
<requires>[^\t\n\r]+                    {
                                           char *cn = trim(yytext);
					   //printd(5, "scanner requesting feature: '%s'\n", cn);
					   QoreStringNode *err = MM.parseLoadModule(cn, getProgram());
					   if (err)
					      getProgram()->cannotProvideFeature(err);
					   free(cn);
					   BEGIN(INITIAL);
                                        }
^%module-cmd{WS}*$                      { parse_error("missing argument to %%module-cmd"); }
^%module-cmd                            BEGIN(module_cmd);
<module_cmd>{WS}*                       // ignore white space
<module_cmd>[^\n\r]+                    {
                                           QoreString str(yytext);
					   str.trim();
					   const char *p = str.getBuffer();
					   const char *op = strchr(p, '(');
					   if (!op)
					      parse_error("%%module-cmd not in format '%%module-cmd(<module-name>) <command>'; missing open parenthesis '(' before module name; text given: '%%module-cmd %s'", p);
					   else {
					      p = op + 1;
					      const char *cp = strchr(p, ')');
					      if (!cp)
						 parse_error("%%module-cmd not in format '%%module-cmd(<module-name>) <command>'; missing close parenthesis ')' after module name; text given: '%%module-cmd %s'", str.getBuffer());
					      else {
						 // get module name
						 QoreString module(p, cp - p);
						 module.trim();

						 // remove preface from string leaving only command
						 str.replace(0, cp - str.getBuffer() + 1, (const char *)0);
						 str.trim();
						 if (!str.strlen())
						    parse_error("%%module-cmd not in format %%module-cmd(<module-name>) <command>; missing command; text given: '%%module-cmd %s'", str.getBuffer());
						 else {
						    ModuleManager::issue_parse_cmd(module.getBuffer(), 0, str);
						 }
					      }
					   }
					   BEGIN(INITIAL);
                                        }
^%define{WS}*$                          { parse_error("missing argument to %%define"); }
^%define{WS}+				BEGIN(p_def);
<p_def>{WS}*                            // ignore white space
<p_def>[^\t\n\r]+                       {
                                           qore_parse_define(yytext);
					   BEGIN(INITIAL);
                                        }
^%ifdef{WS}*$                           { parse_error("missing argument to %%ifdef"); }
^%ifdef{WS}+                            BEGIN(p_ifdef);
<p_ifdef>{
   [^\t\n\r]+$                          {
                                           parse_cond_push(true);
                                           if (parse_is_defined(yytext)) {
					      //printd(5, "ifdef: '%s' is defined\n", yytext);
					      BEGIN(INITIAL);
					   }
					   else {
					      //printd(5, "ifdef: '%s' is not defined\n", yytext);
					      // skip to the next %else or %endif
					      BEGIN(p_skip_to_endif_or_else);
					   }
                                        }
}
^%ifndef{WS}*$                           { parse_error("missing argument to %%ifndef"); }
^%ifndef{WS}+                            BEGIN(p_ifndef);
<p_ifndef>{
   [^\t\n\r]+$                          {
                                           parse_cond_push(true);
                                           if (!parse_is_defined(yytext)) {
					      //printd(5, "ifndef: '%s' is not defined\n", yytext);
					      BEGIN(INITIAL);
					   }
					   else {
					      //printd(5, "ifndef: '%s' is defined\n", yytext);
					      // skip to the next %else or %endif
					      BEGIN(p_skip_to_endif_or_else);
					   }
                                        }
}
^%else{WS}*$                            {
                                              if (!parse_cond_else()) {
						 parse_error("%%else found without %%if");
					      }
					      else {
						 BEGIN(p_skip_to_endif);
					      }                                           
                                        }
<p_skip_to_endif>{
   ^%endif{WS}*$                        {
                                           if (parse_cond_pop()) {
					      printd(5, "p_skip_to_endif: found %%endif (%s) (final)\n", yytext);
					      BEGIN(INITIAL);
					   }
#ifdef DEBUG
					   //else
					   //printd(5, "p_skip_to_endif: found %%endif (%s) (not final)\n", yytext);
#endif
                                        }
   ^.*                                  {
                                           if (!strncmp("%ifdef", yytext, 6)) {
					      //printd(5, "p_skip_to_endif: found %%ifdef (%s); skipping\n", yytext);
					      parse_cond_push();
					   }
#ifdef DEBUG
                                           // ignore other text
                                           //printd(5, "p_skip_to_endif: %s\n", yytext);
#endif
                                        }
   \n                                   // ignore
}
<p_skip_to_endif_or_else>{
   ^%else{WS}*$                         {
                                           //printd(5, "p_skip_to_endif_or_else: found %else\n");
                                           BEGIN(INITIAL);
                                        }
   ^%endif{WS}*$                        {
                                           if (parse_cond_pop()) {
					      //printd(5, "p_skip_to_endif_or_else: found %%endif (%s) (final)\n", yytext);
					      BEGIN(INITIAL);
					   }
#ifdef DEBUG
					   //else
					   //printd(5, "p_skip_to_endif_or_else: found %%endif (%s) (not final)\n", yytext);
#endif
                                        }
   ^.*                                  {
                                           if (!strncmp("%ifdef", yytext, 6)) {
					      //printd(5, "p_skip_to_endif_or_else: found %%ifdef (%s); skipping\n", yytext);
					      parse_cond_push();
					   }
#ifdef DEBUG
                                           // ignore other text
                                           //printd(5, "p_skip_to_endif_or_else: %s\n", yytext);
#endif
                                        }
   \n                                   // ignore
}
^%endif{WS}*$                           parse_cond_pop();
^%include{WS}*$                         { parse_error("missing argument to %%include"); }
^%include{WS}+				BEGIN(incl);
<exec_class_state>{
   [^\t\n\r]+$   	                {
                                           char *cn = trim(yytext);
					   //printf("setting class name to: '%s'\n", cn);
	 				   getProgram()->setExecClass(cn);
					   getProgram()->parseSetParseOptions(PO_NO_TOP_LEVEL_STATEMENTS);
					   free(cn);
					   BEGIN(INITIAL);
                                        }
}
<incl>{WS}*				// ignore white space
<incl>[^\t\n\r]+			{
					   TempString fname(getIncludeFileName(yytext));
					   const char *fn = fname->getBuffer();
					   // remove enclosing quotes if any
					   if (fname->strlen() 
					       && ((fn[0] == '\"' && fn[fname->strlen() - 1] == '\"')
						   || (fn[0] == '\'' && fn[fname->strlen() - 1] == '\''))) {
					      fname->trim(fn[0]);
					   }

					   if (!fname->strlen()) {
					      parse_error("missing argument to %%include", yytext);
					      BEGIN(INITIAL);
					   }
					   else {
					      // re-get the buffer pointer
					      fn = fname->getBuffer();
					      // check if regular file
					      struct stat sbuf;
					      int rc = stat(fn, &sbuf);
					      if (rc) {
					         ExceptionSink *xsink = getProgram()->getParseExceptionSink();
						 if (xsink)
						    xsink->raiseErrnoException("PARSE-ERROR", errno, "stat() failed on include file: \"%s\"", fn);
						 BEGIN(INITIAL);
					      }
					      else {
						 //printd(0, "%s: mode=%o, s_ifmt=%o, &=%o, reg=%o comp=%s\n", fname->getBuffer(), sbuf.st_mode, S_IFMT, sbuf.st_mode & S_IFMT, S_IFREG, (sbuf.st_mode & S_IFMT) != S_IFREG ? "true" : "false");
						 if ((sbuf.st_mode & S_IFMT) != S_IFREG) {
						    parse_error("cannot include \"%s\"; is not a regular file", fn);
						    BEGIN(INITIAL);
						 }
						 else {
						    FILE *save_yyin = yyin;
						    yyin = fopen(fn, "r");
						    
						    if (!yyin) {
						       parse_error("cannot open include file \"%s\"", fn);
						       yyin = save_yyin;
						       BEGIN(INITIAL);
						    }
						    else {
						       // take string from buffer
						       char *str = fname->giveBuffer();
						       // save file name string in QoreProgram's list - the list now owns the string memory
						       getProgram()->addFile(str);
						       beginParsing(str, (void *)YY_CURRENT_BUFFER);
						       yy_switch_to_buffer(yy_create_buffer(yyin, YY_BUF_SIZE, yyscanner), yyscanner);
						       BEGIN(INITIAL);
						    }
						 }
					      }
					   }
                                        }
<<EOF>>                                 {
                                           QORE_FLEX_DO_EOF
                                        }
\"					yylval->String = new QoreStringNode; yylloc->setExplicitFirst(yylineno); BEGIN(str_state);
<str_state>{
      \"				BEGIN(INITIAL); return QUOTED_WORD;
      \n				yylval->String->concat('\n');
      {OCTAL_CONST}			{
					   int result;
					   sscanf(yytext + 1, "%o", &result);
					   if (result > 0xff)
					      parse_error("octal constant out of bounds\n");
					   yylval->String->concat((char)result);
					}
      \\{DIGIT}+			parse_error("bad escape sequence");
      \\n				yylval->String->concat('\n');
      \\t				yylval->String->concat('\t');
      \\r				yylval->String->concat('\r');
      \\b				yylval->String->concat('\b');
      \\f				yylval->String->concat('\f');
      \\v				yylval->String->concat('\v');
      \\.				yylval->String->concat(yytext[1]);
      \\\n                              yylval->String->concat('\n');
      [^\\\n\"]+			{
					   char *yptr = yytext;
					   while (*yptr)
					      yylval->String->concat(*(yptr++));
					}
}
<regex_subst2>{
      \/				{
                                           // get regex modifiers
	                                   int c;
	                                   do {
					      c = yyinput(yyscanner);
					   } while (isRegexSubstModifier(yylval->RegexSubst, c));
					   unput(c);
					   BEGIN(INITIAL); 
					   yylval->RegexSubst->parse(); 
					   return REGEX_SUBST;
                                        }
      \n				{
					   yylval->RegexSubst->concatTarget('\n');
                                        }
      \\\/                              yylval->RegexSubst->concatTarget('/');
      \\.                               { yylval->RegexSubst->concatTarget('\\'); yylval->RegexSubst->concatTarget(yytext[1]); }
      [^\n\\/]+			        {
					   char *yptr = yytext;
					   while (*yptr)
					      yylval->RegexSubst->concatTarget(*(yptr++));
					}
}
<regex_subst1>{
      \/  	                        BEGIN(regex_subst2);
      \n				yylval->RegexSubst->concatSource('\n');
      \\\/                              yylval->RegexSubst->concatSource('/');
      \\.                               { yylval->RegexSubst->concatSource('\\'); yylval->RegexSubst->concatSource(yytext[1]); }
      [^\n\\/]+			        {
					   char *yptr = yytext;
					   while (*yptr)
					      yylval->RegexSubst->concatSource(*(yptr++));
					}
}
<regex_trans2>{
      -                                 yylval->RegexTrans->setTargetRange();
      \/				{
					   BEGIN(INITIAL); 
					   yylval->RegexTrans->finishTarget(); 
					   return REGEX_TRANS;
                                        }
      \n				yylval->RegexTrans->concatTarget('\n');
      \\n				yylval->RegexTrans->concatTarget('\n');
      \\t				yylval->RegexTrans->concatTarget('\t');
      \\r				yylval->RegexTrans->concatTarget('\r');
      \\b				yylval->RegexTrans->concatTarget('\b');
      \\f				yylval->RegexTrans->concatTarget('\f');
      \\\n                              yylval->RegexTrans->concatTarget('\n');
      \\\/                              yylval->RegexTrans->concatTarget('/');
      \\.				yylval->RegexTrans->concatTarget(yytext[1]);
      [^\n\\/\-]+			        {
					   char *yptr = yytext;
					   while (*yptr)
					      yylval->RegexTrans->concatTarget(*(yptr++));
					}
}
<regex_trans1>{
      -                                 yylval->RegexTrans->setSourceRange();
      \/  	                        BEGIN(regex_trans2); yylval->RegexTrans->finishSource();
      \n				yylval->RegexTrans->concatSource('\n');
      \\n				yylval->RegexTrans->concatSource('\n');
      \\t				yylval->RegexTrans->concatSource('\t');
      \\r				yylval->RegexTrans->concatSource('\r');
      \\b				yylval->RegexTrans->concatSource('\b');
      \\f				yylval->RegexTrans->concatSource('\f');
      \\\n                              yylval->RegexTrans->concatSource('\n');
      \\\/                              yylval->RegexTrans->concatSource('/');
      \\.				yylval->RegexTrans->concatSource(yytext[1]);
      [^\n\\/\-]+			        {
					   char *yptr = yytext;
					   while (*yptr)
					      yylval->RegexTrans->concatSource(*(yptr++));
					}
}
<regex_state>{
      \/				{
                                           // get regex modifiers
	                                   int c;
	                                   do {
					      c = yyinput(yyscanner);
					   } while (isRegexModifier(yylval->Regex, c));
					   unput(c);
					   BEGIN(INITIAL); 
					   yylval->Regex->parse(); 
					   return REGEX;
                                        }
      \n				yylval->Regex->concat('\n');
      \\\/                              yylval->Regex->concat('/');
      \\.                               { yylval->Regex->concat('\\'); yylval->Regex->concat(yytext[1]); }
      [^\n\\/]+			        {
					   char *yptr = yytext;
					   while (*yptr)
					      yylval->Regex->concat(*(yptr++));
					}
}
<regex_extract_state>{
      \/				{
                                           // get regex modifiers
	                                   int c;
	                                   do {
					      c = yyinput(yyscanner);
					   } while (isRegexModifier(yylval->Regex, c));
					   unput(c);
					   BEGIN(INITIAL); 
					   yylval->Regex->parse(); 
					   return REGEX_EXTRACT;
                                        }
      \n				yylval->Regex->concat('\n');
      \\\/                              yylval->Regex->concat('/');
      \\.                               { yylval->Regex->concat('\\'); yylval->Regex->concat(yytext[1]); }
      [^\n\\/]+			        {
					   char *yptr = yytext;
					   while (*yptr)
					      yylval->Regex->concat(*(yptr++));
					}
}
\#                                      {
                                           int c;
					   while ((c = yyinput(yyscanner))) {
					      if (c == '\n')
						 break;
					      else if (c == EOF) {
						 QORE_FLEX_DO_EOF
						 break;
					      }
					   }
                                        }
where					return TOK_WHERE;
NULL					return TOK_NULL;
NOTHING					return TOK_NOTHING;
class                                   return TOK_CLASS;
private                                 return TOK_PRIVATE;
public                                  return TOK_PUBLIC;
interface                               return TOK_INTERFACE;
implements                              return TOK_IMPLEMENTS;
abstract                                return TOK_ABSTRACT;
unreference                             return TOK_UNREFERENCE;
new                                     return TOK_NEW;
shift                                   return TOK_SHIFT;
unshift                                 return TOK_UNSHIFT;
do					return TOK_DO;
while					return TOK_WHILE;
if					return TOK_IF;
else					return TOK_ELSE;
for					return TOK_FOR;
foreach                                 return TOK_FOREACH;
in                                      return TOK_IN;
elements                                return TOK_ELEMENTS;
keys                                    return TOK_KEYS;
sub                                     { new_argv_ref(); return TOK_SUB; }
const                                   return TOK_CONST;
namespace				return TOK_NAMESPACE;
return					return TOK_RETURN;
returns                                 return TOK_RETURNS;
my					return TOK_MY;
our 					return TOK_OUR;
break					return TOK_BREAK;
continue				return TOK_CONTINUE;
try                                     return TOK_TRY;
throw                                   return TOK_THROW;
rethrow                                 return TOK_RETHROW;
catch                                   return TOK_CATCH;
finally                                 return TOK_FINALLY;
find                                    return TOK_FIND;
delete                                  return TOK_DELETE;
remove                                  return TOK_REMOVE;
background                              return TOK_BACKGROUND;
synchronized                            return TOK_SYNCHRONIZED;
deprecated				return TOK_DEPRECATED;
thread_exit                             return TOK_THREAD_EXIT;
exists                                  return TOK_EXISTS;
context				        return TOK_CONTEXT;
summarize				return TOK_SUMMARIZE;
subcontext				return TOK_SUB_CONTEXT;
sortBy				        return TOK_SORT_BY;
sortDescendingBy			return TOK_SORT_DESCENDING_BY;
by					return TOK_BY;
switch                                  return TOK_SWITCH;
case                                    BEGIN(case_state); return TOK_CASE;
<case_state>{
   \/                                   yylval->Regex = new QoreRegexNode(); yylloc->setExplicitFirst(yylineno); BEGIN(regex_state);
   {WS}+                                /* ignore */
   [^\/]                                yyless(0); BEGIN(INITIAL);
}
default                                 return TOK_DEFAULT;
inherits                                return TOK_INHERITS;
push                                    return TOK_PUSH;
pop                                     return TOK_POP;
splice                                  return TOK_SPLICE;
extract                                 return TOK_EXTRACT;
instanceof                              return TOK_INSTANCEOF;
chomp					return TOK_CHOMP;
trim					return TOK_TRIM;
on_exit 		 		return TOK_ON_EXIT;
on_success				return TOK_ON_SUCCESS;
on_error 				return TOK_ON_ERROR;
map                                     { push_ignore_numeric_argv_ref(); return TOK_MAP; }
foldr                                   { push_ignore_numeric_argv_ref(); return TOK_FOLDR; }
foldl                                   { push_ignore_numeric_argv_ref(); return TOK_FOLDL; }
select                                  { push_ignore_numeric_argv_ref(); return TOK_SELECT; }
static                                  return TOK_STATIC;
interface\(                             yylval->string = strdup("interface"); return KW_IDENTIFIER_OPENPAREN;
class\(                                 yylval->string = strdup("class"); return KW_IDENTIFIER_OPENPAREN;
private\(                               yylval->string = strdup("private"); return KW_IDENTIFIER_OPENPAREN;
new\(                                   yylval->string = strdup("new"); return KW_IDENTIFIER_OPENPAREN;
delete\(                                yylval->string = strdup("delete"); return KW_IDENTIFIER_OPENPAREN;
case\(                                  yylval->string = strdup("case"); return KW_IDENTIFIER_OPENPAREN;
chomp\(                                 yylval->string = strdup("chomp"); return KW_IDENTIFIER_OPENPAREN;
trim\(                                  yylval->string = strdup("trim"); return KW_IDENTIFIER_OPENPAREN;
push\(                                  yylval->string = strdup("push"); return KW_IDENTIFIER_OPENPAREN;
pop\(                                   yylval->string = strdup("pop"); return KW_IDENTIFIER_OPENPAREN;
splice\(                                yylval->string = strdup("splice"); return KW_IDENTIFIER_OPENPAREN;
shift\(                                 yylval->string = strdup("shift"); return KW_IDENTIFIER_OPENPAREN;
unshift\(                               yylval->string = strdup("unshift"); return KW_IDENTIFIER_OPENPAREN;
background\(	   			yylval->string = strdup("background"); return KW_IDENTIFIER_OPENPAREN;
exists\(                                yylval->string = strdup("exists"); return KW_IDENTIFIER_OPENPAREN;
map\(                                   yylval->string = strdup("map"); return KW_IDENTIFIER_OPENPAREN;
foldr\(                                 yylval->string = strdup("foldr"); return KW_IDENTIFIER_OPENPAREN;
foldl\(                                 yylval->string = strdup("foldl"); return KW_IDENTIFIER_OPENPAREN;
select\(                                yylval->string = strdup("select"); return KW_IDENTIFIER_OPENPAREN;
inherits\(                              yylval->string = strdup("inherits"); return KW_IDENTIFIER_OPENPAREN;
default{WS}*\(                          yylval->string = strdup("default"); return KW_IDENTIFIER_OPENPAREN;
static{WS}*\(                           yylval->string = strdup("static"); return KW_IDENTIFIER_OPENPAREN;
returns{WS}*\(                          yylval->string = strdup("returns"); return KW_IDENTIFIER_OPENPAREN;
public{WS}*\(                           yylval->string = strdup("public"); return KW_IDENTIFIER_OPENPAREN;
deprecated{WS}*\(                       yylval->string = strdup("deprecated"); return KW_IDENTIFIER_OPENPAREN;
\.returns[^A-Za-z_0-9]                  DO_DOT_KW_IDENTIFIER("returns")
\.new[^A-Za-z_0-9]                      DO_DOT_KW_IDENTIFIER("new")
\.private[^A-Za-z_0-9]                  DO_DOT_KW_IDENTIFIER("private")
\.public[^A-Za-z_0-9]                   DO_DOT_KW_IDENTIFIER("public")
\.class[^A-Za-z_0-9]                    DO_DOT_KW_IDENTIFIER("class")
\.elements[^A-Za-z_0-9]                 DO_DOT_KW_IDENTIFIER("elements")
\.delete[^A-Za-z_0-9]                   DO_DOT_KW_IDENTIFIER("delete")
\.case[^A-Za-z_0-9]                     DO_DOT_KW_IDENTIFIER("case")
\.default[^A-Za-z_0-9]                  DO_DOT_KW_IDENTIFIER("default")
\.map[^A-Za-z_0-9]                      DO_DOT_KW_IDENTIFIER("map")
\.select[^A-Za-z_0-9]                   DO_DOT_KW_IDENTIFIER("select")
\.keys[^A-Za-z_0-9]                     DO_DOT_KW_IDENTIFIER("keys")
\.chomp[^A-Za-z_0-9]                    DO_DOT_KW_IDENTIFIER("chomp")
\.trim[^A-Za-z_0-9]                     DO_DOT_KW_IDENTIFIER("trim")
\.push[^A-Za-z_0-9]                     DO_DOT_KW_IDENTIFIER("push")
\.pop[^A-Za-z_0-9]                      DO_DOT_KW_IDENTIFIER("pop")
\.splice[^A-Za-z_0-9]                   DO_DOT_KW_IDENTIFIER("splice")
\.shift[^A-Za-z_0-9]                    DO_DOT_KW_IDENTIFIER("shift")
\.unshift[^A-Za-z_0-9]                  DO_DOT_KW_IDENTIFIER("unshift")
\.background[^A-Za-z_0-9]               DO_DOT_KW_IDENTIFIER("background")
\.find[^A-Za-z_0-9]                     DO_DOT_KW_IDENTIFIER("find")
\.exists[^A-Za-z_0-9]                   DO_DOT_KW_IDENTIFIER("exists")
\.foldr[^A-Za-z_0-9]                    DO_DOT_KW_IDENTIFIER("foldr")
\.foldl[^A-Za-z_0-9]                    DO_DOT_KW_IDENTIFIER("foldl")
\.static[^A-Za-z_0-9]                   DO_DOT_KW_IDENTIFIER("static")
\.abstract[^A-Za-z_0-9]                 DO_DOT_KW_IDENTIFIER("abstract")
\.deprecated[^A-Za-z_0-9]               DO_DOT_KW_IDENTIFIER("deprecated")
\.summarize[^A-Za-z_0-9]		DO_DOT_KW_IDENTIFIER("summarize")
\.sub                                   DO_DOT_KW_IDENTIFIER("sub")
\.subcontext[^A-Za-z_0-9]		DO_DOT_KW_IDENTIFIER("subcontext")
\.sortBy[^A-Za-z_0-9]           	DO_DOT_KW_IDENTIFIER("sortBy")
\.sortDescendingBy[^A-Za-z_0-9]		DO_DOT_KW_IDENTIFIER("sortDescendingBy")
\.by[^A-Za-z_0-9]                       DO_DOT_KW_IDENTIFIER("by")
\.switch[^A-Za-z_0-9]                   DO_DOT_KW_IDENTIFIER("switch")
\.return[^A-Za-z_0-9]                   DO_DOT_KW_IDENTIFIER("return")
\.rethrow[^A-Za-z_0-9]                  DO_DOT_KW_IDENTIFIER("rethrow")
\.break[^A-Za-z_0-9]                    DO_DOT_KW_IDENTIFIER("break")
\.catch                                 DO_DOT_KW_IDENTIFIER("catch")
\.const                                 DO_DOT_KW_IDENTIFIER("const")
\.context                               DO_DOT_KW_IDENTIFIER("context")
\.continue                              DO_DOT_KW_IDENTIFIER("continue")
\.do                                    DO_DOT_KW_IDENTIFIER("do")
\.else                                  DO_DOT_KW_IDENTIFIER("else")
\.for                                   DO_DOT_KW_IDENTIFIER("for")
\.foreach                               DO_DOT_KW_IDENTIFIER("foreach")
\.if                                    DO_DOT_KW_IDENTIFIER("if")
\.in                                    DO_DOT_KW_IDENTIFIER("in")
\.inherits                              DO_DOT_KW_IDENTIFIER("inherits")
\.instanceof                            DO_DOT_KW_IDENTIFIER("instanceof")
\.namespace                             DO_DOT_KW_IDENTIFIER("namespace")
\.my                                    DO_DOT_KW_IDENTIFIER("my")
\.on_error                              DO_DOT_KW_IDENTIFIER("on_error")
\.on_exit                               DO_DOT_KW_IDENTIFIER("on_exit")
\.on_success                            DO_DOT_KW_IDENTIFIER("on_success")
\.our                                   DO_DOT_KW_IDENTIFIER("our")
\.synchronized                          DO_DOT_KW_IDENTIFIER("synchronized")
\.thread_exit                           DO_DOT_KW_IDENTIFIER("thread_exit")
\.throw                                 DO_DOT_KW_IDENTIFIER("throw")
\.try                                   DO_DOT_KW_IDENTIFIER("try")
\.where                                 DO_DOT_KW_IDENTIFIER("where")
\.while                                 DO_DOT_KW_IDENTIFIER("while")
\.interface                             DO_DOT_KW_IDENTIFIER("interface")

{YEAR}-{MONTH}-{DAY}T{HOUR}:{MSEC}(:{MSEC}(\.{US})?)?{TZ}?   yylval->datetime = makeDateTime(yytext, true); return DATETIME;
{YEAR}-{MONTH}-{DAY}-{HOUR}:{MSEC}:{MSEC}(\.{US})?{TZ}?      yylval->datetime = makeDateTime(yytext, true); return DATETIME;
{YEAR}-{MONTH}-{DAY}?{TZ}?                                   yylval->datetime = makeDateTime(yytext, false); return DATETIME;
{HOUR}:{MSEC}(:{MSEC}(\.{US})?)?{TZ}?   yylval->datetime = makeTime(yytext); return DATETIME;
P{YEAR}-{D2}-{D2}(T{D2}:{D2}(:{D2}(\.{US})?)?)?   yylval->datetime = makeRelativeDateTime(yytext+1); return DATETIME;
PT{D2}:{D2}(:{D2}(\.{US})?)?            yylval->datetime = makeRelativeTime(yytext+2); return DATETIME;
P{D2}:{D2}(:{D2}(\.{US})?)?             yylval->datetime = makeRelativeTime(yytext+1); return DATETIME;
{RDATETIME}                             yylval->datetime = new DateTimeNode(yytext); return DATETIME;
{RDATE}                                 yylval->datetime = new DateTimeNode(yytext); return DATETIME;
{RTIME}                                 yylval->datetime = new DateTimeNode(yytext); return DATETIME;
({WORD}::)+{WORD}                       yylval->string = strdup(yytext); return SCOPED_REF;
(::{WORD})+                             yylval->string = strdup(yytext); return SCOPED_REF;
cast\<{WS}*({WORD}::)+{WORD}{WS}*\>     yylval->string = make_cast(yytext); return QORE_CAST;
cast\<{WS}*{WORD}{WS}*\>                yylval->string = make_cast(yytext); return QORE_CAST;
({WORD}::)+\$\.{WORD}                   yylval->nscope = new NamedScope(strdup(yytext)); yylval->nscope->fixBCCall(); return BASE_CLASS_CALL;
{DIGIT}+"."{DIGIT}+			yylval->decimal = strtod(yytext, 0); return QFLOAT;
0[0-7]+				        yylval->integer = strtoll(yytext+1, 0, 8); return INTEGER;
{DIGIT}+				yylval->integer = parse_get_integer(yytext); return INTEGER;
{DIGIT}+Y                               yylval->datetime = makeYears(strtol(yytext, 0, 10));   return DATETIME;
{DIGIT}+M                               yylval->datetime = makeMonths(strtol(yytext, 0, 10));  return DATETIME;
{DIGIT}+D                               yylval->datetime = makeDays(strtol(yytext, 0, 10));    return DATETIME;
{DIGIT}+h                               yylval->datetime = makeHours(strtol(yytext, 0, 10));   return DATETIME;
{DIGIT}+ms                              yylval->datetime = makeMilliseconds(strtol(yytext, 0, 10)); return DATETIME;
{DIGIT}+us                              yylval->datetime = makeMicroseconds(strtol(yytext, 0, 10)); return DATETIME;
{DIGIT}+m                               yylval->datetime = makeMinutes(strtol(yytext, 0, 10)); return DATETIME;
{DIGIT}+s                               yylval->datetime = makeSeconds(strtol(yytext, 0, 10)); return DATETIME;
{HEX_CONST}				yylval->integer = strtoll(yytext, 0, 16); return INTEGER;
{BINARY}                                yylval->binary = parseHex(yytext + 1, strlen(yytext + 1) - 1); return BINARY;
\$\.{WORD}                              yylval->string = strdup(yytext + 2); return SELF_REF;
\${WORD}				yylval->string = strdup(yytext + 1); return VAR_REF;
{WORD}					yylval->string = strdup(yytext); return IDENTIFIER;
\%{WORD}                                yylval->string = strdup(yytext + 1); return CONTEXT_REF;
\%{WORD}\:{WORD}                        yylval->string = strdup(yytext + 1); return COMPLEX_CONTEXT_REF;
\%\%                                    return TOK_CONTEXT_ROW;
\`[^`]*\`                               yylval->string = strdup(remove_quotes(yytext)); return BACKQUOTE;
\'[^\']*\'				yylval->String = new QoreStringNode(remove_quotes(yytext)); return QUOTED_WORD;
\$\$                                    yylval->implicit_arg = new QoreImplicitArgumentNode(-1); return IMPLICIT_ARG_REF;
\$[0-9][0-9]*                           yylval->implicit_arg = new QoreImplicitArgumentNode(strtol(yytext + 1, 0, 0)); return IMPLICIT_ARG_REF;
\$#                                     return IMPLICIT_ELEMENT;
\<{WS}*=				return LOGICAL_LE;
\>{WS}*=				return LOGICAL_GE;
\!{WS}*=				return LOGICAL_NE;
\<{WS}*\>				return LOGICAL_NE;
={WS}*={WS}*=                           return ABSOLUTE_EQ;
\!{WS}*={WS}*=                          return ABSOLUTE_NE;
={WS}*= 				return LOGICAL_EQ;
\<{WS}*={WS}*\>                         return LOGICAL_CMP;
&{WS}*& 	 			return LOGICAL_AND;
\|{WS}*\|				return LOGICAL_OR;
\>{WS}*\>				return SHIFT_RIGHT;
\<{WS}*\<				return SHIFT_LEFT;
\+{WS}*\+				return P_INCREMENT;
-{WS}*- 				return P_DECREMENT;
\+{WS}*=				return PLUS_EQUALS;
-{WS}*= 	 			return MINUS_EQUALS;
&{WS}*= 				return AND_EQUALS;
\|{WS}*=				return OR_EQUALS;
\%{WS}*=                                return MODULA_EQUALS;
\*{WS}*=                                return MULTIPLY_EQUALS;
\/{WS}*=                                return DIVIDE_EQUALS;
\^{WS}*=                                return XOR_EQUALS;
\>{WS}*\>{WS}*=				return SHIFT_RIGHT_EQUALS;
\<{WS}*\<{WS}*=				return SHIFT_LEFT_EQUALS;
\/\*                                    {
                                           int c;
					   while ((c = yyinput(yyscanner))) {
					      if (c == '*') {
						 do {
						    c = yyinput(yyscanner);
						 }
						 while (c == '*');
						 if (c == '/') 
						    break;
					      }
					      if (c == EOF) {
						 parse_error("open block comment at EOF");
						 QORE_FLEX_DO_EOF;
						 break;
					      }
					   }
                                        }
<regex_googleplex>{
   s\/                                  yylval->RegexSubst = new RegexSubstNode(); yylloc->setExplicitFirst(yylineno); BEGIN(regex_subst1);
   x\/                                  yylval->Regex      = new QoreRegexNode();  yylloc->setExplicitFirst(yylineno); BEGIN(regex_extract_state);
   tr\/                                 yylval->RegexTrans = new RegexTransNode(); yylloc->setExplicitFirst(yylineno); BEGIN(regex_trans1);
   m\/                                  yylval->Regex      = new QoreRegexNode();  yylloc->setExplicitFirst(yylineno); BEGIN(regex_state); 
   \/                                   yylval->Regex      = new QoreRegexNode();  yylloc->setExplicitFirst(yylineno); BEGIN(regex_state);
   {WSNL}+                              /* ignore whitespace */
   [^sxmt\/]                            parse_error("missing regular expression after =~"); BEGIN(INITIAL);
}
<regex_negative_universe>{
   m\/                                  yylval->Regex      = new QoreRegexNode();  yylloc->setExplicitFirst(yylineno); BEGIN(regex_state); 
   \/                                   yylval->Regex      = new QoreRegexNode();  yylloc->setExplicitFirst(yylineno); BEGIN(regex_state);
   {WSNL}+                              /* ignore whitespace */
   [^m\/]                               parse_error("missing regular expression after !~"); BEGIN(INITIAL);
}
=\~                                     BEGIN(regex_googleplex); return REGEX_MATCH;
\!\~                                    BEGIN(regex_negative_universe); return REGEX_NMATCH;
{WSNL}+					/* ignore whitespace */
.					return yytext[0];
%%
