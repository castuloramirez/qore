# -*- mode: qore; indent-tabs-mode: nil -*-
# @file SqlUtil.qm Qore user module for working with SQL data

/*  SqlUtil.qm Copyright 2013 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.8 or better
%requires qore >= 0.8.8

# requires the Util module
%requires Util >= 1.0

# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings
%disable-warning non-existent-method-call

module SqlUtil {
    version = "1.0";
    desc = "user module for working with SQL data";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
}

/*  Version History
    * 2013-xx-xx v1.0: David Nichols <david@qore.org>
      + the initial version of the SqlUtil module
*/

/** @mainpage SqlUtil Module

    The %SqlUtil module provides a high level API for working with database objects.

    To use this module, use \c "%requires SqlUtil" in your code.
    
    All the public symbols in the module are defined in the SqlUtil namespace
*/

#! the SqlUtil namespace contains all the objects in the SqlUtil module
public namespace SqlUtil {
    /** @defgroup ColumnSizeOptions Column Size Options
        These constants represent the possible values for column size options
     */
    #@{
    #! the data type does not take a size parameter
    public const SZ_NONE = 0;

    #! the data type takes a mandatory size parameter
    public const SZ_MAND = 1;

    #! the data type takes an optional size parameter
    public const SZ_OPT = 2;

    #! the data type is numeric so takes an optional precision and scale
    public const SZ_NUM = 3;
    #@}

    #! abstract container class that throws an exception if an unknown key is accessed
    public class AbstractHashContainer {
        public {}

        private {
            *hash h;
        }

        constructor(*hash nh) {
            h = nh;
        }

        any memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        add(string k, any val) {
            h{k} = val;
        }

        any take(string k) {
            return remove h{k};
        }

        *hash val() {
            return h;
        }

        list keys() {
            return h.keys();
        }

        AbstractIterator iterator() {
            return h.iterator();
        }

        AbstractIterator keyIterator() {
            return h.keyIterator();
        }

        AbstractIterator pairIterator() {
            return h.pairIterator();
        }

        bool empty() {
            return h.empty();
        }

        int size() {
            return h.size();
        }

        bool hasKey(string k) {
            return h.hasKey(k);
        }

        bool hasKeyValue(string k) {
            return h.hasKeyValue(k);
        }

        *string firstKey() {
            return h.firstKey();
        }

        *string lastKey() {
            return h.lastKey();
        }

        abstract string getElementName();
    }

    #! column container class that throws an exception if an unknown column is accessed
    public class Columns inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        AbstractColumn memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        Columns subset(list l) {
            return new Columns(h{l});
        }

        string getElementName() {
            return "column";
        }
    }

    #! the base class for column information
    public class AbstractColumn {
        public {
            #! the name of the column
            string name;

            #! the native type name of the column
            string native_type;

            #! the equivalent qore type name of the column if the native type is known
            *string qore_type;

            #! the size of the column
            int size;

            #! the size of the column in characters
            int char_size;

            #! the precision for numeric columns
            int precision;
            
            #! the scale for numeric columns
            int scale;

            #! Qore::True "True" if the column can hold a NULL value, @ref Qore::False "False" if not
            bool nullable; 

            #! default value for column
            *string def_val;
        }

        constructor(string n, string nt, *string qt, int sz, int cs, int prec, int sc, bool nul, *string dv) {
            name = n;
            native_type = nt;
            qore_type = qt;
            size = sz;
            char_size = cs;
            precision = prec;
            scale = sc;
            nullable = nul;
            def_val = dv;
        }

        string getNativeTypeString() {            
            string sql = native_type;
            if (precision) {
                sql += sprintf("(%d", precision);
                if (scale)
                    sql += sprintf(",%d", scale);
                sql += ")";
            }
            else if (size)
                sql += sprintf("(%d)", size);
            #printf("%y: %s\n", self, sql);
            return sql;
        }

        string getCreateSql() {
            string sql = sprintf("%s %s", name, getNativeTypeString());
            if (def_val)
                sql += " default " + def_val + "";
            if (!nullable)
                sql += " not null";
            return sql;
        }

        #! returns a list of sql strings that can be used to add the column to an existing table
        /** @par Example:
            @code
my list $l = $col.getCreateSql($t);
            @endcode

            @param t the AbstractTable object to modify
         */
        softlist getCreateSql(AbstractTable t) {
            return sprintf("alter table %s add %s", t.getSqlName(), getCreateSql());
        }

        string getDropSql(string table_name) {
            return sprintf("alter table %s drop column %s", table_name, name);
        }
    }

    #! index container class that throws an exception if an unknown index is accessed
    public class Indexes inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        AbstractIndex memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "index";
        }
    }

    #! the base class for index information
    public class AbstractIndex {
        public {
            #! the name of the index
            string name;
            
            #! @ref Qore::True "True" if the index is a unique index, @ref Qore::False "False" if not
            bool unique;

            #! an object of class Columns representing the columns in the index
            Columns columns;
        }

        constructor(string n, bool u, hash c) {
            name = n;
            unique = u;
            columns = new Columns(c);
        }

        abstract string getCreateSql(string table_name, *hash opt);

        string getDropSql(string table_name) {
            return sprintf("drop index %s", name);
        }
    }

    #! constraint container class that throws an exception if an unknown constraint is accessed
    public class Constraints inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        AbstractConstraint memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "constraint";
        }
    }

    #! AbstractConstraint base class
    public class AbstractConstraint {
        public {}

        private {
            #! the name of the constraint
            string name;
        }
        
        constructor(string n) {
            name = n;
        }

        string getName() {
            return name;
        }

        abstract string getCreateSql(string table_name, *hash opt);        

        string getDropSql(string table_name) {
            return sprintf("alter table %s drop constraint %s", table_name, name);
        }
    }

    #! represents a primary key
    public class AbstractPrimaryKey inherits AbstractConstraint, Columns {
        constructor(string n, *hash c) : AbstractConstraint(n), Columns(c) {
        }

        abstract string getCreateSql(string table_name, *hash opts);
        
        string getDropSql(string table_name) {
            return sprintf("alter table %s drop constraint %s", table_name, name);
        }
    }


    #! foreign constraint container class that throws an exception if an unknown constraint is accessed
    public class ForeignConstraints inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        AbstractForeignConstraint memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "foreign constraint";
        }
    }

    #! a class describing a foreign constraint target
    public class ForeignConstraintTarget {
        public {
            #! the name of the target table
            string table;

            #! columns in the target table
            Columns columns;
        }

        constructor(string t, Columns c) {
            table = t;
            columns = c;
        }
    }

    #! the base class for foreign key constraint information
    public class AbstractForeignConstraint inherits AbstractConstraint {
        public {
            #! an object of class Columns giving the source table that make up the constraint
            Columns columns;

            #! a ForeignConstraintTarget object to describe the target table and columns
            ForeignConstraintTarget target;
        }

        constructor(string n, Columns c, ForeignConstraintTarget t) : AbstractConstraint(n) {
            columns = c;
            target = t;
        }
    }

    #! the base class for triggers
    public class AbstractTrigger {
        public {
            #! the name of the trigger
            string name;
            
            #! the source of the trigger
            string src;
        }

        constructor(string n, string n_src) {
            name = n;
            src = n_src;
        }

        abstract string getCreateSql(string table_name, *hash opt);
    }

    #! trigger container class that throws an exception if an unknown trigger is accessed
    public class Triggers inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        AbstractTrigger memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "trigger";
        }
    }

    #! base class for functions
    public class AbstractFunction {
        public {
            #! the name of the function
            string name;
            
            #! the source of the function
            string src;
        }

        constructor(string n, string n_src) {
            name = n;
            src = n_src;
        }

        abstract string getCreateSql(*hash opt);
    }

    #! function container class that throws an exception if an unknown function is accessed
    public class Functions inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        AbstractFunction memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "function";
        }
    }

    #! represents a database table
    public class Table {
        private {
            AbstractTable t;
        }

        constructor(AbstractDatasource ds, string name, *hash opts) {
            t = AbstractTable::getTable(ds, name, opts);
        }

        constructor(string ds, string name, *hash opts) {
            t = AbstractTable::getTable(ds, name, opts);
        }
        
        constructor(hash ds, string name, *hash opts) {
            t = AbstractTable::getTable(ds, name, opts);
        }

        #! returns the name of the table
        string getName() {
            return t.getName();
        }

        #! gets the underlying AbstractDatasource
        AbstractDatasource getDatasource() {
            return t.getDatasource();
        }

        #! executes a method on the contained AbstractTable object
        any methodGate(string meth) {
            return callObjectMethodArgs(t, meth, argv);
        }

        #! returns @ref Qore::True "True" if the table has been read from or created in the database, @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $table.inDb();
            @endcode

            @return @ref Qore::True "True" if the table has been read from or created in the database, @ref Qore::False "False" if not
         */
        bool inDb() {
            return t.inDb();
        }

        #! drops the table from the database; releases the transaction lock after dropping the table
        /** @par Example:
            @code
$table.drop();
            @endcode

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref dropNoCommit() to execute without any transaction management
         */
        drop() {
            t.drop();
        }

        #! drops the table from the database without any transaction management
        /** @par Example:
            @code
$table.dropNoCommit();
            @endcode

            @note Transaction management is normally not performed when dropping tables, however this method uses the AbstractDtasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        dropNoCommit() {
            t.dropNoCommit();
        }
        
        #! truncates all the table data; releases the transaction lock after executing
        /** @par Example:
            @code
$table.truncate();
            @endcode

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref truncateNoCommit() to execute without any transaction management
         */
        truncate() {
            t.truncate();
        }

        #! truncates all the table data without any transaction management
        /** @par Example:
            @code
$table.truncateNoCommit();
            @endcode

            @note Transaction management may not be applied when truncating tables depending on the database driver (for example truncating tables in Oracle does not participate in transaction management), however this method uses the AbstractDtasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        truncateNoCommit() {
            t.truncateNoCommit();
        }
        
        #! creates the table in the database; releases the transaction lock after creating the table
        /** @par Example:
            @code
$table.create();
            @endcode

            @param opt a hash of options for the SQL creation strings

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref createNoCommit() to execute without any transaction management
         */
        create(*hash opt) {
            t.create(opt);
        }

        #! creates the table with all associated properties (indexes, constraints, etc) without any transaction management
        /** @par Example:
            @code
$table.createNoCommit();
            @endcode

            @param opt a hash of options for the SQL creation strings

            @note Transaction management is normally not performed when creating tables, however this method uses the AbstractDtasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        createNoCommit(*hash opt) {
            t.createNoCommit(opt);
        }
        
        #! adds a column to the table; if the table already exists, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
$table.addColumn("name", ("qore_type": Type::String, "size": 50), False);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column
            @param opt a hash describing the column; the following keys are permitted (other column options may be supported depending on the underlying AbstractTable implementation):
            - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion;
            - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
            - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
            - \c scale: for numeric data types, this value gives the scale
            - \c default_value: the default value for the column
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @param nullable if @ref Qore::True "True" then the column can hold NULL values; note that primary key columns cannot be nullable

            @throw COLUMN-ERROR no \c native_type or \c qore_type keys in column option hash, column already exists, invalid column data

            @note make sure and add a \c default_value value when adding a column with a \c "not null" constraint with existing data
         */
        AbstractColumn addColumn(string cname, hash opt, bool nullable = True, *reference lsql) {
            return t.addColumn(cname, opt, nullable, \lsql);
        }

        #! adds a primary key to the table; if the table already exists, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractPrimaryKey $pk = $table.addPrimaryKey("pk_mytable", "id", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new primary key constraint
            @param cols a single column name or a list of columns that make up the primary key
            @param opt a hash of options for the new primary key; each driver may implement it's own options; for common options, see @ref PrimaryKeyOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractPrimaryKey object corresponding to the primary key created

            @throw PRIMARY-KEY-ERROR the table already has a primary key or invalid columns or options passed
         */
        AbstractPrimaryKey addPrimaryKey(string cname, softlist cols, *hash opt, *reference sql) {
            return t.addPrimaryKey(cname, cols, opt, \sql);
        }

        #! drops the primary key from the table
        /** @par Example:
            @code
$table.dropPrimaryKey();
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the primary key dropped from the table

            @note this method retrieves the primary key definition from the database if none has already been defined
         */
        AbstractPrimaryKey dropPrimaryKey(*reference sql) {
            return t.dropPrimaryKey(\sql);
        }

        #! adds an index to the table; if the table already exists, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractIndex $ix = $table.addIndex("uk_mytable_name", True, "name", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param iname the name of the new index
            @param unique a flag to tell if the new index should be unique or not
            @param cols a single column name or a list of columns that make up the index
            @param opt a hash of options for the new index; each driver may implement it's own options; for common options, see @ref IndexOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractIndex object corresponding to the index created

            @throw INDEX-ERROR the table already has an index with the given name or invalid columns or options were passed
         */
        AbstractIndex addIndex(string iname, bool unique, softlist cols, *hash opt, *reference sql) {
            return t.addIndex(iname, unique, cols, opt, \sql);
        }

        #! drops the index from the table
        /** @par Example:
            @code
$table.dropIndex("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param iname the name of the index to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the index dropped from the table

            @note this method retrieves all current index definitions from the database if none have already been defined
         */
        AbstractIndex dropIndex(string iname, *reference sql) {
            return t.dropIndex(iname, \sql);
        }

        #! adds an foreign constraint to the table; if the table already exists, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractForeignConstraint $fc = $table.addForeignConstraint("fk_mytable_other_table", ("name", "version"), "other_table", NOTHING, \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new foreign constraint
            @param cols a single column name or a list of columns in the local table that make up the foreign constraint
            @param table the name of the other table that the constraint targets
            @oaram tcols a single column name or a list of columns in the foreign table or @ref nothing meaning that the column names are the same as in the local table; if column names are given the same number of columns must be given in the local and foreign tables
            @param opt a hash of options for the new foreign constraint; each driver may implement it's own options; for common options, see @ref ForeignConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractForeignConstraint object corresponding to the foreign constraint created

            @throw FOREIGN-CONSTRAINT-ERROR the table already has an foreign constraint with the given name or invalid columns or options were passed
         */
        AbstractForeignConstraint addForeignConstraint(string cname, softlist cols, string table, *softlist tcols, *hash opt, *reference sql) {
            return t.addForeignConstraint(cname, cols, table, tcols, opt, \sql);
        }

        #! drops the foreign constraint from the table
        /** @par Example:
            @code
$table.dropForeignConstraint("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the foreign constraint to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the foreign constraint dropped from the table

            @note this method retrieves all current foreign constraint definitions from the database if none have already been defined
         */
        AbstractForeignConstraint dropForeignConstraint(string cname, *reference sql) {
            return t.dropForeignConstraint(cname, \sql);
        }

        #! drops a constraint from the table; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint
        /** @par Example:
            @code
$table.dropConstraint("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the constraint to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the constraint dropped from the table

            @note this method retrieves current constraint definitions from the database if not already loaded or defined
         */
        AbstractConstraint dropConstraint(string cname, *reference sql) {
            return t.dropConstraint(cname, \sql); 
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument
        /** @par Example:
            @code
my string $str = $table.getSqlValue($date);
            @endcode

            @param v the value to convert to an SQL value

            @return a string representing the value usable in SQL strings for the given database driver
         */
        string getSqlValue(any v) {
            return t.getSqlValue(v);
        }
        
        #! drops a column from the table
        /** @par Example:
            @code
$table.dropColumn("notes_2");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @throw COLUMN-ERROR the named column is not present in the table

            @note this method retrieves the table definition from the database if none has already been defined
         */
         AbstractColumn dropColumn(string cname, *reference sql) {
             return t.dropColumn(cname, \sql);
         }

        #! inserts a row into the table; the transaction is committed if successful, if an error occurs, it is rolled back
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert
         */
        insert(hash row) {
            t.insert(row);
        }

        #! inserts a row into the table without any transaction management; a transaction will be in progress after this method is successfully executed
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert
         */
        insertNoCommit(hash row) {
            t.insertNoCommit(row);
        }

        #! returns an SQL string that could be used to create the table and all known properties of the table
        /** @par Example:
            @code
printf("%s\n", $table.getCreateSqlString());
            @endcode

            @param opt a hash of options for the SQL creation string

            @return an SQL string that could be used to create the table and all known properties of the table
        */
        string getCreateSqlString(*hash opt) {
            return t.getCreateSqlString(opt);
        }

        #! returns a list of SQL strings that could be used to create the table and all known properties of the table
        /** @par Example:
            @code
map printf("$1;\n", $1), $table.getCreateSql();
            @endcode

            @param opt a hash of options for the SQL creation strings

            @return a list of SQL strings that could be used to create the table and all known properties of the table
        */
        list getCreateSql(*hash opt) {
            return t.getCreateSql(opt);
        }

        #! returns an SQL string that could be used to create the basic table structure without indexes and constraints 
        /** @par Example:
            @code
my string $sql = $table.getCreateTableSql();
            @endcode

            @param opt a hash of options for the table creation string

            @return an SQL string that could be used to create the basic table structure without indexes and constraints 
        */
        string getCreateTableSql(*hash opt) {
            return t.getCreateTableSql(opt);
        }

        #! returns a list of SQL strings that could be used to create indexes on the table or @ref nothing if there are no indexes on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateIndexesSql();
            @endcode

            @param opt a hash of options for the index creation string

            @return a list of SQL strings that could be used to create indexes on the table or @ref nothing if there are no indexes on the table
        */
        *list getCreateIndexesSql(*hash opt) {
            return t.getCreateIndexesSql(opt);
        }

        #! returns an SQL string that could be used to create the primary key on the table
        /** @par Example:
            @code
my *string $sql = $table.getCreatePrimaryKeySql();
            @endcode

            @param opt a hash of options for the primary key creation string

            @return an SQL string that could be used to create the primary key on the table or @ref nothing if there is no primary key on the table
        */
        *string getCreatePrimaryKeySql(*hash opt) {
            return t.getCreatePrimaryKeySql(opt);
        }

        #! returns a list of SQL strings that could be used to create foreign constraints on the table or @ref nothing if there are no foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateForeignConstraintsSql();
            @endcode

            @param opt a hash of options for the foreign constraint creation string

            @return a list of SQL strings that could be used to create foreign constraints on the table or @ref nothing if there are no foreign constraints on the table
        */
        *list getCreateForeignConstraintsSql(*hash opt) {
            return t.getCreateForeignConstraintsSql(opt);
        }

        #! returns a list of SQL strings that could be used to create non-foreign constraints on the table or @ref nothing if there are no non-foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateConstraintsSql();
            @endcode

            @param opt a hash of options for the non-foreign constraint creation string

            @return a list of SQL strings that could be used to create non-foreign constraints on the table or @ref nothing if there are no non-foreign constraints on the table

            @see getCreateForeignConstraintsSql()
        */
        *list getCreateConstraintsSql(*hash opt) {
            return t.getCreateConstraintsSql(opt);
        }

        #! returns a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or @ref nothing if there are none
        /** @par Example:
            @code
my *list $l = $table.getCreateMiscSql();
            @endcode

            @param opt a hash of options for the SQL creation string

            @return a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or @ref nothing if there are none
        */
        *list getCreateMiscSql(*hash opt) {
            return t.getCreateMiscSql(opt);
        }

        #! returns a list of SQL strings that could be used to create triggers on the table or @ref nothing if there are no triggers on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateTriggersSql();
            @endcode

            @param opt a hash of options for the trigger creation string

            @return a list of SQL strings that could be used to create triggers on the table or @ref nothing if there are no triggers on the table
        */
        *list getCreateTriggersSql(*hash opt) {
            return t.getCreateTriggersSql(opt);
        }

        #! finds a row in the table with the given primary key value; if no row matches the primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *hash $row = $table.find($id);
            @endcode

            @param id the primary key ID to find

            @return a hash of the row value matching the primary key ID or @ref nothing if no row matches the primary key value passed

            @throw PRIMARY-KEY-ERROR the table has no primary key or the primary key has more than one column
         */
        *hash find(any id) {
            return t.find(id);
        }

        #! finds rows in the table with the given primary key values; if no row matches any primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *list $rows = $table.find($list);
            @endcode

            @param ids the list of primary key IDs to find

            @return a list of hashes of rows matching the primary key IDs passed or @ref nothing if no row matches any primary key value passed

            @throw PRIMARY-KEY-ERROR the table has no primary key or the primary key has more than one column
         */
        *list find(list ids) {
            return t.find(ids);
        }

        #! reads in all attributes of the table from the database
        /** @par Example:
            @code
$table.cache();
            @endcode
        */
        cache() {
            t.cache();
        }

        #! returns an object of class Columns describing the Table
        /** @par Example:
            @code
my Columns $cols = $table.describe();
            @endcode

            @return an object of class Columns describing the Table
        */
        Columns describe() {
            return t.describe();
        }

        #! returns an object of class AbstractPrimaryKey describing the primary key of the table
        /** If there is no primary key then the object returned will be empty (see @ref AbstractPrimaryKey::empty())

            @par Example:
            @code
my AbstractPrimaryKey $cols = $table.getPrimaryKey();
            @endcode

            @return an object of class AbstractPrimaryKey describing the primary key of the table
        */
        AbstractPrimaryKey getPrimaryKey() {
            return t.getPrimaryKey();
        }

        #! returns an object of class Indexes describing the indexes on the table
        /** If there are no indexes on the table then the object returned will be empty (see @ref Indexes::empty())

            @par Example:
            @code
my Indexes $ix = $table.getIndexes();
            @endcode

            @return an object of class Indexes describing the indexes on the table
        */
        Indexes getIndexes() {
            return t.getIndexes();
        }

        #! returns an object of class Triggers describing the triggers on the table
        /** If there are no triggers on the table then the object returned will be empty (see @ref Triggers::empty())

            @par Example:
            @code
my Triggers $trig = $table.getTriggers();
            @endcode

            @return an object of class Triggers describing the triggers on the table
        */
        Triggers getTriggers() {
            return t.getTriggers();
        }

        #! returns a ForeignConstraints object describing the foreign constraints that the table has on other tables
        ForeignConstraints getForeignConstraints() {
            return t.getForeignConstraints();
        }

        #! returns a Constraints object describing non-foreign constraints on the table
        Constraints getConstraints() {
            return t.getConstraints();
        }

        #! returns the database driver name 
        string getDriverName() {
            return t.getDriverName();
        }
    }

    #! the base abstract class for the table implementation
    public class AbstractTable {
        public {
            #! table options
            const TableOptions = (
                "native-case": True,
                );

            #! default index options
            const IndexOptions = (
                "index_tablespace": Type::String,
                );

            #! default pk options
            const PrimaryKeyOptions = IndexOptions;

            #! default foreign constraint options
            const ForeignConstraintOptions = hash();

            #! table creation options
            const TableCreationOptions = IndexOptions + (
                "data_tablespace": Type::String,
                );

            #! Column options
            const ColumnOptions = (
                "qore_type": Type::String,
                "native_type": Type::String,
                "size": Type::Int,
                "scale": Type::Int,
                "default_value": NOTHING,
                );
        }

        private {
            AbstractDatasource ds;
            # table name
            string name;
            # datasource description
            string dsdesc;
            # column description hash
            Columns columns;
            # primary key description
            *AbstractPrimaryKey primaryKey;
            # index description
            Indexes indexes;
            # foreign constraints description
            ForeignConstraints foreignConstraints;
            # constraints description
            Constraints constraints;
            # trigger description
            Triggers triggers;
            # mutex for on-demand retrieval of table attributes
            Mutex l();
            # option hash
            *hash opts;
            # native case option
            bool native_case = False;
            # in database
            bool inDb = False;
            # manual edits
            bool manual = False;
        }

        private constructor(AbstractDatasource nds, string nname, *hash nopts, hash rh = TableOptions) {
            checkOptions(nopts, rh);
            opts = nopts;
            name = nname;
            ds = nds;
            # ensure datasource is open
            ds.getServerVersion();
            dsdesc = sprintf("%s:%s@%s", ds.getDriverName(), ds.getUserName(), ds.getDBName());
            if (ds.getHostName())
                dsdesc += "%" + ds.getHostName();
            if (nds.getPort())
                dsdesc += sprintf(":%d", ds.getPort());
        }

        #! returns @ref Qore::True "True" if the table has been read from or created in the database, @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $table.inDb();
            @endcode

            @return @ref Qore::True "True" if the table has been read from or created in the database, @ref Qore::False "False" if not
         */
        bool inDb() {
            return inDb;
        }

        #! drops the table from the database; releases the transaction lock after dropping the table
        /** @par Example:
            @code
$table.drop();
            @endcode

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref dropNoCommit() to execute without any transaction management
         */
        drop() {
            on_exit ds.commit();
            on_error ds.rollback();
            dropNoCommit();
        }

        #! drops the table from the database without any transaction management
        /** @par Example:
            @code
$table.dropNoCommit();
            @endcode

            @note Transaction management is normally not performed when dropping tables, however this method uses the AbstractDtasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        dropNoCommit() {
            ds.exec("drop table %s", getSqlName());
            inDb = False;
        }
        
        #! truncates all the table data; releases the transaction lock after executing
        /** @par Example:
            @code
$table.truncate();
            @endcode

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref truncateNoCommit() to execute without any transaction management
         */
        truncate() {
            on_exit ds.commit();
            on_error ds.rollback();
            truncateNoCommit();
        }

        #! truncates all the table data without any transaction management
        /** @par Example:
            @code
$table.truncateNoCommit();
            @endcode

            @note Transaction management may not be applied when truncating tables depending on the database driver (for example truncating tables in Oracle does not participate in transaction management), however this method uses the AbstractDtasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        truncateNoCommit() {
            ds.exec("truncate table %s", getSqlName());
            inDb = False;
        }
        
        #! creates the table in the database; releases the transaction lock after creating the table
        /** @par Example:
            @code
$table.create();
            @endcode

            @param opt a hash of options for the SQL creation strings

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref createNoCommit() to execute without any transaction management
         */
        create(*hash opt) {
            on_exit ds.commit();
            on_error ds.rollback();
            createNoCommit(opt);
        }

        #! creates the table with all associated properties (indexes, constraints, etc) without any transaction management
        /** @par Example:
            @code
$table.createNoCommit();
            @endcode

            @param opt a hash of options for the SQL creation strings

            @note Transaction management is normally not performed when creating tables, however this method uses the AbstractDtasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        createNoCommit(*hash opt) {
            if (inDb) 
                throw "CREATE-TABLE-ERROR", sprintf("table %s has already been read from or created in the database", getSqlName());

            map printf("%s\n", $1), getCreateSql(opt, False);

            # get and execute all the creation strings
            map ds.exec($1), getCreateSql(opt, False);
            inDb = True;
            manual = False;
        }

        #! adds a column to the table; if the table already exists, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
$table.addColumn("name", ("qore_type": Type::String, "size": 50), False);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column
            @param opt a hash describing the column; the following keys are permitted (other column options may be supported depending on the underlying AbstractTable implementation):
            - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion;
            - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
            - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
            - \c scale: for numeric data types, this value gives the scale
            - \c default_value: the default value for the column
            @param nullable if @ref Qore::True "True" then the column can hold NULL values; note that primary key columns cannot be nullable
            @param sql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @throw COLUMN-ERROR no \c native_type or \c qore_type keys in column option hash, column already exists, invalid column data

            @note make sure and add a \c default_value value when adding a column with a \c "not null" constraint with existing data
         */
        AbstractColumn addColumn(string cname, hash opt, bool nullable = True, *reference lsql) {
            if (!columns)
                columns = new Columns();
            else if (columns.hasKey(cname))
                throw "COLUMN-ERROR", sprintf("%s.%s: this column already exists", name, cname);    

            if (!opt.native_type && !opt.qore_type)
                throw "COLUMN-ERROR", sprintf("%s.%s: no native_type or qore_type keys in column option hash: %y", name, cname, opt);

            validateColumnOptions(cname, \opt, nullable);

            # get the new column object
            AbstractColumn c = addColumnImpl(cname, opt, nullable);

            # add column in table if the table already exists in the DB
            execSql(lsql = c.getCreateSql(self));

            # add the column to the internal column representation
	    columns.add(cname, c);
            return c;
        }

        private execSql(softlist lsql) {
            if (inDb) {
                on_success ds.commit();
                on_error ds.rollback();
                map ds.exec($1), lsql;
            }
            else 
                manual = True;
        }

        #! adds a primary key to the table; if the table already exists, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractPrimaryKey $pk = $table.addPrimaryKey("pk_mytable", "id", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param pkname the name of the new primary key constraint
            @param cols a single column name or a list of columns that make up the primary key
            @param opt a hash of options for the new primary key; each driver may implement it's own options; for common options, see @ref PrimaryKeyOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractPrimaryKey object corresponding to the primary key created

            @throw PRIMARY-KEY-ERROR the table already has a primary key or invalid columns or options passed
         */
        AbstractPrimaryKey addPrimaryKey(string pkname, softlist cols, *hash opt, *reference sql) {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            if (inDb)
                getPrimaryKeyUnlocked();

            if (!primaryKey.empty())
                throw "PRIMARY-KEY-ERROR", sprintf("%s add primary key %y: already has primary key %y with columns: %y", name, pkname, primaryKey.getName(), primaryKey.keys());

            if (!cols)
                throw "PRIMARY-KEY-ERROR", sprintf("%s add primary key %y: no column names passed to %s::addPrimaryKey()", name, pkname, self.className());

            hash ch;
            while (cols) {
                any v = shift cols;
                if (v.typeCode() != NT_STRING)
                    throw "PRIMARY-KEY-ERROR", sprintf("%s add primary key %y: %y argument passed as column name to %s::addPrimaryKey(); expecting \"string\" (value: %y)", name, pkname, v.type(), self.className(), v);
                if (!columns.hasKey(v))
                    throw "PRIMARY-KEY-ERROR", sprintf("%s add primary key %y: table has no column named %y", name, pkname, v);
                ch{v} = columns{v};
            }

            # validate options
            hash pkopt = getPrimaryKeyOptions();
            validateOptionsIntern("PRIMARY-KEY-ERROR", pkopt, \opt);

            # get the new primary key object
            AbstractPrimaryKey pk = addPrimaryKeyImpl(pkname, ch, opt);
            
            # add pk to table if the table already exists in the DB
            execSql(sql = pk.getCreateSql(getSqlName()));

            # set as primary key for the table
            return primaryKey = pk;
        }

        #! drops the primary key from the table
        /** @par Example:
            @code
$table.dropPrimaryKey();
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the primary key dropped from the table

            @note this method retrieves the primary key definition from the database if none has already been defined
         */
        AbstractPrimaryKey dropPrimaryKey(*reference sql) {
            l.lock();
            on_exit l.unlock();
            getPrimaryKeyUnlocked();
            if (primaryKey.empty())
                throw "PRIMARY-KEY-ERROR", sprintf("%s: has no primary key", name);

            # drop pk from table if the table already exists in the DB
            execSql(sql = primaryKey.getDropSql(getSqlName()));

            return remove primaryKey;
        }
        
        #! adds an index to the table; if the table already exists, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractIndex $ix = $table.addIndex("uk_mytable_name", True, "name", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param iname the name of the new index
            @param unique a flag to tell if the new index should be unique or not
            @param cols a single column name or a list of columns that make up the index
            @param opt a hash of options for the new index; each driver may implement it's own options; for common options, see @ref IndexOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractIndex object corresponding to the index created

            @throw INDEX-ERROR the table already has an index with the given name or invalid columns or options were passed
         */
        AbstractIndex addIndex(string iname, bool unique, softlist cols, *hash opt, *reference sql) {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            if (inDb)
                getIndexesUnlocked();

            if (indexes.hasKey(iname))
                throw "INDEX-ERROR", sprintf("%s: already has an index named %y with columns: %y", name, iname, indexes{iname}.columns.keys());

            if (!cols)
                throw "INDEX-ERROR", sprintf("%s: no column names passed to %s::addIndex()", name, self.className());

            hash ch;
            while (cols) {
                any v = shift cols;
                if (v.typeCode() != NT_STRING)
                    throw "INDEX-ERROR", sprintf("%s: %y argument passed as column name to %s::addIndex(); expecting \"string\" (value: %y)", name, v.type(), self.className(), v);
                if (!columns.hasKey(v))
                    throw "INDEX-ERROR", sprintf("%s: has no column named %y", name, v);
                ch{v} = columns{v};
            }

            # validate options
            hash ixopt = getIndexOptions();
            validateOptionsIntern("INDEX-ERROR", ixopt, \opt);

            # get the new index object
            AbstractIndex ix = addIndexImpl(iname, unique, ch, opt);
            
            # add index to table in the DB if the table already exists in the DB
            execSql(sql = ix.getCreateSql(getSqlName(), opt));

            # set as index for the table
            indexes.add(iname, ix);

            # return the new index
            return ix;
        }

        #! drops the given index from the table
        /** @par Example:
            @code
$table.dropIndex("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param iname the name of the index to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the index dropped from the table

            @note this method retrieves all current index definitions from the database if none have already been defined
         */
        AbstractIndex dropIndex(string iname, *reference sql) {
            l.lock();
            on_exit l.unlock();
            getIndexesUnlocked();
            if (!indexes.hasKey(iname))
                throw "INDEX-ERROR", sprintf("%s: has no index %y; valid indexes: %y", name, iname, indexes.keys());

            # drop index from table if the table already exists in the DB
            execSql(sql = indexes{iname}.getDropSql(getSqlName()));

            # remove from index structure and return removed index
            return indexes.take(iname);
        }

        #! adds a foreign constraint to the table; if the table already exists, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractForeignConstraint $fc = $table.addForeignConstraint("fk_mytable_other_table", ("name", "version"), "other_table", NOTHING, \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new foreign constraint
            @param cols a single column name or a list of columns in the local table that make up the foreign constraint
            @param table the name of the other table that the constraint targets
            @oaram tcols a single column name or a list of columns in the foreign table or @ref nothing meaning that the column names are the same as in the local table; if column names are given the same number of columns must be given in the local and foreign tables
            @param opt a hash of options for the new foreign constraint; each driver may implement it's own options; for common options, see @ref ForeignConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractForeignConstraint object corresponding to the foreign constraint created

            @throw FOREIGN-CONSTRAINT-ERROR the table already has an foreign constraint with the given name or invalid columns or options were passed
         */
        AbstractForeignConstraint addForeignConstraint(string cname, softlist cols, string table, *softlist tcols, *hash opt, *reference sql) {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            if (inDb)
                getForeignConstraintsUnlocked();

            if (foreignConstraints.hasKey(cname))
                throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y: already has a foreign constraint named %y with columns: %y", name, cname, foreignConstraints{cname}.columns.keys());

            if (!cols)
                throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y: no column names passed to %s::addForeignConstraint()", name, self.className());

            hash ch;
            while (cols) {
                any v = shift cols;
                if (v.typeCode() != NT_STRING)
                    throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y: %y argument passed as column name to %s::addForeignConstraint(); expecting \"string\" (value: %y)", name, v.type(), self.className(), v);
                if (!columns.hasKey(v))
                    throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y: has no column named %y", name, v);
                ch{v} = columns{v};
            }

            if (!tcols)
                tcols = ch.keys();

            # get target table description
            Table targ(ds, table);
            Columns targ_cols = targ.describe();
            hash tch;
            while (tcols) {
                any v = shift tcols;
                if (v.typeCode() != NT_STRING)
                    throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y target %y: %y argument passed as target column name to %s::addForeignConstraint(); expecting \"string\" (value: %y)", name, table, v.type(), self.className(), v);
                if (!targ_cols.hasKey(v))
                    throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y target %y: target table has no column named %y", name, table, v);
                tch{v} = targ_cols{v};
            }

            # validate options
            validateOptionsIntern("FOREIGN-CONSTRAINT-ERROR", getForeignConstraintOptions(), \opt);

            # get the new foreign constraint object
            AbstractForeignConstraint fc = addForeignConstraintImpl(cname, ch, table, tch, opt);
            
            # add foreign constraint to table in the DB if the table already exists in the DB
            execSql(sql = fc.getCreateSql(getSqlName()));

            # set as foreign constraint for the table
            foreignConstraints.add(cname, fc);

            # return the new foreign constraint
            return fc;
        }

        #! drops a foreign constraint from the table
        /** @par Example:
            @code
$table.dropForeignConstraint("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the foreign constraint to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the foreign constraint dropped from the table

            @note this method retrieves all current foreign constraint definitions from the database if none have already been defined
         */
        AbstractForeignConstraint dropForeignConstraint(string cname, *reference sql) {
            l.lock();
            on_exit l.unlock();
            getForeignConstraintsUnlocked();
            if (!foreignConstraints.hasKey(cname))
                throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%s: has no foreign constraint %y; valid foreign constraints: %y", name, cname, foreignConstraints.keys());

            # drop foreign constraint from table if the table already exists in the DB
            execSql(sql = foreignConstraints{cname}.getDropSql(getSqlName()));

            # remove from foreign constraint structure and return removed foreign constraint
            return foreignConstraints.take(cname);
        }

        #! drops a constraint from the table; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint
        /** @par Example:
            @code
$table.dropConstraint("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the constraint to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the constraint dropped from the table

            @note this method retrieves current constraint definitions from the database if not already loaded or defined
         */
        AbstractConstraint dropConstraint(string cname, *reference sql) {
            l.lock();
            on_exit l.unlock();
            getConstraintsUnlocked();
            
            AbstractConstraint c;

            code rmv;

            if (constraints.hasKey(cname)) {
                c = constraints{cname};
                rmv = sub () { constraints.take(cname); };
            }
            else {
                if (inDb) {
                    getPrimaryKeyUnlocked();
                    if (primaryKey.getName() == cname) {
                        c = primaryKey;
                        rmv = sub () { remove primaryKey; };
                    }
                    else {
                        getForeignConstraintsUnlocked();
                        if (foreignConstraints.hasKey(cname)) {
                            c = foreignConstraints{cname};
                            rmv = sub () { foreignConstraints.take(cname); };
                        }
                    }
                }
            }
            
            if (!c) {
                list cl = ();
                # get a list of all constraint names
                cl += constraints.keys();
                if (primaryKey)
                    cl += primaryKey.getName();
                if (foreignConstraints)
                    cl += foreignConstraints.keys();
                throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%s: has no constraint %y; valid constraints: %y", name, cname, cl);
            }

            # drop foreign constraint from table if the table already exists in the DB
            execSql(sql = c.getDropSql(getSqlName()));

            # remove from foreign constraint structure and return removed foreign constraint
            rmv();
            return c;
        }

        private validateOptionsIntern(string err, hash ropt, reference opt, *string tag) {
            if (!tag)
                tag = name;
            # check valid options and option value types
            foreach string k in (opt.keyIterator()) {
                if (!ropt.hasKey(k))
                    throw err, sprintf("%s: unknown option %y; valid options for %y: %y", tag, k, self.className(), ropt.keys());

                switch (ropt{k}) {
                    case Type::Int: {
                        if (!opt{k}.intp())
                            throw err, sprintf("%s: option %y has type %y, expecting \"int\" (value: %y)", tag, k, opt{k}.type(), opt{k});
                        if (opt{k}.type() != ropt{k})
                            opt{k} = opt{k}.toInt();
                        break;
                    }
                    case Type::Boolean: {
                        if (!opt{k}.intp())
                            throw err, sprintf("%s: option %y has type %y, expecting \"boolean\" (value: %y)", tag, k, opt{k}.type(), opt{k});
                        if (opt{k}.type() != ropt{k})
                            opt{k} = opt{k}.toBool();
                        break;
                    }
                    case Type::String: {
                        if (!opt{k}.strp())
                            throw err, sprintf("%s: option %y has type %y, expecting \"string\" (value: %y)", tag, k, opt{k}.type(), opt{k});
                        if (opt{k}.type() != ropt{k})
                            opt{k} = opt{k}.toString();
                        break;
                    }
                    # no validation for NOTHING
                    case NOTHING: break;

                    # throw an exception if the type is not supported
                    default: throw err, sprintf("option %y requires type %y which is not currently supported", k, ropt{k});
                }
            }
        }

        #! validates column options
        private validateColumnOptions(string cname, reference opt, bool nullable) {
            hash copt = getColumnOptions();

            # check valid options and option value types
            validateOptionsIntern("COLUMN-ERROR", copt, \opt, sprintf("%s.%s", name, cname));
            
            hash otm = getTypeMapImpl();

            if (!opt.native_type) {
                hash qtm = getQoreTypeMapImpl();
                opt.native_type = qtm{opt.qore_type};
                if (!opt.native_type)
                    throw "COLUMN-ERROR", sprintf("%s.%s: qore type %y cannot be mapped to a column type (valid values: %y)", name, cname, opt.qore_type, qtm.keys());
            }
            else if (!otm{opt.native_type})
                throw "COLUMN-ERROR", sprintf("%s.%s: unknown native_type %y (valid values: %y)", name, cname, opt.native_type, otm.keys());

            # get native type description
            hash th = otm{opt.native_type};

            # reset qore type from native type
            opt.qore_type = th.qore;

            if (exists opt.size) {
                if (!th.size)
                    throw "COLUMN-ERROR", sprintf("%s.%s: size %y given but type %y does not take a size attribute", name, cname, opt.size, opt.native_type);
                if (th.size_range && (opt.size < th.size_range[0] || opt.size > th.size_range[1]))
                    throw "COLUMN-ERROR", sprintf("%s.%s: size %y is not valid for type %y; must be between %d and %d inclusive", name, cname, opt.size, opt.native_type, th.size_range[0], th.size_range[1]);
            }
            else if (th.size == SZ_MAND)
                throw "COLUMN-ERROR", sprintf("%s.%s: type %y requires a size argument but none was supplied (options: %y)", name, cname, opt.native_type, opt);

            if (th.size == SZ_NUM) {
                opt.precision = opt.size;
                opt.size = 0;
                if (opt.scale) {
                    if (th.scale_range && (opt.scale < th.scale_range[0] || opt.scale > th.scale_range[1]))
                        throw "COLUMN-ERROR", sprintf("%s.%s: scale %y is not valid for type %y; must be between %d and %d inclusive", name, cname, opt.scale, opt.native_type, th.scale_range[0], th.scale_range[1]);
                }
            }
            else if (opt.scale) 
                throw "COLUMN-ERROR", sprintf("%s.%s: scale %y is not valid for type %y; it is not a numeric type", name, cname, opt.scale, opt.native_type);
            else
                opt.precision = opt.scale = 0;
            
            # check type of default value (must match column type)
            if (exists opt.default_value) {
                checkValue(cname, "default_value", \opt.default_value, th.qore);
                opt.default_value = getSqlValue(opt.default_value);
            }
        }

        #! drops a column from the table
        /** @par Example:
            @code
$table.dropColumn("notes_2");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the AbstractColumn object representing the column dropped from the table

            @throw COLUMN-ERROR the named column is not present in the table

            @note this method retrieves the table definition from the database if none has already been defined
         */
        AbstractColumn dropColumn(string cname, *reference sql) {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            if (!columns.hasKey(cname))
                throw "COLUMN-ERROR", sprintf("%s.%s: no such column (valid columns: %y)", name, cname, columns.keys());
            # drop column from table if the table already exists in the DB
            execSql(sql = columns{cname}.getDropSql(getSqlName()));
            return columns.take(cname);
        }

        #! inserts a row into the table; the transaction is committed if successful, if an error occurs, it is rolled back
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert
         */
        insert(hash row) {
            on_success ds.commit();
            on_error ds.rollback();

            insertNoCommit(row);
        }

        #! inserts a row into the table without any transaction management; a transaction will be in progress after this method is successfully executed
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert
         */
        insertNoCommit(hash row) {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            string sql = sprintf("insert into %s (", getSqlName());
            foreach string k in (row.keyIterator()) {
                if (!columns{k})
                    throw "COLUMN-ERROR", sprintf("%s.%s is not a valid column (valid columns: %y)", name, k, columns.keys());
            }
            sql += (foldl $1 + "," + $2, row.keyIterator());
            sql += ") values (";
            sql += (foldl $1 + "," + $2, (map "%v", row.keyIterator()));
            sql += ")";

            ds.vexec(sql, row.values());
        }

        private checkValue(string cname, string argname, reference val, string type) {
            if (val === NULL) {
                delete val;
                return;
            }
                
            switch (type) {
                case Type::Int: {
                    if (!val.intp())
                        throw "COLUMN-ERROR", sprintf("%s.%s: %s has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                    if (val.type() != type)
                        val = val.toInt();
                    break;
                }
                case Type::Float: {
                    if (!val.intp())
                        throw "COLUMN-ERROR", sprintf("%s.%s: %s has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                    if (val.type() != type)
                        val = val.toFloat();
                    break;
                }
                case Type::Number: {
                    if (!val.intp())
                        throw "COLUMN-ERROR", sprintf("%s.%s: %s has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                    if (val.type() != type)
                        val = number(val);
                    break;
                }
                case Type::Boolean: {
                    if (!val.intp())
                        throw "COLUMN-ERROR", sprintf("%s.%s: %s has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                    if (val.type() != type)
                        val = val.toBool();
                    break;
                }
                case Type::String: {
                    if (!val.strp())
                        throw "COLUMN-ERROR", sprintf("%s.%s: %s has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                    if (val.type() != type)
                        val = val.toString();
                    break;
                }
              default: {
                  if (val.type() != type)
                      throw "COLUMN-ERROR", sprintf("%s.%s: %s value for has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                  break;
                }
            }
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument
        /** @par Example:
            @code
my string $str = $table.getSqlValue($date);
            @endcode

            @param v the value to convert to an SQL value

            @return a string representing the value usable in SQL strings for the given database driver
         */
        string getSqlValue(any v) {
            *string str = getSqlValueImpl(v);
            if (!str)
                throw "VALUE-ERROR", sprintf("class %s cannot convert type %y to an SQL string (value: %y)", self.className(), v.type(), v);

            return str;
        }
        
        #! returns the name of the table
        string getName() {
            return name;
        }

        #! gets the underlying AbstractDatasource
        AbstractDatasource getDatasource() {
            return ds;
        }

        #! returns the database driver name 
        string getDriverName() {
            return ds.getDriverName();
        }

        #! reads in all attributes of the table from the database
        /** @par Example:
            @code
$table.cache();
            @endcode
        */
        cache() {
            l.lock();
            on_exit l.unlock();
            cacheUnlocked();
        }

        # returns the table description hash as acquired in the constructor
        /** @par Example:
            @code
my hash $h = $table.describe();
            @endcode

            @return a hash of column names assigned to AbstractColumn objects

        */
        Columns describe() {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            return columns;
        }

        #! returns an object of class AbstractPrimaryKey describing the primary key of the table
        /** If there is no primary key then the object returned will be empty (see @ref AbstractPrimaryKey::empty())

            @par Example:
            @code
            @endcode

            @return an object of class AbstractPrimaryKey describing the primary key of the table
        */
        *AbstractPrimaryKey getPrimaryKey() {
            l.lock();
            on_exit l.unlock();
            getPrimaryKeyUnlocked();
            return primaryKey;
        }

        #! returns an object of class Indexes describing the indexes on the table
        /** If there are no indexes on the table then the object returned will be empty (see @ref Indexes::empty())

            @par Example:
            @code
my Indexes $ix = $table.getIndexes();
            @endcode

            @return an object of class Indexes describing the indexes on the table
        */
        Indexes getIndexes() {
            l.lock();
            on_exit l.unlock();
            getIndexesUnlocked();
            return indexes;
        }

        #! returns a ForeignConstraints object describing the foreign constraints that the table has on other tables
        ForeignConstraints getForeignConstraints() {
            l.lock();
            on_exit l.unlock();
            getForeignConstraintsUnlocked();
            return foreignConstraints;
        }

        #! returns a Constraints object describing the non-foreign constraints on the table
        Constraints getConstraints() {
            l.lock();
            on_exit l.unlock();
            getConstraintsUnlocked();
            return constraints;
        }

        #! returns an object of class Triggers describing the triggers on the table
        /** If there are no triggers on the table then the object returned will be empty (see @ref Triggers::empty())

            @par Example:
            @code
my Triggers $trig = $table.getTriggers();
            @endcode

            @return an object of class Triggers describing the triggers on the table
        */
        Triggers getTriggers() {
            l.lock();
            on_exit l.unlock();
            getTriggersUnlocked();
            return triggers;
        }

        #! returns an SQL string that could be used to create the table and all known properties of the table
        /** @par Example:
            @code
printf("%s\n", $table.getCreateSqlString());
            @endcode

            @param opt a hash of options for the SQL creation string

            @return an SQL string that could be used to create the table and all known properties of the table
        */
        string getCreateSqlString(*hash opt) {
            l.lock();
            on_exit l.unlock();
            cacheUnlocked();
            return getCreateSqlStringImpl(getCreateSqlUnlocked(opt));
        }

        #! returns a list of SQL strings that could be used to create the table and all known properties of the table
        /** @par Example:
            @code
map printf("$1;\n", $1), $table.getCreateSql();
            @endcode

            @param opt a hash of options for the table, index, and constraint creation strings
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create the table and all known properties of the table
        */
        list getCreateSql(*hash opt, bool cache = True) {
            l.lock();
            on_exit l.unlock();
            return getCreateSqlUnlocked(opt, cache);
        }

        #! returns an SQL string that could be used to create the basic table structure without indexes and constraints 
        /** @par Example:
            @code
my string $sql = $table.getCreateTableSql();
            @endcode

            @param opt a hash of options for the table creation string

            @return an SQL string that could be used to create the basic table structure without indexes and constraints 
        */
        string getCreateTableSql(*hash opt) {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            return getCreateTableSqlImpl(opt);
        }

        #! returns a list of SQL strings that could be used to create indexes on the table or @ref nothing if there are no indexes on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateIndexesSql();
            @endcode

            @param opt a hash of options for the index creation string
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create indexes on the table or @ref nothing if there are no indexes on the table
        */
        *list getCreateIndexesSql(*hash opt, bool cache = True) {
            l.lock();
            on_exit l.unlock();
            if (cache)
                getIndexesUnlocked();
            if (!indexes)
                return;
            return getCreateIndexesSqlImpl(opt);
        }

        #! returns an SQL string that could be used to create the primary key on the table
        /** @par Example:
            @code
my *string $sql = $table.getCreatePrimaryKeySql();
            @endcode

            @param opt a hash of options for the primary key creation string
            @param cache read in data from the database for uncached properties of the table

            @return an SQL string that could be used to create the primary key on the table or @ref nothing if there is no primary key on the table
        */
        *string getCreatePrimaryKeySql(*hash opt, bool cache = True) {
            l.lock();
            on_exit l.unlock();
            if (cache)
                getPrimaryKeyUnlocked();
            if (!primaryKey)
                return;
            return getCreatePrimaryKeySqlImpl(opt);
        }

        #! returns a list of SQL strings that could be used to create foreign constraints on the table or @ref nothing if there are no foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateForeignConstraintsSql();
            @endcode

            @param opt a hash of options for the foreign constraint creation string
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create foreign constraints on the table or @ref nothing if there are no foreign constraints on the table
        */
        *list getCreateForeignConstraintsSql(*hash opt, bool cache = True) {
            l.lock();
            on_exit l.unlock();
            if (cache)
                getForeignConstraintsUnlocked();
            if (!foreignConstraints)
                return;
            return getCreateForeignConstraintsSqlImpl(opt);
        }

        #! returns a list of SQL strings that could be used to create non-foreign constraints on the table or @ref nothing if there are no non-foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateConstraintsSql();
            @endcode

            @param opt a hash of options for the non-foreign constraint creation string
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create non-foreign constraints on the table or @ref nothing if there are no non-foreign constraints on the table

            @see getCreateForeignConstraintsSql()
        */
        *list getCreateConstraintsSql(*hash opt, bool cache = True) {
            l.lock();
            on_exit l.unlock();
            if (cache)
                getConstraintsUnlocked();
            if (!constraints)
                return;
            return getCreateConstraintsSqlImpl(opt);
        }

        #! returns a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or @ref nothing if there are none
        /** @par Example:
            @code
my *list $l = $table.getCreateMiscSql();
            @endcode

            @param opt a hash of options for the SQL creation string
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or @ref nothing if there are none
        */
        *list getCreateMiscSql(*hash opt, bool cache = True) {
            l.lock();
            on_exit l.unlock();
            return getCreateMiscSqlImpl(opt, cache);
        }

        #! returns a list of SQL strings that could be used to create triggers on the table or @ref nothing if there are no triggers on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateTriggersSql();
            @endcode

            @param opt a hash of options for the trigger creation strings
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create triggers on the table or @ref nothing if there are no triggers on the table

            @see getCreateTriggersSql()
        */
        *list getCreateTriggersSql(*hash opt, bool cache = True) {
            l.lock();
            on_exit l.unlock();
            if (cache)
                getTriggersUnlocked();
            if (!triggers)
                return;
            return getCreateTriggersSqlImpl(opt);
        }

        #! finds a row in the table with the given primary key value; if no row matches the primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *hash $row = $table.find($id);
            @endcode

            @throw PRIMARY-KEY-ERROR the table has no primary key or the primary key has more than one column
         */
        *hash find(any id) {
            string cname;
            {
                l.lock();
                on_exit l.unlock();
                getPrimaryKeyUnlocked();
                if (!primaryKey)
                    throw "PRIMARY-KEY-ERROR", sprintf("table %s has no primary key", name);
                if (primaryKey.size() > 1)
                    throw "PRIMARY-KEY-ERROR", sprintf("table %s has a primary key with %d columns (%y)", name, primaryKey.size(), primaryKey.keys());

                cname = primaryKey.firstKey();
            }

            return ds.selectRow("select * from %s where %s = %v", getSqlName(), cname, id);
        }

        #! finds rows in the table with the given primary key values; if no row matches any primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *list $rows = $table.find($list);
            @endcode

            @param ids the list of primary key IDs to find; if the list is empty then @ref nothing is returned

            @return a list of hashes of rows matching the primary key IDs passed or @ref nothing if no row matches any primary key value passed

            @throw PRIMARY-KEY-ERROR the table has no primary key or the primary key has more than one column
            */
        *list find(list ids) {
            string cname;
            {
                l.lock();
                on_exit l.unlock();
                getPrimaryKeyUnlocked();
                if (!primaryKey)
                    throw "PRIMARY-KEY-ERROR", sprintf("table %s has no primary key", name);
                if (primaryKey.size() > 1)
                    throw "PRIMARY-KEY-ERROR", sprintf("table %s has a primary key with %d columns (%y)", name, primaryKey.size(), primaryKey.keys());
                if (!ids)
                    return;

                cname = primaryKey.firstKey();
            }

            string sql = sprintf("select * from %s where %s in (%s)", getSqlName(), cname, (foldl $1 + "," + $2, (map "%v", ids)));

            return ds.vselectRows(sql, ids);
        }

        private list getCreateSqlUnlocked(*hash opt, bool cache = True) {
            list l += getCreateTableSql(opt);
            *list tl = getCreateIndexesSql(opt, cache); if (tl) l += tl;
            *string sql = getCreatePrimaryKeySql(opt, cache); if (sql) l += sql;
            tl = getCreateForeignConstraintsSql(opt, cache); if (tl) l += tl;
            tl = getCreateConstraintsSql(opt, cache); if (tl) l += tl;
            tl = getCreateMiscSql(opt, cache); if (tl) l += tl;
            tl = getCreateTriggersSql(opt, cache); if (tl) l += tl;

            return l;
        }

        private cacheUnlocked() {
            getColumnsUnlocked();
            getPrimaryKeyUnlocked();
            getIndexesUnlocked();
            getForeignConstraintsUnlocked();
            getConstraintsUnlocked();
            getTriggersUnlocked();
        }

        private checkCreateOptions(*hash nopts, *hash rh) {
            foreach string k in (nopts.keyIterator()) {
                if (!rh{k})
                    throw "TABLE-CREATION-ERROR", sprintf("creation option %y is not supported by class %y; possible options: %y", k, self.className(), rh.keys());
                if (rh{k} && nopts{k}.type() != rh{k})
                    throw "TABLE-CREATION-ERROR", sprintf("value passed to table creation option %y is type %y (%y); expecting %y", k, nopts{k}.type(), nopts{k}, rh{k});
            }
        }

        #! returns the name of the table to be used in SQL (with a possible qualifiers for schema, etc)
        string getSqlName() {
            return name;
        }

        private checkCreateIndexOptions(*hash nopts, *hash rh) {
            foreach string k in (nopts.keyIterator()) {
                if (!rh{k})
                    throw "INDEX-CREATION-ERROR", sprintf("index creation option %y is not supported by class %y; possible options: %y", k, self.className(), rh.keys());
                if (rh{k} && nopts{k}.type() != rh{k})
                    throw "INDEX-CREATION-ERROR", sprintf("value passed to index creation option %y is type %y (%y); expecting %y", k, nopts{k}.type(), nopts{k}, rh{k});
            }
        }

        private checkCreatePrimaryKeyOptions(*hash nopts, *hash rh) {
            foreach string k in (nopts.keyIterator()) {
                if (!rh{k})
                    throw "PK-CREATION-ERROR", sprintf("primary key creation option %y is not supported by class %y; possible options: %y", k, self.className(), rh.keys());
                if (rh{k} && nopts{k}.type() != rh{k})
                    throw "PK-CREATION-ERROR", sprintf("value passed to primary key creation option %y is type %y (%y); expecting %y", k, nopts{k}.type(), nopts{k}, rh{k});
            }
        }

        private checkCreateConstraintOptions(*hash nopts, *hash rh) {
            foreach string k in (nopts.keyIterator()) {
                if (!rh{k})
                    throw "CONSTRAINT-CREATION-ERROR", sprintf("constraint creation option %y is not supported by class %y; possible options: %y", k, self.className(), rh.keys());
                if (rh{k} && nopts{k}.type() != rh{k})
                    throw "CONSTRAINT-CREATION-ERROR", sprintf("value passed to constraint creation option %y is type %y (%y); expecting %y", k, nopts{k}.type(), nopts{k}, rh{k});
            }
        }

        private checkCreateMiscOptions(*hash nopts, *hash rh) {
            foreach string k in (nopts.keyIterator()) {
                if (!rh{k})
                    throw "SQL-CREATION-ERROR", sprintf("SQL creation option %y is not supported by class %y; possible options: %y", k, self.className(), rh.keys());
                if (rh{k} && nopts{k}.type() != rh{k})
                    throw "SQL-CREATION-ERROR", sprintf("value passed to SQL creation option %y is type %y (%y); expecting %y", k, nopts{k}.type(), nopts{k}, rh{k});
            }
        }

        private checkCreateTriggerOptions(*hash nopts, *hash rh) {
            foreach string k in (nopts.keyIterator()) {
                if (!rh{k})
                    throw "TRIGGER-CREATION-ERROR", sprintf("trigger creation option %y is not supported by class %y; possible options: %y", k, self.className(), rh.keys());
                if (rh{k} && nopts{k}.type() != rh{k})
                    throw "TRIGGER-CREATION-ERROR", sprintf("value passed to trigger creation option %y is type %y (%y); expecting %y", k, nopts{k}.type(), nopts{k}, rh{k});
            }
        }

        private checkOptions(*hash nopts, hash rh) {
            foreach string k in (nopts.keyIterator()) {
                if (!rh{k})
                    throw "TABLE-ERROR", sprintf("option %y is not supported by class %y; possible options: %y", k, self.className(), rh.keys());
            }
            if (nopts."native-case")
                native_case = True;
        }

        static AbstractTable getTable(AbstractDatasource nds, string nname, *hash opts) {
            string drv = nds.getDriverName();

            # generate module and module namespace name
            string mn = drv[0].upr() + drv.substr(1) + "SqlUtil";

            # try to load module
            try {
                load_module(mn);                
            }
            catch (hash ex) {
                throw "TABLE-DRIVER-ERROR", sprintf("%s: no support for driver %y yet: %s: %s", get_ex_pos(ex), drv, ex.err, ex.desc);
            }

            # try to get AbstractTable object
            try {
                return call_function(mn + "::" + "get_table", nds, nname, opts);
            }
            catch (hash ex) {
                throw "TABLE-DRIVER-ERROR", sprintf("%s: error retrieving AbstractTable object for driver %y: %s: %s", get_ex_pos(ex), drv, ex.err, ex.desc);
            }
        }

        static AbstractTable getTable(string dsstr, string nname, *hash opts) {
            Datasource nds(dsstr);
            return AbstractTable::getTable(nds, nname, opts);
        }

        static AbstractTable getTable(hash dsh, string nname, *hash opts) {
            Datasource nds(dsh);
            return AbstractTable::getTable(nds, nname, opts);
        }

        private getColumnsUnlocked() {
            if (columns)
                return;
            columns = describeImpl();
            inDb = True;
        }

        private getPrimaryKeyUnlocked() {
            if (primaryKey)
                return;
            getColumnsUnlocked();
            primaryKey = getPrimaryKeyImpl();
            inDb = True;
        }

        private getIndexesUnlocked() {
            if (indexes)
                return;
            getColumnsUnlocked();
            indexes = getIndexesImpl();
            inDb = True;
        }

        private getForeignConstraintsUnlocked() {
            if (foreignConstraints)
                return;
            getColumnsUnlocked();
            foreignConstraints = getForeignConstraintsImpl();
            inDb = True;
        }

        private getConstraintsUnlocked() {
            if (constraints)
                return;
            getColumnsUnlocked();
            constraints = getConstraintsImpl();            
            inDb = True;
        }

        private getTriggersUnlocked() {
            if (triggers)
                return;
            triggers = getTriggersImpl();
            inDb = True;
        }

        #! override in subclasses to return driver-specific options
        private hash getColumnOptions() {
            return ColumnOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getIndexOptions() {
            return IndexOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getPrimaryKeyOptions() {
            return PrimaryKeyOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getForeignConstraintOptions() {
            return ForeignConstraintOptions;
        }

        private abstract Columns describeImpl();
        private abstract *AbstractPrimaryKey getPrimaryKeyImpl();
        private abstract Indexes getIndexesImpl();
        private abstract ForeignConstraints getForeignConstraintsImpl();
        private abstract Constraints getConstraintsImpl();
        private abstract Triggers getTriggersImpl();

        private abstract string getCreateTableSqlImpl(*hash opt);
        private abstract *list getCreateIndexesSqlImpl(*hash opt);
        private abstract *string getCreatePrimaryKeySqlImpl(*hash opt);
        private abstract *list getCreateForeignConstraintsSqlImpl(*hash opt);
        private abstract *list getCreateConstraintsSqlImpl(*hash opt);
        private abstract *list getCreateMiscSqlImpl(*hash opt, bool cache);
        private abstract *list getCreateTriggersSqlImpl(*hash opt);
        private abstract string getCreateSqlStringImpl(list l);

        private abstract AbstractColumn addColumnImpl(string cname, hash opt, bool nullable = True);
        private abstract AbstractPrimaryKey addPrimaryKeyImpl(string cname, hash ch, *hash opt);
        private abstract AbstractIndex addIndexImpl(string iname, bool enabled, hash ch, *hash opt);
        private abstract AbstractForeignConstraint addForeignConstraintImpl(string cname, hash ch, string table, hash tch, *hash opt);

        #! returns the qore type -> column type map
        private abstract hash getQoreTypeMapImpl();

        #! returns the type name -> type description hash
        private abstract hash getTypeMapImpl();

        #! returns a string for use in SQL queries representing the DB-specific value of the argument; returns @ref nothing if the type cannot be converted to an SQL string
        private abstract *string getSqlValueImpl(any v);
    }

/*
    public class Sqlite3Table inherits AbstractTable {

        public {
            const Sqlite3TypeMap = (
                "INTEGER": ("qore": "integer",),
                "NUMERIC": ("qore": "number",),
                "TEXT": ("qore": "string",),
                "BLOB": ("qore": "binary",),
                "NONE": ("qore": "any",),
                "REAL": ("qore": "float",),
                );

            const QoreTypeMap = (
                "integer": "INTEGER",
                "float": "NUMBER",
                "number": "NUMBER",
                "string": "VARCHAR2",
                #"date": "TIMESTAMP",
                "binary": "BLOB",
                );
        }

        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
        }

        private hash describeImpl() {
            hash rv;
            
            # NOTE: sqlite3's pragmas cannot use %v binding
            
            # table info - PK is part of the table description
            hash tableInfo = ds.select("pragma table_info(%s)", name);
            context(tableInfo) {
                rv.columns{%name} = (
                        "native_type"   : %type,
                        "qore_type"     : Sqlite3TypeMap{%type}.qore,
                        "size"          : NOTHING,
                        "nullable"      : %notnull == 1 ? NOTHING : "YES",
                    );
                if (%pk)
                    rv.primary_key{%name} = True;
            }
            
            # get index description
            hash indexes = ds.select("pragma index_list(%s)", name);
            context(indexes) {
                rv.indexes{%name}.unique = %unique == 0 ? False : True;
                hash indexColumns = ds.select("pragma index_info(%s)", %name);
                string columnName = %name;
                context (indexColumns) {
                    rv.indexes{columnName}.columns{%name} = True;
                }
            }
            
            # TODO/FIXME: FKs
            
            return rv;
        }
    }
*/
}

