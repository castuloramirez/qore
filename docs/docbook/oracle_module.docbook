<?xml version="1.0" encoding="UTF-8" ?>

  <sect1 id="oracle_Module">
    <title>oracle Module</title>

    <para>The oracle module provides an Oracle driver to Qore's DBI system, allowing Qore programs to take access Oracle databases through the <link linkend="Datasource_Class">Datasource</link> and <link linkend="DatasourcePool_Class">DatasourcePool</link> classes.</para>

    <para>Example of creating an Oracle Datasource:</para>

    <programlisting>$db = new Datasource(SQL::DSOracle, $user, $pass, $db, $charset);</programlisting>

    <para>This driver supports the following <link linkend="DBI_Capability_Constants">DBI capabilities</link>: <code>DBI_CAP_TRANSACTION_MANAGEMENT, DBI_CAP_STORED_PROCEDURES, DBI_CAP_CHARSET_SUPPORT, DBI_CAP_LOB_SUPPORT, DBI_CAP_BIND_BY_VALUE, DBI_CAP_BIND_BY_PLACEHOLDER</code>.</para>

    <para>Binding by value is supported, and binding by placeholder is required to retrieve values from a procedure or function call.  The oracle driver assumes that any placeholder values are string values unless a placeholder buffer specification is passed in the argument position corresponding to the placeholder specification in the string.  For placeholder buffer spcification values, see <link linkend="oracle_placeholder_specifications">Oracle Type Mappings for Placeholder Specifications</link>.</para>

    <para>Oracle TIMESTAMP data supports time resolution to the microsecond, however Qore's date/time value only supports a millisecond resolution.  Any Oracle TIMESTAMP values are rounded to millisecond resolution when converted to Qore data types.</para>

    <para>The <link linkend="Qore::SQL::Datasource::getServerVersion">Datasource::getServerVersion()</link> and <link linkend="Qore::SQL::Datasource::getClientVersion">Datasource::getClientVersion()</link> methods are implemented for this driver.  <link linkend="Qore::SQL::Datasource::getServerVersion">Datasource::getServerVersion()</link> returns a string giving server information similar to the following:</para>

    <programlisting>Oracle Database 10g Release 10.2.0.1.0 - 64bit Production</programlisting>

    <para>The  <link linkend="Qore::SQL::Datasource::getClientVersion">Datasource::getClientVersion()</link> returns a hash giving version information in the following keys: <code>major, minor, update, patch, port_update</code>.</para>

    <para>PL/SQL code and stored procedure and function execution is supported; the following is an example of a stored procedure call:</para>

    <programlisting>$result = $db.exec(&quot;begin h3g_psft_order_import.insert_h3g_psft_customers(%v, %v, :status_code, :error_code, :error_description); end;&quot;, &quot;Customer Name&quot;, &quot;Customer-ID&quot;, Type::Int, Type::Int);
printf(&quot;%N\n&quot;, $result);</programlisting>

    <para>Resulting in:</para>

    <programlisting>hash: (3 members)
  status_code : 0
  error_code : 0
  error_description : &lt;NULL&gt;</programlisting>

    <para>The following table describes how Oracle data types are converted to Qore data types by the oracle driver.  All Oracle types not listed are converted to a string.</para>

    <table>
      <title>Oracle to Qore Type Mappings</title>
      <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Oracle Column Type</para></entry>
	    <entry><para>Qore Type</para></entry>
	    <entry><para>Notes</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><code>REAL</code>, <code>FLOAT</code>, <code>DOUBLE PRECISION</code>, <code>BINARY_FLOAT</code>, <code>BINARY_DOUBLE</code></para></entry>
	    <entry><para><link linkend="Float"><code>Type::Float</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>DATE</code></para></entry>
	    <entry><para><link linkend="Date"><code>Type::Date</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>TIMESTAMP</code></para></entry>
	    <entry><para><link linkend="Date"><code>Type::Date</code></link> (absolute)</para></entry>
	    <entry><para>microseconds are converted to milliseconds, some precision may be lost</para></entry>
	  </row>
	  <row>
	    <entry><para><code>TIMESTAMP WITH TIME ZONE</code></para></entry>
	    <entry><para><link linkend="Date"><code>Type::Date</code></link> (absolute)</para></entry>
	    <entry><para>time zone information is ignored and as microseconds are converted to milliseconds, some precision may be lost</para></entry>
	  </row>
	  <row>
	    <entry><para><code>TIMESTAMP WITH LOCAL TIME ZONE</code></para></entry>
	    <entry><para><link linkend="Date"><code>Type::Date</code></link> (absolute)</para></entry>
	    <entry><para>time zone information is ignored and as microseconds are converted to milliseconds, some precision may be lost</para></entry>
	  </row>
	  <row>
	    <entry><para><code>INTERVAL YEAR TO MONTH</code></para></entry>
	    <entry><para><link linkend="Date"><code>Type::Date</code></link> (relative)</para></entry>
	    <entry><para>direct conversion to a relative date</para></entry>
	  </row>
	  <row>
	    <entry><para><code>INTERVAL DAY TO SECOND</code></para></entry>
	    <entry><para><link linkend="Date"><code>Type::Date</code></link> (relative)</para></entry>
	    <entry><para>direct conversion to a relative date</para></entry>
	  </row>
	  <row>
	    <entry><para><code>SMALLINT</code>, <code>INTEGER</code></para></entry>
	    <entry><para><link linkend="Integer"><code>Type::Int</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>NUMBER</code>, <code>NUMERIC</code>, <code>DECIMAL</code></para></entry>
	    <entry><para><link linkend="String"><code>Type::String</code></link></para></entry>
	    <entry><para>conversion to a string to avoid loss of precision</para></entry>
	  </row>
	  <row>
	    <entry><para><code>CLOB</code></para></entry>
	    <entry><para><link linkend="String"><code>Type::String</code></link></para></entry>
	    <entry><para>the LOB handle is used to read the entire CLOB content into a string</para></entry>
	  </row>
	  <row>
	    <entry><para><code>RAW</code>, <code>LONG RAW</code></para></entry>
	    <entry><para><link linkend="Binary"><code>Type::Binary</code></link></para></entry>
	    <entry><para>direct conversion</para></entry>
	  </row>
	  <row>
	    <entry><para><code>BLOB</code></para></entry>
	    <entry><para><link linkend="Binary"><code>Type::Binary</code></link></para></entry>
	    <entry><para>the LOB handle is used to read the entire BLOB content into a binary object</para></entry>
	  </row>
	  <row>
	    <entry><para><code>CURSOR</code> (result set)</para></entry>
	    <entry><para><link linkend="Hashes"><code>Type::Hash</code></link></para></entry>
	    <entry><para>the result set is returned as a hash of lists</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <table>
      <title>Qore to Oracle Type Mappings for Binding by Value</title>
      <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Argument</para></entry>
	    <entry><para>OCI Type</para></entry>
	    <entry><para>Description</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><link linkend="Binary"><code>Type::Binary</code></link></para></entry>
	    <entry><para><code>SQLT_BIN</code></para></entry>
	    <entry><para>For use with <code>BLOB</code> columns, for example.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="String"><code>Type::String</code></link></para></entry>
	    <entry><para><code>SQLT_STR</code></para></entry>
	    <entry><para>For use with string data, <code>VARCHAR</code>, <code>CHAR</code>, <code>CLOB</code> columns, etc</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Integer"><code>Type::Int</code></link></para></entry>
	    <entry><para><code>SQLT_INT</code> or <code>SQLT_STR</code></para></entry>
	    <entry><para>if the int &gt; 32-bits = SQLT_STR, &lt;= 32-bit int = SQLT_INT</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Boolean"><code>Type::Boolean</code></link></para></entry>
	    <entry><para><code>SQLT_INT</code></para></entry>
	    <entry><para>True is bound as 1, False as 0</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Float"><code>Type::Float</code></link></para></entry>
	    <entry><para><code>SQLT_BDOUBLE</code></para></entry>
	    <entry><para>For use with <code>FLOAT</code>, <code>BINARY_FLOAT</code>, <code>BINARY_DOUBLE</code> columns, etc</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Date"><code>Type::Date</code></link></para></entry>
	    <entry><para><code>SQLT_TIMESTAMP</code></para></entry>
	    <entry><para>For use with <code>DATE</code>, <code>TIMESTAMP</code>, etc column</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <table id="oracle_placeholder_specifications">
      <title>Qore to Oracle Type Mappings for Placeholder Specifications in Datasource::exec()</title>
      <tgroup cols='3' align='left' colsep='1' rowsep='1'>
	<thead>
	  <row>
	    <entry><para>Argument</para></entry>
	    <entry><para>OCI Type</para></entry>
	    <entry><para>Description</para></entry>
	  </row>
	</thead>
	<tbody>
	  <row>
	    <entry><para><link linkend="Binary"><code>Type::Binary</code></link></para></entry>
	    <entry><para><code>SQLT_BIN</code></para></entry>
	    <entry><para>For retrieving <code>RAW</code> data up to 65531 bytes in size.</para></entry>
	  </row>
	  <row>
	    <entry><para><code>SQL::BLOB</code></para></entry>
	    <entry><para><code>SQLT_BLOB</code></para></entry>
	    <entry><para>For retrieving <code>BLOB</code> data.  The LOB handle is used to read the entire BLOB content into a binary object.</para></entry>
	  </row>
	  <row>
	    <entry><para><code>SQL::CLOB</code></para></entry>
	    <entry><para><code>SQLT_CLOB</code></para></entry>
	    <entry><para>For retrieving <code>CLOB</code> data.  The LOB handle is used to read the entire CLOB content into a Qore string.</para></entry>
	  </row>
	  <row>
	    <entry><para><code>SQL::VARCHAR</code></para></entry>
	    <entry><para><code>SQLT_STR</code></para></entry>
	    <entry><para>For retrieving character data (<code>VARCHAR</code>, etc).  To specify a buffer size larger than 512 bytes, simply use the size in bytes as the argument.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Integer"><code>Type::Int</code></link></para></entry>
	    <entry><para><code>SQLT_INT</code></para></entry>
	    <entry><para>For retrieving integer numeric data up to 32 bits (for larger numbers or for non-integer numbers use <code>SQL::VARCHAR</code> or <link linkend="Float"><code>Type::Float</code></link>.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Float"><code>Type::Float</code></link></para></entry>
	    <entry><para><code>SQLT_BDOUBLE</code></para></entry>
	    <entry><para>For retrieving data in 64-bit floating point format.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Date"><code>Type::Date</code></link></para></entry>
	    <entry><para><code>SQLT_TIMESTAMP</code></para></entry>
	    <entry><para>For retrieving dates and times.</para></entry>
	  </row>
	  <row>
	    <entry><para><link linkend="Hashes"><code>Type::Hash</code></link></para></entry>
	    <entry><para><code>SQLT_RSET</code></para></entry>
	    <entry><para>For retrieving result sets from a stored procedure that returns a cursor.</para></entry>
	  </row>
	</tbody>
      </tgroup>
    </table>

    <note><para>There seems to be a bug in Oracle 9i and earlier in the streaming OCILobRead() function, where the LOB buffer must be at least twice as big as the LOB data to be read.  This bug does not affect versions of the Qore oracle module linked with Oracle 10g libraries.</para></note>

  </sect1>
