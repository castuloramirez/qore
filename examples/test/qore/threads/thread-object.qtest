#!/usr/bin/env qore 

%require-types
%enable-all-warnings
%new-style

%requires UnitTest

%exec-class thread_object_test

const opts = 
    ( "help"       : "h,help",
      "verbose"    : "v,verbose" );

class thread_object_test {
    private {
        int threads;
        int iters;
    }
    constructor() {
        my UnitTest t();
        process_command_line();
        new CounterTest(threads, iters, t);
        new QueueTest(threads, iters, t);
        new ThreadTest(threads, iters, t);
    }

    usage() {
        printf("usage: %s -[options] [iterations [threads]]
  -h,--help           this help text
  -v,--verbose        more information
", basename(ENV."_"));
        exit();
    }

    process_command_line() {
        GetOpt g(opts);
        any o = g.parse(\ARGV);
        
        if (exists o."_ERRORS_") {
            printf("%s\n", o."_ERRORS_"[0]);
            exit(1);
        }
        
        if (o.help)
            usage();

        iters = int(shift ARGV);
        if (!iters)
            iters = 2000;
        threads = int(shift ARGV);
        if (!threads)
            threads = 5;
    }
}

class CounterTest {
    private {
        int threads;
        int iters;
        any obj;
        Counter c;
    }
    constructor(int nthreads, int niters, UnitTest t) {
        threads = nthreads;
        iters = niters;
        obj.key.500.hello = 0;

        c = new Counter();
        do_threads();
        c.waitForZero();
        t.ok(!obj.key.500.hello, "counter");
    }

    private do_threads() {
        while (threads--) {
            c.inc();
            background add();
            c.inc();
            background subtract();
        }
    }

    private add() {
        for (int i = 0; i < iters; i++)
            obj.key.500.hello++;
        c.dec();
    }

    private subtract() {
        for (int i = 0; i < iters; i++)
            obj.key.500.hello--;
        c.dec();
    }
}

class QueueTest {
    private {
        Queue q;
        Counter x;
    }
    constructor(int threads, int iters, UnitTest t) {
        q = new Queue();
        x = new Counter();
        
        for (int i; i < threads; i++) {
            x.inc();
            background qt(threads, iters);
        }
        int c = threads * iters;
        while (c--)
            if (rand() % 2)
                q.pop();
            else
                q.get();

        x.waitForZero();
        t.ok(!q.size(), "queue");
    }

    private qt(int threads, int iters) {
        for (int i; i < iters; i++)
            q.push(sprintf("tid-%d-%d", gettid(), i));
        x.dec();
    }
}

class ThreadTest inherits Mutex {
    private {
        hash data;
        int threads;
        int iters;

        RWLock drw;
        Gate g;
        Counter c;

        hash gdata;
        hash rwdata;
    }
    constructor(int nthreads, int niters, UnitTest t) {
        threads = nthreads;
        iters = niters;
        drw = new RWLock();
        g   = new Gate();
        c   = new Counter();
        while (threads) {
            c.inc();
            background worker();
            threads--;
        }
        c.waitForZero();
        t.ok(True, "thread object tests");
    }
    hash getData(list l) {
        hash rv;
        lock();
        foreach string key in (l)
            rv{key} = data{key};
        unlock();
        return rv;
    }
    setData(hash h) {
        lock();
        foreach string key in (keys h)
            data{key} = h{key};
        unlock();
    }
    hash getRWData(list l) {
        hash rv;
        drw.readLock();
        foreach string key in (l)
            rv{key} = rwdata{key};
        drw.readUnlock();
        return rv;
    }
    setRWData(hash h) {
        drw.writeLock();
        foreach string key in (keys h)
            rwdata{key} = h{key};
        drw.writeUnlock();
    }
    hash getGateData(list l) {
        hash rv;
        g.enter();
        foreach string key in (l)
            rv{key} = gdata{key};
        g.exit();
        return rv;
    }
    setGateData(hash h) {
        g.enter();
        foreach string key in (keys h)
            gdata{key} = h{key};
        g.exit();
    }
    worker() {
        for (int i = 0; i < iters; i++) {
            #if (!(i % 1000))
            #    printf("TID %3d: %d/%d\n", gettid(), i, iters);
            int c = rand() % 6;
            string key1 = sprintf("key%d", rand() % 10);
            string key2 = sprintf("key%d", (rand() % 10) + 10);
            string key3 = sprintf("key%d", rand() % 20);
            if (!c) {
                hash h.key1 = rand() % 10;
                h.key2 = rand() % 10;
                setData(h);
                continue;
            }
            if (c == 1) {
                getData((key1, key2, key3));
                continue;
            }
            if (c == 2) {
                hash h.key1 = rand() % 10;
                h.key2 = rand() % 10;
                setRWData(h);
                continue;
            }
            if (c == 3) {
                getRWData((key1, key2, key3));
                continue;
            }
            if (c == 4) {
                hash h.key1 = rand() % 10;
                h.key2 = rand() % 10;
                setGateData(h);
                continue;
            }
            if (c == 5) {
                getGateData((key1, key2, key3));
                continue;
            }
        }
        c.dec();
    }
}

