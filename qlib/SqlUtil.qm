# -*- mode: qore; indent-tabs-mode: nil -*-
# @file SqlUtil.qm Qore user module for working with SQL data

/*  SqlUtil.qm Copyright 2013 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.8 or better
%requires qore >= 0.8.8

# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings
%disable-warning non-existent-method-call

module SqlUtil {
    version = "1.0";
    desc = "user module for working with SQL data";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
}

/** @mainpage SqlUtil Module

    The %SqlUtil module provides functionality for parsing SQL-like files.

    To use this module, use \c "%requires SqlUtil" in your code.
    
    All the public symbols in the module are defined in the SqlUtil namespace
*/

#! the SqlUtil namespace contains all the objects in the SqlUtil module
public namespace SqlUtil {
    #! compares complex versions by breaking down strings into component parts
    /** each element is compared separately, so that compare_version("2.11.1", "2.2") returns 1 
        (a regular string comparison would give the opposite result)

        @param lv left-hand version
        @param rv right-hand version

        @return -1 if lv < rv, 0 if equal, and 1 if lv > rv
    */
    public int sub compare_version(string lv, string rv) {
        list ll = lv.split(".");
        list rl = rv.split(".");

        int le = ll.size();
        int re = rl.size();

        int i = 0;
        while (True) {
            if (le == i) {
                if (re == i) {
                    return 0;
                }
                # see if all remaining elements in rl are 0
                splice rl, 0, i;
                return (select rl, $1) ? -1 : 0;
            }
            if (re == i) {
                # see if all remaining elements in ll are 0
                splice ll, 0, i;
                return (select ll, $1) ? 1 : 0;
            }
            any l = ll[i];
            any r = rl[i];
            if (l =~ /^[0-9]/)
                l = int(l);
            if (r =~ /^[0-9]/)
                r = int(r);
            
            int rc = l <=> r;
            if (rc)
                return rc;
            
            ++i;
        }
    }

    #! abstract container class that throws an exception if an unknown key is accessed
    public class AbstractHashContainer {
        public {}

        private {
            *hash h;
        }

        constructor(*hash nh) {
            h = nh;
        }

        any memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        *hash val() {
            return h;
        }

        list keys() {
            return h.keys();
        }

        AbstractIterator iterator() {
            return h.iterator();
        }

        AbstractIterator keyIterator() {
            return h.keyIterator();
        }

        AbstractIterator pairIterator() {
            return h.pairIterator();
        }

        bool empty() {
            return h.empty();
        }

        int size() {
            return h.size();
        }

        bool hasKey(string k) {
            return h.hasKey(k);
        }

        bool hasKeyValue(string k) {
            return h.hasKeyValue(k);
        }

        *string firstKey() {
            return h.firstKey();
        }

        *string lastKey() {
            return h.lastKey();
        }

        abstract string getElementName();
    }

    #! column container class that throws an exception if an unknown column is accessed
    public class Columns inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        Column memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        Columns subset(list l) {
            return new Columns(h{l});
        }

        string getElementName() {
            return "column";
        }
    }

    #! represents a primary key
    public class AbstractPrimaryKey inherits Columns {
        private {
            string name;
        }

        constructor(string n, *hash c) : Columns(c) {
            name = n;
        }

        string getName() {
            return name;
        }

        abstract string getCreatePrimaryKeySql(string table_name, *hash opts);
    }

    #! the base class for column information
    public class Column {
        public {
            #! the name of the column
            string name;

            #! the native type name of the column
            string native_type;

            #! the equivalent qore type name of the column if the native type is known
            *string qore_type;

            #! the size of the column
            int size;

            #! the size of the column in characters
            int char_size;

            #! the precision for numeric columns
            int precision;
            
            #! the scale for numeric columns
            int scale;

            #! Qore::True "True" if the column can hold a NULL value, @ref Qore::False "False" if not
            bool nullable; 
        }

        constructor(string n, string nt, *string qt, int sz, int cs, int prec, int sc, bool nul) {
            name = n;
            native_type = nt;
            qore_type = qt;
            size = sz;
            char_size = cs;
            precision = prec;
            scale = sc;
            nullable = nul;
        }

        string getNativeTypeString() {            
            string sql = native_type;
            if (precision) {
                sql += sprintf("(%d", precision);
                if (scale)
                    sql += sprintf(",%d", scale);
                sql += ")";
            }
            else if (size)
                sql += sprintf("(%d)", size);
            #printf("%y: %s\n", self, sql);
            return sql;
        }

        string getCreateSql() {
            string sql = sprintf("%s %s", name, getNativeTypeString());
            if (!nullable)
                sql += " not null";
            return sql;
        }
    }

    #! index container class that throws an exception if an unknown index is accessed
    public class Indexes inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        AbstractIndex memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "index";
        }
    }

    #! the base class for index information
    public class AbstractIndex {
        public {
            #! the name of the index
            string name;
            
            #! @ref Qore::True "True" if the index is a unique index, @ref Qore::False "False" if not
            bool unique;

            #! an object of class Columns representing the columns in the index
            Columns columns;
        }

        constructor(string n, bool u, hash c) {
            name = n;
            unique = u;
            columns = new Columns(c);
        }

        abstract string getCreateIndexSql(string table_name, *hash opt);
    }

    #! constraint container class that throws an exception if an unknown constraint is accessed
    public class Constraints inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        AbstractConstraint memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "constraint";
        }
    }

    #! AbstractConstraint base class
    public class AbstractConstraint {
        public {
            #! the name of the constraint
            string name;
        }

        constructor(string n) {
            name = n;
        }

        abstract string getCreateSql(string table_name, *hash opt);        
    }

    #! foreign constraint container class that throws an exception if an unknown constraint is accessed
    public class ForeignConstraints inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        AbstractForeignConstraint memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "foreign constraint";
        }
    }

    #! a class describing a foreign constraint target
    public class ForeignConstraintTarget {
        public {
            #! the name of the target table
            string table;

            #! columns in the target table
            Columns columns;
        }

        constructor(string t, Columns c) {
            table = t;
            columns = c;
        }
    }

    #! the base class for foreign key constraint information
    public class AbstractForeignConstraint inherits AbstractConstraint {
        public {
            #! an object of class Columns giving the source table that make up the constraint
            Columns columns;

            #! a ForeignConstraintTarget object to describe the target table and columns
            ForeignConstraintTarget target;
        }

        constructor(string n, Columns c, ForeignConstraintTarget t) : AbstractConstraint(n) {
            columns = c;
            target = t;
        }
    }

    #! trigger container class that throws an exception if an unknown trigger is accessed
    public class Triggers inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        AbstractTrigger memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "trigger";
        }
    }

    #! the base class for triggers
    public class AbstractTrigger {
        public {
            #! the name of the index
            string name;
            
            #! the source of the index
            string src;
        }

        constructor(string n, string n_src) {
            name = n;
            src = n_src;
        }

        abstract string getCreateTriggerSql(string table_name, *hash opt);
    }

    #! represents a database table
    public class Table {
        private {
            AbstractTable t;
        }

        constructor(AbstractDatasource ds, string name, *hash opts) {
            t = AbstractTable::getTable(ds, name, opts);
        }

        constructor(string ds, string name, *hash opts) {
            t = AbstractTable::getTable(ds, name, opts);
        }
        
        constructor(hash ds, string name, *hash opts) {
            t = AbstractTable::getTable(ds, name, opts);
        }
        
        #! returns the name of the table
        string getName() {
            return t.getName();
        }

        #! gets the underlying AbstractDatasource
        AbstractDatasource getDatasource() {
            return t.getDatasource();
        }

        #! executes a method on the contained AbstractTable object
        any methodGate(string meth) {
            return callObjectMethodArgs(t, meth, argv);
        }

        #! returns a list of SQL strings that could be used to create the table and all known properties of the table
        /** @par Example:
            @code
map printf("$1;\n", $1), $table.getCreateSql();
            @endcode

            @param opt a hash of options for the SQL creation strings

            @return a list of SQL strings that could be used to create the table and all known properties of the table
        */
        list getCreateSql(*hash opt) {
            return t.getCreateSql(opt);
        }

        #! returns an SQL string that could be used to create the basic table structure without indexes and constraints 
        /** @par Example:
            @code
my string $sql = $table.getCreateTableSql();
            @endcode

            @param opt a hash of options for the table creation string

            @return an SQL string that could be used to create the basic table structure without indexes and constraints 
        */
        string getCreateTableSql(*hash opt) {
            return t.getCreateTableSql(opt);
        }

        #! returns a list of SQL strings that could be used to create indexes on the table or NOTHING if there are no indexes on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateIndexesSql();
            @endcode

            @param opt a hash of options for the index creation string

            @return a list of SQL strings that could be used to create indexes on the table or NOTHING if there are no indexes on the table
        */
        *list getCreateIndexesSql(*hash opt) {
            return t.getCreateIndexesSql(opt);
        }

        #! returns an SQL string that could be used to create the primary key on the table
        /** @par Example:
            @code
my *string $sql = $table.getCreatePrimaryKeySql();
            @endcode

            @param opt a hash of options for the primary key creation string

            @return an SQL string that could be used to create the primary key on the table or NOTHING if there is no primary key on the table
        */
        *string getCreatePrimaryKeySql(*hash opt) {
            return t.getCreatePrimaryKeySql(opt);
        }

        #! returns a list of SQL strings that could be used to create foreign constraints on the table or NOTHING if there are no foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateForeignConstraintsSql();
            @endcode

            @param opt a hash of options for the foreign constraint creation string

            @return a list of SQL strings that could be used to create foreign constraints on the table or NOTHING if there are no foreign constraints on the table
        */
        *list getCreateForeignConstraintsSql(*hash opt) {
            return t.getCreateForeignConstraintsSql(opt);
        }

        #! returns a list of SQL strings that could be used to create non-foreign constraints on the table or NOTHING if there are no non-foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateConstraintsSql();
            @endcode

            @param opt a hash of options for the non-foreign constraint creation string

            @return a list of SQL strings that could be used to create non-foreign constraints on the table or NOTHING if there are no non-foreign constraints on the table

            @see getCreateForeignConstraintsSql()
        */
        *list getCreateConstraintsSql(*hash opt) {
            return t.getCreateConstraintsSql(opt);
        }

        #! returns a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or NOTHING if there are none
        /** @par Example:
            @code
my *list $l = $table.getCreateMiscSql();
            @endcode

            @param opt a hash of options for the SQL creation string

            @return a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or NOTHING if there are none
        */
        *list getCreateMiscSql(*hash opt) {
            return t.getCreateMiscSql(opt);
        }

        #! returns a list of SQL strings that could be used to create triggers on the table or NOTHING if there are no triggers on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateTriggersSql();
            @endcode

            @param opt a hash of options for the trigger creation string

            @return a list of SQL strings that could be used to create triggers on the table or NOTHING if there are no triggers on the table
        */
        *list getCreateTriggersSql(*hash opt) {
            return t.getCreateTriggersSql(opt);
        }

        #! returns an object of class Columns describing the Table
        /** @par Example:
            @code
my Columns $cols = $table.describe();
            @endcode

            @return an object of class Columns describing the Table
        */
        Columns describe() {
            return t.describe();
        }

        #! returns an object of class AbstractPrimaryKey describing the primary key of the table
        /** If there is no primary key then the object returned will be empty (see @ref AbstractPrimaryKey::empty())

            @par Example:
            @code
my AbstractPrimaryKey $cols = $table.getPrimaryKey();
            @endcode

            @return an object of class AbstractPrimaryKey describing the primary key of the table
        */
        AbstractPrimaryKey getPrimaryKey() {
            return t.getPrimaryKey();
        }

        #! returns an object of class Indexes describing the indexes on the table
        /** If there are no indexes on the table then the object returned will be empty (see @ref Indexes::empty())

            @par Example:
            @code
my Indexes $ix = $table.getIndexes();
            @endcode

            @return an object of class Indexes describing the indexes on the table
        */
        Indexes getIndexes() {
            return t.getIndexes();
        }

        #! returns an object of class Triggers describing the triggers on the table
        /** If there are no triggers on the table then the object returned will be empty (see @ref Triggers::empty())

            @par Example:
            @code
my Triggers $trig = $table.getTriggers();
            @endcode

            @return an object of class Triggers describing the triggers on the table
        */
        Triggers getTriggers() {
            return t.getTriggers();
        }

        #! returns a ForeignConstraints object describing the foreign constraints that the table has on other tables
        ForeignConstraints getForeignConstraints() {
            return t.getForeignConstraints();
        }

        #! returns a Constraints object describing non-foreign constraints on the table
        Constraints getConstraints() {
            return t.getConstraints();
        }

        #! returns the database driver name 
        string getDriverName() {
            return t.getDriverName();
        }
    }

    #! the base abstract class for the table implementation
    public class AbstractTable {
        public {
            #! drivers known to 
            const DriverMap = (
                "oracle": \AbstractTable::getOracleTable(),
                "pgsql": \AbstractTable::getPgsqlTable(),
                #"mysql": \AbstractTable::getMysqlTable(),
                #"sqlite3" : \AbstractTable::getSqlite3Table(),
                );

            #! table options
            const TableOptions = (
                "native-case": True,
                );

            #! table creation options
            const TableCreationOptions = (
                "data_tablespace": Type::String,
                "index_tablespace": Type::String,
                );
        }

        private {
            AbstractDatasource ds;
            # table name
            string name;
            # datasource description
            string dsdesc;
            # column description hash
            Columns columns;
            # primary key description
            *AbstractPrimaryKey primaryKey;
            # index description
            Indexes indexes;
            # foreign constraints description
            ForeignConstraints foreignConstraints;
            # constraints description
            Constraints constraints;
            # trigger description
            Triggers triggers;
            # mutex for on-demand retrieval of table attributes
            Mutex l();
            # option hash
            *hash opts;
            # native case option
            bool native_case = False;
        }

        private constructor(AbstractDatasource nds, string nname, *hash nopts, hash rh = TableOptions) {
            checkOptions(nopts, rh);
            opts = nopts;
            name = nname;
            ds = nds;
            # ensure datasource is open
            ds.getServerVersion();
            dsdesc = sprintf("%s:%s@%s", ds.getDriverName(), ds.getUserName(), ds.getDBName());
            if (ds.getHostName())
                dsdesc += "%" + ds.getHostName();
            if (nds.getPort())
                dsdesc += sprintf(":%d", ds.getPort());
        }

        #! returns the name of the table
        string getName() {
            return name;
        }

        #! gets the underlying AbstractDatasource
        AbstractDatasource getDatasource() {
            return ds;
        }

        #! returns the database driver name 
        string getDriverName() {
            return ds.getDriverName();
        }

        # returns the table description hash as acquired in the constructor
        /** @par Example:
            @code
my hash $h = $table.describe();
            @endcode

            @return a hash of column names assigned to Column objects

        */
        Columns describe() {
            getColumnsIntern();
            return columns;
        }

        #! returns an object of class AbstractPrimaryKey describing the primary key of the table
        /** If there is no primary key then the object returned will be empty (see @ref AbstractPrimaryKey::empty())

            @par Example:
            @code
            @endcode

            @return an object of class AbstractPrimaryKey describing the primary key of the table
        */
        *AbstractPrimaryKey getPrimaryKey() {
            getPrimaryKeyIntern();
            return primaryKey;
        }

        #! returns an object of class Indexes describing the indexes on the table
        /** If there are no indexes on the table then the object returned will be empty (see @ref Indexes::empty())

            @par Example:
            @code
my Indexes $ix = $table.getIndexes();
            @endcode

            @return an object of class Indexes describing the indexes on the table
        */
        Indexes getIndexes() {
            getIndexesIntern();
            return indexes;
        }

        #! returns a ForeignConstraints object describing the foreign constraints that the table has on other tables
        ForeignConstraints getForeignConstraints() {
            getForeignConstraintsIntern();
            return foreignConstraints;
        }

        #! returns a Constraints object describing the non-foreign constraints on the table
        Constraints getConstraints() {
            getConstraintsIntern();
            return constraints;
        }

        #! returns an object of class Triggers describing the triggers on the table
        /** If there are no triggers on the table then the object returned will be empty (see @ref Triggers::empty())

            @par Example:
            @code
my Triggers $trig = $table.getTriggers();
            @endcode

            @return an object of class Triggers describing the triggers on the table
        */
        Triggers getTriggers() {
            getTriggersIntern();
            return triggers;
        }

        #! returns a list of SQL strings that could be used to create the table and all known properties of the table
        /** @par Example:
            @code
map printf("$1;\n", $1), $table.getCreateSql();
            @endcode

            @param opt a hash of options for the table, index, and constraint creation strings

            @return a list of SQL strings that could be used to create the table and all known properties of the table
        */
        list getCreateSql(*hash opt) {
            list l += getCreateTableSql(opt);
            l += getCreateIndexesSql(opt);
            l += getCreatePrimaryKeySql(opt);
            l += getCreateForeignConstraintsSql(opt);
            l += getCreateConstraintsSql(opt);
            l += getCreateMiscSql(opt);
            l += getCreateTriggersSql(opt);

            return l;
        }

        #! returns an SQL string that could be used to create the basic table structure without indexes and constraints 
        /** @par Example:
            @code
my string $sql = $table.getCreateTableSql();
            @endcode

            @param opt a hash of options for the table creation string

            @return an SQL string that could be used to create the basic table structure without indexes and constraints 
        */
        string getCreateTableSql(*hash opt) {            
            getColumnsIntern();
            return getCreateTableSqlImpl(opt);
        }

        #! returns a list of SQL strings that could be used to create indexes on the table or NOTHING if there are no indexes on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateIndexesSql();
            @endcode

            @param opt a hash of options for the index creation string

            @return a list of SQL strings that could be used to create indexes on the table or NOTHING if there are no indexes on the table
        */
        *list getCreateIndexesSql(*hash opt) {
            getIndexesIntern();
            return getCreateIndexesSqlImpl(opt);
        }

        #! returns an SQL string that could be used to create the primary key on the table
        /** @par Example:
            @code
my *string $sql = $table.getCreatePrimaryKeySql();
            @endcode

            @param opt a hash of options for the primary key creation string

            @return an SQL string that could be used to create the primary key on the table or NOTHING if there is no primary key on the table
        */
        *string getCreatePrimaryKeySql(*hash opt) {
            getPrimaryKeyIntern();
            if (!primaryKey)
                return;
            return getCreatePrimaryKeySqlImpl(opt);
        }

        #! returns a list of SQL strings that could be used to create foreign constraints on the table or NOTHING if there are no foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateForeignConstraintsSql();
            @endcode

            @param opt a hash of options for the foreign constraint creation string

            @return a list of SQL strings that could be used to create foreign constraints on the table or NOTHING if there are no foreign constraints on the table
        */
        *list getCreateForeignConstraintsSql(*hash opt) {
            getForeignConstraintsIntern();
            if (!foreignConstraints)
                return;
            return getCreateForeignConstraintsSqlImpl(opt);
        }

        #! returns a list of SQL strings that could be used to create non-foreign constraints on the table or NOTHING if there are no non-foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateConstraintsSql();
            @endcode

            @param opt a hash of options for the non-foreign constraint creation string

            @return a list of SQL strings that could be used to create non-foreign constraints on the table or NOTHING if there are no non-foreign constraints on the table

            @see getCreateForeignConstraintsSql()
        */
        *list getCreateConstraintsSql(*hash opt) {
            getConstraintsIntern();
            if (!constraints)
                return;
            return getCreateConstraintsSqlImpl(opt);
        }

        #! returns a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or NOTHING if there are none
        /** @par Example:
            @code
my *list $l = $table.getCreateMiscSql();
            @endcode

            @param opt a hash of options for the SQL creation string

            @return a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or NOTHING if there are none
        */
        *list getCreateMiscSql(*hash opt) {
            return getCreateMiscSqlImpl(opt);
        }

        #! returns a list of SQL strings that could be used to create triggers on the table or NOTHING if there are no triggers on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateTriggersSql();
            @endcode

            @param opt a hash of options for the trigger creation strings

            @return a list of SQL strings that could be used to create triggers on the table or NOTHING if there are no triggers on the table

            @see getCreateTriggersSql()
        */
        *list getCreateTriggersSql(*hash opt) {
            getTriggersIntern();
            if (!triggers)
                return;
            return getCreateTriggersSqlImpl(opt);
        }

        private checkCreateOptions(*hash nopts, *hash rh) {
            foreach string k in (nopts.keyIterator()) {
                if (!rh{k})
                    throw "TABLE-CREATION-ERROR", sprintf("creation option %y is not supported by class %y; possible options: %y", k, self.getClassName(), rh.keys());
                if (rh{k} && nopts{k}.type() != rh{k})
                    throw "TABLE-CREATION-ERROR", sprintf("value passed to table creation option %y is type %y (%y); expecting %y", k, nopts{k}.type(), nopts{k}, rh{k});
            }
        }

        private checkCreateIndexOptions(*hash nopts, *hash rh) {
            foreach string k in (nopts.keyIterator()) {
                if (!rh{k})
                    throw "INDEX-CREATION-ERROR", sprintf("index creation option %y is not supported by class %y; possible options: %y", k, self.getClassName(), rh.keys());
                if (rh{k} && nopts{k}.type() != rh{k})
                    throw "INDEX-CREATION-ERROR", sprintf("value passed to index creation option %y is type %y (%y); expecting %y", k, nopts{k}.type(), nopts{k}, rh{k});
            }
        }

        private checkCreatePrimaryKeyOptions(*hash nopts, *hash rh) {
            foreach string k in (nopts.keyIterator()) {
                if (!rh{k})
                    throw "PK-CREATION-ERROR", sprintf("primary key creation option %y is not supported by class %y; possible options: %y", k, self.getClassName(), rh.keys());
                if (rh{k} && nopts{k}.type() != rh{k})
                    throw "PK-CREATION-ERROR", sprintf("value passed to primary key creation option %y is type %y (%y); expecting %y", k, nopts{k}.type(), nopts{k}, rh{k});
            }
        }

        private checkCreateConstraintOptions(*hash nopts, *hash rh) {
            foreach string k in (nopts.keyIterator()) {
                if (!rh{k})
                    throw "CONSTRAINT-CREATION-ERROR", sprintf("constraint creation option %y is not supported by class %y; possible options: %y", k, self.getClassName(), rh.keys());
                if (rh{k} && nopts{k}.type() != rh{k})
                    throw "CONSTRAINT-CREATION-ERROR", sprintf("value passed to constraint creation option %y is type %y (%y); expecting %y", k, nopts{k}.type(), nopts{k}, rh{k});
            }
        }

        private checkCreateMiscOptions(*hash nopts, *hash rh) {
            foreach string k in (nopts.keyIterator()) {
                if (!rh{k})
                    throw "SQL-CREATION-ERROR", sprintf("SQL creation option %y is not supported by class %y; possible options: %y", k, self.getClassName(), rh.keys());
                if (rh{k} && nopts{k}.type() != rh{k})
                    throw "SQL-CREATION-ERROR", sprintf("value passed to SQL creation option %y is type %y (%y); expecting %y", k, nopts{k}.type(), nopts{k}, rh{k});
            }
        }

        private checkCreateTriggerOptions(*hash nopts, *hash rh) {
            foreach string k in (nopts.keyIterator()) {
                if (!rh{k})
                    throw "TRIGGER-CREATION-ERROR", sprintf("trigger creation option %y is not supported by class %y; possible options: %y", k, self.getClassName(), rh.keys());
                if (rh{k} && nopts{k}.type() != rh{k})
                    throw "TRIGGER-CREATION-ERROR", sprintf("value passed to trigger creation option %y is type %y (%y); expecting %y", k, nopts{k}.type(), nopts{k}, rh{k});
            }
        }

        private checkOptions(*hash nopts, hash rh) {
            foreach string k in (nopts.keyIterator()) {
                if (!rh{k})
                    throw "TABLE-ERROR", sprintf("option %y is not supported by class %y; possible options: %y", k, self.getClassName(), rh.keys());
            }
            if (nopts."native-case")
                native_case = True;
        }

        static AbstractTable getTable(AbstractDatasource nds, string nname, *hash opts) {
            string drv = nds.getDriverName();
            *code c = DriverMap{drv};
            if (!c)
                throw "TABLE-DRIVER-ERROR", sprintf("no support for driver %y yet in SqlUtil::AbstractTable", drv);
            return c(nds, nname, opts);
        }

        static AbstractTable getTable(string dsstr, string nname, *hash opts) {
            Datasource nds(dsstr);
            string drv = nds.getDriverName();
            *code c = DriverMap{drv};
            if (!c)
                throw "TABLE-DRIVER-ERROR", sprintf("no support for driver %y yet in SqlUtil::AbstractTable", drv);
            return c(nds, nname, opts);
        }

        static AbstractTable getTable(hash dsh, string nname, *hash opts) {
            Datasource nds(dsh);
            string drv = nds.getDriverName();
            *code c = DriverMap{drv};
            if (!c)
                throw "TABLE-DRIVER-ERROR", sprintf("no support for driver %y yet in SqlUtil::AbstractTable", drv);
            return c(nds, nname, opts);
        }

        static OracleTable getOracleTable(AbstractDatasource nds, string nname, *hash opts) {
            return new OracleTable(nds, nname, opts);
        }

        static PgsqlTable getPgsqlTable(AbstractDatasource nds, string nname, *hash opts) {
            return new PgsqlTable(nds, nname, opts);
        }

        /*
        static MysqlTable getMysqlTable(AbstractDatasource nds, string nname, *hash opts) {
            return new MysqlTable(nds, nname, opts);
        }
        
        static Sqlite3Table getSqlite3Table(AbstractDatasource nds, string nname, *hash opts) {
            return new Sqlite3Table(nds, nname, opts);
        }
        */

        private getColumnsIntern() {
            if (columns)
                return;
            l.lock();
            on_exit l.unlock();
            if (!columns)
                columns = describeImpl();            
        }

        private getPrimaryKeyIntern() {
            if (primaryKey)
                return;
            getColumnsIntern();
            l.lock();
            on_exit l.unlock();
            if (!primaryKey)
                primaryKey = getPrimaryKeyImpl();            
        }

        private getIndexesIntern() {
            if (indexes)
                return;
            getColumnsIntern();
            l.lock();
            on_exit l.unlock();
            if (!indexes)
                indexes = getIndexesImpl();            
        }

        private getForeignConstraintsIntern() {
            if (foreignConstraints)
                return;
            getColumnsIntern();
            l.lock();
            on_exit l.unlock();
            if (!foreignConstraints)
                foreignConstraints = getForeignConstraintsImpl();            
        }

        private getConstraintsIntern() {
            if (constraints)
                return;
            getColumnsIntern();
            l.lock();
            on_exit l.unlock();
            if (!constraints)
                constraints = getConstraintsImpl();            
        }

        private getTriggersIntern() {
            if (triggers)
                return;
            l.lock();
            on_exit l.unlock();
            if (!triggers)
                triggers = getTriggersImpl();
        }

        private abstract Columns describeImpl();
        private abstract *AbstractPrimaryKey getPrimaryKeyImpl();
        private abstract Indexes getIndexesImpl();
        private abstract ForeignConstraints getForeignConstraintsImpl();
        private abstract Constraints getConstraintsImpl();
        private abstract Triggers getTriggersImpl();
        private abstract string getCreateTableSqlImpl(*hash opt);
        private abstract *list getCreateIndexesSqlImpl(*hash opt);
        private abstract *string getCreatePrimaryKeySqlImpl(*hash opt);
        private abstract *list getCreateForeignConstraintsSqlImpl(*hash opt);
        private abstract *list getCreateConstraintsSqlImpl(*hash opt);
        private abstract *list getCreateMiscSqlImpl(*hash opt);
        private abstract *list getCreateTriggersSqlImpl(*hash opt);
    }

    public class OracleColumn inherits Column {
        public {
            #! the column uses character semantics
            bool char_used;
            #! any comments on the column
            *string comment;
            #! byte size of the column
            int byte_size;
        }

        constructor(string n, string nt, *string qt, int sz, int cs, softint prec, softint sc, bool nul, bool cu, *string cm, int bs) : Column(n, nt, qt, sz, cs, prec, sc, nul) {
            char_used = cu;
            comment = cm;
            byte_size = bs;
        }
    }

    public class OracleIndex inherits AbstractIndex {
        public {
            #! the native type of the index (if supported)
            string native_type;

            #! the tablespace name of the index (if supported)
            string tablespace;
        }

        constructor(string n, bool u, hash c, string nt, string t) : AbstractIndex(n, u, c) {
            native_type = nt;
            tablespace = t;
        }

        string getCreateIndexSql(string table_name, *hash opt) {
            string sql = sprintf("create %sindex %s on %s (%s)", unique ? "unique " : "", name, table_name, (foldl $1 + ", " + $2, columns.keyIterator()));

            *string ts = opt.index_tablespace ? opt.index_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);
            return sql;
        }
    }

    public class OracleForeignConstraint inherits AbstractForeignConstraint {
        public {
            #! @ref Qore::True if the constraint is enabled, @ref Qore::False if not
            bool enabled;
        }

        constructor(string n, Columns c, ForeignConstraintTarget t, bool e) : AbstractForeignConstraint(n, c, t) {
            enabled = e;
        }

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s foreign key (%s) references %s (%s)", table_name, name, (foldl $1 + ", " + $2, columns.keys()), target.table, (foldl $1 + ", " + $2, target.columns.keys()));
        }
    }

    public class OracleCheckConstraint inherits AbstractConstraint {
        public {
            #! the constraint source
            string src;

            #! @ref Qore::True if the constraint is enabled, @ref Qore::False if not
            bool enabled;
        }

        constructor(string n, string n_src, bool e) : AbstractConstraint(n) {
            src = n_src;
            enabled = e;
        }

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s check (%s)", table_name, name, src);
        }
    }

    public class OraclePrimaryKey inherits AbstractPrimaryKey {
        constructor(string n, *hash c) : AbstractPrimaryKey(n, c) {
        }

        string getCreatePrimaryKeySql(string table_name, *hash opts) {
            return sprintf("alter table %s add constraint %s primary key (%s)", table_name, name, (foldl $1 + ", " + $2, keyIterator()));
        }
    }

    public class OracleTrigger inherits AbstractTrigger {
        public {
            #! trigger type
            string type;
            
            #! the triggering event
            string event;

            #! referencing names
            string ref;

            #! @ref Qore::True if the trigger is enabled, @ref Qore::False if not
            bool enabled;

            #! the trigger description
            string desc;

            #! then when clause
            *string when;
        }

        constructor(string n, string n_src, string t, string ev, string r, bool en, string d, *string w) : AbstractTrigger(n, n_src) {
            type = t;
            event = ev;
            ref = r;
            enabled = en;
            desc = d;
            when = w;

            desc =~ s/\n/ /g;
        }

        string getCreateTriggerSql(string table_name, *hash opt) {
            return sprintf("create trigger %s\n%s", desc, src); 
        }
    }

    public class OracleTable inherits AbstractTable {
        public {
            const OraTypeMap = (
                "NUMBER": ("qore": "number",),
                "VARCHAR2": ("qore": "string",),
                "CHAR": ("qore": "string",),
                "DATE": ("qore": "date",),
                "TIMESTAMP(0)": ("qore": "date",),
                "TIMESTAMP(1)": ("qore": "date",),
                "TIMESTAMP(2)": ("qore": "date",),
                "TIMESTAMP(3)": ("qore": "date",),
                "TIMESTAMP(4)": ("qore": "date",),
                "TIMESTAMP(5)": ("qore": "date",),
                "TIMESTAMP(6)": ("qore": "date",),
                "TIMESTAMP(7)": ("qore": "date",),
                "TIMESTAMP(8)": ("qore": "date",),
                "TIMESTAMP(9)": ("qore": "date",),
                "TIMESTAMP(0) WITH TIME ZONE": ("qore": "date",),
                "TIMESTAMP(1) WITH TIME ZONE": ("qore": "date",),
                "TIMESTAMP(2) WITH TIME ZONE": ("qore": "date",),
                "TIMESTAMP(3) WITH TIME ZONE": ("qore": "date",),
                "TIMESTAMP(4) WITH TIME ZONE": ("qore": "date",),
                "TIMESTAMP(5) WITH TIME ZONE": ("qore": "date",),
                "TIMESTAMP(6) WITH TIME ZONE": ("qore": "date",),
                "TIMESTAMP(7) WITH TIME ZONE": ("qore": "date",),
                "TIMESTAMP(8) WITH TIME ZONE": ("qore": "date",),
                "TIMESTAMP(9) WITH TIME ZONE": ("qore": "date",),
                "TIMESTAMP(0) WITH LOCAL TIME ZONE": ("qore": "date",),
                "TIMESTAMP(1) WITH LOCAL TIME ZONE": ("qore": "date",),
                "TIMESTAMP(2) WITH LOCAL TIME ZONE": ("qore": "date",),
                "TIMESTAMP(3) WITH LOCAL TIME ZONE": ("qore": "date",),
                "TIMESTAMP(4) WITH LOCAL TIME ZONE": ("qore": "date",),
                "TIMESTAMP(5) WITH LOCAL TIME ZONE": ("qore": "date",),
                "TIMESTAMP(6) WITH LOCAL TIME ZONE": ("qore": "date",),
                "TIMESTAMP(7) WITH LOCAL TIME ZONE": ("qore": "date",),
                "TIMESTAMP(8) WITH LOCAL TIME ZONE": ("qore": "date",),
                "TIMESTAMP(9) WITH LOCAL TIME ZONE": ("qore": "date",),
                "CLOB": ("qore": "string",),
                "BLOB": ("qore": "binary",),
                "LONG": ("qore": "binary",),
                "RAW": ("qore": "binary",),
                "BFILE": ("qore": "binary",),
                "BINARY_FLOAT": ("qore": "float",),
                "BINARY_DOUBLE": ("qore": "float",),
                "ROWID": ("qore": "string",),
                "UROWID": ("qore": "string",),
                );

            const QoreTypeMap = (
                "integer": "NUMBER",
                "float": "NUMBER",
                "number": "NUMBER",
                "string": "VARCHAR2",
                "date": "TIMESTAMP(6)",
                "binary": "BLOB",
                );
        }

        private {
            string schema;
            string tablespace;
            bool readonly;
            *string comment;

            #! does the current oracle driver support long values
            bool has_long;
        }

        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
            # see if there is a schema in the name
            *string sstr = (nname =~ x/^(\w+)\.\w+/)[0];
            hash row;
            if (sstr) {
                schema = sstr;
                splice nname, 0, schema.size() + 1;
                name = nname;

                row = setSchemaTable();
            }
            else
                row = setTable();
            
            tablespace = row.tablespace_name;
            readonly = row.read_only == "YES";
            if (!native_case)
                tablespace = tablespace.lwr();

            # get any comment
            any cm = ds.selectRow("select * from all_tab_comments where owner = %v and table_name = %v", schema.upr(), name.upr()).comments;
            comment = cm ? cm : NOTHING;

            # the oracle driver >= 3.0 supports selecting from LONG columns
            has_long = compare_version("3.0", getModuleHash().oracle.version) >= 0;
        }

        private hash setSchemaTable() {
            # get the table information if possible
            *hash row = ds.selectRow("select * from all_tables where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (!row)
                throw "TABLE-ERROR", sprintf("table %y.%y does not exist or is not accessible to this user (%s)", schema, name, getDBString());
            return row;
        }

        private hash setTable() {
            # see if the current user has the table
            *hash row = ds.selectRow("select * from user_tables where table_name = %v", name.upr());
            if (row) {
                schema = getUserSchema();
                return row;
            }

            bool pub = False;
            # see if there is a user synonym with this name
            row = ds.selectRow("select * from user_synonyms where synonym_name = %v", name.upr());
            if (!row) {
                # see if there is a public synonym with this name
                row = ds.selectRow("select * from all_synonyms where owner = 'PUBLIC' and synonym_name = %v", name.upr());
                if (!row)
                    throw "TABLE-ERROR", sprintf("table %y or synonym %y does not exist or is not accessible to this user (%s)", name, name, ds.getDBString());
                pub = True;
            }
            
            # update the table name if necessary
            string orig_name = name;
            if (name.upr() != row.table_name) {
                name = row.table_name;
                if (!native_case)
                    name = name.lwr();
            }
            
            schema = row.table_owner;
            if (!native_case)
                schema = schema.lwr();
            
            # get the table information if possible
            row = ds.selectRow("select * from all_tables where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (!row)
                throw "TABLE-ERROR", sprintf("%y is a %ssynonym pointing to table %y.%y which does not exist or is not accessible to this user (%s)", orig_name, pub ? "public " : "", schema, name, getDBString());
            return row;
        }

        private string getUserSchema() {
            string rv = ds.getUserName();
            if (native_case)
                rv = rv.upr();
            return rv;
        }

        private string getDBString() {
            return sprintf("%s@%s", ds.getUserName(), ds.getDBName());
        }

        string getSchemaName() {
            return schema;
        }

        string getTablespaceName() {
            return tablespace;
        }

        *string getComment() {
            return comment;
        }

        bool readOnly() {
            return readonly;
        }

        private Columns describeImpl() {
            # get column descriptions
            *hash qh = ds.select("select col.column_name, data_type, data_length, data_precision, data_scale, nullable, char_length, char_used, comments from all_tab_columns col, all_col_comments com where col.owner = %v and col.table_name = %v and com.owner = col.owner and com.table_name = col.table_name and com.column_name = col.column_name order by column_id", schema.upr(), name.upr());
            if (!qh.column_name)
                throw "TABLE-ERROR", sprintf("cannot retrieve table information for table %y in %y", name, dsdesc);

            hash rv;
            foreach hash row in (qh.contextIterator()) {
                *hash th = OraTypeMap.(row.data_type);
                int size = row.data_type == "NUMBER" && row.data_precision ? row.data_precision : row.data_length;
                switch (row.data_type) {
                    case "ROWID":
                    case "UROWID":
                    case "DATE":
                    case "BINARY_FLOAT":
                    case "BINARY_DOUBLE":
                    case =~ /^TIMESTAMP/:
                    case "BFILE":
                    case "BLOB":
                    case "CLOB": size = 0; break;
                }
                if (!native_case) {
                    row.column_name = row.column_name.lwr();
                    row.data_type = row.data_type.lwr();
                }
                rv.(row.column_name) = new OracleColumn(row.column_name, row.data_type, th.qore, size, row.char_length, row.data_precision, row.data_scale, row.nullable == "Y", row.char_used == "C", row.comments ? row.comments : NOTHING, row.data_length);
            }

            return new Columns(rv);
        }

        private *OraclePrimaryKey getPrimaryKeyImpl() {
            hash rv;

            # get primary key description
            *hash qh = ds.select("select cons.constraint_name, cols.column_name, cols.position, cons.status, cons.owner from all_constraints cons, all_cons_columns cols where cols.owner = %v and cols.table_name = %v and cons.constraint_type = 'P' and cons.owner = %v and cons.constraint_name = cols.constraint_name order by cols.position", schema.upr(), name.upr(), schema.upr());
            if (!qh.constraint_name)
                return;

            foreach string col in (qh.column_name) {
                string cn = native_case ? col : col.lwr();
                rv{cn} = columns{cn};
            }

            string pkname = qh.constraint_name[0];
            if (!native_case)
                pkname = pkname.lwr();
            return new OraclePrimaryKey(pkname, rv);
        }

        private Indexes getIndexesImpl() {
            hash rv;

            # get index description
            *hash qh = ds.select("select index_name, index_type, uniqueness, tablespace_name from all_indexes where owner = %v and table_name = %v", schema.upr(), name.upr());
            if (qh.index_name) {
                hash ih;
                # get column info for all indexes in 1 query
                *hash iqh = ds.select("select * from all_ind_columns where table_owner = %v and table_name = %v order by index_name, column_position", schema.upr(), name.upr());
                foreach hash row in (iqh.contextIterator()) {
                    if (!native_case) {  
                        row.index_name = row.index_name.lwr();
                        row.column_name = row.column_name.lwr();
                    }
                    ih{row.index_name}{row.column_name} = columns{row.column_name};
                }
                
                foreach hash row in (qh.contextIterator()) {
                    if (!native_case) {
                        row.index_name = row.index_name.lwr();
                        row.tablespace_name = row.tablespace_name.lwr();
                    }
                    # skip system indexes
                    if (!ih{row.index_name})
                        continue;
                    rv.(row.index_name) = new OracleIndex(row.index_name, row.uniqueness == "UNIQUE", ih{row.index_name}, row.index_type, row.tablespace_name);
                }

            }

            return new Indexes(rv);
        }

        private ForeignConstraints getForeignConstraintsImpl() {
            hash ch;

            # get foreign referential constraints
            *hash qh = ds.select("select constraint_name, status from user_constraints where owner = %v and table_name = %v and constraint_type = 'R'", schema.upr(), name.upr());
            if (qh.status) {
                hash rv;
                foreach hash row in (qh.contextIterator()) {
                    if (!native_case)
                        row.constraint_name = row.constraint_name.lwr();
                    rv.(row.constraint_name) = (
                        "enabled": row.status == "ENABLED",
                        );
                }
                qh = ds.select("select c.constraint_name, status, cols1.column_name source_column, cols1.position, cols2.table_name target_table, cols2.column_name target_column from all_constraints c, all_cons_columns cols1, all_cons_columns cols2 where c.owner = %v and c.table_name = %v and c.constraint_name = cols1.constraint_name and constraint_type = 'R' and c.r_constraint_name = cols2.constraint_name and cols1.position = cols2.position and cols1.owner = %v and cols2.owner = %v order by cols1.position", schema.upr(), name.upr(), schema.upr(), schema.upr());
                foreach hash row in (qh.contextIterator()) {
                    if (!native_case) {
                        row.constraint_name = row.constraint_name.lwr();
                        row.source_column = row.source_column.lwr();
                        row.target_column = row.source_column.lwr();
                        row.target_table = row.target_table.lwr();
                    }
                    reference c = \rv.(row.constraint_name);
                    c.columns.(row.source_column) = columns{row.source_column};
                    c.target.table = row.target_table;
                    c.target.columns.(row.target_column) = True;
                }

                # temporary foreign table buffer hash
                hash fth;
                foreach hash c in (rv.pairIterator()) {
                    # get a description of the target table for the target column descriptions
                    if (!fth{c.value.target.table})
                        fth{c.value.target.table} = new OracleTable(ds, c.value.target.table, opts);
                    ForeignConstraintTarget fct(c.value.target.table, fth{c.value.target.table}.describe().subset(c.value.target.columns.keys()));
                    ch.(c.key) = new OracleForeignConstraint(c.key, new Columns(c.value.columns), fct, c.value.enabled);
                }
            }

            return new ForeignConstraints(ch);
        }

        private Constraints getConstraintsImpl() {
            # if we cannot select "long" values then skip this: all_constraints.search_condition is a LONG for example
            if (!has_long)
                return new Constraints();

            # get only user constraints
            *hash qh = ds.select("select constraint_name, search_condition, status from all_constraints where owner = %v and table_name = %v and constraint_type = 'C' and generated != 'GENERATED NAME'", schema.upr(), name.upr());
            hash rv;
            foreach hash row in (qh.contextIterator()) {
                if (!native_case)
                    row.constraint_name = row.constraint_name.lwr();
                rv.(row.constraint_name) = new OracleCheckConstraint(row.constraint_name, row.search_condition, row.status == "ENABLED");
            }
            return new Constraints(rv);
        }

        private Triggers getTriggersImpl() {
            hash rv;

            # get trigger description
            *hash qh = ds.select("select * from all_triggers where owner = %v and table_name = %v", schema.upr(), name.upr());
            foreach hash row in (qh.contextIterator()) {
                if (!native_case)
                    map row.$1 = row.$1.lwr(), ("trigger_name", "trigger_type", "triggering_event", "referencing_names", "description");
                printf("%y: %s\n", row.trigger_name, row.description);
                rv{row.trigger_name} = new OracleTrigger(row.trigger_name, row.trigger_body, row.trigger_type, row.triggering_event, row.referencing_names, row.status == "ENABLED", row.description, row.when ? row.when : NOTHING);
            }
            
            return new Triggers(rv);
        }

        string getCreateTableSqlImpl(*hash opt) {
            checkCreateOptions(opt, TableCreationOptions);
            string sql = sprintf("create table %s (\n", name);

            sql += foldl $1 + ",\n" + $2, (map "  " + $1.getCreateSql(), columns.iterator());
            sql += "\n)";

            *string ts = opt.data_tablespace ? opt.data_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            return sql;
        }

        *list getCreateIndexesSqlImpl(*hash opt) {
            checkCreateIndexOptions(opt, TableCreationOptions);
            return map $1.getCreateIndexSql(name, opt), indexes.iterator();
        }

        *string getCreatePrimaryKeySqlImpl(*hash opt) {
            checkCreatePrimaryKeyOptions(opt, TableCreationOptions);
            return primaryKey.getCreatePrimaryKeySql(name, opt);
        }

        *list getCreateForeignConstraintsSqlImpl(*hash opt) {
            checkCreateConstraintOptions(opt, TableCreationOptions);
            return map $1.getCreateSql(name, opt), foreignConstraints.iterator();
        }

        *list getCreateConstraintsSqlImpl(*hash opt) {
            checkCreateConstraintOptions(opt, TableCreationOptions);
            return map $1.getCreateSql(name, opt), constraints.iterator();
        }

        *list getCreateMiscSqlImpl(*hash opt) {
            checkCreateMiscOptions(opt, TableCreationOptions);
            return map sprintf("comment on column %s.%s is '%s'", name, $1.name, $1.comment), columns.iterator(), $1.comment;
        }

        *list getCreateTriggersSqlImpl(*hash opt) {
            checkCreateTriggerOptions(opt, TableCreationOptions);
            return map $1.getCreateTriggerSql(name, opt), triggers.iterator();
        }
    }

    public class PgsqlIndex inherits AbstractIndex {
        public {
            #! the tablespace name of the index
            *string tablespace;
        }

        constructor(string n, bool u, hash c, *string t) : AbstractIndex(n, u, c) {
            tablespace = t;
        }

        string getCreateIndexSql(string table_name, *hash opt) {
            string sql = sprintf("create %sindex %s on %s (%s)", unique ? "unique " : "", name, table_name, (foldl $1 + ", " + $2, columns.keyIterator()));

            *string ts = opt.index_tablespace ? opt.index_tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);
            return sql;
        }
    }

    public class PgsqlForeignConstraint inherits AbstractForeignConstraint {
        constructor(string n, Columns c, ForeignConstraintTarget t) : AbstractForeignConstraint(n, c, t) {
        }

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s foreign key (%s) references %s (%s)", table_name, name, (foldl $1 + ", " + $2, columns.keys()), target.table, (foldl $1 + ", " + $2, target.columns.keys()));
        }
    }


    public class PgsqlCheckConstraint inherits AbstractConstraint {
        public {
            string src;
        }

        constructor(string n, string n_src) : AbstractConstraint(n) {
            name = n;
            src = n_src;
        }        

        string getCreateSql(string table_name, *hash opt) {
            return sprintf("alter table %s add constraint %s check (%s)", table_name, name, src);
        }
    }

    public class PgsqlColumn inherits Column {
        public {
            #! any comments on the column
            *string comment;

            #! byte size of the column
            int byte_size;
        }

        constructor(string n, string nt, *string qt, int sz, int cs, softint prec, softint sc, bool nul, *string cm, softint bs) : Column(n, nt, qt, sz, cs, prec, sc, nul) {
            comment = cm;
            byte_size = bs;
        }

        string getNativeTypeString() {
            string sql = native_type;
            switch (native_type) {
                case =~ /^timestamp/: return splice sql, 9, 0, "(" + string(size) + ")";
                case =~ /^time/: return splice sql, 4, 0, string(size);
            }
            if (precision) {
                sql += sprintf("(%d", precision);
                if (scale)
                    sql += sprintf(",%d", scale);
                sql += ")";
            }
            else if (size)
                sql += sprintf("(%d)", size);
            #printf("%y: %s\n", self, sql);
            return sql;
        }
    }

    public class PgsqlPrimaryKey inherits AbstractPrimaryKey {
        public {
            #! any tablespace for the primary key index
            *string tablespace;
        }

        constructor(string n, *hash c, *string ts) : AbstractPrimaryKey(n, c) {
            tablespace = ts;
        }

        string getCreatePrimaryKeySql(string table_name, *hash opts) {
            string sql = sprintf("alter table %s add constraint %s primary key (%s)", table_name, name, (foldl $1 + ", " + $2, keyIterator()));
            *string ts = opts.index_tablespace ? opts.index_tablespace : tablespace;
            if (ts)
                sql += sprintf(" using index tablespace %s", ts);
            return sql;
        }
    }

    public class PgsqlTrigger inherits AbstractTrigger {
        public {
            #! trigger timing
            string timing;

            #! trigger event
            string event;

            #! action orientation
            string orientation;
        }

        constructor(string n, string n_src, string t, string e, string o) : AbstractTrigger(n, n_src) {
            timing = t;
            event = e;
            orientation = o;
        }

        string getCreateTriggerSql(string table_name, *hash opt) {
            return sprintf("create trigger %s %s %s on %s for each %s %s", name, timing, event, table_name, orientation, src);
        }
    }

    public class PgsqlTable inherits AbstractTable {
        public {
            const PgsqlTypeMap = (
                "numeric": ("qore": "number",),
                "money": ("qore": "number",),
                "smallint": ("qore": "int",),
                "integer": ("qore": "int",),
                "bigint": ("qore": "int",),
                "smallserial": ("qore": "int",),
                "serial": ("qore": "int",),
                "bigserial": ("qore": "int",),
                "real": ("qore": "float",),
                "double precision": ("qore": "float",),
                "oid": ("qore": "number",),
                "varchar": ("qore": "string",),
                "character": ("qore": "string",),
                "character varying": ("qore": "string",),
                "date": ("qore": "date",),
                "timestamp without time zone": ("qore": "date",),
                "timestamp with time zone": ("qore": "date",),
                "time without time zone": ("qore": "date",),
                "time with time zone": ("qore": "date",),
                "interval": ("qore": "date",),
                "abstime": ("qore": "date",),
                "reltime": ("qore": "date",),
                "text": ("qore": "string",),
                "bytea": ("qore": "binary",),
                "bit": ("qore": "binary",),
                "bit varying": ("qore": "binary",),
                "boolean": ("qore": "bool",),
                "macaddr": ("qore": "string",),
                "inet": ("qore": "string",),
                "cidr": ("qore": "string",),
                );

            const PgsqlNameMap = (
                "character varying": "varchar",
                "timestamp without time zone": "timestamp",
                "time without time zone": "time",
                );
            
            const QoreTypeMap = (
                "integer": "bigint",
                "float": "double precision",
                "number": "numeric",
                "string": "varchar",
                "date": "timestamp with time zone",
                "binary": "bytea",
                "bool": "boolean",
                );
        }

        private {
            *string tablespace;
        }

        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
            # get table info
            *hash row = ds.selectRow("select * from pg_tables where tablename = %v", name);
            tablespace = row.tablespace ? row.tablespace : NOTHING;
        }

        *string getTablespaceName() {
            return tablespace;
        }

        private Columns describeImpl() {
            # get column descriptions
            *hash qh = ds.select("select column_name, data_type, character_maximum_length, character_octet_length, numeric_precision, numeric_scale, datetime_precision, is_nullable, description from information_schema.columns c join pg_catalog.pg_statio_all_tables st on (c.table_schema = st.schemaname and c.table_name = st.relname) left join pg_catalog.pg_description pgd on (st.relid = pgd.objoid and pgd.objsubid = c.ordinal_position) where table_name = %v order by ordinal_position", name);
            if (!qh.column_name)
                throw "TABLE-ERROR", sprintf("cannot retrieve table information for table %y in %y", name, dsdesc);

            hash rv;
            foreach hash row in (qh.contextIterator()) {
                *hash th = PgsqlTypeMap.(row.data_type);
                softint size = row.character_maximum_length ? row.character_maximum_length : row.numeric_precision;
                if (!size)
                    size = row.datetime_precision;
                softint cs = row.character_maximum_length ? row.character_maximum_length : 0;
                # use short names in descriptions
                *string an = PgsqlNameMap{row.data_type};
                if (an)
                    row.data_type = an;
                switch (th.qore) {
                    case "int":
                    case "float": {
                        size = 0;
                        break;
                    }
                }
                rv.(row.column_name) = new PgsqlColumn(row.column_name, row.data_type, th.qore, exists size ? size : 0, cs, row.numeric_precision, row.numeric_scale, row.is_nullable == "YES", row.description ? row.description : NOTHING, row.character_octet_length);
            }

            return new Columns(rv);
        }

        private *PgsqlPrimaryKey getPrimaryKeyImpl() {
            hash rv;

            # get primary key description
            *hash qh = ds.select("select c1.relname index_name, a.attname, format_type(a.atttypid, a.atttypmod) coltype, tablespace from pg_index i, pg_class c, pg_attribute a, pg_class c1, pg_indexes xs where c.oid = %v::regclass and indrelid = c.oid and a.attrelid = c.oid and a.attnum = any(i.indkey) and indisprimary and c1.oid = indexrelid and c1.relname = xs.indexname", name);
            if (!qh.index_name)
                return;

            foreach string col in (qh.attname)
                rv{col} = columns{col};

            return new PgsqlPrimaryKey(qh.index_name[0], rv, qh.tablespace[0]);
        }

        private Indexes getIndexesImpl() {
            hash rv;

            # get index description
            *hash qh = ds.select("select i.relname index_name, a.attname column_name, indisunique, tablespace from pg_class t, pg_class i, pg_index ix, pg_attribute a, pg_indexes xs where t.oid = ix.indrelid and i.oid = ix.indexrelid and a.attrelid = t.oid and a.attnum = any(ix.indkey) and t.relkind = 'r' and t.relname = %v and not indisprimary and i.relname = xs.indexname group by i.relname, a.attname, indisunique, tablespace order by i.relname", name);
            if (qh.index_name) {
                hash ih;
                foreach hash row in (qh.contextIterator()) {
                    if (!ih.(row.index_name))
                        ih.(row.index_name) = (
                            "unique": row.indisunique,
                            "tablespace": row.tablespace,
                        );
                    ih.(row.index_name).columns{row.column_name} = columns{row.column_name};
                }

                foreach hash i in (ih.pairIterator())
                    rv.(i.key) = new PgsqlIndex(i.key, i.value.unique, i.value.columns, i.value.tablespace);
            }

            return new Indexes(rv);
        }

        private ForeignConstraints getForeignConstraintsImpl() {
            hash rv;

            # get foreign referential constraints
            *hash qh = ds.select("select tc.constraint_name, kcu.column_name source_column, ccu.table_name target_table, ccu.column_name target_column from information_schema.table_constraints tc join information_schema.key_column_usage kcu on tc.constraint_name = kcu.constraint_name join information_schema.constraint_column_usage as ccu on ccu.constraint_name = tc.constraint_name where constraint_type = 'FOREIGN KEY' and tc.table_name = %v order by ordinal_position", name);
            if (qh.constraint_name) {
                hash ch;
                foreach hash row in (qh.contextIterator()) {
                    reference c = \ch.(row.constraint_name); 
                    c.columns.(row.source_column) = columns{row.source_column};
                    c.target.table = row.target_table;
                    c.target.columns.(row.target_column) = True;
                }
                
                # temporary foreign table buffer hash
                hash fth;
                foreach hash c in (ch.pairIterator()) {
                    # get a description of the target table for the target column descriptions
                    if (!fth{c.value.target.table})
                        fth{c.value.target.table} = new PgsqlTable(ds, c.value.target.table);
                    
                    ForeignConstraintTarget fct(c.value.target.table, fth{c.value.target.table}.describe().subset(c.value.target.columns.keys()));
                    rv.(c.key) = new PgsqlForeignConstraint(c.key, new Columns(c.value.columns), fct);
                }
            }

            return new ForeignConstraints(rv);
        }

        private Constraints getConstraintsImpl() {
            # get check constraints
            *hash qh = ds.select("SELECT c.conname AS constraint_name, CASE WHEN c.condeferrable = 'f' THEN 0 ELSE 1 END AS is_deferrable, CASE WHEN c.condeferred = 'f' THEN 0 ELSE 1 END AS is_deferred, t.relname AS table_name, array_to_string(c.conkey, ' ') AS constraint_key, CASE confupdtype WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END AS on_update, CASE confdeltype WHEN 'a' THEN 'NO ACTION' WHEN 'r' THEN 'RESTRICT' WHEN 'c' THEN 'CASCADE' WHEN 'n' THEN 'SET NULL' WHEN 'd' THEN 'SET DEFAULT' END AS on_delete, CASE confmatchtype WHEN 'u' THEN 'UNSPECIFIED' WHEN 'f' THEN 'FULL' WHEN 'p' THEN 'PARTIAL' END AS match_type, t2.relname AS references_table, array_to_string(c.confkey, ' ') AS fk_constraint_key, consrc FROM pg_constraint c LEFT JOIN pg_class t  ON c.conrelid  = t.oid LEFT JOIN pg_class t2 ON c.confrelid = t2.oid WHERE c.contype = 'c' and t.relname = %v", name);
            hash rv;
            foreach hash row in (qh.contextIterator())
                rv.(row.constraint_name) = new PgsqlCheckConstraint(row.constraint_name, row.consrc);

            return new Constraints(rv);
        }

        private Triggers getTriggersImpl() {
            hash rv;

            # get trigger description
            *hash qh = ds.select("select * from information_schema.triggers where event_object_table = %v", name);

            # list of functions
            list fl = ();
            foreach hash row in (qh.contextIterator()) {
                if (!native_case)
                    map row.$1 = row.$1.lwr(), ("event_manipulation", "action_statement", "action_timing", "action_orientation");
                if (rv{row.trigger_name}) {
                    rv{row.trigger_name}.event += " or " + row.event_manipulation;
                    continue;
                }

                *string f = (row.action_statement =~ /EXECUTE PROCEDURE (\w+)\(\)$/)[0];
                if (f)
                    fl += f;
                    
                rv{row.trigger_name} = new PgsqlTrigger(row.trigger_name, row.action_statement, row.action_timing, row.event_manipulation, row.action_orientation);
            }
            
            return new Triggers(rv);
        }

        string getCreateTableSqlImpl(*hash opt) {
            checkCreateOptions(opt, TableCreationOptions);
            string sql = sprintf("create table %s (\n", name);

            sql += foldl $1 + ",\n" + $2, (map "  " + $1.getCreateSql(), columns.iterator());
            sql += "\n)";

            *string ts = opt.tablespace ? opt.tablespace : tablespace;
            if (ts)
                sql += sprintf(" tablespace %s", ts);

            return sql;
        }

        *list getCreateIndexesSqlImpl(*hash opt) {
            checkCreateIndexOptions(opt, TableCreationOptions);
            return map $1.getCreateIndexSql(name, opt), indexes.iterator();
        }

        *string getCreatePrimaryKeySqlImpl(*hash opt) {
            checkCreatePrimaryKeyOptions(opt, TableCreationOptions);
            return primaryKey.getCreatePrimaryKeySql(name, opt);
        }

        *list getCreateForeignConstraintsSqlImpl(*hash opt) {
            checkCreateConstraintOptions(opt, TableCreationOptions);
            return map $1.getCreateSql(name, opt), foreignConstraints.iterator();
        }

        *list getCreateConstraintsSqlImpl(*hash opt) {
            checkCreateConstraintOptions(opt, TableCreationOptions);
            return map $1.getCreateSql(name, opt), constraints.iterator();
        }

        *list getCreateMiscSqlImpl(*hash opt) {
            checkCreateMiscOptions(opt, TableCreationOptions);
            return map sprintf("comment on column %s.%s is '%s'", name, $1.name, $1.comment), columns.iterator(), $1.comment;
        }

        *list getCreateTriggersSqlImpl(*hash opt) {
            checkCreateTriggerOptions(opt, TableCreationOptions);
            return map $1.getCreateTriggerSql(name, opt), triggers.iterator();
        }
    }

    public class MysqlTable inherits AbstractTable {
        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
        }

        private hash describeImpl() {
            return hash();
        }
    }

/*
    public class Sqlite3Table inherits AbstractTable {

        public {
            const Sqlite3TypeMap = (
                "INTEGER": ("qore": "integer",),
                "NUMERIC": ("qore": "number",),
                "TEXT": ("qore": "string",),
                "BLOB": ("qore": "binary",),
                "NONE": ("qore": "any",),
                "REAL": ("qore": "float",),
                );

            const QoreTypeMap = (
                "integer": "INTEGER",
                "float": "NUMBER",
                "number": "NUMBER",
                "string": "VARCHAR2",
                #"date": "TIMESTAMP",
                "binary": "BLOB",
                );
        }

        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
        }

        private hash describeImpl() {
            hash rv;
            
            # NOTE: sqlite3's pragmas cannot use %v binding
            
            # table info - PK is part of the table description
            hash tableInfo = ds.select("pragma table_info(%s)", name);
            context(tableInfo) {
                rv.columns{%name} = (
                        "native_type"   : %type,
                        "qore_type"     : Sqlite3TypeMap{%type}.qore,
                        "size"          : NOTHING,
                        "nullable"      : %notnull == 1 ? NOTHING : "YES",
                    );
                if (%pk)
                    rv.primary_key{%name} = True;
            }
            
            # get index description
            hash indexes = ds.select("pragma index_list(%s)", name);
            context(indexes) {
                rv.indexes{%name}.unique = %unique == 0 ? False : True;
                hash indexColumns = ds.select("pragma index_info(%s)", %name);
                string columnName = %name;
                context (indexColumns) {
                    rv.indexes{columnName}.columns{%name} = True;
                }
            }
            
            # TODO/FIXME: FKs
            
            return rv;
        }
    }
*/
}
