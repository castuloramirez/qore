RELEASE NOTES for qore v0.7.0

NOTE: modules are now delivered separately from the qore library, see the file README-MODULES for more information
NOTE: for platform-specific notes and build instructions, please see the file BUILD

qore 0.7.0 is a major release with major new features.

release overview:
*) stable ABI and API, cleaned-up public header files, development packages
*) library may be used under the GPL or LGPL (enforced with license tagging on library and module initialization)
*) documented public API (with doxygen), documentation packages
*) complete reimplementation of the type and operator subsystems
*) reimplemented variable and object locking, no more possibility of nested locks and deadlocks
*) major performance and memory usage improvements
*) support for closures and encapsulating the state of local variables in the closure
*) some (quasi) functional programming support: new operators: map, foldr, foldl, select
*) new implicit argument references: $$ (entire argument list), $1, $2, ...
*) new special object method: "memberNotification()", called when members are updated externally to the class
*) "static" class methods are now supported
*) dereference string characters with [] operator
*) new qt-core, qt-gui, qt-opengl, qt-svg, opengl, glut, asn1, and xmlsec modules (delivered separately, see the file README-MODULES for more information)
*) bz2 compressed data support (compression and decompression)
*) file locking support in the File class (based on fcntl())
*) support for SHA224, SHA256, SHA384, and SHA512 digest algorithms
*) 64-bit builds are the default on x86_64 CPUs
*) module dependencies
*) XML improvements, some XSD support
*) thread stack overrun protection on some platforms
*) build option support and constants
*) lots of bug fixes, new functions, new clases, class improvements, etc

*) stable ABI and API, cleaned-up public header files, development packages
finally Qore is useful for what it was designed to be in the first place: for embedding code in arbitrary applications.
With a public, stable, and documented API, qore can be used by anyone that wants to support logic embedding in their application.
Relevant classes exported by the Qore API now have private implementations, separating the interface from the implementation.
"const correctness" has been liberally applied to the API as well.
Modules may now be packaged and delivered separately from Qore.

Development packages (rpms) are now available as well.

*) library may be used under the GPL or LGPL 
With this release, the qore library may be used under either the GPL or LGPL licenses.  
When calling qore_init() to initialize the library, you have to pass a license argument.
When the qore library is initialized with the LGPL license, no licenses tagged as requiring the GPL license can be loaded.

*) documented public API (with doxygen), documentation packages
The Qore API documentation is generated with doxygen directly from the Qore header files.

Documentation packages (rpms) are now available as well.

*) complete reimplementation of the type and operator subsystems
The internal type and operator subsystems have been streamlined and improved for this release.

*) reimplemented variable and object locking, no more possibility of nested locks and deadlocks
Internal locking in Qore was simplified by eliminating nested locks and the possibility of deadlocking based on internal locks.

*) major performance and memory usage improvements
Performance of Qore code has been significantly improved for this release.  Additionally, the qore library uses less memory than in previous versions.

*) support for closures and encapsulating the state of local variables in the closure
Closures are now supported, ex:

my $a = sub () { return $x + $y * 3; };

the local variable $a can be returned as a return value of a function or called like a call reference.  If the closure references local variables from outside the closure's scope, when the closure is created the values of those variables are encapsulated in the closure and can be used normally.  Such encapsulated local variables can also be used in other threads (normally Qore local variables are local to the thread they are declared in).

*) some (quasi) functional programming support: new operators: map, foldr, foldl, select
These operators provide advanced and efficient list processing functionality to Qore.

  +) map: "maps" an expression onto a list and returns a list of the results of evaluting the expression on each element of the list
  +) foldr and foldl: "fold" an expression on a list, evaluting each new element of the list with the result of the last evaluation and the new element
  +) select: creates a new list from a list

*) new implicit argument references: $$ (entire argument list), $1, $2, ...
Implicit arguments are used primary with the new list operators (map, foldr, foldl, and select), but can also be used in functions now as well.

*) new special object method: "memberNotification()", called when members are updated externally to the class
Objects can now be notified if public members are modified from outside the object's scope by declaring a new special method: "memberNotification()"

*) "static" class methods are now supported
Static class methods are not associated with an object; they are like regular functions attached to a class.
Static methods may also be private.

This allows programmers to write more efficient object-oriented programs and also addresses some Qore programmers' desire to put functions in namespaces (functions cannot be declared in a Qore namespace).

*) dereference string characters and binary bytes with [] operator
To get a single character of a string, the [] operator may be used, similar to how it's used with lists.
To get the value of a byte, the [] operator may be used as well.

Note that the [] operator when used in an lvalue expression will always convert its argument to a list
(i.e. $string[1] = "a" or $binary[1] = 0x1f will not work yet - assuming $string is a string and $binary is a binary)

*) new modules: qt-core, qt-gui, qt-opengl, qt-svg, opengl, glut, asn1, and xmlsec
QT modules are based on QT4
all modules are now delivered separately from the qore library, see the file README-MODULES for more information

*) bz2 compressed data support (compression and decompression)
libbz2 is now required to run qore, and bz2 includes are required to build qore
new functions provided: bzip2(), bunzip2_to_binary(), bunzip2_to_string() 

*) improvements to the File class 
file locking support in the File class (based on fcntl()), more
new File class members:
  +) File::lock()
  +) File::lockBlocking()
  +) File::getLockInfo()
  +) File::chown()

*) support for SHA224, SHA256, SHA384, and SHA512 digest algorithms
if Qore is built with an appropriate version of openssl, support for these new digest algorithms is supplied through the following functions:
  +) SHA224()
  +) SHA224_bin()
  +) SHA256()
  +) SHA256_bin()
  +) SHA384()
  +) SHA384_bin()
  +) SHA512()
  +) SHA512_bin()

*) 64-bit builds are the default on x86_64 CPUs on Linux
the configure script will automatically set the build to a 64-bit target if the CPU is detected to be x86_64 on Linux
note that on Solaris x86_64 you still have to manually add --enable-64bit to configure

*) XML improvements, XSD support
  +) parseXMLWithSchema() - new function supports parsing an XML string based on an XSD schema
  +) improved XML generation, top-level elements may now have attributes
  +) improved XML parse error reporting, more details are included and context is now reported in the exception strings

*) thread stack overrun protection on some platforms
there is a new "stack guard" implementation that will cause an exception to be thrown when a thread runs out of stack space (instead of crashing the entire process, which is what happened previously).
The "stack guard" implementation simply determines the stack size for the thread and then checks the stack pointer before each Qore statement is executed to see if if passes a threshold.  
If the threshold has been breached, the statement is not executed and an exception is raised instead.
See the new test in test/stack-test.q for an example.

Stack guard availability depends on the compiler and CPU used to build qore; so far there are tested implementations on:
  + i386 (gcc, SunPro CC), x86_64 (gcc, SunPro CC), 32-bit powerpc (gcc), 32-bit sparc (gcc, SunPro CC)

Other platforms will still crash when the thread's stack is overrun.

*) build option support
now qore has constants that will tell you which options are available in the library.
Furthermore all functions are now available for parsing; but functions without an implementation will throw an exception.
You can check the option constants before running the function.
Optional functions are: 
  +) round()                                                   (depends on C library support, missing on Solaris 8 for example)
  +) timegm()                                                  (depends on C library support, missing on Solaris for example)
  +) setegid()                                                 (depends on C library support)
  +) seteuid()                                                 (depends on C library support)
  +) parseXMLWithSchema()                                      (depends on libxml2 support)
  +) all SHA224*(), SHA256*(), SHA384*(), SHA512*() functions  (depends on openssl support)
  +) all MDC2*() functions                                     (depends on openssl support)
  +) all RC5*() functions                                      (depends on openssl support)

The new constants are all in the Option namespaace:
  +) HAVE_ATOMIC_OPERATIONS
  +) HAVE_STACK_GUARD
  +) HAVE_RUNTIME_THREAD_STACK_TRACE
  +) HAVE_ROUND
  +) HAVE_TIMEGM
  +) HAVE_SETEUID
  +) HAVE_SETEGID
  +) HAVE_PARSEXMLWITHSCHEMA
  +) HAVE_SHA224
  +) HAVE_SHA256
  +) HAVE_SHA224
  +) HAVE_SHA256
  +) HAVE_SHA384
  +) HAVE_SHA512
  +) HAVE_SHA384
  +) HAVE_SHA512
  +) HAVE_MDC2
  +) HAVE_RC5

you can see what options qore has now by typing "qore -V" as well from the command-line.

*) bug fixes, new functions, class improvements
  +) Qore revision tag now reflects the svn version used to make the build (instead of a meaningless private build number that was different on each machine).
  +) new "Dir" class for manipulating and traversing directories (by Wolfgang Ritzinger).
  +) inlist() and inlist_hard() functions for checking if a value is in a list
  +) HTTPClient now understand bzip content encoding
  +) new chown(), lchown(), call_builtin_function(), call_builtin_function_args(), force_encoding(), get_script_path(), get_script_name() functions
  +) parseURL() improvements
  +) new Program restrictions: PO_NO_TERMINAL_IO and PO_NO_GUI
  +) "-" operator updated: hash - list and hash -= list now work to delete multiple hash keys in a single (atomic) expression
  +) major updates to internal object and class code to allow for c++ class hierarchies to be properly reflected as Qore class hierarchies (used extensively by the qt modules, for example)
  +) qore -V now gives verbose information about the build and library options

***********************
*** LANGUAGE ISSUES ***
***********************

Thread Stacks Overrun
---------------------
*) BUG: on platforms without the new "stack guard" implementation; when the thread stack space is exhausted, the program will simply crash.  Currently qore is vulnerable to this, as it is heavily threaded and uses the stack often to save thread state, so a program like: 'sub a() { a(); } a();' will cause a core dump fairly quickly.
The following platforms are *not* vulnerable (because they have assembly stack guard implementations): 
  + i386 (gcc, SunPro CC), x86_64 (gcc, SunPro CC), 32-bit powerpc (gcc), 32-bit sparc (gcc, SunPro CC)

Out of Memory Errors
--------------------
*) BUG: out of memory conditions are not handled with the c++ new operator... I need a good solution for that.  Generally the Qore program will crash if the new operator cannot allocate the memory it needs, however work has begun on handling out of memory errors starting in v0.5.2.  Of particular note is running out of thread stack space (which causes a crash); program-controlled thread stack space needs to be implemented in order to address this shortcoming

Object Comparisons
------------------
Note that the comparison operator == (and ===) will only report True if the two objects are the same object - future versions of Qore will support a mechanism to allow objects to implement their own handling for operators like these.

References, Copying, Passing by Value
-------------------------------------
Unlike some other languages requiring garbage collection, Qore uses a deterministic reference-counted architecture for memory management.  When the references on a value node reach 0, that object is deleted.  When arguments to a function or method are passed by value, internally, for all value types other than an object (instantiation of a Qore class), the reference count is atomically incremented and the same value node is passed to the function or method.  In this case, if that value node is changed, then the value is copied and the changes are made to the copy.  So, for all value node types other than objects, a copy-on-write approach is used.  However objects are always passed by reference.  There is always only one copy of each object unless the object is explicitly copied.  In this sense, Qore acts like Java as far as I am aware (actually, like Java, a copy of a reference is passed when an object is passed as the argument to another function).

Parsing
-------
*) Note that there is a parse lock on each program object.  Parsing on a single program object is single-threaded.  However, the reentrant parser is able to support simultaneous parsing on different program objects.
*) Parsing happens in 2 stages - 1) parse to pending data structures, and 2) commit the pending data structures to the Qore Program object.  References are resolved in the second stage, which allows flexible referencing of functions, constants, classes, etc before they are declared.  Any parse errors at any stage will cause all the uncomitted parsing to be rolled back.  The Qore Program class allows the programmer control over the 2 stages of parsing with the Program::parsePending(), Program::parseCommit(), and Program::parseRollback() methods.


*********************
*** SQL Subsystem ***
*********************

*) NOTE that there is a transaction lock on the Datasource class (above the DBI driver level) that is automatically enabled if autocommit is off on the Datasource that prohibits two or more threads from being in a transaction at the same time on the same datasource.  To best use this feature when starting a transaction with a Datasource::select() (like a "select for update"), call Datasource::beginTransaction() before the "select for update".  You notify qore that the transaction has completed by calling Datasource::commit() or Datasource::rollback().  Note that this must be done in the same thread that started the transaction.  Currently there is no way in qore to execute SQL in separate threads simultaneously on the same datasource if autocommit is off and one of the threads has started a transaction (either by calling Datasource::beginTransaction() or Datasource::exec()).


**************************************
*** Current and Future Development ***
**************************************

The file docs/roadmap.html contains line-by-line feature information.  Generally, qore should hit version 1.0 when:
*) the bugs listed in this file are resolved
*) have more robust DBI drivers
*) binding and fetching has been implemented with explicit APIs so Qore programs can handle data sets larger than available memory


*********************
*** General Notes ***
*********************

Threading
---------
Qore was designed to favor multithreaded performance over single-threaded performance.  Due to this reason Qore programs should be very scalable on SMP systems.

Memory Cleanliness
------------------
Qore has been thoroughly reviewed with valgrind (on Linux) and dbx (on Solaris) for memory errors.  There are no known static or dynamic memory leaks in qore at this time.  However, see below on handling out of memory conditions.
The new features have not been as extensively tested, and there is some danger of memory leaks with exception handling, as not every code path has been explicitly tested.

Stability & Bugs
----------------
NOTE that while qore is version 0.7.*, this does not indicate a lack of stability.  The qore language is in heavy commercial use and must absolutely remain stable and without memory leaks.
However not all code paths are as well tested as others; there are certainly unknown bugs out there.  

---------------------
RELEASE NOTES HISTORY
---------------------

**********************************************
RELEASE SUMMARY for qore v0.6.2.1 and v0.6.2.2
**********************************************

0.6.2.2 contains one additional bugfix from 0.6.2.1:
        * fixed an XML parsing bug with multiple out-of-order keys that could cause a crash

0.6.2.1 is a bug-fix release from 0.6.2.  The following bugs were fixed in 0.6.2.1:
        * fixed a bug where null values could be inserted into the parse tree with certain invalid expressions (causing a subsequent segfault)
        * fixed a bug in HTTPClient::head() where the message body was erroneously attempted to be read
        * fixed a thread resource tracking bug in the DatasourcePool class that could cause a crash
        * fixed a bug with implicit conversions from Qore type boolean to Qore type string (caused memory corruption)
        * fixed a bug in QoreString::parseBase64ToString() that set an invalid internal string length marker
        * added a "decode_url()" function to replace percent encodings in URL strings with the characters encoded
        * updated HTTPClient to automatically encode space characters in the path as %20


*******************************
RELEASE SUMMARY for qore v0.6.2
*******************************

RELEASE SUMMARY: major new features (see compatibility warnings below)
	*) 3 new DBI drivers, PostgreSQL, Sybase, and FreeTDS ("pgsql", "sybase", "mssql")
	*) more support for database and driver-independent programming
	*) new DatasourcePool class for transparent Datasource connection pooling
	*) HTTPClient improvements (redirections, basic authentication, proxy support)
	*) safe signal handling
	*) complete deadlock detection and thread primitive error handling
	*) all thread locking primitives now take an optional timeout value
	*) call references (including object method references that will be executed in the context of the object referenced)
 	*) mysql and oracle driver improvements
	*) extensive enhancements for exception-safe programming (on_exit, on_error, on_success statements, new classes, etc)
	*) significant performance improvements
	*) tibae module improvements
	*) many new functions and methods, bug fixes, extensive documentation updates, etc

RPM NOTES: the "tibae" module was removed from Linux i386 F7 binary packages because it requires g++-32; if you need this module; build it from source

*) ***COMPATIBILITY WARNING***: all timeouts changed to milliseconds
affects Condition::wait(), Datasource::setTransactionLockTimeout(), and Datasource::getTransactionLockTimeout()
the optional timeout value is no longer seconds, but milliseconds

This change will be transparent for code using relative times, i.e.:
	$cond.wait($mutex, 2s);

Otherwise for integers make sure and multiply any values representing seconds by 1000, i.e.:
	$cond.wait($mutex, 2 * 1000); # wait for 2 seconds

*) ***COMPATIBILITY WARNING**: Gate::enter() no longer takes a key argument, takes an optional timeout in ms instead
the key is always assumed to be the TID (thread ID); meaning that only one thread can hold the lock at one time; however it can be acquired recursively
Any integer passed to this method will be assumed to be a timeout value in milliseconds
with a timeout, if the return value is -1, then the Gate was not grabbed
The Gate class participates in the new Qore deadlock detection, more on this below.

*) ***COMPATIBILITY WARNING**: the RMutex class is deprecated, use the Gate class instead
Internally the RMutex class as of this release is a clone of the new implementation of the Gate class
The RMutex class will be removed in the next release of Qore

*) significant performance improvements
stack traces are now generated on-demand when an exception occurs, instead of constantly allocating heap objects in each thread for each call.
"argv" stacks and program stacks are now stored per-thread with no allocations (or locking).
thread resource tracking is now done with a lock-free, per thread mechanism (the global lock has been removed)
local variable usage was optimized, the number of memory allocations/deallocations has been reduced by more than 2 orders of magnitude, also memory space usage has improved

note that the stack trace optimization means the getAllThreadCallStacks() function does not return any useful value with non-debugging versions of qore.
Call stacks are still maintained with debugging versions of qore so this function can be used to generate a live stack trace of all active threads at any time (useful for finding deadlocks, etc).  The performance impact vs. the utility of maintaining constant stack traces led to the decision to include continuous thread stack tracking only in debugging versions of qore.

Due to the performance improvements in this release, this release of Qore faster than previous releases, even in the face of significant enhancements to the Qore execution engine (deadlock detection, timeout support, etc).

Average speed improvement compared to 0.6.1.* on most platforms is 20%, however on Solaris 10 (sparc and x86_64, but mostly on x86_64) the difference is incredible.
On Solaris 10, qore 0.6.2 executes qore code normally between 2x - 3x as fast as with qore 0.6.1* (probably due to using libumem on this platform).  
With heavily threaded code the speed improvement is smaller, but still noticeable.

*) "pgsql" module: PostgreSQL driver
the new "pgsql" driver uses efficient binary communication with PostgreSQL servers for binding and retrieving values from queries.
The driver supports the following features:
* all builtin PostgreSQL data types are supported
* multi-dimensional arrays are supported for binding and retrieving
* is thread-safe
* stored procedure execution is supported
* transaction management is supported
* transparent character encoding conversion is supported if necessary

The driver's name is "pgsql" and the Datasource type constant is SQL::DSPGSQL
ex: $db = new Datasource(DSPGSQL);
ex: $db = new Datasource("pgsql");

*) "sybase" module: Sybase driver
the new "sybase" driver uses Sybase' ct-lib to communicate with Sybase servers.

The driver's name is "sybase" and the Datasource type constant is SQL::DSSybase
ex: $db = new Datasource(DSSybase);
ex: $db = new Datasource("sybase");

features:
* all builtin Sybase data types are supported
* is thread-safe
* stored procedure execution is supported
* transaction management is supported
* transparent character encoding conversion is supported if necessary
* verbose error reporting in exceptions using client and server message information when available

This driver also provides a special format for returning multiple result sets and/or output parameters in a single statement.  See the qore documentation for more information.

*) "mssql" module: FreeTDS-based driver for connecting to Sybase and MS SQL Server databases
This driver is built from the same sources as the "sybase" driver, but compiled with FreeTDS (http://www.freetds.org).

The driver's name is "mssql" and the Datasource type constant is SQL::DSMSSQL
ex: $db = new Datasource(DSMSSQL);
ex: $db = new Datasource("mssql");

It supports the same features as the "sybase" driver, except the freetds.conf file is used for connection information (instead of Sybase' interfaces file).

The main difference between this driver and the Sybase driver is that it can connect to more types of databases (if they are properly configured in freetds.conf, also with the correct tds version level), and the UNICHAR and VARUNICHAR column types are not yet supported (have not yet been able to make them work).

*) new DatasourcePool class provides transparent Datasource connection pooling
Use the DatasourcePool class like the Datasource class; when you enter a transaction, a Datasource is automatically allocated to the thread, and released when the transaction is committed or rolled back.  
Allocated connections are tracked with Qore's thread resource tracking and failure to release a connection before a thread terminates will result in an exception being thrown and the connection being automatically returned to the pool.

Minimum and maximum number of connections can be set in the constructor; see the DatasourcePool class documentation for more information.

Note that this class is only useful for transaction management; autocommit cannot be enabled with this class (this is because the automatic connection allocation to a thread is made when the thread starts a transaction).

*) HTTPClient improvements
the HTTPClient class now supports redirections, basic authentication, and proxy support (and basic proxy authentication).
new methods in the HTTPClient class:

	HTTPClient::setURL() allows the URL to be changed (will disconnect if connected)
	HTTPClient::getURL() returns the current URL
	HTTPClient::setProxyURL() allows a proxy URL to be set or cleared
	HTTPClient::getProxyURL() returns the current proxy URL
	HTTPClient::clearProxyURL() clears the currenty proxy URL
	HTTPClient::setProxySecure() sets TLS/SSL mode for next proxy connection
	HTTPClient::isProxySecure() return TLS/SSL flag for proxy connection
	HTTPClient::setMaxRedirects() set the maximum number of redirections (default: 5)
	HTTPClient::getMaxRedirects() returns the current max redirects value 

The constructor understands a couple of new hash keys:
	"max_redirects" to set the max redirects value
	"proxy" to set the proxy URL

Since the XmlRpcClient and JsonRpcClient inherit HTTPClient, all improvements to the HTTPClient class are also available in the XmlRpcClient and JsonRpcClient classes as well.

*) call references (references to functions and object methods) implemented
a reference to a function or an object method can be made like this
	function reference:
	$cr = \function_name();

	object method reference:
	$cr = \$object_expression.method_name();

such references can then be executed like this:
$result = $fr($arg1, ...);

so function f() returning a call reference can be executed like this:
$result = f()($arg);

Note that no arguments must be given when the reference is created; the empty parentheses in call references serve to distinguish normal references from call references.

The following functions accept call references:
	sort()                 - for an optional callback function
	sortStable()           - for an optional callback function
	min()                  - for an optional callback function
	max()                  - for an optional callback function
	set_signal_handler()   - for the signal handler code

function references are resolved at parse time during stage 2 parsing (commit phase).
object method references are resolved at run-time.

This change also enables pure object-oriented programming, as functions formerly requiring a user function name can now accept a call reference which may be an object method reference.

*) support for safe signal handling in qore scripts
see the documentation for the set_signal_handler() and remove_signal_handler() functions

qore-language signal handlers are handled in a dedicated thread that's launched when the qore library is initialized.  special handling is included to support fork() properly.

*) run-time module loading
a new function "load_module()" can be used to load modules at run-time

*) no modules in the "auto" directory by default, DBI drivers loaded on demand
before the "mysql" and "oracle" drivers were in the "auto" subdirectory of the modules subdirectory (ex: /usr/lib/qore-<VER>/auto) meaning that they were loaded every time qore was executed.
Now all drivers are in the module directory and the auto subdirectory is empty.
However, an atomic, thread-safe mechanism is used to load DBI drivers on-demand - if the driver is not already loaded, then qore will attempt to load a module of the same name.  If no module can be loaded, then an exception is thrown, otherwise the code continues normally.
So now to load any database driver all you have to do is execute:
	$db = new Datasource("<driver name>",...);

there is no need to write
	%requires <dbi-driver> 
anymore. (however you may want to do this if your code requires the database driver, so that if it cannot be loaded at parse time, the user will see a meaningful parse exception and the code will not execute)

*) new "on_exit", "on_success", and "on_error" statements
allows exception-safe cleanup code to be placed right next to the code requiring the cleanup
	on_exit : queues code to be executed when the current block is exited (regardless of exceptions or return statements)
	on_success: queues code to be executed when the current block is exited, if there is no active exception
	on_error: queues code to be executed when the current block is exited, but only if there is an active exception

These statements provide a powerful mechanism for exception-safe or exception-dependent cleanup code
	example:

	{
	    $mutex.lock();
	    # the lock will be released when the block is exited
	    on_exit
		$mutex.unlock();

	    # ... do something
	    return 0;
	}

*) deadlock detection
All Qore threading primitives (including internal locks for global variables and "synchronized" methods, etc) now use the new deadlock detection framework.  Potential deadlocks are checked before any primitive would otherwise block.  If a deadlock is detected, a DEADLOCK-EXCEPTION is thrown.  

See test/deadlock.q for deadlock and thread error tests.

Deadlock detection affects:
* all qore threading classes
* "synchronized" functions and methods
* global variable accesses
* object accesses

Deadlock detection has been optimized with a fast algorithm and efficient data structures and is only executed when a thread would block.

Despite the new deadlock detection infrastructure and significantly enhanced threading primitives in this release, this release of qore is faster than any previous release on single and multi-processor systems, even with Qore code making extensive use of global variables, objects, "synchronized" code, and threading primitives.

*) thread locking methods take optional timeouts in ms
All thread locking methods take an optional timeout value in ms.  
This affects:
	Mutex::lock()
	Gate::enter()
	RWLock::writeLock()
	RWLock::readLock()
	Condition::wait()
	Counter::waitForZero()
	Queue::get()
	Queue::pop()

It's recommended to use a relative time value to make the units clear, i.e
	$m = new Mutex();
	if ($m.lock(250ms))
	{
	    # lock not grabbed due to timeout...
	}

*) threading errors cause exceptions to be thrown
Common thread errors, such as trying to lock a Mutex twice in the same thread without an intervening Mutex::unlock(), or trying to release a lock that is not held, will cause exceptions to be thrown as of this version of Qore.
Furthermore, locks are tracked as thread resources, and if a thread terminates without freeing the lock, an exception is thrown and the lock is freed automatically.

See test/deadlock.q for deadlock and thread error tests.

*) Oracle driver improvements
added support for the following types:
TIMESTAMP* types
INTERVAL* types
BINARY_FLOAT
BINARY_DOUBLE
UNSIGNED INT
RAW
LONG RAW

Qore date/time types are now bound as TIMESTAMP value to preseve milliseconds when possible (for both binding by value and binding by placeholder).  Milliseconds are preserved in all TIMESTAMP* and INTERVAL DAY TO SECOND types.

Timezone information is discarded when converting from Oracle types to Qore types, as Qore's date/time type does not yet support timezone information.

*) mysql driver improvements
added support for binary types (BLOBs, etc)
mapped DECIMAL type to a string to avoid losing precision
timed-out connections will be automatically reconnected if no transaction is in progress
column names always returned in lower-case

*) Datasource class now throws an exception if deleted while in a transaction

*) new classes for exception-safe lock handling
	AutoLock       (for Mutexes)
	AutoGate       (for Gates)
	AutoReadLock   (for RWLocks - grabs the read lock)
	AutoWriteLock  (for RWLocks - grabs the write lock)

to be used ONLY with local variables - they grab the lock when created and release when destroyed, i.e.

$m = new Mutex();
...
{
   my $al = new AutoLock($m);
   # ... some more code
   # when the block is exited (by a return, exception, etc) the lock will automatically be released
}

or
$g = new Gate();
...
{
   my $ag = new AutoGate($g);
   # ... some more code
   # when the block is exited (by a return, exception, etc) the gate will automatically be released
}
etc...

*) SQL strings accept '%d' placeholder for integer values
provides a mechanism to deal with DECIMAL (NUMERIC, NUMBER) columns in a database-independent way (substitutes 'null' for NULL or NOTHING, the integer text for anything else).
This ensures that values will be set properly even for databases such as PostgreSQL that do not convert from string or integer types to DECIMAL when binding bx value.

*) new functions
	- reverse()                - reverses strings and lists
	- set_signal_handler()     - sets or replaces a signal handler 
	- remove_signal_handler()  - removes a signal handler
	- load_module()            - loads a module at run time
	- regex_extract()          - extracts patterns from a string based on a regular expression given at run time
	- gethostbyaddr()          - returns the fully qualified hostname for the given network address
	- gethostbyaddr_long()     - returns a hash of all host information (all names, addresses, etc) for the given network address
	- gethostbyname()          - returns the first network address for the given host name
	- gethostbyname_long()     - returns a hash of all host information (all names, addresses, etc) for the given host name
	- trim()                   - removes characters from the front and end of a string, by default whitespace characters, accepts references

modified functions:
	- chomp()                  - was modified to accept variable references to chomp in place (as an alternative to the chomp operator) 

*) new File class methods for reading unsigned integer values and for handling 64-bit integers
	File::readu1()
	File::readu2()
	File::readu4()
	File::readi8()
	File::readu2LSB()
	File::readu4LSB()
	File::readi8LSB()
	File::writei8()
	File::writei8LSB()

*) new Socket class methods for receiving unsigned integer values
	Socket::recvu1()
	Socket::recvu2()
	Socket::recvu4()
	Socket::recvu2LSB()
	Socket::recvu4LSB()

*) tibae module improvements
the tibae module (TIBCO ActiveEnterprise/Adapters(TM) module) now can deal with interval, time, and binary types.  Milliseconds are now preserved with datetime and time when sending and receiving.

the tibae_type() function has been added to allow control over how types are serialized (useful with the "any" type or to override default serialization).
New constants have been added to the Tibae namespace for use with the tibae_type() function:
        TIBAE_BINARY
        TIBAE_BOOLEAN
        TIBAE_BYTE
        TIBAE_CHAR
        TIBAE_DATE
        TIBAE_DATETIME
        TIBAE_FIXED
        TIBAE_I1
        TIBAE_I2
        TIBAE_I4
        TIBAE_I8
        TIBAE_INTERVAL
        TIBAE_R4
        TIBAE_R8
        TIBAE_STRING
        TIBAE_TIME
        TIBAE_U1
        TIBAE_U2
        TIBAE_U4
        TIBAE_U8

*) fixed parser to accept variable declarations and list assignment
i.e.:
	my ($a, $b, $c) = split(",", $string); 
	our ($a, $b, $c) = $list;

are now legal...

*) the switch/case statement accepts regular expressions and regular expression operators in case expressions
i.e.:
	switch ($str)
	{
	    case /abc/:
	    case /^hello[1-9]*/:
	}

*) trim operator implemented
removes whitespace from the beginning and end of strings, string elements of lists, and string values in hashes, similar to the chomp operator

*) chomp modified to ignore arguments that are not a string, list, or hash
before it would throw an exception, which was unfriendly when run on NOTHING

*) += and -= operators updated to work more naturally when the lvalue is NOTHING
now += and -= use the right-hand-side's type when assigning to the lvalue if the lvalue is NOTHING, i.e. the following is now possible:

	my $str += "hello";                  # assigns "hello" to $str
	my $hash += ( "new-key" : "value" ); # assigns ( "new-key" : "value" ) to $hash
	my $float -= -4.5;                   # assigns -4.5 to $float

before this change $str and $hash would be = 0 and $float would be = -4.  This means that it's no longer necessary to assign a type to a variable before using the += and -= operators; they will behave more intuitively in these cases. 

*) "reference optimization" for temporary objects disabled on platforms where atomic reference operations are not available (Sparc, PA-RISC)
This optiimzation, designed to reduce the number of cache invalidations in SMP environments, leads to a race condition on platforms requiring a mutex lock for atomic reference operations.
It's possible for one thread to delete an object while another thread is holding the lock.  This can lead to memory corruption/segmentation faults on these platforms.
The fix was to disable the optimization if atomic reference operations are not supported (ie: without a mutex lock).

*) significant documentation updates
many more code examples added, including examples for all functions and classes in the main section (module docs not yet updated)
the Datasource class, DBI drivers, and encryption functionality were significantly expanded
many corrections were made

*) other bugfixes, updates, etc
see CHANGELOG for details


*******************************
RELEASE SUMMARY for qore v0.6.1
*******************************

this release is mostly a bug-fix release

*) bugs in HTTPClient class fixed
the Host: header is now set correctly; this bug prohibited connections form being made to HTTP 1.1 servers
path is set to "/" when otherwise empty
host number is set in the Host: field if not port 80

*) HTTPClient class improvements
chunked traqnsfer encoding accepted and correctly parsed
"deflate" and "gzip" content-encoding accepted and handled transparently

*) thread-resource tracking bugs fixed, particularly affecting the Datasource class
leaving uncomitted transactions open when the thread terminates would cause programs to crash in the previous version of qore

*) compression functions rewritten, gzip() and gunzip_to_string() and gunzip_to_binary() implemented
buffer sizes are automatically handled (and transparently resized internally if necessary); it's now possible to specify the string character encoding for *_to_string() functions

*) min() and max() functions implemented for lists
callback functions accepted to work on lists of complex dta types

*) unicode numeric character sequences decoded in HTTP contexts and in JSON strings

*) CDATA elements in XML strings are now handled correctly
CDATA elements are put in ^cdata^ hash keys when deserializing XML strings - no escape code processing is performed on this data
conversely, serialization to XML strings will handle ^cdata^ keys by creating CDATA elements

*) strtoint() function implemented, gmtime() and localtime() modified to return current time if no argument passed

*) other minor bugs fixed, see CHANGELOG for details


*******************************
RELEASE SUMMARY for qore v0.6.0
*******************************

*) major SMP performance increases
work was done to dramatically reduce the number of cache invalidations which results in a very significant performance increase (more than 2x for affected code paths) - this also affects single-threaded code running on SMP machines.  Basically due to these changes the CPUs are able to use their caches much more effectively, thus improving performance drastically.  This was done without sacrificing the clean threading model - from the qore user code/programming interface perspective no compatibility has been sacrificed; the language is simply faster.

Future releases will take this further and give even better performance increases.

*) stable shared-library interface, version 1.0
The qore library now exports a stable shared-library interface - this will be further improved in future release as internal implementation details of exported classes are further abstracted from the interface.

*) qore line-number reporting bug finally quashed
The bug where qore would report an incorrect line number with multi-line statements has finally been fixed - error messages now give the entire statement range where the error occured.  Furthermore parse error reporting has been further improved by making error messages more informative and readable.

*) internal JSON-RPC support
support for JSON-RPC has been added, including support for serializing and deserializing between qore data structures and JSON strings and a built-in JsonRpcClient class subclassed from the new HTTPClient class - see the 0.6.0 documentation for more details.

*) builtin HTTPClient, XmlRpcClient, and JsonRpcClient classes
the old qore-language HTTPClient and XmlRpcClient classes have been replaced with new high-performance internal versions.  The external API has been kept backwards-compatible as well.  The XmlRpcClient and JsonRpcClient classes are subclassed from the new HTTPClient class using qore's new support for builtin class hierarchies (in previous releases class hierarchies could only be implemented in qore code).

*) the switch/case statement accepts simple relational operators in case expressions

*) new functions: is_dir(), is_file(), is_executable(), is_readable(), is_dev(), etc
To verify file types easier

*) new single compilation unit build support, visibility tagging
g++ visibility tagging is used when possible allowing header files to clearly label API entry points as well as private interfaces.
Furthermore, when used with the default single compilation unit builds (where all files in a given directory are built together), the compiler can perform much better optimizations on the code.
Visibiility tagging also allows the symbol table size to be drastically reduced (particularly with templated objects) as symbols for private interfaces are not included in the shared library.

*) BEA Tuxedo (TM) module implemented
The full Tuxedo client API is available in qore if you have a licensed version of BEA Tuxedo installed, see the updated documentation for the "tuxedo" module

*) TIBCO synchronous client operation support added to "tibae" module
The "tibae" module added new methods to the TibcoAdapter class to support client-side synchronous operation calls

*) initial support for deadlock detection
Due to time constraints the deadlock solution was not universally applied to all user locks.  Complete deadlock detection (with qore threading primitives, including deadlocks with "synchronous" methods/functions) will be delivered in the next version of qore.
However some deadlocks are now detected and will cause an exception to be thrown and all locks of one thread to be released.

*) bug fixes, miscellaneous new functions, etc
see CHANGELOG and the updated qore 0.6.0 documentation for details


*******************************
RELEASE SUMMARY for qore v0.5.3
*******************************

* scanner and parser modified to accept direct specification of opaque binary objects using hexadecimal digits enclosed in angle brackets:
        ex: const bin = <a4b7297b>;

must be an even number of digits or a parse error will result

* new functions
  + hstat(), hlstat() - perform a "stat()" on a file/directory/etc and return a hash instead of a list - much easier to use output, including a "type" key, which gives the file type
  + makeHexString(), parseHexString() - to covert from a binary object to a hex string and vice versa

* performance improvements
temporary objects no longer cause a cache sync on deletion, use STL map when hash_map is not available, more use of STL map in other data structures for quicker lookups

* Solaris shared library fix
finally Solaris shared-library builds are working properly

* GetOpt class date parsing improvements
all Qore formats should also be parsable by the GetOpt class

* lots of bug fixes
deadlocks in several classes were fixed that happened after timeouts (Datasource, SingleExitGate classes)
bug in Datasource copy constructor
broken ncurses module fixed, initscr() is now optional


*******************************
RELEASE SUMMARY for qore v0.5.2
*******************************

*) ***CHANGE***: COMPATIBILITY WARNING: "tibco" module renamed "tibae"
the "tibco" module was renamed "tibae" to be consistent with the new "tibrv" module - see below
programs requiring the old "tibco" module should now use "%requires tibae"

*) ***CHANGE***: COMPATIBILITY WARNING: date/time handling changes
**WARNING**: int <-> date conversions are now done with 64-bit offset from Jan 1, 1970 00:00:00
previously int <-> date conversions were done with a not-very-useful direct conversion, like this:
  int(2006-01-01) => 20060101000000   (and vice-versa)

as of v0.5.2 integers converted to a date and dates converted to an integer will be based on the offset in seconds from January 1, 1970 (the UNIX epoch).   This is done with a 64-bit number so dates far in the past and future are supported.  Note that the date algorithms implement a "proleptic gregorian calendar"; that is; leap years are still calculated according to the Gregorian formula before the actual adoption of the Gregorian calendar in 1582 (in parts of Europe anyway), so date calculations before 1582 may not match with historical records (when the Julian calendar was used in Europe).

Date differences are now much easier to calculate, for example:
# calculate the number of seconds different between two dates:
$diff = int(2006-01-01) - int(2005-12-31);

this gives 86400 seconds = 1 day.  previsouly you had to use mktime() which would only work with 32-bit offsets, so dates far in the past or future would give erroneous answers.

While this could in theory introduce incompatibilies in qore scripts, I expect that it will not in practice.  The only time where this conversion was useful was for specifying dates, i.e.: $date = date(20060101000000), however this should be changed to the clearer format: $date = 2006-01-01 (or $date = 2006-01-01-00:00:00), or for the lazy, the string <-> date conversion logic remains unchanged, so this could still be written as: $date = date("20060101000000") (just add quotes around the integer dates);

**WARNING**: date/time arithmetic no longer takes daylight savings time into consideration
this is because the internal 64-bit algorithm is not time-zone/DST aware - the old algorithm used mktime().  If you need to do date arithmetic possibly over DST changes and it's important to take these changes into account, and your dates are within the UNIX epoch (before Jan 19 2038), then use qore's mktime() function instead.

**FIX**: subtracting one absolute date by another will now give a relative date giving the time difference, 
i.e.: $d = 2006-01-02 - 2006-01-01 = 1D
the resulting relative date is normalized to days, hours, minutes, seconds, and milliseconds (months and years are not of fixed length - the units below can be reliably interconverted)

Additionally, the scanner has been modified to only accept valid month, day, hour, minute, and second values (i.e. dates like 2006-13-45-34:78:89 will throw parse exceptions)

Other date changes (not expected to cause compatibility problems) are:
* millisecond subtraction fixed
* ISO 8601 date formats like 2006-01-01T10:00:00 are accepted (without the time zone component) as well as qore's format: 2006-01-01-10:00:00
* ISO 8601 relative date formats like P0001-02-01T01:01:01 are accepted (however qore's relative date format is arguably more readable)
* dates can be specified with an optional millisecond value, i.e.: 2006-01-01T10:00:00.502 for 502 seconds after Jan 1 2006 10:00 am
* relative milliseconds can be directly specified with <num>ms: i.e.: $date + 250ms;
* absolute dates printed with the %n or %N *printf format specification that include a millisecond value will be output with the millisecond value like "2006-01-01 10:00:00.502"
* relative dates printed with the %n or %N *printf format specification will take the following format: <time: x years x months x days x hours x minutes x seconds x milliseconds>
  units that are zero are not printed, unless all units are zero and then only <time: 0 seconds> is printed
* new date functions & support for calculating ISO-8601 calendar week information: getISOWeekHash(), getISOWeekString(), getDateFromISOWeek(), getDayNumber(), getDayOfWeek(), getISODayOfWeek(), get_years(), get_months(), get_days(), get_hours(), get_minutes(), get_seconds(), get_milliseconds()
* all qore functions and methods taking timeout values will now accept date/time values, i.e. Queue::pop(250ms) will timeout after 250 milliseconds.  If an absolute date is passed then the timeout value will be calculated based on the current date (this will probably be only rarely used).  The ability of these functions and methods to accept relative times is good for the programmer - if in doubt about the units, just use a relative time - i.e. Queue::pop(10s) will wait 10 seconds before timing out, however if a method or function expects larger units than those passed, passing smaller units will not magically make the timeout period respect a smaller time resolution (i.e. Datasource::setTransactionLockTimeout(90s + 500ms) will have the ms units truncated to give a value of 90 seconds)

*) New direct TIBCO Rendezvous support
Direct TIBCO Rendezvous sending and listening is now supported with the new "tibrv" module - as of this version it's now possible to build in tibrv support without tibae support (tibrv is also supported on OS X ppc and intel now as well)

To use the new TIBCO Rendezvous support use the "%use tibrv" directive to ensure that the functionality is loaded

Classes supplied by this module:
 + TibrvListener         - for listening to reliable messages
 + TibrvSender           - for sending reliable messages
 + TibrvCmListener       - for listening to certified messages
 + TibrvCmSender         - for sending certified messages
 + TibrvFtMember         - to implement a fault-tolerant node
 + TibrvFtMonitor        - to monitor a fault-tolerant group
 + TibrvDistributedQueue - to manage certified messages in a distributed queue

NOTE: we do not send native Rendezvous arrays - we use the old style "multiple fields with the same name" approach to have more flexible arrays (different datatype in each element, etc).   Native Tibrv arrays are decoded properly when received.

automatic type mapping:
  TIBRVMSG_BOOL <-> boolean
  TIBRVMSG_I8,U8,I16,U16,I32,U32,I64,U64 -> int (note there is a loss of precision with the U64 -> int conversion)
  int -> TIBRVMSG_I64
  TIBRVMSG_F32,F64 -> float
  float -> TIBRVMSG_F64
  TIBRVMSG_DATETIME <-> date
  TIBRVMSG_OPAQUE <-> binary
  TIBRVMSG_STRING -> string     (strings are marked with the default encoding for the object)
  string -> TIBRVMSG_STRING     (encoding conversions are made if necessary to the encoding set for the object)
  TIBRVMSG_XML -> string        (to explicitly send this type, use the tibrv_xml() function)
  TIBRVMSG_IPPORT16 -> int      (to explicitly send this type, use the tibrv_ipport16() function)
  TIBRVMSG_IPADDR32 -> string   (produces a string like "192.168.1.1" - to explicitly send this type, use the tibrv_ipaddr32() function)

to do explicit qore->tibrv type mapping, use the following helper functions supplied by the module:
  tibrv_i8()
  tibrv_u8()
  tibrv_i16()
  tibrv_u16()
  tibrv_i32()
  tibrv_u32()
  tibrv_i64()
  tibrv_u64()
  tibrv_f32()
  tibrv_f64()
  tibrv_ipport16()
  tibrv_ipaddr32()  - note: takes a string argument like "192.168.1.1"
  tibrv_xml()
  tibrv_bool()

set certificates for secure daemons using tibrvSetDaemonCert() and tibrvSetUserCertWithKey() using the SSLCertificate and SSLPrivateKey classes.  Note that these functions are only available if your tibrvcpp library was compiled with secure daemon support.  See BUILD for more information.

*) strong encryption and digest support
added SSLCertificate and SSLPrivateKey classes - the constructors for these classes expect a text file in PEM format defining the appropriate object.  Detailed information about the objects can be retrieved using member functions, see the updated qore v0.5.2 documentation for details.

Added new functions supporting strong cryptography:
 *** BLOWFISH 
   + blowfish_encrypt_cbc()
   + blocfish_decrypt_cbc()
   + blowfish_decrypt_cbc_to_string()
 *** DES and DESX (including multiple-key algorithms)
   + des_encrypt_cbc()
   + des_decrypt_cbc()
   + des_decrypt_cbc_to_string()
   + des_ede_encrypt_cbc()
   + des_ede_decrypt_cbc()
   + des_ede_decrypt_cbc_to_string()
   + des_ede3_encrypt_cbc()
   + des_ede3_decrypt_cbc()
   + des_ede3_decrypt_cbc_to_string()
   + desx_encrypt_cbc()
   + desx_decrypt_cbc()
   + desx_decrypt_cbc_to_string()
 *** RC4
   + rc4_encrypt()
   + rc4_decrypt()
   + rc4_decrypt_to_string()
 *** RC2
   + rc2_encrypt_cbc()
   + rc2_decrypt_cbc()
   + rc2_decrypt_cbc_to_string()
 *** CAST5
   + cast5_encrypt_cbc()
   + cast5_decrypt_cbc()
   + cast5_decrypt_cbc_to_string()
 *** RC5
   + rc5_encrypt_cbc()
   + rc5_decrypt_cbc()
   + rc5_decrypt_cbc_to_string()

added digest functions: MD2(), MD4(), MD5(), SHA(), SHA1(), DSS(), DSS1(), RIPEMD160(), MDC2()

NOTE: when the digest functions are run on strings, the trailing null character is not included in the digest calculation.  however, when the cryptographic functions are run on strings, the trailing null is included, so that strings can be decrypted with the trailing null.

*) new Socket methods supporting TLS/SSL communication with strong encryption
making or accepting TLS/SSL connections is nearly transparent with the new Socket class changes.  Instead of Socket::connect() you would use Socket::connectSSL().  Instead of Socket::accept() you use Socket::acceptSSL() (requires setting a certificate and private key using the SSLCertificate and SSLPrivateKey classes and the Socket::setCertificate() and Socket::setPrivateKey() classes)

Once a TLS/SSL connection has been established on a socket, subsequent reads and writes using the standard Socket methods will be done using the equivalent SSL functions in a manner transparent to the programmer.

new methods:
  + Socket::connectSSL()              - makes a TLS/ SSL connection to a remote socket
  + Socket::acceptSSL()               - accepts a connection on a socket and negotiates a TLS/SSL session
  + Socket::shutdownSSL()             - shuts down an active TLS/SSH session by sending the "close notify" shutdown alert to the peer
  + Socket::setCertificate()          - associates a certificate with a socket
  + Socket::setPrivateKey()           - associates a private key with a socket
  + Socket::verifyPeerCertificate()   - returns a verification code describing the state of the peer's certificate
  + Socket::isSecure()                - returns True if a secure connection has been established
  + Socket::isOpen()                  - returns True if the socket is open
  + Socket::getSSLCipherName()        - returns the name of the encryption algorithm for secure connection
  + Socket::getSSLCipherVersion()     - returns the version of the encryption algorithm for secure connection

*) the FtpClient class has been modified to support the ftps protocol according to RFC-4217
a RFC-4217 compliant secure connection will be made if the protocol in the URL is set to "ftps" or if the setSecure() method is called before connect()

new FtpClient methods:
  + FtpClient::setSecure()                - will try to make an RFC-4217 compliant secure control and data connections to the server
  + FtpClient::setInsecure()              - will try to make unencrypted connections to the server
  + FtpClient::setInsecureData()          - will try to make unencrypted data connections to the server even if the control connection is secure
  + FtpClient::isSecure()                 - returns True if a secure control connection has been established
  + FtpClient::isDataSecure()             - returns True if the data connection is secure
  + FtpClient::getSSLCipherName()         - returns the name of the encryption algorithm for ftps connections
  + FtpClient::getSSLCipherVersion()      - returns the version of the encryption algorithm for ftps connections
  + FtpClient::verifyPeerCertificate()    - verifies the peer's certificate for ftps connections
  + FtpClient::setModeAuto()              - sets the object to automatically try EPSV, PASV, and PORT for the data connection
  + FtpClient::setModeEPSV()              - sets the object to only try EPSV mode for the data connection
  + FtpClient::setModePASV()              - sets the object to only try PASV mode for the data connection
  + FtpClient::setModePORT()              - sets the object to only try PORT mode for the data connection

*) "oracle" driver improvements
the select() and selectRows() methods both support binding data directly in queries with the same syntax as with exec()
for example:
my $result = $oradb.select("select * from table where value = %v", $value);

*) "mysql" driver improvements
The "mysql" module now supports directly binding data and retrieving values from queries in the qore DBI syntax (already supported by the "oracle" module) - also the select() and selectRows() DBI methods support value binding as well
for example, using the test database as given in examples/mysql-test-db.sql and the following stored procedure:
delimiter //
create procedure get_family (in id int, out fname varchar(32))
begin
   select name into fname from family where family_id = id;
end;
//

executing:
$h = $mysqldb.exec("call get_family(%v, :name)", 1);

will return ( "name" : "Smith" )

*) improved XML serialization and deserialization
mixed elements and text can now be serialized and deserialized without data loss (except whitespace is still not retained) - for example, now it's possible to deserialize (parse) a docbook xml file and then reserialize it (generate the XML from the Qore data structure) without losing information (this was not possible with previous versions of qore).

*) 64-bit build support on x86_64 (AMD64, etc)
native 64-bit binaries can now be built on Linux x86_64 - the build system has been modified to be able to correctly find paths and set directory names for 64-bit libraries if the --enable-64bit configure option is used.  By default 64-bit builds are made on x86_64 CPUs unless the --disable-64bit option is passed to the configure script

*) %requires error reporting improved
if any requested features cannot be loaded, then only exceptions related to missing features will be reported.  this avoids possibly hundreds (or more) exceptions in large programs where features cannot be loaded (i.e. unresolved classes, functions, etc)

*) new warning framework
enable warnings from the command-line with "-W" or from qore code with the new parse directives: %enable-all-warnings and %enable-warning <warn>.  Disable warnings from qore code with %disable-warning <warn>
initial warnings are: 
   duplicate-local-vars
   warning-mask-unchanged
   unknown-warning
   undeclared-var
   duplicate-global-vars
   unreachable-code

Other new command-line flags related to warnings: -r: treat warnings as errors, -A: lock warnings
The %lock-warnings parse directive and the PO_LOCK_WARNINGS parse option were implemented in order to ensure that warning levels can't be changed when this option is set

*) parse restrictions enforced for classes
all classes tagged with capabilities and the capabilities are checked against the parse options when the new operator is parsed and when inherited classes are declared
new parse restrictions: PO_NO_DATABASE (parse directive: %no-database), PO_NO_THREAD_CONTROL (%no-thread-control), PO_NO_THREAD_CLASSES (%no-thread-classes)
note that PO_NO_THREADS is now equivalent to PO_NO_THREAD_CONTROL | PO_NO_THREAD_CLASSES

*) internal qore class API significantly simplified and streamlined
it is now much easier to develop qore classes in c++ with the new API

*) lots of bug fixes, etc
see CHANGELOG for details


*******************************
RELEASE SUMMARY for qore v0.5.1
*******************************
*) PCRE (Perl-Compatible Regular Expression) support added
All regular expression operations in Qore are now performed using the PCRE library, meaning that regular expressions in Qore should be much more perl compatible and finally consistent on all platforms.
new flags for matching and substitution:
	/i = ignore case
	/s = makes a dot (.) match a newline character
	/x = extended matching
	/m = multiline matching

Subpattern backreference substitutions are now supported, i.e.:
	$str = "abc def";
	$str =~ s/(\w+) +(\w+)/$2, $1/;
	# now $str = "def, abc"

Regular expressions are now parsed one time at parse time (in previous versions of Qore using POSIX regular expression support, the regular expressions were parsed every time they were executed which was very inefficient).

*) UTF-8 multi-byte character support fixed - character offsets now used instead of byte offsets for multi-byte strings
Qore now assumes character offsets instead of byte offsets for multi-byte characters in: substr(), splice operator with strings, index(), rindex(), length()
NOTE: length() and strlen() will now return different values for strings with multi-byte characters.
The ord() function still accepts only byte offsets and returns single-byte values.

*) transliteration operator implemented, i.e.:
	$str =~ tr/abc/123/;
        $str =~ tr/a-z/A-Z/;
note that this operator is not yet multi-byte charset aware for range specifications

*) support for non-threading build of qore removed
had been broken for a long time anyway.  from now on optimizations will be concentrated on the single multi-threaded version of qore

*) rindex() semantics fixed
The optional offset value works like perl's rindex offset - if present, it specifies the character offset from which the reverse search will begin - starting at that character to the beginning of the string.

*) bindex() and brindex() functions added
give byte offsets into strings when a match is found.

*) new function "regex_subst()" added
allows regular expression substitution to be performed with patterns potentially generated at run-time

*) new constants added for regex() and regex_subst()
	RE_Caseless  - sets caseless matching
	RE_DotAll    - makes a dot (.) match a newline character
	RE_Extended  - extended matching
	RE_MultiLine - enables multiline matching

*) libz-based compression function support added
compress(), compress2(), uncompress_to_string(), and uncompress_to_binary() functions added to allow for compressing and uncompressing data

*) the "elements" operator modified to work on binary and string types
returns the number of bytes in a binary object
returns the number of characters in a string

*) the "-" and "-=" operators updated to delete keys from hashes
ex: $hash - "string" or $hash -= "string"
will remove the key "string" from the hash if it exists.  note that this will only dereference the value at that key, so if the value is an object and this is not the last reference to the object, the object will not be deleted.

* implemented "instanceof" operator
like Java's operator of the same name

*) implemented %= (modula-equals), *= (multiply-equals), /= (divide-equals), ^= (xor-equals), <<= (shift-left-equals), and >>= (shift-right-equals) operators

*) fixed bugs in the |=, &=, +=, and -= operators
the precision was artificially restricted to 32 bits

*) "shift" and "unshift" can now be used as function and method names

*) Oracle driver fixed to not throw parse exceptions when the ":" character is not followed by an alphabetic character
so ":=" is legal in SQL statements again :-)

*) added VARCHAR, CLOB, BLOB, DATE constants
to be used in Datasource::exec() and Datasource::vexec() calls to specify placeholder buffer types.

*) modified Oracle driver to accept an integer as a placeholder bind argument
To be used as an easy way to specify the length of a string buffer to bind - otherwise the maximum length is set by default to 512 bytes, which will cause a run-time exception to be thrown if a longer string is attempted to be bound to the buffer.

*) optional timeout values in ms implemented for Queue::pop() and Queue::get() methods

*) copy-on-write implemented for class definitions in subprograms
performance & memory efficiency improvement when creating subprograms (Program objects)

*) module subsystem enhacements
any program can use "%requires" at any time.

*) bug fixes and other miscellaneous enhancements
see CHANGELOG for details


*******************************
RELEASE SUMMARY for qore v0.5.0
*******************************
*) the release documentation has been greatly improved with this release; all Qore features, functions, classes are documented, see the qore.html file included with the release, or http://qore.sourceforge.net/?manual=1

*) deprecated "file" type removed, use the File class instead
the following functions have been removed, use File methods instead:
	fprint()        File::print()
	fprintf()       File::printf()
	f_fprintf()     File::f_printf()
	vfprintf()      File::vprintf()
	create_file()   File::open("name", O_CREAT | O_WRONLY)
	close_file()    File::close()
	open()          File::open()
	close()         File::close()
	readline()      File::readLine()
	fflush()        File::sync()
	eof()           N/A: test read return values

the following global variables have been removed:
	$STDERR, $STDOUT

the following constants have been implemented to replace them:
	stdout, stdin, stderr   - all objects of type File

the following new methods have been implemented in the File class:
	File::vprintf()
	File::f_printf()
	File::f_vprintf()

*) exception handling semantics changed and "rethrow" statement implemented
as of this release, catch blocks may only declare one parameter which will receive the exception hash.  user information is stored in the err, desc, and arg keys.  if a list is thrown, the elements of the list will be assigned to the new "err", "desc", and "arg" keys of the exception hash.  any type of value(s) can be thrown, but lists are mapped as described above.  If a list longer than 3 elements is thrown, then elements 2 - the remainder of the list are mapped to a new list assigned to the "arg" key of the exception hash.  If only one argument is thrown, it is mapped to the "err" key of the exception hash.
If no parameter is declared in the catch block then the exception information cannot be accessed in the catch block (however it can be rethrown, see the "rethrow" statement below).
The automatic $argv variable is no longer assigned in catch blocks.
The exception hash is otherwise the same as before.
System exceptions always populate the err and desc keys, and never the arg key.
    old syntax:
	try {
	    throw "ERROR", "description", new Info();
	}
	catch ($ex, $err, $desc, $arg)
	{
	    printf("exception at %s:%f: %s: %s (arg=%N)", $ex.file, $ex.line, $err, $desc, $arg);
	}

    new syntax:
	try {
	    throw "ERROR", "description", new Info();
	}
	catch ($ex)
	{
	    printf("exception at %s:%f: %s: %s (arg=%N)", $ex.file, $ex.line, $ex.err, $ex.desc, $ex.arg);
	}

the "rethrow" statement (taking no arguments) was implemented and can only be used in a catch block.  This statement will cause the current exception to be rethrown, and an entry is added on the call stack tagged as a rethrow entry (i.e.: $ex.type == "rethrow").  
This allows programs to maintain a coherent call stack even when exceptions are handled with one or more catch blocks.

*) Socket class method changes - consistent error handling for all Socket methods
socket errors will throw exceptions, when a read or write is attempted on a closed socket.  for example, if the other side closes the connection: a SOCKET-CLOSED exception is thrown, for socket read errors a SOCKET-RECV-ERROR exception is thrown.
Timeouts cause NOTHING to be returned.
These changes were made because some methods (like Socket::readi4() for example) could return a -1 value as a legitimate read - to make socket handling consistent across all qore Socket methods.
This will requre changes in almost all socket code in qore - I apologize for the inconvenience, but the changes were necessary to have a consistent socket API and to allow all socket methods to handle communications errors (previously it was not possible to catch errors in the Socket::readi*() methods, for example).

*) Module optimizations and reorganization
The XML module has been merged into qore: qore can no longer be built without libxml2 support.
The FtpClient module has also been merged into qore - there are no particular dependencies on this class anyway to justify it being a module.
Qore modules now need to declare their API conformity level and will be explicitly initialized.
Note that older qore modules used an OS-level mechanism for automatically initializing themselves, and, since the internal API is not yet clever enough to detect duplicate internal symbols, the older qore modules will register themselves with the qore runtime engine, which, in the case of the FtpClient and XML modules, can cause core dumps or other errors when the duplicate symbols are referenced.  Therefore older qore modules cannot be used with this version of qore.
The default module directory has been changed to pgklibdir-version, meaning that, if your --prefix=/usr, the module directory will now be /usr/lib/qore-0.5.0
Modules installed in the "auto" subdirectory of the module directory (and any modules in the directories listed in the QORE_AUTO_MODULE_DIR environment variable) will be automatically loaded when qore starts, before any parsing begins.
Other modules (in the root module directory) must be loaded with the %requires directive (see next point)

*) %requires directive for explicitly listing qore feature requirements
the "%requires" directive will attempt to load a module of the same name if the named feature is not already present in qore.
Modules are searched in the directories in colon-separated order listed in the QORE_MODULE_DIR environment variable and then in the pgklibdir-version (/usr/lib/qore-0.5.0 in the example above) directory.
Modules must have the same file name as the object of the "%requires" directive and must have the extension ".qmod"
The following modules must be explicitly loaded with %requires in a shared build of qore:
	tibco
	ncurses (still experimental)

*) Oracle driver enhancements
there is a new DB-independent Datasource::exec() syntax (although so far only the Oracle driver has been modified to support it).  In Oracle *LOB columns are supported for binding and passing values through ::exec().  The syntax is somewhat similar to *printf() except %v is used for all value types:
For example, to bind values in a generic SQL statement:
$ds.exec("insert into table values ( %v, %v, %v, %v, %v, %v )", binary($data), "string", 12345, True, now(), 1.43);
for Oracle, values are bound as follows:
	Type::Binary   = SQLT_BIN  (can be a BLOB for example)
	Type::String   = SQLT_STR
	Type::Integer  = SQLT_INT or SQLT_STR  (int > 32-bits = SQLT_STR, <= 32-bit int = SQLT_INT)
	Type::Boolean  = SQLT_INT  (1 or 0)
	Type::Float    = SQLT_FLT
	Type::Date     = SQLT_DAT

attempts to bind other types will result in a run-time exception.

To retrieve values from a stored procedure or function, you must specify placeholder with a syntax more similar to Oracle's as follows:
$hash = $ds.exec(begin stored_procedure_name('Literal String', :param1, :param2, param3); end;");

The placeholders are the :param* elements in the string, and will correspond to the keys in the result hash (without the leading ':' character).  If no types are defined by arguments following the string, then they default to strings with a maximum length of 512 bytes.  To retrieve other types or longer string values using placeholders, you have to include arguments after the string, one argument for each placeholder.  The arguments should be the data type for the bind as follows:
	Type::Binary  = BLOB
	"clob"        = CLOB
	Type::String  = SQLT_STR
	Type::Integer = SQLT_INT  (returns a 32 bit integer)
	Type::Float   = SQLT_FLT
	Type::Date    = SQLT_DAT
	Type::Hash    = SQLT_RSET (for result sets, stored procs that return cursors, etc)

This new syntax is meant to be driver-independent, so, for example, when the MySQL driver is updated to take advantage of MySQL 5.0 features like stored procedure execution, support for this syntax will be implemented as well.

*) splice, push, and pop list operators implemented
do not use parentheses directly after the operator keywords, if you do, qore will assume you want to call a function of the same name.
Generally this is another point where qore differs philosophically from perl.  In qore, operators can change lvalues directly, but functions must be explicitly passed references to change lvalues.
qore's splice operator works like perl's splice function
    i.e.: $l = (1, 2, 3);

    INCORRECT usage of the splice operator:
	splice($l, 1, 1);   # <- WRONG! this will try to call qore function "splice()", which can never change the value of $l in qore

    CORRECT example:
	splice $l, 1, 1;    # RIGHT! now $l = (1, 3) 

The same is true of the push and pop operators.  splice, push, and pop are all special keywords in qore in that they can also be used as function and method names.  The qore parser determines if you want to use the operator by checking if these special keywords are followed by an open parenthesis.  If so, then qore assumes you want to execute a function of the same name.

qore's push operator will add one element to the end of a list - to concatenate lists in qore use the + operator.  Note that this differs from perl's "push" function.
qore's pop operator removes the last element from a list and returns that element (i.e. it works like perl's pop function)

Note that all three operators (like all qore operators) perform thread-atomic operations - no explicit locking is needed in multithreaded programs to guarantee the atomicity of these operations.
Note also that the splice operator in qore works on strings as well as lists.

*) internal Gate class replaced with a more efficient RMutex class
the RMutex class is based on a recursive pthread lock; as this is the locking element most often used in Qore to ensure atomicity and thread-safety, this change should bring about a performance increase overall for Qore programs (even single-threaded ones)

*) ncurses classes
Some ncurses functions and classes (Window and Panel) have been added.  See examples in test/ncurses.q, examples/hanoi.q, examples/worm.q.  Note that threading is enabled but still highly experimental with qore ncurses programs.
Use "%requires ncurses" in qore programs that would like to use ncurses functionality.
This module is still experimental.

*) private inheritance has been implemented
ex: class MyClass inherits private Mutex;

With private inheritance methods of the parent classes can only be executed from within the class.  Any attempt to execute a method of a privately inherited class from outside the class will result in a run-time exception.  However the inheriting class has no restrictions on accessing members or methods of parent classes - private inheritance only affects access of instantiated objects from outside the class.

*) Datasource::selectRows() implemented returning a list of hashes
sometimes it's more convenient to work with a list of hashes, rather than the hash of lists as returned by the Datasource::select() method.  The Oracle and MySQL drivers have been updated with support for this new DBI method (however it's not implemented for old versions of MySQL without the prepared statement interface)

*) Datasource::vexec() implemented to allow a variable-length list of arguments to be passed

*) parseXMLRPCResponse(), parseXMLRPCCall(), and parseXMLRPCValue() implemented as native functions
now XML-RPC support is much better integrated in qore (and much faster).  The old user functions in examples/xmlrpc.ql have been removed.

*) HTTPServer.qc and HTTPClient.qc updated to perform HTTP 1.1 compliant connection handling
Now the HTTPServer class is a little closer to being actually HTTP 1.1 compliant :-)

*) build system updated to delete binary versions of modules
it's no longer required to include --disable-static in the configure command-line to keep useless static versions of qore modules from being built (however if you don't need the static library, the build should be about twice as fast with --disable-static)

*) added Socket::shutdown() method

*) added a Queue::pop() method so the Queue class can be used as a blocking and thread-safe stack

*) MySQL driver fixed to use the more efficient prepared statement interface when available
there was a bug in the driver causing it to always use the older character-based interface even when the prepared statement interface was available; this has been fixed

*) the SQL subsystem is no longer optional
DBI drivers are still optionally-compiled, but it will no longer be possible to build qore without SQL infrastructure support

*) other new functions, methods, backwards-compatible changes to existing methods, and lots of bug fixes
see CHANGELOG for details


*******************************
RELEASE SUMMARY for qore v0.4.3
*******************************
*) XML parsing and generation bugs fixed along with some memory leaks plugged...

*) *_thread_data() functions no longer accessible in programs with the PO_NO_THREADS option enabled

*) many run-time class inheritance fixes

*) Socket class bug fixes for server processes

*) Type::* constant values are now strings instead of unpredictable integers

*) HP-UX build fixes
still not 100% out-of-the-box supported, but coming soon...

*) core dump, memory leaks, Oracle stored proc execution fixes, and many other changes and fixes
for details see the CHANGELOG


*******************************
RELEASE SUMMARY for qore v0.4.2 
*******************************

*) objects and references
objects are always passed by reference now - like Java.  They are only copied if the special ::copy() method is explicitly executed, and the class supports copying.  This change was necessary to facilitate pure Object-Oriented programming.  The ::copy() method exists for every object as a system method, but can be overridden - to prevent an object from being copied, define a copy() method and throw an exception in it...

*) class inheritance
multiple class inheritance is supported; the basic syntax is:

	class [namespaces::...]class_name inherits [namespaces::...]class_1[, class 2 ...];

You can also give explicit arguments to base class constructors with a C++-like syntax, and you can override base class constructor arguments in subclasses withthe same syntax if desired.  see examples/inherit.q for more information.   Also see examples/XmlRpcClient.qc for another, more practical, example - the XmlRpcClient class is now a child of the HTTPClient client and gives explicit arguments to the HTTPClient constructor...

*) private class member support
references to private class members outside the class will cause an exception to be thrown.  declare like this (only in in-line class declarations):
	private $.mem_1[, $.mem_2 ...];

*) *LOB support in Datasource::select() in the Oracle driver
the 128K limit for CLOBs is now gone and BLOBs will now be selected as binary objects.  However I have found what I believe is a bug in Oracle 9i where even if you are trying to stream CLOB data you have to allocate a buffer bigger than the CLOB you are trying to stream or you will get an "ORA-24812: character set conversion to or from UCS2 failed" error (I saw this on Saolaris with a 9i client and 9i server), to change the buffer size in modules/oracle/oracle.h with the LOB_BLOCK_SIZE define (currently it's set at 32K as a compromise - not ideal for working streaming like with 10g, but medium large for the broken versions...)

*) internal GetOpt class support
works the same as the old GetOpt user class delivered in the examples directory, see the new examples/getopt.q script for more information

*) new command-line options
--exec-class (-x), taking an optional class name argument, will instantiate the class with the same same as the Qore script (override by giving an argument).  This option also turns on --no-top-level.  To be used for more pure OO programming.

*) much improved reference support
References are not quite universally supported, but getting closer; now recursive local variable reference expressions are supported as well as references to object members (i.e.: do_something(\$.var_name)) - these are now also properly supported in background expressions.

*) XML generation improvements, bug fixes
Generating formatted XML will give better-formatted XML, also empty elements will be output in the recommended short form (<node/> rather than <node></node>)

*) binary integer support in the Socket class
Socket::sendi1(), ::sendi2(), and ::sendi4() (and associated ::readi*() methods) have been implemented; they respect network byte order.

*) deprecated socket_* functions removed
use the Socket class instead...

* many miscellaneous bug fixes
see CHANGELOG for details


*******************************
RELEASE SUMMARY for qore v0.4.0
*******************************

*) mysql driver substantially updated  
It now supports threading, proper character set handling, transactions, and uses the more efficient prepared statement interface.

*) C/C++-style switch/case statement implemented
by popular demand :-).  The syntax is the same as the C/C++ statement of the same name, except that case values can be any expression non requiring run-time evaluation (any expression you can assign to a constant can be used as a case expression).

*) list assignment implemented
ex: ($a, $b, $c) = (1, 2, 3); 
does what you would expect.  Lists assignments in qore work (as far as I could tell by my testing) just like list assignments in perl.  The lvalues on the left-hand side of the assignment can be any valid lvalue expression.

*) "our" and "my" accept lists, "our" can appear anywhere
it's now possible to declare lists of local and global variables by putting a list of variables after "my" or "our", like:
my ($a, $b, $c);
our ($a, $b, $c);

*) elements in "foreach" can modify the list argument by using a reference
ex: 
--
$l = (1, 2);
foreach my $e in (\$l)
   $e = sprintf("str-%d", $e);
-- 
afterwards $l will be ("str-1", "str-2");

*) new command-line options "-e" (--exec) and "-m" (--show-module-errors)
-e allows a qore program to be given on the command line, and -m can be used to see if there are errors loading qore modules

*) empty programs do not throw a parse error

*) system() does a fork() and exec() if no shell meta-characters are present
means more efficent system() execution

*) imported functions can be exported to subprogram objects

*) new File::printf() and Socket::isDataAvailable() methods

*) Socket::recv*() methods accept negative or extremely large arguments safely

*) Socket::recv*() methods accept an optional timeout value in milliseconds after the buffer argument
With this change it's possible to do non-blocking I/O with Qore sockets

*) Socket::bind() can reuse socket addresses
Socket::bind() now takes a boolean argument after the socket specifier, if this is True, then the socket option SO_REUSEADDR will be set on the socket, meaning that even if the socket has not been 100% closed it can be opened and bound to (for example, if the socket is still in a TIME_WAIT state because the socket was closed while there were open client connections)

*) lists (and hashes) can end with a trailing comma
makes it easier to comment out the last element in a list or hash

*) new functions added
mkdir(), chmod(), rmdir(), pow(), hypot(), sqrt() functions added

*) STL hash_map used to accellerate hash lookups
on supported platforms

*) lots of bug fixes
see the CHANGELOG for details
