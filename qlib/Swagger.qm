# -*- mode: qore; indent-tabs-mode: nil -*-
#! @file Swagger.qm Swagger: https://swagger.io/, OpenAPI: https://github.com/OAI/OpenAPI-Specification

/*  Swagger.qm Copyright (C) 2017 Qore Technologies, s.r.o.

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

%new-style
%enable-all-warnings
%require-types
%strict-args

# make sure we have the required qore version
%requires qore >= 0.8.13

# try importing JSON and YAML modules
%try-module json
%define NoJson
%endtry

%try-module yaml
%define NoYaml
%endtry

%try-module xml
%define NoXml
%endtry

# need mime definitions
%requires(reexport) Mime >= 1.3.4.1
# requires the Util module
%requires(reexport) Util >= 1.3
# requires the HttpServerUtil module
%requires(reexport) HttpServerUtil >= 0.3.12
# requires the RestSchemaValidator module
%requires(reexport) RestSchemaValidator >= 1.0

module Swagger {
    version = "0.1.0";
    desc = "Swagger module providing functionality for Swagger 2.0 schema definitions";
    author = "Ondrej Musil <ondrej.musil@qoretechnologies.com>, David Nichols <david.nichols@qoretechnologies.com>";
    url = "http://qore.org";
    license = "MIT";
}

/** @mainpage Swagger module

    @tableofcontents

    @section swaggerintro Swagger Module Introduction

    The %Swagger module provides a <a href="https://swagger.io/">Swagger 2.0 REST API validation API</a> to %Qore.

    Primary classes provided by this module:
    - @ref Swagger::SwaggerObject "SwaggerObject"

    JSON and YAML serialization and deserialization are supported, XML is currently not supported.

    @section swagger_relnotes Swagger Module Release Notes

    @subsection swagger_1_0 Swagger v1.0

    - initial release of the Swagger module
*/

#! main namespace for all public Swagger declarations
public namespace Swagger {
#! Valid integer type formats
public const ValidIntFormats = ("int32", "int64");
#! Valid number type formats
public const ValidNumberFormats = ("double", "float");
#! Valid string type formats
public const ValidStringFormats = ("binary", "byte", "date", "date-time", "password");

#! A hash of valid integer type formats
public const ValidIntFormatsHash = map {$1: True}, ValidIntFormats;
#! A hash of valid number type formats
public const ValidNumberFormatsHash = map {$1: True}, ValidNumberFormats;
#! A hash of valid string type formats
public const ValidStringFormatsHash = map {$1: True}, ValidStringFormats;

#! supported mime types for de/serializing data
public const MimeDataTypes = {
%ifndef NoJson
    MimeTypeJson: (
        "serialize": \make_json(),
        "serialize_verbose": string sub (hash h) {return make_json(h, JGF_ADD_FORMATTING);},
        "deserialize": \parse_json(),
        "module": "json",
    ),
%endif
%ifndef NoYaml
    MimeTypeYamlRpc: (
        "serialize": \make_yaml(),
        "serialize_verbose": string sub (hash h) {return make_yaml(h, BlockStyle);},
        "deserialize": \parse_yaml(),
        "module": "yaml",
    ),
%endif
    # Content-Type: application/x-www-form-urlencoded
    MimeTypeFormUrlEncoded: (
        "serialize": \mime_get_form_urlencoded_string(),
        "serialize_verbose": \mime_get_form_urlencoded_string(),
        "deserialize": \mime_parse_form_urlencoded_string(),
    ),
    # Content-Type: multipart/form-data (handled manually)
    MimeTypeMultipartFormData: {},
};

#! modules available for data serialization and/or deserialization
public const SerializationModules = map $1.module, MimeDataTypes.iterator(), $1;

#! MIME types for data serialization
public const MimeContentTypes = keys MimeDataTypes;

#! Valid transfer protocol schemes.
public const ValidSchemes = ("http", "https", "ws", "wss");
public const ValidSchemesHash = map {$1: True}, ValidSchemes;

#! Base class for the Swagger specification objects, wrapping the vendor extensions.
class ObjectBase {
    public {
        #! Allows extensions to the Swagger Schema.
        /**
            The field name MUST begin with \c x-, for example, \c x-internal-id.
            The value can be \c null, a primitive, an array or an object.
         */
        hash vendorExtensions;
    }

    #! Constructor.
    public constructor() {
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing the object
     */
    public constructor(hash oh) {
        initialize(oh);
    }

    #! copy constructor
    constructor(ObjectBase other) {
        vendorExtensions = other.vendorExtensions;
    }

    #! Initialize.
    /**
        @param oh deserialized hash from the source schema description
     */
    public initialize(hash oh) {
        vendorExtensions = map {$1.key: $1.value}, oh.pairIterator(), $1.key =~ /^x-/;
    }
}

#! Base used by @ref OtherParameter, @ref ItemsObject, @ref HeaderObject and @ref SchemaObject.
class SchemaBase {
    public {
        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.2.
        *float maximum;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.3.
        *float minimum;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.2.
        *bool exclusiveMax;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.3.
        *bool exclusiveMin;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.1.
        *int maxLength;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.2.
        *int minLength;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.2.3.
        *string pattern;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.2.
        *int maxItems;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.3.
        *int minItems;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.4.
        *bool uniqueItems;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.1.
        hash<string, bool> enum;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.1.1.
        *float multipleOf;
    }

    #! Constructor.
    /** @param objType the type of object
        @param oh deserialized hash from the source schema description
     */
    public constructor(string objType, hash oh) {
        optional_field(objType, oh, "maximum", (NT_FLOAT: True, NT_INT: True), \maximum);
        optional_field(objType, oh, "minimum", (NT_FLOAT: True, NT_INT: True), \minimum);
        optional_field(objType, oh, "exclusiveMaximum", NT_BOOLEAN, \exclusiveMax);
        optional_field(objType, oh, "exclusiveMinimum", NT_BOOLEAN, \exclusiveMin);
        optional_field(objType, oh, "maxLength", NT_INT, \maxLength);
        optional_field(objType, oh, "minLength", NT_INT, \minLength);
        optional_field(objType, oh, "pattern", NT_STRING, \pattern);
        optional_field(objType, oh, "maxItems", NT_INT, \maxItems);
        optional_field(objType, oh, "minItems", NT_INT, \minItems);
        optional_field(objType, oh, "uniqueItems", NT_BOOLEAN, \uniqueItems);
        optional_field(objType, oh, "enum", SwaggerListToSet, \enum);
        optional_field(objType, oh, "multipleOf", (NT_FLOAT: True, NT_INT: True), \multipleOf);
    }

    #! Copy constructor
    constructor(SchemaBase other) {
        self += map {$1: other.$1}, (
            "maximum", "minimum", "exclusiveMax", "exclusiveMin",
            "maxLength", "minLength", "pattern", "maxItems", "minItems",
            "uniqueItems", "enum", "multipleOf"), exists other.$1;
    }

    #! validates the value against the schema definition
    private check(bool serialize, bool request, string type, *ItemsObject items, string path, string method, string name, reference value) {
        # accept a single value for an array (= one-element list)
        if (type == "array")
            checkArrayParam(serialize, request, items, path, method, name, \value);
        else
            checkIntern(serialize, request, type, path, method, name, value, \value);
    }

    #! validates string values
    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, string v, reference<string> value) {
        if (type != "string")
            throwInvalidType(name, "string", type);

        checkStringIntern(path, method, name, value);
    }

    private checkStringIntern(string path, string method, string name, data value) {
        if (exists maxLength && value.size() > maxLength)
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y is too long (maxLength: %d, actual: %d)",
                    name, path, method, maxLength, value.size());
        if (exists minLength && value.size() < minLength)
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y is too short (minLength: %d, actual: %d)",
                    name, path, method, minLength, value.size());
        if (exists pattern && value.typeCode() == NT_STRING && !value.regex(pattern))
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y does not fit the parameter string pattern (pattern:%y, value: %y)",
                    name, path, method, pattern, value);
        if (enum && !enum{value})
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y does not fit the enumerated values (enum: %y, actual: %y)",
                    name, path, method, keys enum, value);
    }

    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, int v, reference<int> value) {
        if (type != "integer")
            throwInvalidType(name, "integer", type);
        if (exists maximum) {
            if (exclusiveMax) {
                if (value >= maximum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %d)",
                            name, path, method, maximum, value);
            }
            else {
                if (value > maximum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %d)",
                            name, path, method, maximum, value);
            }
        }

        if (exists minimum) {
            if (exclusiveMin) {
                if (value <= minimum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %d)",
                            name, path, method, maximum, value);
            }
            else {
                if (value < minimum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %d)",
                            name, path, method, maximum, value);
            }
        }

        if (enum && !enum{value})
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y does not fit the enumerated values (enum: %y, actual: %d)",
                    name, path, method, keys enum, value);
    }

    # NOTE: "number" also accepts "float"
    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, number v, reference<number> value) {
        if (type != "number")
            throwInvalidType(name, "number", type);
        if (exists maximum) {
            if (exclusiveMax) {
                if (value >= maximum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %f)",
                            name, path, method, maximum, value);
            }
            else {
                if (value > maximum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too big (maximum: %f, actual: %f)",
                            name, path, method, maximum, value);
            }
        }

        if (exists minimum) {
            if (exclusiveMin) {
                if (value <= minimum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %f)",
                            name, path, method, maximum, value);
            }
            else {
                if (value < minimum)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y is too small (minimum: %f, actual: %f)",
                            name, path, method, maximum, value);
            }
        }

        if (enum && !enum{value})
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y does not fit the enumerated values (enum: %y, actual: %f)",
                    name, path, method, keys enum, value);
    }

    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, bool v, reference<bool> value) {
        if (type != "boolean")
            throwInvalidType(name, "boolean", type);
    }

    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, nothing v, reference<nothing> value) {
        if (type != "null")
            throw "INVALID-PARAMETER-VALUE", sprintf("Parameter %y for path %y and method %y is null, but the expected type is %y", name, path, method, type);
    }

    #! validates the value against the schema definition
    private checkArrayParam(bool serialize, bool request, ItemsObject items, string path, string method, string name, reference<softlist> value) {
        if (exists maxItems && value.size() > maxItems)
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y has too many items (maxItems: %d, actual: %d)",
                    name, path, method, maxItems, value.size());
        if (exists minItems && value.size() < minItems)
            throw "INVALID-PARAMETER-VALUE",
                sprintf("Parameter %y for path %y and method %y has too few items (minItems: %d, actual: %d)",
                    name, path, method, minItems, value.size());

        # check array element types
        if (!uniqueItems || items.type != "array") {
            # hash for checking uniqueness if uniqueItems is true
            #printf("v: %y self: %N\n", value, self);
            hash h;
            foreach any v in (\value) {
                items.check(serialize, request, path, method, name, \v);
                if (uniqueItems) {
                    if (h{v})
                        throw "INVALID-PARAMETER-VALUE", sprintf("%s %s: parameter value %y is duplicated in the array", method, path, v);
                    h{v} = True;
                }
            }
        }
        else {
            # perform slow array uniqueness check
            list uniqueItems = ();
            foreach any val in (\value) {
                items.check(serialize, request, path, method, name, \val);
                if (uniqueItems.contains(val))
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("%s %s: Array parameter %y does not have unique items",
                            method, path, name);
                uniqueItems += val;
            }
        }
    }

    #! throws an \c INVALID-PARAMETER-TYPE exception
    static private throwInvalidType(string name, string actual, string expected) {
        throw "INVALID-PARAMETER-TYPE",
            sprintf("Parameter %y has invalid type %y (should be %y)", name, actual, expected);
    }
}

#! Used for loading the Swagger definitions.
public class SwaggerLoader {
    #! Load Swagger definition from a string.
    /**
        @param swaggerSpecification Swagger API specification
        @param json whether the specification is in JSON or YAML format

        @throws JSON-MODULE-MISSING trying to parse a JSON Swagger specification with JSON module unavailable
        @throws YAML-MODULE-MISSING trying to parse a YAML Swagger specification with YAML module unavailable
     */
    static SwaggerObject fromString(string swaggerSpecification, bool json = True) {
        hash val;
        if (json) {
%ifdef NoJson
            throw "JSON-MODULE-MISSING", "Trying to parse a JSON Swagger specification, but the json module is unavailable";
%else
            val = parse_json(swaggerSpecification);
%endif
        }
        else {
%ifdef NoYaml
            throw "YAML-MODULE-MISSING", "Trying to parse a YAML Swagger specification, but the yaml module is unavailable";
%else
            val = parse_yaml(swaggerSpecification);
%endif
        }
        return new SwaggerObject(val);
    }

    #! Load Swagger definition from a file.
    /**
        @param filepath path to the Swagger file

        @throws EMPTY-SCHEMA-FILE swagger file is empty
        @throws JSON-MODULE-MISSING trying to parse a JSON Swagger specification with the json module unavailable
        @throws YAML-MODULE-MISSING trying to parse a YAML Swagger specification with the yaml module unavailable
        @throws XML-MODULE-MISSING trying to parse an XML Swagger specification with the xml module unavailable
     */
    static SwaggerObject fromFile(string filepath) {
        return new SwaggerObject(SwaggerLoader::parseSchemaContent(filepath, ReadOnlyFile::readTextFile(filepath)));
    }

    #! Load a schema definition from a file
    /**
        @param filepath path to the schema file

        @throws EMPTY-SCHEMA-FILE schema file is empty
        @throws JSON-MODULE-MISSING trying to parse a JSON schema with the json module unavailable
        @throws YAML-MODULE-MISSING trying to parse a YAML schema specification with the yaml module unavailable
        @throws XML-MODULE-MISSING trying to parse an XML schema specification with the xml module unavailable
     */
    static hash parseSchemaContent(string filepath, string str) {
        if (!str)
            throw "EMPTY-SCHEMA-FILE", sprintf("%y: file is empty", filepath);

        string ser = "json";
        string filename = basename(filepath);
        if (filename =~ /.*\.json$/i) {
            ser = "json";
        }
        else if (filename =~ /.*\.yaml$/i) {
            ser = "yaml";
        }
        else if (filename =~ /.*\.xml$/i) {
            ser = "xml";
        }
        else {
            DataLineIterator it(str);
            while (it.next()) {
                string line = trim(it.getValue());
                if (line.size()) {
                    if (line =~ /^<\?xml/)
                        ser = "xml";
                    else if (line =~ /^([^{])+:/ || line =~ /^(---|%YAML)/)
                        ser = "yaml";
                    else
                        ser = "json";
                    break;
                }
            }
        }

        hash rv;
        switch (ser) {
            case "json": {
%ifdef NoJson
                throw "JSON-MODULE-MISSING", "Trying to parse a JSON schema, but the json module is unavailable";
%else
                rv = parse_json(str);
                break;
%endif
            }
            case "yaml": {
%ifdef NoYaml
                throw "YAML-MODULE-MISSING", "Trying to parse a YAML schema, but the yaml module is unavailable";
%else
                rv = parse_yaml(str);
                break;
%endif
            }
            case "xml": {
%ifdef NoXml
                throw "XML-MODULE-MISSING", "Trying to parse an XML schema, but the xml module is unavailable";
%else
                rv = parse_xml(str);
                break;
%endif
            }
        }
        return rv;
    }
}

#! This is the root document object for the API specification. It combines what previously was the Resource Listing and API Declaration (version 1.2 and earlier) together into one document.
public class SwaggerObject inherits ObjectBase, AbstractRestSchemaValidator {
    public {
        #! Swagger Specification version being used.
        /**
            It can be used by the Swagger UI and other clients to interpret the
            API listing. The value MUST be \c "2.0".
         */
        string swaggerSpec;

        #! Required. Provides metadata about the API. The metadata can be used by the clients if needed.
        InfoObject info;

        #! Required. The available paths and operations for the API.
        PathsObject paths;

        #! The host (name or IP) serving the API.
        /**
            This MUST be the host only and does not include the scheme nor sub-paths.
            It MAY include a port. If the \c host is not included, the host serving
            the documentation is to be used (including the port).
            The host does not support path templating.
         */
        *string host;

        #! The base path on which the API is served, which is relative to the @ref SwaggerObject::host "host".
        /**
            If it is not included, the API is served directly under the \c host.
            The value MUST start with a leading slash (/).
            The \c basePath does not support path templating.
         */
        *string basePath;

        #! The transfer protocol of the API.
        /**
            Values MUST be from the list: \c "http", \c "https", \c "ws", \c "wss".
            If the schemes is not included, the default scheme to be used is
            the one used to access the Swagger definition itself.
         */
        hash<string, bool> schemes;

        #! A set of MIME types (strings) the APIs can consume.
        /**
            This is global to all APIs but can be overridden on specific API calls.
            Values MUST be as described under @ref mimetypes "Mime Types".
         */
        hash<string, bool> consumes;

        #! A set of MIME types (strings) the APIs can produce.
        /**
            This is global to all APIs but can be overridden on specific API calls.
            Values MUST be as described under @ref mimetypes "Mime Types".
         */
        hash<string, bool> produces;

        #! An object to hold data types produced and consumed by operations.
        /**
            A hash of @ref SchemaObject objects. Keys are schema names.
         */
        hash<string, SchemaObject> definitions();

        #! Parameter definitions that can be used across operations. This property does not define global parameters for all operations.
        /**
            A hash of @ref AbstractParameterObject objects. Keys are parameter names.
         */
        hash<string, AbstractParameterObject> parameters();

        #! Response definitions that can be used across operations. This property does not define global responses for all operations.
        /**
            A hash of @ref ResponseObject objects. Keys are response names.
         */
        hash<string, ResponseObject> responses;

        #! Security scheme definitions that can be used across the specification.
        /**
            A hash of @ref SecuritySchemeObject objects. Keys are scheme names.
         */
        hash<string, SecuritySchemeObject> securityDefinitions;

        #! A declaration of which security schemes are applied for the API as a whole.
        /**
            The list of values describes alternative security schemes that can
            be used (that is, there is a logical OR between the security
            requirements). Individual operations can override this definition.

            Individual values are hashes in the form of Security Requirement Objects.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#securityRequirementObject.
            That is, the hash keys MUST correspond to security schemes declared
            in the @ref SwaggerObject::securityDefinitions "Security Definitions",
            while the values are lists of scope names (strings) required for the execution.
         */
        hash<string, softlist<string>> security;

        #! A list of @ref TagObject "tags" used by the specification with additional metadata.
        /**
            The order of the tags can be used to reflect on their order by the
            parsing tools. Not all tags that are used by the @ref OperationObject
            must be declared. The tags that are not declared may be organized
            randomly or based on the tools' logic. Each tag name in the list
            MUST be unique.

            Individual values in this list are of type @ref TagObject "TagObject".
         */
        list<TagObject> tags;

        #! Additional external documentation.
        *ExternalDocumentationObject externalDocs;

        #! SwaggerObject options
        const SwaggerOptions = (
            "compact_serialization": True,
            "def_path": True,
            "try_import": True,
        );
    }

    private {
        #! if serialized data should be subject to compact serialization (default: @ref Qore::True "True")
        bool compact_serialization;

        #! the default path to use when retrieving external schema references
        *string def_path;

        #! a call reference or closure to be passed a string name for external schema references, must take a string argument (the resource name) and return a string (the resource data)
        *code try_import;
    }

    #! Builds the schema representation from the deserialized schema hash describing the root document object
    /**
        @param oh deserialized hash from the source schema description describing the root document object
        @param opts options as per @ref SwaggerOptions as follows:
        - \c compact_serialization (default @ref Qore::True "True"): optimize the size of serialized data strings
        - \c def_path: the default path to use when retrieving external schema references
        - \c try_import: a call reference or closure to be passed a string name for external schema references, must take a string argument (the resource name) and return a string (the resource data)

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
        @throws SECURITY-ERROR inconsistent security information in schema
     */
    public constructor(hash oh, *hash opts) : ObjectBase(oh) {
        # process options
        compact_serialization = remove opts.compact_serialization ?? True;
        def_path = remove opts.def_path;
        try_import = remove opts.try_import;
        if (opts)
            throw "SWAGGER-OPTION-ERROR", sprintf("unknown options in SwaggerObject constructor: %y; known options: %y", keys opts, keys SwaggerOptions);

        string objType = "Swagger";
        if (!oh.hasKey("swagger"))
            throw "REQUIRED-FIELD-MISSING", sprintf("%s Object: 'swagger' field is missing", objType);
        if (oh.swagger.typeCode() == NT_STRING)
            swaggerSpec = oh.swagger;
        else if (oh.swagger.typeCode() == NT_FLOAT || oh.swagger.typeCode() == NT_INT)
            swaggerSpec = sprintf("%.1f", oh.swagger);
        else
            throw "INVALID-FIELD-TYPE",
                sprintf("%s Object: 'swagger' field has invalid type %y (should be string or float)", objType, oh.swagger.type());
        if (swaggerSpec != "2.0")
            throw "INVALID-SWAGGER-VERSION", sprintf("invalid schema version %y; expecting \"2.0\"", swaggerSpec);

        {
            hash obj;
            optional_field(objType, oh, "definitions", NT_HASH, \obj);
            foreach hash item in (obj.pairIterator()) {
                if (item.value.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "Swagger Object: invalid definition datatype: " + item.value.type();
                definitions{item.key} = SchemaObject::newSchemaObject(item.key, item.value, self);
            }

            delete obj;
            optional_field(objType, oh, "parameters", NT_HASH, \obj);
            foreach hash item in (obj.pairIterator()) {
                if (item.value.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "Swagger Object: invalid parameter datatype: " + item.value.type();
                parameters{item.key} = AbstractParameterObject::newParameter(item.key, item.value, self);
            }

            delete obj;
            optional_field(objType, oh, "responses", NT_HASH, \obj);
            foreach hash item in (obj.pairIterator()) {
                if (item.value.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "Swagger Object: invalid response datatype: " + item.value.type();
                responses{item.key} = ResponseObject::newResponse(item.key, item.value, self);
            }
        }

        {
            hash infoObj;
            required_field(objType, oh, "info", NT_HASH, \infoObj);
            info = new InfoObject(infoObj);
        }

        {
            hash pathsObj;
            required_field(objType, oh, "paths", NT_HASH, \pathsObj);
            paths = new PathsObject(pathsObj, self);
        }

        optional_field(objType, oh, "host", NT_STRING, \host);
        if (optional_field(objType, oh, "basePath", NT_STRING, \basePath)) {
            if (basePath.size() && basePath[0] != "/")
                throw "INVALID-FIELD-FORMAT", "Swagger Object: basePath does not begin with a slash: " + basePath;
        }

        if (oh.schemes) {
            optional_field(objType, oh, "schemes", SwaggerListToSet, \schemes);
            # check for invalid schemes
            if ((hash h = (schemes - ValidSchemes)))
                throw "INVALID-FIELD-VALUE", sprintf("Swagger Object: invalid transfer protocol scheme%s: %y", h.size() == 1 ? "" : "s", keys h);
        }

        optional_field(objType, oh, "consumes", SwaggerListToSet, \consumes);

        optional_field(objType, oh, "produces", SwaggerListToSet, \produces);

        {
            hash obj;
            optional_field(objType, oh, "securityDefinitions", NT_HASH, \obj);
            foreach hash item in (obj.pairIterator()) {
                if (item.value.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "Swagger Object: invalid security definition datatype: " + item.value.type();
                securityDefinitions{item.key} = new SecuritySchemeObject(item.value);
            }
        }

        optional_field(objType, oh, "security", SwaggerListToHashOfStrings, \security);

        # verify security consistency
        if (security) {
            hash h = security - securityDefinitions.keys();
            if (h)
                throw "SECURITY-ERROR", sprintf("the following security schemes are not defined: %y", keys h);
        }

        {
            list lobj = ();
            optional_field(objType, oh, "tags", NT_LIST, \lobj);
            foreach any val in (lobj) {
                if (val.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", "Swagger Object: invalid tag datatype: " + val.type();
                tags += new TagObject(val);
            }
        }

        {
            *hash extDocsObj;
            if (optional_field(objType, oh, "externalDocs", NT_HASH, \extDocsObj))
                externalDocs = new ExternalDocumentationObject(extDocsObj);
        }
    }

    #! resolves a reference to a schema object
    /** @throw INVALID-REFERENCE invalid reference
    */
    SchemaObject resolveSchemaObject(string name, string refstr, hash oh) {
        # resolve external reference
        if (refstr !~ /^#\//)
            return SchemaObject::newSchemaObject(name, getExternalReference(refstr), self);
        if (refstr !~ /^#\/definitions\//)
            throw "INVALID-REFERENCE", sprintf("cannot resolve SchemaObject %y reference %y", name, refstr);
        string rstr = (refstr =~ x/^#\/definitions\/(.*)$/)[0];
        *SchemaObject ref = definitions{rstr};
        if (!ref)
            throw "INVALID-REFERENCE", sprintf("cannot resolve SchemaObject %y reference %y", name, refstr);
        int size = foldl $1 + $2, (map 1, keys oh, $1 !~ /^x-/);
        if (size > 1)
            throw "INVALID-REFERENCE", sprintf("Invalid attribute(s) in reference: %y", (map $1, keys oh, $1 !~ /^x-/));
        return ref;
    }

    #! resolves a reference to a parameter
    /** @throw INVALID-REFERENCE invalid reference
    */
    AbstractParameterObject resolveParameter(string name, string refstr, hash oh) {
        # resolve external reference
        if (refstr !~ /^#\//)
            return AbstractParameterObject::newParameter(name, getExternalReference(refstr), self);
        if (refstr !~ /^#\/parameters\//)
            throw "INVALID-REFERENCE", sprintf("cannot resolve ParameterObject %y reference %y; expecting \"#/parameters/...\"", name, refstr);
        string rstr = (refstr =~ x/^#\/parameters\/(.*)$/)[0];
        *AbstractParameterObject ref = parameters{rstr};
        if (!ref)
            throw "INVALID-REFERENCE", sprintf("cannot resolve ParameterObject %y reference %y; known parameter references: %y", name, refstr, keys parameters);
        int size = foldl $1 + $2, (map 1, keys oh, $1 !~ /^x-/);
        if (size > 1)
            throw "INVALID-REFERENCE", sprintf("Invalid attribute(s) in reference: %y", (map $1, keys oh, $1 !~ /^x-/));
        return ref;
    }

    #! resolves a reference to a response
    /** @throw INVALID-RESPONSE invalid response
    */
    ResponseObject resolveResponse(string name, string refstr, hash oh) {
        # resolve external reference
        if (refstr !~ /^#\//)
            return ResponseObject::newResponse(name, getExternalReference(refstr), self);
        if (refstr !~ /^#\/responses\//)
            throw "INVALID-RESPONSE", sprintf("cannot resolve ResponseObject %y reference %y; expecting \"#/responses/...\"", name, refstr);
        string rstr = (refstr =~ x/^#\/responses\/(.*)$/)[0];
        *ResponseObject res = responses{rstr};
        if (!res)
            throw "INVALID-RESPONSE", sprintf("cannot resolve ResponseObject %y reference %y; known response references: %y", name, refstr, keys responses);
        int size = foldl $1 + $2, (map 1, keys oh, $1 !~ /^x-/);
        if (size > 1)
            throw "INVALID-RESPONSE", sprintf("Invalid attribute(s) in reference: %y", (map $1, keys oh, $1 !~ /^x-/));
        return res;
    }

    #! resolves a reference to an ItemsObject
    /** @throw INVALID-ITEMS invalid ItemsObject reference
    */
    ItemsObject resolveItems(string refstr, hash oh) {
        # resolve external reference
        if (refstr !~ /^#\//)
            return ItemsObject::newItemsObject(getExternalReference(refstr), NOTHING, self);
        if (refstr !~ /^#\/definitions\//)
            throw "INVALID-ITEMS", sprintf("cannot resolve ItemsObject reference %y; expecting \"#/responses/...\"", refstr);
        string rstr = (refstr =~ x/^#\/definitions\/(.*)$/)[0];
        *SchemaObject ref = definitions{rstr};
        if (!ref)
            throw "INVALID-ITEMS", sprintf("cannot resolve ItemsObject reference %y; known definition references: %y", refstr, keys definitions);
        int size = foldl $1 + $2, (map 1, keys oh, $1 !~ /^x-/);
        if (size > 1)
            throw "INVALID-ITEMS", sprintf("Invalid attribute(s) in ItemsObject reference: %y", (map $1, keys oh, $1 !~ /^x-/));
        return new ItemsObject(ref);
    }

    #! processes a client-side REST request and returns a hash that can be used to make the outgoing client-side HTTP request
    /** @param method the HTTP method (case-insensitive)
        @param path the URI path with any query arguments
        @param body the unserialized message body hash
        @param headers any headers to include in the request
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown; if this argument is not present, then json is preferred over yaml

        @return if there is ano message body to serialize, an empty hash is returned, otherwise a hash is returned with the following keys:
        - \c body the serialized message body (if any)
        - \c content the MIME type for the serialized body (if any) to be used for the \c Content-Type header

        @throws SERIALIZATION-ERROR unsupported message body MIME type requested or missing serialization module
    */
    private hash<RestRequestClientInfo> processRequestImpl(string method, string path, *hash body, *hash headers, *softlist<string> content_types) {
        hash<string, bool> mime_types;

        hash<UriQueryInfo> h = parse_uri_query(path);
        method = method.lwr();

        PathItemObject pio = paths.match(h.method);
        OperationObject op = pio.getOperation(method, h.method);

        op.validateRequest(True, pio, \h, \body, \headers, \mime_types);

        hash<RestRequestClientInfo> rv((
            "uri_path": h.method,
        ));

        if (h.params) {
            string query_arg_separator = (path =~ x/([;&])/)[0] ?? ";";
            rv.uri_path += "?" + (foldl $1 + query_arg_separator + $2, (map sprintf("%s=%s", $1.key, $1.value), h.params.pairIterator()));
        }

        if (!body)
            return rv;

        if (!exists content_types)
            content_types = MimeContentTypes;

        foreach string content in (content_types) {
            if (!mime_types{content})
                continue;
            if (content == MimeTypeMultipartFormData) {
                hash<string, hash<FormDataMessageInfo>> parts = cast<hash<string, hash<FormDataMessageInfo>>>(map {$1.key: cast<hash<FormDataMessageInfo>>((
                    "name": $1.key,
                    "filename": $1.key,
                    "hdr": ("Content-Type": MimeTypeText),
                    "body": $1.value,
                  ))}, body.pairIterator());

                hash<MessageInfo> mh = MultiPartFormDataMessage::makeMessage(parts).getMsgAndHeaders();
                return rv += (
                    "body": mh.body,
                    "content": mh.hdr."Content-Type",
                );
            }
            if (!MimeDataTypes{content})
                continue;
            return rv += (
                "body": compact_serialization ? MimeDataTypes{content}.serialize(body) : MimeDataTypes{content}.serialize_verbose(body),
                "content": content,
            );
        }
        if (body)
            if (content_types == MimeContentTypes)
                throw "SERIALIZATION-ERROR", sprintf("%s %s: message body cannot be serialized; available MIME type(s): %y; available serialization modules: %y", method.upr(), path, mime_types, SerializationModules);
            else
                throw "SERIALIZATION-ERROR", sprintf("%s %s: message body cannot be serialized; requested MIME type(s): %y; available MIME types: %y; available serialization modules: %y", method.upr(), path, content_types, mime_types, SerializationModules);
        return rv;
    }

    #! processes and parses a client request and returns the deserialized message body (if any)
    /** @param method the HTTP method (case-insensitive)
        @param path the URI path with any query arguments
        @param body the unserialized message body hash
        @param headers a reference to the hash of HTTP headers received; any default header values to be assumed by the server for the request will be added here

        @return a @ref RestRequestInfo hash of request information

        @throw DESERIALIZATION-ERROR the request body could not be deserialized
    */
    private hash<RestRequestServerInfo> parseRequestImpl(string method, string path, *data http_body, reference<hash> headers) {
        hash body;
        # deserialize body according to Content-Type
        if (exists http_body) {
            if (headers."content-type" =~ /^multipart\/form-data/) {
                hash<string, hash<FormDataMessageInfo>> h = MultiPartFormDataMessage::parseMessage(headers."content-type", http_body.toString());
                body = map {$1.key: $1.value.body}, h.pairIterator();
            }
            else {
                *code ds = MimeDataTypes.(headers."content-type").deserialize;
                if (!ds)
                    throw "DESERIALIZATION-ERROR", sprintf("%s %s: cannot deserialize message body with Content-Type: %y; supported MIME types: %y; available deserialization modules: %y", method, path, headers."content-type", MimeContentTypes, SerializationModules);

                body = ds(http_body);
            }
        }

        hash<UriQueryInfo> h = parse_uri_query(path);
        method = method.lwr();

        PathItemObject pio = paths.match(h.method);
        OperationObject op = pio.getOperation(method, h.method);

        op.parseRequest(pio, \h, \body, \headers);
        return new hash<RestRequestServerInfo>((
            "path": h.method,
            "query": h.params,
            "body": body,
        ));
    }

    #! processes a REST response with a serialized message body, validates any response data against schema definitions if possible
    /** @param method the HTTP method of the original request
        @param path the URI path of the original request (without query arguments)
        @param code the HTTP response code
        @param response_body the response body data (if any)
        @param headers HTTP headers to include in the response
        @param content_types the desired MIME types for serialization in order of preference; if none are usable then an exception is thrown; if this argument is not present, then json is preferred over yaml

        @return an HttpResponseInfo hash for the response

        @throw SERIALIZATION-ERROR the response body could not be serialized due to an error
    */
    private hash<HttpResponseInfo> processResponseImpl(string method, string path, int code, any response_body, *hash headers, *softlist<string> content_types) {
        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        hash<string, bool> mime_types;
        op.validateResponse(method, path, pio, code, response_body, \mime_types);

        hash<HttpResponseInfo> rv((
            "code": code,
            "hdr": headers,
        ));

        if (exists response_body) {
            if (!exists content_types)
                content_types = MimeContentTypes;
            foreach string content in (content_types) {
                if (!mime_types{content})
                    continue;
                if (content == MimeTypeMultipartFormData) {
                    if (response_body.typeCode() != NT_HASH)
                        throw "SERIALIZATION-ERROR", sprintf("response to %s %s: cannot serialize type %y to MIME type %y; expecing \"hash\"", method.upr(), path, response_body.type(), content);
                    hash<string, hash<FormDataMessageInfo>> parts = cast<hash<string, hash<FormDataMessageInfo>>>(map {$1.key: cast<hash<FormDataMessageInfo>>((
                        "name": $1.key,
                        "filename": $1.key,
                        "hdr": ("Content-Type": MimeTypeText),
                        "body": $1.value,
                    ))}, response_body.pairIterator());

                    hash<MessageInfo> mh = MultiPartFormDataMessage::makeMessage(parts).getMsgAndHeaders();
                    return rv += (
                        "body": mh.body,
                        "hdr": rv.hdr + ("Content-Type": mh.hdr."Content-Type"),
                    );
                }
                if (!MimeDataTypes{content})
                    continue;
                return rv += (
                    "body": compact_serialization ? MimeDataTypes{content}.serialize(response_body) : MimeDataTypes{content}.serialize_verbose(response_body),
                    "hdr": rv.hdr + ("Content-Type": content),
                );
            }
            if (content_types == MimeContentTypes)
                throw "SERIALIZATION-ERROR", sprintf("response to %s %s: message body cannot be serialized; available MIME type(s): %y; available serialization modules: %y", method.upr(), path, mime_types, SerializationModules);
            else
                throw "SERIALIZATION-ERROR", sprintf("response to %s %s: message body cannot be serialized; requested MIME type(s): %y; available MIME types: %y; available serialization modules: %y", method.upr(), path, content_types, mime_types, SerializationModules);
        }

        return rv;
    }

    #! parses and validates the response from the server and returns a hash of the processed info
    /** @param method the HTTP method (case insensitive)
        @param path the URI path of the original request (without any query arguments)
        @param code the HTTP response code
        @param response_body the HTTP response body data (if any)
        @param hdr as hash of HTTP headers received

        @throw DESERIALIZATION-ERROR the request body could not be deserialized or had an invalid \c Content-Type
    */
    private hash<RestResponseClientInfo> parseResponseImpl(string method, string path, int code, *data response_body, hash hdr) {
        method = method.lwr();
        PathItemObject pio = paths.match(path);
        OperationObject op = pio.getOperation(method, path);

        hash<RestResponseClientInfo> rv((
            "code": code,
            "hdr": hdr,
        ));

        string content = hdr."content-type" ?? hdr."Content-Type";

        # deserialize body according to Content-Type
        if (exists response_body) {
            if (content =~ /^multipart\/form-data/) {
                hash<string, hash<FormDataMessageInfo>> h = MultiPartFormDataMessage::parseMessage(hdr."content-type", response_body.toString());
                rv.body = map {$1.key: $1.value.body}, h.pairIterator();
                content = MimeTypeMultipartFormData;
            }
            else {
                *code ds = MimeDataTypes{content}.deserialize;
                if (!ds)
                    throw "DESERIALIZATION-ERROR", sprintf("%s %s: cannot deserialize message body with Content-Type: %y; supported MIME types: %y; available deserialization modules: %y", method, path, hdr."content-type", MimeContentTypes, SerializationModules);

                rv.body = ds(response_body);
            }
        }

        hash<string, bool> mime_types;
        op.validateResponse(method, path, pio, code, rv.body, \mime_types);

        if (!mime_types{content})
            throw "DESERIALIZATION-ERROR", sprintf("%s %s: content type %y is not accepted by this operation; accepted content types: %y", method.upr(), path, content, mime_types);

        return rv;
    }

    #! retrieves external references
    /** @throw INVALID-REFERENCE invalid reference
    */
    private hash getExternalReference(string refstr) {
        (string ext_ref, *string int_ref) = (refstr =~ x/([^#]+)(?:#\/(.*))/);

        #! get file content
        string content;

        if (try_import)
            content = call_function(try_import, ext_ref);
        else {
            # do environment variable substitution
            map ext_ref = replace(ext_ref, "\$" + $1, ENV.$1), (ext_ref =~ x/\$(\w+)/g);
            # derive target file name if def_path is set and the reference is not an absolute path
            if (def_path && !absolute_path(ext_ref))
                ext_ref = def_path + DirSep + ext_ref;
            content = ReadOnlyFile::readTextFile(ext_ref);
        }

        hash h = SwaggerLoader::parseSchemaContent(ext_ref, content);
        if (int_ref) {
            if (!h.hasKey(int_ref))
                throw "INVALID-REFERENCE", sprintf("%y: external reference %y loaded (%d bytes) and parsed, but internal reference %y is not available; known internal references: %y", refstr, ext_ref, content.size(), int_ref, keys h);
            if (h{int_ref}.typeCode() != NT_HASH)
                throw "INVALID-REFERENCE", sprintf("%y: external reference %y loaded (%d bytes) and parsed, but internal reference %y is not a hash; got type %y instead", refstr, ext_ref, content.size(), int_ref, h{int_ref}.type());
            return h{int_ref};
        }
        return h;
    }
}

#! The object provides metadata about the API. The metadata can be used by the clients if needed, and can be presented in the Swagger-UI for convenience.
public class InfoObject inherits ObjectBase {
    public {
        #! Required. The title of the application.
        string title;

        #! A short description of the application. GFM syntax can be used for rich text representation.
        *string desc;

        #! The Terms of Service for the API.
        *string termsOfService;

        #! Required. Provides the version of the application API (not to be confused with the specification version).
        string version;

        #! The contact information for the exposed API.
        *ContactObject contact;

        #! The license information for the exposed API.
        *LicenseObject license;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing metadata about the API

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "Info";
        required_field(objType, oh, "title", NT_STRING, \title);
        required_field(objType, oh, "version", NT_STRING, \version);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
        optional_field(objType, oh, "termsOfService", NT_STRING, \termsOfService);

        *hash contactObj;
        if (optional_field(objType, oh, "contact", NT_HASH, \contactObj))
            contact = new ContactObject(contactObj);

        *hash licenseObj;
        if (optional_field(objType, oh, "license", NT_HASH, \licenseObj))
            license = new LicenseObject(licenseObj);
    }
}

#! Contact information for the exposed API.
public class ContactObject inherits ObjectBase {
    public {
        #! The identifying name of the contact person/organization.
        *string name;

        #! The URL pointing to the contact information. MUST be in the format of a URL.
        *string url;

        #! The email address of the contact person/organization. MUST be in the format of an email address.
        *string email;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing contact information about the API

        @throws INVALID-FIELD-TYPE field has invalid type
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "Contact";
        optional_field(objType, oh, "name", NT_STRING, \name);
        optional_field(objType, oh, "url", NT_STRING, \url);
        optional_field(objType, oh, "email", NT_STRING, \email);
    }
}

#! License information for the exposed API.
public class LicenseObject inherits ObjectBase {
    public {
        #! Required. The license name used for the API.
        string name;

        #! A URL to the license used for the API. MUST be in the format of a URL.
        *string url;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing license information about the API

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "License";
        required_field(objType, oh, "name", NT_STRING, \name);
        optional_field(objType, oh, "url", NT_STRING, \url);
    }
}

#! Holds the relative paths to the individual endpoints.
/**
    The path is appended to the @ref SwaggerObject::basePath "basePath" in order to construct the full URL.
    The Paths may be empty, due to ACL constraints.

    This class stores a tree or a component of a path for path matching, supports wildcard matching
 */
public class PathComponent {
    private {
        #! path prefix
        string pfx;

        #! current component name
        string name;

        #! if there is a wildcard to a PathComponent
        *PathComponent wildcard;

        #! the PathItemObject associated with this path (if any)
        *PathItemObject pio;

        #! hash of non-wildcard paths to the next level
        hash<string, PathComponent> paths;
    }

    #! creates the object
    constructor(hash oh, string pfx, SwaggerObject swagger) {
        self.pfx = pfx;
        name = "/";
        foreach hash h in (oh.pairIterator()) {
            if (!pfx.val() && h.key !~ /^\//)
                throw "INVALID-FIELD-FORMAT", sprintf("Paths Object: root path %y does not begin with a slash", h.key);
            list l = h.key.split("/");
            shift l;
            add(h.key, l, 0, h.value, swagger);
        }
    }

    #! private constructor
    private constructor(string full_path, list l, int offset, hash oh) {
        list l0 = l;
        splice l0, offset + 1;
        pfx = l0.join("/");
        name = l[offset - 1];
        #printf("pfx: %y name: %y\n", pfx, name);
    }

    #! adds a component or a Path Item Object to the tree
    private add(string full_path, list l, int offset, hash oh, SwaggerObject swagger) {
        #printf("PathComponent::add(): %y l: %y offset: %y\n", full_path, l, offset);
        if (offset == l.size()) {
            if (pio)
                throw "INVALID-PATH-COMPONENT", sprintf("cannot terminate path %y twice", full_path);
            pio = new PathItemObject(full_path, oh, swagger);
            return;
        }

        PathComponent next;
        string key = l[offset];
        if (key =~ /^{/)
            next = wildcard ?? (wildcard = new PathComponent(full_path, l, offset + 1, oh));
        else
            next = paths{key} ?? (paths{key} = new PathComponent(full_path, l, offset + 1, oh));

        next.add(full_path, l, offset + 1, oh, swagger);
    }

    #! returns either a PathItemObject for the path
    /** @throw INVALID-PATH the path could not be matched or has no API definition
    */
    PathItemObject match(list path) {
        PathComponent w = self;
        for (int i = 1; i < path.size(); ++i) {
            *PathComponent next = w.paths{path[i]} ?? w.wildcard;
            if (!next)
                throw "INVALID-PATH", sprintf("component %y cannot be matched in %y", path[i], path.join("/"));
            w = next;
        }
        if (!w.pio)
            throw "INVALID-PATH", sprintf("path %y is valid but has no API definition", path.join("/"));
        return w.pio;
    }
}

public class PathsObject inherits ObjectBase {
    private {
        #! the tree of path components for path matching with wildcards
        PathComponent paths;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing paths to schema endpoints

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
     */
    public constructor(hash oh, SwaggerObject swagger) : ObjectBase(oh) {
        paths = new PathComponent(oh, "", swagger);
    }

    #! matches a URI path with a PathItemObject
    /** @throw INVALID-PATH the path could not be matched
    */
    PathItemObject match(string path) {
        return paths.match(path.split("/"));
    }
}

#! Describes the operations available on a single path.
/**
    A Path Item may be empty, due to ACL constraints. The path itself is still
    exposed to the documentation viewer but they will not know which operations
    and parameters are available.
 */
public class PathItemObject inherits ObjectBase {
    public {
        #! Allows for an external definition of this path item.
        /**
            The referenced structure MUST be in the format of a @ref PathItemObject.
            If there are conflicts between the referenced definition and this
            PathItem's definition, the behavior is undefined.
         */
        *string ref;

        #! A definition of a GET operation on this path.
        *OperationObject get;

        #! A definition of a PUT operation on this path.
        *OperationObject put;

        #! A definition of a POST operation on this path.
        *OperationObject post;

        #! A definition of a DELETE operation on this path.
        *OperationObject del;

        #! A definition of a OPTIONS operation on this path.
        *OperationObject options;

        #! A definition of a HEAD operation on this path.
        *OperationObject head;

        #! A definition of a PATCH operation on this path.
        *OperationObject patch;

        #! A hash of parameters that are applicable for all the operations described under this path.
        /**
            Hash values are @ref AbstractParameterObject "AbstractParameterObjects"

            These parameters can be overridden at the operation level, but cannot
            be removed there. The list MUST NOT include duplicated parameters.
            A unique parameter is defined by a combination of a
            @ref AbstractParameterObject::name "name" and @ref AbstractParameterObject::inLoc "location".
            There can be one \c body parameter at most.
         */
        hash<string, AbstractParameterObject> parameters();

        #! The body parameter, if defined for this path
        AbstractParameterObject body;
    }

    private {
        #! A hash of @ref OperationObject "OperationObjects" correspoding to different methods.
        /**
            Keys are lowercase method names, with possible values being:
            - "get"
            - "put"
            - "post"
            - "del"
            - "options"
            - "head"
            - "patch"
         */
        hash<string, OperationObject> operations;
    }

    #! Constructor.
    /**
        @param path the URI path for the object
        @param oh deserialized hash from the source schema description describing the operations available on a single path

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(string path, hash oh, SwaggerObject swagger) : ObjectBase(oh) {
        string objType = "Path Item";
        optional_field(objType, oh, "$ref", NT_STRING, \ref);

        *hash opObj;
        if (optional_field(objType, oh, "get", NT_HASH, \opObj))
            operations.get = new OperationObject(path, "get", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "put", NT_HASH, \opObj))
            operations.put = new OperationObject(path, "put", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "post", NT_HASH, \opObj))
            operations.post = new OperationObject(path, "post", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "delete", NT_HASH, \opObj))
            operations.del = new OperationObject(path, "delete", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "options", NT_HASH, \opObj))
            operations.options = new OperationObject(path, "options", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "head", NT_HASH, \opObj))
            operations.head = new OperationObject(path, "head", opObj, swagger);

        delete opObj;
        if (optional_field(objType, oh, "patch", NT_HASH, \opObj))
            operations.patch = new OperationObject(path, "patch", opObj, swagger);

        *list params;
        if (optional_field(objType, oh, "parameters", NT_LIST, \params)) {
            foreach any param in (params) {
                if (param.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE",
                        sprintf("Path Item Object: 'parameters' list value has invalid type %y",
                            param.type());
                AbstractParameterObject p = AbstractParameterObject::newParameter(sprintf("%d/%d", $# + 1, params.lsize()), param, swagger);
                if (p.inLoc == "body")
                    body = p;
                else
                    parameters{p.name} = p;
            }
        }

        # TODO check parameter duplication; check that there's only one "body" parameter
    }

    #! returns the operation object for the given method
    /** @param path the path to be used in any error message
        @param method the HTTP method name

        @return the OperationObject corresponding to the arguments

        @throws INVALID-METHOD the given path does not have any operation defined for the given method
    */
    OperationObject getOperation(string method, string path) {
        *OperationObject op = operations{method};
        if (!op)
            throw "INVALID-METHOD", sprintf("%s %s: no operation defined for this path; known methods: %y", method.upr(), path, keys operations);
        return op;
    }
}

#! Describes a single API operation on a path.
public class OperationObject inherits ObjectBase {
    public {
        #! the URI path for the operation
        string path;

        #! the HTTP method for the operation
        string method;

        #! A list of tags (strings or @ref TagObject "TagObjects") for API documentation control.
        /**
            Tags can be used for logical grouping of operations by resources or any other qualifier.
         */
        list tags;

        #! A short summary of what the operation does.
        *string summary;

        #! A verbose explanation of the operation behavior. GFM syntax can be used for rich text representation.
        *string desc;

        #! Declares this operation to be deprecated.
        /**
            Usage of the declared operation should be refrained.
            Default value is \c false.
         */
        bool deprec = False;

        #! Additional external documentation for this operation.
        *ExternalDocumentationObject externalDocs;

        #! Unique string used to identify the operation.
        /**
            The id MUST be unique among all operations described in the API.
            Tools and libraries MAY use the operationId to uniquely identify
            an operation, therefore, it is recommended to follow common
            programming naming conventions.
         */
        *string operationId;

        #! A list of MIME types (strings) the operation can consume.
        /**
            This overrides the @ref SwaggerObject::consumes "consumes" definition
            at the Swagger Object. An empty value MAY be used to clear the global definition.
            Values MUST be as described under @ref mimetypes "Mime Types".
         */
        hash<string, bool> consumes;

        #! A hash of MIME types (strings) the operation can produce.
        /**
            This overrides the @ref SwaggerObject::produces "produces" definition
            at the Swagger Object. An empty value MAY be used to clear the global definition.
            Values MUST be as described under @ref mimetypes "Mime Types".
         */
        hash<string, bool> produces;

        #! A hash of parameters that are applicable for this operation.
        /**
            If a parameter is already defined at the @ref PathItemObject "Path Item",
            the new definition will override it, but can never remove it.
            The hash MUST NOT include duplicated parameters.
            A unique parameter is defined by a combination of a @ref AbstractParameterObject::name "name"
            and @ref AbstractParameterObject::inLoc "location".
            There can be one "body" parameter at most.
         */
        hash<string, AbstractParameterObject> parameters();

        #! the body parameter, if defined for this operation
        AbstractParameterObject body;

        #! Required. The list of possible responses as they are returned from executing this operation.
        ResponsesObject responses;

        #! The transfer protocol for the operation.
        /**
            Values MUST be from the list: \c "http", \c "https", \c "ws", \c "wss".
            The value overrides the SwaggerObject @ref SwaggerObject::schemes "schemes" definition.
         */
        list<string> schemes;

        #! A declaration of which security schemes are applied for this operation.
        /**
            The list of values describes alternative security schemes that can be
            used (that is, there is a logical OR between the security requirements).
            This definition overrides any declared top-level @ref SwaggerObject::security "security".
            To remove a top-level security declaration, an empty array can be used.

            Individual values are hashes in the form of Security Requirement Objects.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#securityRequirementObject.
            That is, the hash keys MUST correspond to security schemes declared
            in the @ref SwaggerObject::securityDefinitions "Security Definitions",
            while the values are lists of scope names (strings) required for the execution.
         */
        list<hash<string, list<string>>> security;
    }

    #! Constructor.
    /** @param path the path for the operation
        @param method the HTTP method for the operation
        @param oh deserialized hash from the source schema description describing the operation

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(string path, string method, hash oh, SwaggerObject swagger) : ObjectBase(oh) {
        self.path = path;
        self.method = method.upr();
        string objType = "Operation";
        *list tagsObj;
        if (optional_field(objType, oh, "tags", NT_LIST, \tagsObj)) {
            foreach any tag in (tagsObj) {
                if (tag.typeCode() == NT_STRING)
                    tags += tag;
                else if (tag.typeCode() == NT_HASH)
                    tags += new TagObject(tag);
                else
                    error("INVALID-FIELD-TYPE", "'tags' list value has invalid type %y; expecting \"hash\" or \"string\"", tag.type());
            }
        }

        optional_field(objType, oh, "summary", NT_STRING, \summary);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
        optional_field(objType, oh, "deprecated", NT_BOOLEAN, \deprec);

        *hash extDocsObj;
        if (optional_field(objType, oh, "externalDocs", NT_HASH, \extDocsObj))
            externalDocs = new ExternalDocumentationObject(extDocsObj);

        optional_field(objType, oh, "operationId", NT_STRING, \operationId);
        # TODO check operationId uniqueness as per docs

        # use the global "consumes" definition if none is defined on the operation
        if (!optional_field(objType, oh, "consumes", SwaggerListToSet, \consumes))
            consumes = swagger.consumes;

        # use the global "produces" definition if none is defined on the operation
        if (!optional_field(objType, oh, "produces", SwaggerListToSet, \produces))
            produces = swagger.produces;

        {
            list listObj;
            optional_field(objType, oh, "parameters", NT_LIST, \listObj);
            foreach any p in (listObj) {
                if (p.typeCode() != NT_HASH)
                    error("INVALID-FIELD-TYPE", "invalid 'parameters' list value datatype %y; expecing \"hash\"", p.type());
                AbstractParameterObject param = AbstractParameterObject::newParameter(sprintf("%d/%d", $# + 1, listObj.lsize()), p, swagger);
                if (param.inLoc == "body")
                    body = param;
                else
                    parameters{param.name} = param;
            }
        }

        {
            hash responsesObj;
            required_field(objType, oh, "responses", NT_HASH, \responsesObj);
            responses = new ResponsesObject(path, self.method, responsesObj, swagger);
        }

        # process schemes
        {
            list schemesList;
            optional_field(objType, oh, "schemes", NT_LIST, \schemesList);
            foreach any val in (schemesList) {
                if (val.typeCode() != NT_STRING)
                    error("INVALID-FIELD-TYPE", "invalid 'schemes' list value datatype %y; expecting \"string\"", val.type());
                if (!ValidSchemesHash{val})
                    error("INVALID-FIELD-VALUE", "invalid operation transfer protocol scheme value %y; expecting one of: %y", val, keys ValidSchemesHash);
            }
            schemes = cast<list<string>>(schemesList);
        }

        {
            list securityList;
            optional_field(objType, oh, "security", NT_LIST, \securityList);
            foreach any val in (securityList) {
                if (val.typeCode() != NT_HASH)
                    error("INVALID-FIELD-TYPE", "invalid 'security' list value datatype %y; expecting \"hash\"", val.type());
                hash h = val;
                foreach hash it in (h.pairIterator()) {
                    if (it.value.typeCode() != NT_LIST)
                        error("INVALID-FIELD-TYPE",
                                "invalid Security Requirement Object value type %y (should be a list of hashes)",
                                val.type());
                    if ((map True, it.value, $1.typeCode() != NT_STRING).size())
                        error("INVALID-FIELD-TYPE",
                                "invalid Security Requirement Object value type %y (should be a list of hashes with list values)",
                                val.type());
                }
            }
            security = cast<list<hash<string, list<string>>>>(securityList);
        }
    }

    #! processes a REST API client-side request to the operation
    /** @param serialize if request arguments should be processed for serialization (client-side) or not (server-side)
        @param pio the PathItemObject corresponding to the URI path
        @param h a reference to the URI query info hash
        @param body a reference to the HTTP message body data hash
        @param headers a reference to a hash of HTTP headers
        @param mime_types a reference to a hash of valid mime types for the operation

        @throws INVALID-PARAMETER-NAME invalid parameter name
        @throws INVALID-PARAMETER-LOCATION invalid parameter location
        @throws MISSING-PARAMETER missing parameter and parameter has no default value
    */
    validateRequest(bool serialize, PathItemObject pio, reference<hash<UriQueryInfo>> h, reference<hash> body, reference<hash> headers, *reference<hash<string, bool>> mime_types) {
        # check query parameters
        foreach string key in (keys h.params) {
            # find URI parameter object
            *AbstractParameterObject po = parameters{key} ?? pio.parameters{key};
            if (!po)
                error("INVALID-PARAMETER-NAME", "No parameter named %y defined for this path and method", key);
            if (po.inLoc != "query")
                error("INVALID-PARAMETER-LOCATION", "invalid parameter %y given in the URI query; expected location %y", key, po.inLoc);

            po.check(serialize, True, path, method, key, \h.params{key});
        }

        # check header parameters
        foreach string key in (keys headers) {
            # find URI parameter object
            *AbstractParameterObject po = parameters{key} ?? pio.parameters{key};
            # extra headers are OK
            if (!po || po.inLoc != "header")
                continue;

            po.check(serialize, True, path, method, key, \headers{key});
        }

        # check body parameters
        {
            *AbstractParameterObject body_po = self.body ?? pio.body;
            if (body_po)
                body_po.check(serialize, True, path, method, "body", \body);
            else if (body)
                error("INVALID-PARAMETER-NAME", "No message body is accepted; body keys passed: %y", keys body);
        }

        # check for missing required parameters
        checkMissingParams(h, headers, body, parameters);
        checkMissingParams(h, headers, body, pio.parameters, parameters);

        if (consumes)
            mime_types = consumes;
    }

    #! parses and processes a REST request on the server side
    /** @param method the HTTP method in lower case
        @param pio the PathItemObject corresponding to the URI path
        @param h a reference to the URI query info hash
        @param body a reference to the HTTP message body data hash
        @param headers a reference to a hash of HTTP headers

        @throws INVALID-PARAMETER-NAME invalid parameter name
        @throws INVALID-PARAMETER-LOCATION invalid parameter location
        @throws MISSING-PARAMETER missing parameter and parameter has no default value
    */
    parseRequest(PathItemObject pio, reference<hash<UriQueryInfo>> h, reference<hash> body, reference<hash> headers) {
        # validate message
        validateRequest(False, pio, \h, \body, \headers);

        # set default parameter values
        doDefaultParams(\h, \headers, \body, parameters);
        doDefaultParams(\h, \headers, \body, pio.parameters, parameters);
    }

    #! validates a response against the response definition, if any
    validateResponse(string method, string path, PathItemObject pio, int code, any response_body, reference<hash<string, bool>> mime_types) {
        *ResponseObject res = getResponse(code);
        if (res.schema)
            res.schema.check(True, False, path, method, "response body", \response_body);

        if (produces)
            mime_types = produces;
    }

    #! add default parameters
    doDefaultParams(reference<hash<UriQueryInfo>> h, reference<hash> headers, reference<hash> body, hash<string, AbstractParameterObject> parameters, *hash<string, ObjectBase> child_params) {
        foreach hash ph in (parameters.pairIterator()) {
            # don't check if child params already checked or if it's the single message body param
            if (child_params{ph.key} || (ph.key == "body" && ph.value.inLoc == "body"))
                continue;
            if (exists (auto val = ph.value.getDefaultValue())) {
                switch (ph.value.inLoc) {
                    case "query":
                        if (!exists h.params{ph.key})
                            h.params{ph.key} = val;
                        break;
                    case "header":
                        if (!exists headers{ph.key})
                            headers{ph.key} = val;
                        break;
                    case "formData":
                        if (!exists body{ph.key})
                            body{ph.key} = val;
                        break;
                    # NOTE: default "path" values are not possible, "body" is handled specially
                }
            }
        }
    }

    #! checks for missing params
    checkMissingParams(hash<UriQueryInfo> h, *hash headers, *hash body, hash<string, AbstractParameterObject> parameters, *hash<string, ObjectBase> child_params) {
        foreach hash ph in (parameters.pairIterator()) {
            # don't check if child params already checked
            if (child_params{ph.key} || (ph.key == "body" && ph.value.inLoc == "body"))
                continue;
            if (ph.value.required) {
                switch (ph.value.inLoc) {
                    case "query":
                        if (!exists h.params{ph.key})
                            error("MISSING-PARAMETER", "request is missing required query parameter %y", ph.key);
                        break;
                    case "header":
                        if (!exists headers{ph.key})
                            error("MISSING-PARAMETER", "request is missing required header parameter %y", ph.key);
                        break;
                    case "formData":
                        if (!exists body{ph.key})
                            error("MISSING-PARAMETER", "request is missing required formData parameter %y", ph.key);
                        break;
                    # NOTE: missing path parameters are not possible (path would not be matched in the first place)
                    #       "body" is handled specially
                }
            }
        }
    }

    #! returns the ResponseObject for hthe given HTTP code or @ref nothing if none is configured
    /** @return the ResponseObject for hthe given HTTP code or @ref nothing if none is configured
    */
    *ResponseObject getResponse(int code) {
        return responses.responses{code} ?? responses.defaultResp;
    }

    #! raises an exception with context information
    error(string err, string fmt) {
        throw err, sprintf("%s %s Operation Object: %s", method.upr(), path, vsprintf(fmt, argv));
    }
}

#! Allows referencing an external resource for extended documentation.
public class ExternalDocumentationObject inherits ObjectBase {
    public {
        #! A short description of the target documentation. GFM syntax can be used for rich text representation.
        *string desc;

        #! Required. The URL for the target documentation. Value MUST be in the format of a URL.
        string url;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description providing a reference to external documentation

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "External Documentation";
        required_field(objType, oh, "url", NT_STRING, \url);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
    }
}

#! Describes a single operation parameter.
/**
    A unique parameter is defined by a combination of a @ref AbstractParameterObject::name "name"
    and @ref AbstractParameterObject::inLoc "location".

    There are five possible parameter types:
    - Path: Used together with Path Templating, where the parameter value is
        actually part of the operation's URL. This does not include the host or
        base path of the API. For example, in <tt>/items/{itemId}</tt>, the path
        parameter is \c itemId.
    - Query: Parameters that are appended to the URL. For example, in <tt>/items?id=###</tt>,
        the query parameter is \c id.
    - Header: Custom headers that are expected as part of the request.
    - Body: The payload that's appended to the HTTP request. Since there can only
        be one payload, there can only be one body parameter. The name of the
        body parameter has no effect on the parameter itself and is used for
        documentation purposes only. Since Form parameters are also in the payload,
        body and form parameters cannot exist together for the same operation.
    - Form: Used to describe the payload of an HTTP request when either
        <tt>application/x-www-form-urlencoded</tt>, <tt>multipart/form-data</tt>
        or both are used as the content type of the request (in Swagger's definition,
        the \c consumes property of an operation). This is the only parameter
        type that can be used to send files, thus supporting the file type.
        Since form parameters are sent in the payload, they cannot be declared
        together with a body parameter for the same operation. Form parameters
        have a different format based on the content-type used (for further details,
        consult http://www.w3.org/TR/html401/interact/forms.html#h-17.13.4):
            - <tt>application/x-www-form-urlencoded</tt> - Similar to the format
                of Query parameters but as a payload. For example,
                <tt>foo=1&bar=swagger</tt> - both foo and bar are form parameters.
                This is normally used for simple parameters that are being transferred.
            - <tt>multipart/form-data</tt> - each parameter takes a section in
                the payload with an internal header. For example, for the header
                <tt>Content-Disposition: form-data; name="submit-name"<tt> the name
                of the parameter is \c submit-name. This type of form parameters
                is more commonly used for file transfers.
 */
public class AbstractParameterObject inherits ObjectBase {
    public {
        #! Required. The name of the parameter. Parameter names are case sensitive.
        /**
            - If @ref AbstractParameterObject::inLoc "inLoc" is \c "path", the \c name
                field MUST correspond to the associated path segment from the
                @ref PathsObject::path "path" field in the @ref PathsObject.
                See Path Templating for further information.
            - For all other cases, the name corresponds to the parameter name
                used based on the @ref AbstractParameterObject::inLoc "inLoc" property.
         */
        string name;

        #! Required. The location of the parameter.
        /**
            Possible values are \c "query", \c "header", \c "path",
            \c "formData" or \c "body".
         */
        string inLoc;

        #! A brief description of the parameter. This could contain examples of use. GFM syntax can be used for rich text representation.
        *string desc;

        #! Determines whether this parameter is mandatory.
        /**
            If the parameter is @ref AbstractParameterObject::inLoc "in" "path",
            this property is \b required and its value MUST be \c true.
            Otherwise, the property MAY be included and its default value is \c false.
         */
        bool required = False;

        #! Additional properties used when @ref AbstractParameterObject::inLoc "inLoc" is \c "body".
        *BodyParameter bodyParam;

        #! Additional properties used when @ref AbstractParameterObject::inLoc "inLoc" is not \c "body".
        *OtherParameter otherParam;
    }

    private {
        const OtherParameterMap = (
            "query": True,
            "header": True,
            "path": True,
            "formData": True,
        );
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description decscribing a single parameter

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "Parameter";
        required_field(objType, oh, "name", NT_STRING, \name);
        required_field(objType, oh, "in", NT_STRING, \inLoc);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
        if (inLoc == "path")
            required_field(objType, oh, "required", NT_BOOLEAN, \required);
        else
            optional_field(objType, oh, "required", NT_BOOLEAN, \required);
    }

    #! verifies the parameter in an actual REST API call
    abstract check(bool serialize, bool request, string path, string method, string name, reference value);

    #! returns the default value of the parameter (default: @ref nothing)
    any getDefaultValue() {
    }

    #! gets a concrete instance of an AbstractParameterObject
    static AbstractParameterObject newParameter(string name, hash oh, SwaggerObject swagger) {
        if (oh.hasKey("$ref"))
            return swagger.resolveParameter(name, oh."$ref", oh);

        if (!oh.hasKey("in"))
            throw "REQUIRED-FIELD-MISSING", sprintf("Parameter Object %y: missing location parameter \"in\"", name);
        if (oh."in" == "body")
            return new BodyParameter(oh, swagger);
        else if (OtherParameterMap{oh."in"})
            return new OtherParameter(oh, swagger);
        throw "INVALID-FIELD-VALUE", sprintf("Parameter Object %y: invalid location (\"in\") parameter value: %y", name, oh."in");
    }
}

#! @ref AbstractParameterObject specialization for \c "body" parameters.
public class BodyParameter inherits AbstractParameterObject {
    public {
        #! Required. The schema defining the type used for the body parameter.
        SchemaObject schema;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing a body parameter

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh, SwaggerObject swagger) : AbstractParameterObject(oh) {
        hash schemaObj;
        required_field("Body Parameter", oh, "schema", NT_HASH, \schemaObj);
        schema = SchemaObject::newSchemaObject("schema for body parameter", schemaObj, swagger);
    }

    #! verifies the parameter in an actual REST API call
    check(bool serialize, bool request, string path, string method, string name, reference value) {
        return schema.check(serialize, request, path, method, name, \value);
    }
}

#! @ref AbstractParameterObject specialization for parameters other than \c "body".
public class OtherParameter inherits AbstractParameterObject, SchemaBase {
    public {
        #! Required. The type of the parameter.
        /**
            Since the parameter is not located at the request body, it is
            limited to simple types (that is, not an object).
            The value MUST be one of \c "string", \c "number", \c "integer",
            \c "boolean", \c "array" or \c "file". If \c type is \c "file",
            the @ref OperationObject::consumes "consumes" MUST be either
            \c "multipart/form-data", \c " application/x-www-form-urlencoded" or
            both and the parameter MUST be @ref AbstractParameterObject::inLoc "in" \c "formData".
         */
        string type;

        #! The extending format for the previously mentioned \c type. See Data Type Formats for further details.
        *string format;

        #! Sets the ability to pass empty-valued parameters.
        /**
            This is valid only for either \c query or \c formData parameters and
            allows you to send a parameter with a name only or an empty value.
            Default value is \c false.
         */
        bool allowEmptyValue = False;

        #! Required if @ref OtherParameter::type "type" is \c "array". Describes the type of items in the array.
        *ItemsObject items;

        #! Determines the format of the array if type array is used.
        /**
            Possible values are:
            - \c "csv": comma separated values; ex: foo,bar
            - \c "ssv": space separated values; ex: foo bar
            - \c "tsv": tab separated values; ex: foo\tbar
            - \c "pipes": pipe separated values; ex: foo|bar
            - \c "multi": corresponds to multiple parameter instances instead of
                multiple values for a single instance <tt>foo=bar&foo=baz</tt>.
                This is valid only for parameters @ref AbstractParameterObject::inLoc "in"
                \c "query" or \c "formData".

            Default value is \c "csv".
         */
        *string collectionFormat;

        #! Declares the value of the parameter that the server will use if none is provided.
        /**
            For example a "count" to control the number of results per page
            might default to 100 if not supplied by the client in the request.
            (Note: "default" has no meaning for required parameters.)
            See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
            Unlike JSON Schema this value MUST conform to the defined type for this parameter.
         */
        any defaultVal;

        #! valid parameter types
        const ParameterTypes = SchemaObject::ScalarTypes + (
            "file": True,
        );

        #! valid collection formats
        const CollectionFormats = ItemsObject::CollectionFormats + (
            "multi": True,
        );
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing general parameters (other than \c "body" parameters)

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh, SwaggerObject swagger) : AbstractParameterObject(oh), SchemaBase("Parameter", oh) {
        string objType = "Parameter";
        required_field(objType, oh, "type", NT_STRING, \type);
        if (!ParameterTypes{type})
            throw "INVALID-FIELD-VALUE", sprintf("Parameter Object: invalid parameter type value passed: %y, expecting one of: %y", type, keys ParameterTypes);
        if (type == "array") {
            items = ItemsObject::newItemsObject(oh, CollectionFormats, swagger);
            if (items.collectionFormat == "multi" && inLoc != "query" && inLoc != "formData")
                throw "INVALID-FIELD-VALUE",
                    "Parameter Object: invalid collectionFormat value 'multi' - is only valid when 'in' (location) is either 'query' or 'formData'";
        }
        else if (oh.collectionFormat)
            throw "INVALID-FIELD-TYPE", sprintf("Parameter Object: type %y (non-array) cannot have a \"collectionFormat\" property (%y)", type, oh.collectionFormat);

        if (optional_field(objType, oh, "format", NT_STRING, \format)) {
            if (type == "integer" && !ValidIntFormatsHash{format})
                throw "INVALID-FIELD-VALUE", "Parameter Object: invalid integer type format value passed: " + format;
            else if (type == "number" && !ValidNumberFormatsHash{format})
                throw "INVALID-FIELD-VALUE", "Parameter Object: invalid number type format value passed: " + format;
            else if (type == "string" && !ValidStringFormatsHash{format})
                throw "INVALID-FIELD-VALUE", "Parameter Object: invalid string type format value passed: " + format;
        }

        optional_field(objType, oh, "allowEmptyValue", NT_BOOLEAN, \allowEmptyValue);

        if (oh.hasKey("default")) {
            defaultVal = oh.default;
            if ((defaultVal.typeCode() == NT_BOOLEAN && type != "boolean") ||
                (defaultVal.typeCode() == NT_INT && type != "integer") ||
                (defaultVal.typeCode() == NT_FLOAT && type != "number") ||
                (defaultVal.typeCode() == NT_STRING && type != "string") ||
                (defaultVal.typeCode() == NT_LIST && type != "array"))
                throw "INVALID-FIELD-TYPE",
                    sprintf("Parameter Object: 'default' value has invalid type %y (should be %y)",
                        defaultVal.type(), type);
            # TODO array
            /*if (type == "array")
                defaultVal = new ItemsObject(defaultVal);*/

            # TODO file type default value
        }
    }

    #! validates the value against the schema definition
    check(bool serialize, bool request, string path, string method, string name, reference value) {
        SchemaBase::check(serialize, request, type, items, path, method, name, \value);
        switch (value.typeCode()) {
            case NT_NOTHING:
                if (!allowEmptyValue)
                    throw "INVALID-PARAMETER-VALUE",
                        sprintf("Parameter %y for path %y and method %y has empty value (allowEmptyValue=false)",
                            name, path, method);
        }
    }

    #! validates string values
    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, string v, reference value) {
        if (type != "string")
            throwInvalidType(name, "string", type);

        if (serialize) {
            switch (format) {
                case "byte":
                    value = make_base64_string(v);
                    break;
                case "binary":
                    value = make_hex_string(v);
                    break;
            }
        }
        else {
            switch (format) {
                # NOTE: deserializes to a binary object
                case "byte":
                    value = parse_base64_string(v);
                    break;
                # NOTE: deserializes to a binary object
                case "binary":
                    value = parse_hex_string(v);
                    break;
                # NOTE: deserializes to a date/time value
                case "date":
                case "date-time":
                    # https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14
                    value = date(v);
                    break;
            }
        }
        checkStringIntern(path, method, name, value);
    }

    #! converts binary values to strings for supported formats
    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, binary v, reference value) {
        if (type != "string")
            throwInvalidType(name, "string", type);

        if (serialize) {
            switch (format) {
                case "byte":
                    value = make_base64_string(v);
                    break;
                case "binary":
                    value = make_hex_string(v);
                    break;
                default:
                    throw "INVALID-PARAMETER-VALUE", sprintf("%s %s: parameters %y: cannot serialize a binary value to a string value with format %y", method.upr(), path, name, format);
            }
        }
        # already-serialized dataa must be a string
        else
            throw "INVALID-PARAMETER-VALUE", sprintf("%s %s: parameters %y: cannot deserialize a binary value to a string value with format %y", method.upr(), path, name, format);

        checkStringIntern(path, method, name, value);
    }

    #! converts strings to/from date/time values for supported formats
    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, date v, reference value) {
        if (type != "string")
            throwInvalidType(name, "string", type);

        if (serialize) {
            switch (format) {
                case "date":
                    # https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14
                    value = v.format("YYYY-MM-DD");
                    break;
                case "date-time":
                    # https://xml2rfc.tools.ietf.org/public/rfc/html/rfc3339.html#anchor14
                    value = v.format("YYYY-MM-DD HH:mm:SS.y Z");
                    break;
                default:
                    throw "INVALID-PARAMETER-VALUE", sprintf("%s %s: parameters %y: cannot serialize a date/time value to a string value with format %y", method.upr(), path, name, format);
            }
        }
        # already-serialized dataa must be a string
        else
            throw "INVALID-PARAMETER-VALUE", sprintf("%s %s: parameters %y: cannot deserialize a date/time value to a string value with format %y", method.upr(), path, name, format);

        checkStringIntern(path, method, name, value);
    }

    #! returns the default value of the parameter (default: @ref nothing)
    any getDefaultValue() {
        return defaultVal;
    }
}

#! A limited subset of JSON-Schema's items object.
/**
    It is used by parameter definitions that are not located @ref AbstractParameterObject::inLoc "in" \c "body".
 */
public class ItemsObject inherits ObjectBase, SchemaBase {
    public {
        #! Required. The internal type of the array.
        /**
            The value MUST be one of \c "string", \c "number", \c "integer",
            \c "boolean", or \c "array". Files and models are not allowed.
         */
        string type;

        #! The extending format for the previously mentioned \c type. See Data Type Formats for further details.
        *string format;

        #! Required if type is \c "array". Describes the type of items in the array.
        *ItemsObject items;

        #! This is the format of this object.
        /**
            Possible values are:
            - \c "csv" - comma separated values foo,bar.
            - \c "ssv" - space separated values foo bar.
            - \c "tsv" - tab separated values foo\tbar.
            - \c "pipes" - pipe separated values foo|bar.

            Default value is \c "csv".
         */
        string collectionFormat = "csv";

        #! Declares the value of the item that the server will use if none is provided.
        /**
            (Note: "default" has no meaning for required items.)
            See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
            Unlike JSON Schema this value MUST conform to the defined
            @ref ItemsObject::type "type" for the data type.
         */
        any defaultVal;

        #! allowed collection formats
        const CollectionFormats = (
            "csv": True,
            "ssv": True,
            "tsv": True,
            "pipes": True,
        );
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing an item to be used by parameter definitions that are not located @ref AbstractParameterObject::inLoc "in" \c "body"

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    private constructor(hash oh, *hash<string, bool> collectionFormats, SwaggerObject swagger) : ObjectBase(oh.items), SchemaBase("Items", oh.items) {
        string objType = "Items";

        hash itemsObj;
        required_field(objType, oh, "items", NT_HASH, \itemsObj);

        if (optional_field(objType, oh, "collectionFormat", NT_STRING, \collectionFormat)) {
            if (collectionFormats && !collectionFormats{collectionFormat})
                throw "INVALID-FIELD-VALUE", "Items Object: invalid collectionFormat value passed: " + collectionFormat;
        }

        required_field(objType, itemsObj, "type", NT_STRING, \type);
        if (!SchemaObject::ScalarTypes{type})
            throw "INVALID-FIELD-VALUE", "Items Object: invalid items type value passed: " + type;

        if (type == "array")
            items = ItemsObject::newItemsObject(itemsObj, CollectionFormats, swagger);
        else if (itemsObj.collectionFormat)
            throw "INVALID-FIELD-TYPE", sprintf("Items Object: type %y (non-array) cannot have a \"collectionFormat\" property (%y)", type, itemsObj.collectionFormat);

        if (optional_field(objType, itemsObj, "format", NT_STRING, \format)) {
            if (type == "integer" && !ValidIntFormatsHash{format})
                throw "INVALID-FIELD-VALUE", "Items Object: invalid integer type format value passed: " + format;
            else if (type == "number" && !ValidNumberFormatsHash{format})
                throw "INVALID-FIELD-VALUE", "Items Object: invalid number type format value passed: " + format;
            else if (type == "string" && !ValidStringFormatsHash{format})
                throw "INVALID-FIELD-VALUE", "Items Object: invalid string type format value passed: " + format;
        }

        if (itemsObj.hasKey("default")) {
            defaultVal = itemsObj.default;
            if ((defaultVal.typeCode() == NT_BOOLEAN && type != "boolean") ||
                (defaultVal.typeCode() == NT_INT && type != "integer") ||
                (defaultVal.typeCode() == NT_FLOAT && type != "number") ||
                (defaultVal.typeCode() == NT_STRING && type != "string") ||
                (defaultVal.typeCode() == NT_LIST && type != "array"))
                throw "INVALID-FIELD-TYPE",
                    sprintf("Items Object: 'default' value has invalid type %y (should be %y)",
                        defaultVal.type(), type);
            # TODO array
            /*if (type == "array")
                defaultVal = new ItemsObject(defaultVal);*/
        }
    }

    #! creates the object from a SchemaObject reference
    constructor(SchemaObject obj) : ObjectBase(obj), SchemaBase(obj) {
        self += obj.("type", "format", "items", "defaultVal");
    }

    #! validates the value against the schema definition
    check(bool serialize, bool request, string path, string method, string name, reference value) {
        SchemaBase::check(serialize, request, type, items, path, method, name, \value);
    }

    #! creates a new ItemsObject and resolves any references
    static ItemsObject newItemsObject(hash oh, *hash<string, bool> collectionFormats, SwaggerObject swagger) {
        if (oh.items.typeCode() != NT_HASH)
            throw "INVALID-FIELD-TYPE", sprintf("expecting a hash 'items' definition; got type %y instead", oh.items.type());
        if (oh.items.hasKey("$ref"))
            return swagger.resolveItems(oh.items."$ref", oh.items);

        return new ItemsObject(oh, collectionFormats, swagger);
    }
}

#! contains the possible responses for an operation
public class ResponsesObject inherits ObjectBase {
    public {
        # The documentation of responses other than the ones declared for specific HTTP response codes.
        /**
            It can be used to cover undeclared responses.
         */
        ResponseObject defaultResp;

        # A hash mapping HTTP status codes to @ref ResponseObject "ResponseObjects".
        /**
            Any HTTP status code can be used as the property name (one property
            per HTTP status code). Describes the expected response for that HTTP status code.
         */
        hash<string, ResponseObject> responses;
    }

    #! Constructor.
    /**
        @param path the URI path for the operation
        @param method the HTTP method for the operation
        @param oh deserialized hash from the source schema description describing the responses for an operation

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
        @throws EMPTY-RESPONSES no responses given
     */
    public constructor(string path, string method, hash oh, SwaggerObject swagger) : ObjectBase(oh) {
        string objType = "Responses";
        *hash defaultObj;
        if (optional_field(objType, oh, "default", NT_HASH, \defaultObj))
            defaultResp = ResponseObject::newResponse("default", defaultObj, swagger);

        *hash r = map {$1.key: $1.value}, oh.pairIterator(), $1.key =~ /^[0-9]+$/;
        foreach hash resp in (r.pairIterator()) {
            if (resp.value.typeCode() != NT_HASH)
                throw "INVALID-FIELD-TYPE", sprintf("%s %s: Responses Object: response has invalid type %y", method, path, resp.value.type());
            responses{resp.key} = ResponseObject::newResponse(resp.key, resp.value, swagger);
        }

        if (responses.empty() && !defaultObj)
            throw "EMPTY-RESPONSES", sprintf("%s %s: no valid responses provided for operation", method, path);
    }
}

#! Describes a single response from an API Operation.
public class ResponseObject inherits ObjectBase {
    public {
        #! Required. A short description of the response. GFM syntax can be used for rich text representation.
        string desc;

        #! A definition of the response structure.
        /**
            It can be a primitive, an array or an object. If this field does not exist,
            it means no content is returned as part of the response. As an extension
            to the @ref SchemaObject "SchemaObject", its root \c type value may also
            be \c "file". This SHOULD be accompanied by a relevant \c produces mime-type.
         */
        *SchemaObject schema;

        #! A hash of headers that are (can be) sent with the response.
        /**
            A hash of @ref HeaderObject objects. Keys are header names.
         */
        hash headers;

        #! A hash of example response messages.
        /**
            A hash of example responses in the form of <tt>Example Object</tt>.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#exampleObject
            Keys MUST be one of the Operation @ref OperationObject::produces "produces"
            values (either implicit or inherited). The value SHOULD be an example
            of what such a response would look like.
         */
        hash examples;
    }

    #! private constructor; use newResponse() instead
    /**
        @param oh deserialized hash from the source schema description describing a single response for an API operation
        @param swagger the schema object for reference lookups

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    private constructor(string key, hash oh, SwaggerObject swagger) : ObjectBase(oh) {
        string objType = key + " Response";
        required_field(objType, oh, "description", NT_STRING, \desc);

        *hash schemaObj;
        if (optional_field(objType, oh, "schema", NT_HASH, \schemaObj))
            schema = SchemaObject::newSchemaObject("response schema", schemaObj, swagger);

        *hash headersObj;
        if (optional_field(objType, oh, "headers", NT_HASH, \headersObj))
            headers = map {$1.key: new HeaderObject($1.value, swagger)}, headersObj.pairIterator();

        optional_field(objType, oh, "examples", NT_HASH, \examples);
        # TODO keys should be Operation 'produces' values
    }

    #! returns a new ResponseObject corresponding to the schema definition passed
    /**
        @param key the response code for the response
        @param oh deserialized hash from the source schema description describing a single response for an API operation
        @param swagger the schema object for reference lookups

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    static ResponseObject newResponse(string key, hash oh, SwaggerObject swagger) {
        if (oh.hasKey("$ref"))
            return swagger.resolveResponse(key, oh."$ref", oh);
        return new ResponseObject(key, oh, swagger);
    }
}

#! describes a single HTTP header
public class HeaderObject inherits ObjectBase, SchemaBase {
    public {
        #! A short description of the header.
        *string desc;

        #! Required. The type of the object.
        /**
            The value MUST be one of \c "string", \c "number", \c "integer",
            \c "boolean", or \c "array".
         */
        string type;

        #! The extending format for the previously mentioned \c type. See Data Type Formats for further details.
        *string format;

        #! Required if @ref HeaderObject::type "type" is \c "array". Describes the type of items in the array.
        *ItemsObject items;

        #! Determines the format of the array if type array is used.
        /**
            Possible values are:
            - \c "csv": comma separated values; ex: foo,bar
            - \c "ssv": space separated values; ex: foo bar
            - \c "tsv": tab separated values; ex: foo\tbar
            - \c "pipes": pipe separated values; ex: foo|bar

            Default value is \c "csv".
         */
        *string collectionFormat;

        #! Declares the value of the header that the server will use if none is provided.
        /**
            (Note: "default" has no meaning for required headers.)
            See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
            Unlike JSON Schema this value MUST conform to the defined
            @ref HeaderObject::type "type" for the header.
         */
        any defaultVal;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing a single HTTP header

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh, SwaggerObject swagger) : ObjectBase(oh), SchemaBase("Header", oh) {
        string objType = "Header";
        required_field(objType, oh, "type", NT_STRING, \type);
        if (!SchemaObject::ScalarTypes{type})
            throw "INVALID-FIELD-VALUE", "Header Object: invalid header type value passed: " + type;

        if (type == "array")
            items = ItemsObject::newItemsObject(oh, ItemsObject::CollectionFormats, swagger);
        else if (oh.collectionFormat)
            throw "INVALID-FIELD-TYPE", sprintf("Header Object: type %y (non-array) cannot have a \"collectionFormat\" property (%y)", type, oh.collectionFormat);

        if (optional_field(objType, oh, "format", NT_STRING, \format)) {
            if (type == "integer" && !ValidIntFormatsHash{format})
                throw "INVALID-FIELD-VALUE", "Header Object: invalid integer type format value passed: " + format;
            else if (type == "number" && !ValidNumberFormatsHash{format})
                throw "INVALID-FIELD-VALUE", "Header Object: invalid number type format value passed: " + format;
            else if (type == "string" && !ValidStringFormatsHash{format})
                throw "INVALID-FIELD-VALUE", "Header Object: invalid string type format value passed: " + format;
        }

        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);

        if (oh.hasKey("default")) {
            defaultVal = oh.default;
            if ((defaultVal.typeCode() == NT_BOOLEAN && type != "boolean") ||
                (defaultVal.typeCode() == NT_INT && type != "integer") ||
                (defaultVal.typeCode() == NT_FLOAT && type != "number") ||
                (defaultVal.typeCode() == NT_STRING && type != "string") ||
                (defaultVal.typeCode() == NT_LIST && type != "array"))
                throw "INVALID-FIELD-TYPE",
                    sprintf("Header Object: 'default' value has invalid type %y (should be %y)",
                        defaultVal.type(), type);
            # TODO array
            /*if (type == "array")
                defaultVal = new ItemsObject(defaultVal);*/
        }

        # TODO default value type
    }
}

#! Allows adding metadata to a single tag that is used by the @ref OperationObject. It is not mandatory to have a TagObject per tag used there.
public class TagObject inherits ObjectBase {
    public {
        #! Required. The name of the tag.
        string name;

        #! A short description for the tag. GFM syntax can be used for rich text representation.
        *string desc;

        #! Additional external documentation for this tag.
        *ExternalDocumentationObject externalDocs;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing a metadata tag associated with an operation

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "Tag";
        required_field(objType, oh, "name", NT_STRING, \name);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);

        *hash extDocsObj;
        if (optional_field(objType, oh, "externalDocs", NT_HASH, \extDocsObj))
            externalDocs = new ExternalDocumentationObject(extDocsObj);
    }
}

#! defines an object in a schema
public class SchemaObject inherits ObjectBase, SchemaBase {
    public {
        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.2.
        /**
            MUST be either a string or an array (list). If it's an array,
            it's elements MUST be strings and MUST be unique.
         */
        string type;

        #! The extending format for the previously mentioned \c type. See Data Type Formats for further details.
        *string format;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.1.
        *string title;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.1.
        *string desc;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.3.1.
        *ItemsObject items;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-6.2.
        any defaultVal;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.1.
        *int maxProperties;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.2.
        *int minProperties;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.4.
        /**
            MUST be an object. Each value of this object MUST be an object,
            and each object MUST be a valid JSON Schema (@ref SchemaObject).
         */
        hash<string, SchemaObject> properties;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.4.
        /**
            MUST be a bool or an object. If it is an object, it MUST also be
            a valid JSON Schema (@ref SchemaObject).
         */
        any additionalProperties;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.4.3.
        /**
            Set of strings. Must have at least one element.
         */
        hash<string, bool> required;

        #! Adds support for polymorphism.
        /**
            The discriminator is the schema property name that is used to
            differentiate between other schemas that inherit this schema.
            The property name used MUST be defined at this schema and it MUST
            be in the @ref SchemaObject::required "required" property list.
            When used, the value MUST be the name of this schema or any schema
            that inherits it.

            While composition offers model extensibility, it does not imply
            a hierarchy between the models. To support polymorphism, Swagger
            adds the support of the \c discriminator field. When used,
            the \c discriminator will be the name of the property used to decide
            which schema definition is used to validate the structure of the model.
            As such, the \c discriminator field MUST be a required field.
            The value of the chosen property has to be the friendly name given to
            the model under the \c definitions property. As such, inline schema
            definitions, which do not have a given id, \e cannot be used in polymorphism.
         */
        *string discriminator;

        #! Relevant only for Schema \c "properties" definitions. Declares the property as "read only".
        /**
            Declares the property as "read only". This means that it MAY be sent
            as part of a response but MUST NOT be sent as part of the request.
            Properties marked as \c readOnly being \c true SHOULD NOT be in the
            @ref SchemaObject::required "required" list of the defined schema.
            Default value is \c false.
         */
        bool readOnly = False;

        #! See https://tools.ietf.org/html/draft-fge-json-schema-validation-00#section-5.5.3.
        /**
            List of @ref SchemaObject "SchemaObjects"; MUST have at least one element.

            Swagger allows combining and extending model definitions using the
            \c allOf property of JSON Schema, in effect offering model composition.
            \c allOf takes in an array of object definitions that are validated
            independently but together compose a single object.
         */
        list<SchemaObject> allOf();

        #! This MAY be used only on properties schemas. It has no effect on root schemas.
        /**
            Adds Additional metadata to describe the XML representation format of this property.

            The \c xml property allows extra definitions when translating the
            JSON definition to XML. The @ref XMLObject contains additional
            information about the available options.
         */
        *XmlObject xml;

        #! Additional external documentation for this schema.
        *ExternalDocumentationObject externalDocs;

        #! A free-form property to include an example of an instance for this schema.
        any example;

        #! valid scalar types
        const ScalarTypes = (
            "string": True,
            "number": True,
            "integer": True,
            "boolean": True,
            "array": True,
        );

        #! valid reference types
        const ReferenceTypes = ScalarTypes + (
            "object": True,
        );
    }

    #! private constructor; use newSchemaObject() instead
    /**
        @param name the name of the object
        @param oh deserialized hash from the source schema description describing an object in the schema
        @param swagger schema object so references can be resolved

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws INVALID-COLLECTION-FORMAT invalid collectionFormat value
        @throws INVALID-REFERENCE cannot resolve reference; unknown attributes in description
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    private constructor(string name, hash oh, SwaggerObject swagger) : ObjectBase(oh), SchemaBase("Schema", oh) {
        string objType = "Schema";

        required_field(objType, oh, "type", NT_STRING, \type);
        if (!ReferenceTypes{type})
            throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: invalid schema type value passed: %y; expected one of: %y", name, type, keys ReferenceTypes);
        if (type == "array") {
            # no collection formats for schema objects
            items = ItemsObject::newItemsObject(oh, NOTHING, swagger);
        }

        if (oh.hasKey("default")) {
            defaultVal = oh.default;
            if ((defaultVal.typeCode() == NT_BOOLEAN && type != "boolean") ||
                (defaultVal.typeCode() == NT_INT && type != "integer") ||
                (defaultVal.typeCode() == NT_FLOAT && type != "number") ||
                (defaultVal.typeCode() == NT_STRING && type != "string") ||
                (defaultVal.typeCode() == NT_LIST && type != "array"))
                throw "INVALID-FIELD-TYPE",
                    sprintf("Schema Object %y: 'default' value has invalid type %y (should be %y)", name,
                        defaultVal.type(), type);
            # TODO array
            /*
            if (type == "array")
                defaultVal = new ItemsObject(defaultVal);
            */
            # TODO file
            # TODO other possibilities?
        }

        if (optional_field(objType, oh, "format", NT_STRING, \format)) {
            if (type == "integer" && !ValidIntFormatsHash{format})
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: invalid integer type format value passed: %y", name, format);
            else if (type == "number" && !ValidNumberFormatsHash{format})
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: invalid number type format value passed: %y", name, format);
            else if (type == "string" && !ValidStringFormatsHash{format})
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: invalid string type format value passed: %y", name, format);
        }

        optional_field(objType, oh, "title", NT_STRING, \title);
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);

        if (optional_field(objType, oh, "maxProperties", NT_INT, \maxProperties)) {
            checkObjectProperty(name, "maxProperties");
            if (maxProperties < 0)
                throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: 'maxProperties' field less than 0", name);
        }
        if (optional_field(objType, oh, "minProperties", NT_INT, \minProperties)) {
            checkObjectProperty(name, "minProperties");
            if (minProperties < 0)
                throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: 'minProperties' field less than 0", name);
        }

        {
            hash props;
            if (optional_field(objType, oh, "properties", NT_HASH, \props)) {
                checkObjectProperty(name, "properties");
                foreach string k in (keys props) {
                    any val = props{k};
                    if (val.typeCode() != NT_HASH)
                        throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: 'properties' field is not a hash of Schema Objects", name);
                    properties{k} = SchemaObject::newSchemaObject(k, val, swagger);
                }
            }
        }

        if (optional_field(objType, oh, "additionalProperties", (NT_BOOLEAN: True, NT_HASH: True), \additionalProperties)) {
            checkObjectProperty(name, "additionalProperties");
            if (additionalProperties.typeCode() == NT_HASH)
                additionalProperties = SchemaObject::newSchemaObject("additionalProperties", additionalProperties, swagger);
        }

        # process "required"
        if (optional_field(objType, oh, "required", SwaggerListToSet, \required)) {
            if (!required)
                throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: field 'required' is an empty list", name);
        }

        if (optional_field(objType, oh, "discriminator", NT_STRING, \discriminator)) {
            if (!required{discriminator})
                throw "INVALID-FIELD-VALUE", sprintf("Schema Object %y: 'discriminator' field value not in the 'required' list", name);
        }

        optional_field(objType, oh, "readOnly", NT_BOOLEAN, \readOnly);

        {
            *list allOfList;
            if (optional_field(objType, oh, "allOf", NT_LIST, \allOfList)) {
                if (allOfList.size() < 1)
                    throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: field 'allOf' is an empty list", name);
                foreach any val in (allOfList) {
                    if (val.typeCode() != NT_HASH)
                        throw "INVALID-FIELD-TYPE", sprintf("Schema Object %y: invalid 'allOf' list value datatype: %y", name, val.type());
                    allOf += SchemaObject::newSchemaObject("allOf schema", val, swagger);
                }
            }
        }

        *hash xmlObj;
        if (optional_field(objType, oh, "xml", NT_HASH, \xmlObj))
            xml = new XmlObject(xmlObj);

        *hash extDocsObj;
        if (optional_field(objType, oh, "externalDocs", NT_HASH, \extDocsObj))
            externalDocs = new ExternalDocumentationObject(extDocsObj);

        if (oh.hasKey("example"))
            example = oh.example;
    }

    private checkObjectProperty(string name, string prop) {
        if (type != "object")
            throw "INVALID-FIELD-FORMAT", sprintf("Schema Object %y: %y cannot be given on an object of type %y", name, prop, type);
    }

    #! validates the value against the schema definition
    check(bool serialize, bool request, string path, string method, string name, reference value) {
        if (request && readOnly)
            throw "READONLY-PROPERTY-ERROR", sprintf("%s %s: property %y is read-only and therefore cannot be included in a request", method.upr(), path, name);

        SchemaBase::check(serialize, request, type, items, path, method, name, \value);
    }

    #! validates a schema object against a value
    private checkIntern(bool serialize, bool request, string type, string path, string method, string name, hash v, reference<hash> value) {
        if (type != "object")
            throwInvalidType(name, "object", type);

        # check "allOf" schemas, if any
        map $1.checkIntern(serialize, request, type, path, method, name, v, \value), allOf;

        /*
        If additionalProperties is set to true, any number of additionalProperties may be present of any data type.
        If additionalProperties is a schema, additional properties (beyond what are defined in ‘properties’) are allowed and must match the schema
        */
        # check properties in this schema definition
        if (additionalProperties !== True) {
            foreach string key in (keys value) {
                *SchemaObject prop = properties{key};
                if (!prop) {
                    if (additionalProperties instanceof SchemaObject)
                        prop = additionalProperties.properties{key};
                    if (!prop)
                        throw "INVALID-PROPERTY", sprintf("property %y is not valid for object %y", key, name);
                }
                prop.check(serialize, request, path, method, name, \value{key});
            }
        }
        # check for missing required properties
        foreach string prop in (keys required) {
            if (!value.hasKey(prop))
                throw "MISSING-PROPERTY", sprintf("object %y: missing required property %y", name, prop);
        }
        #printf("SchemaObject::checkIntern() %y type: %y val: %y self: %N\n", name, type, value, self);
    }

    #! returns a SchemaObject for the schema definition; resolves references
    /**
        @param name the name of the object
        @param oh deserialized hash from the source schema description describing an object in the schema
        @param swagger schema object so references can be resolved

        @throws INVALID-FIELD-FORMAT field has invalid format
        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FIELD-VALUE field has invalid value
        @throws INVALID-COLLECTION-FORMAT invalid collectionFormat value
        @throws INVALID-REFERENCE cannot resolve reference; unknown attributes in description
        @throws REQUIRED-FIELD-MISSING required field is missing
    */
    static SchemaObject newSchemaObject(string name, hash oh, SwaggerObject swagger) {
        string refstr;
        if (optional_field("Schema", oh, "$ref", NT_STRING, \refstr))
            return swagger.resolveSchemaObject(name, refstr, oh);
        return new SchemaObject(name, oh, swagger);
    }
}

#! A metadata object that allows for more fine-tuned XML model definitions.
/**
    When using arrays, XML element names are not inferred (for singular/plural
    forms) and the @ref XmlObject::name "name" property should be used to add that information.
    See examples for expected behavior.
 */
public class XmlObject inherits ObjectBase {
    public {
        #! Replaces the name of the element/attribute used for the described schema property.
        /**
            When defined within the @ref ItemsObject (\c items), it will affect
            the name of the individual XML elements within the list.
            When defined alongside \c type being \c array (outside the \c items),
            it will affect the wrapping element and only if \c wrapped is \c true.
            If \c wrapped is \c false, it will be ignored.
         */
        *string name;

        #! The URL of the namespace definition. Value SHOULD be in the form of a URL.
        *string ns;

        #! The prefix to be used for the @ref XmlObject::name "name".
        *string prefix;

        #! Declares whether the property definition translates to an attribute instead of an element. Default value is \c false.
        bool attribute = False;

        #! MAY be used only for an array definition. Signifies whether the array is wrapped (for example, \c <books><book/><book/></books>) or unwrapped (\c <book/><book/>).
        /**
            Default value is \c false. The definition takes effect only when
            defined alongside \c type being \c array (outside the \c items).
         */
        bool wrapped = False;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing XML model definitions

        @throws INVALID-FIELD-TYPE field has invalid type
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "XML";
        optional_field(objType, oh, "name", NT_STRING, \name);
        optional_field(objType, oh, "namespace", NT_STRING, \ns);
        optional_field(objType, oh, "prefix", NT_STRING, \prefix);
        optional_field(objType, oh, "attribute", NT_BOOLEAN, \attribute);
        optional_field(objType, oh, "wrapped", NT_BOOLEAN, \wrapped);
    }
}

#! Allows the definition of a security scheme that can be used by the operations.
/**
    Supported schemes are basic authentication, an API key (either as a header
    or as a query parameter) and OAuth2's common flows (implicit, password,
    application and access code).
 */
public class SecuritySchemeObject inherits ObjectBase {
    public {
        #! Required. The type of the security scheme. Valid values are \c "basic", \c "apiKey" or \c "oauth2".
        string type;

        #! A short description for security scheme.
        *string desc;

        #! The name of the header or query parameter to be used.
        /**
            Required when type is \c "apiKey".
         */
        *string name;

        #! The location of the API key. Valid values are \c "query" or \c "header".
        /**
            Required when type is \c "apiKey".
         */
        *string inLoc;

        #! The flow used by the OAuth2 security scheme.
        /**
            Required when type is \c "oauth2".

            Valid values are \c "implicit", \c "password", \c "application" or \c "accessCode".
         */
        *string flow;

        #! The authorization URL to be used for this flow. This SHOULD be in the form of a URL.
        /**
            Required when type is \c "oauth2" and flow is \c "implicit" or \c "accessCode".
         */
        *string authorizationUrl;

        #! The token URL to be used for this flow. This SHOULD be in the form of a URL.
        /**
            Required when type is \c "oauth2" and flow is one of \c "password", \c "application" or \c "accessCode".
         */
        *string tokenUrl;

        #! The available scopes for the OAuth2 security scheme.
        /**
            Required when type is \c "oauth2".

            A hash in the form of </tt>Scopes Object</tt> mapping scope names to short descriptions of them.
            See https://github.com/OAI/OpenAPI-Specification/blob/master/versions/2.0.md#scopesObject
            Keys are scope names. Values are short string descriptions.
         */
        *ScopesObject scopes;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing a security schema that can be used by REST API operations

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws INVALID-FLOW invalid OAuth2 flow value
        @throws INVALID-APIKEY-LOCATION invalid 'in' (location) value
        @throws INVALID-SCHEME-TYPE invalid security scheme type; see @ref SecuritySchemeObject::type "type"
        @throws REQUIRED-FIELD-MISSING required field is missing
     */
    public constructor(hash oh) : ObjectBase(oh) {
        string objType = "Security Scheme";
        required_field(objType, oh, "type", NT_STRING, \type);
        if (type == "apiKey") {
            required_field(objType, oh, "name", NT_STRING, \name);
            required_field(objType, oh, "in", NT_STRING, \inLoc);
            if (inLoc != "query" && inLoc != "header")
                throw "INVALID-APIKEY-LOCATION", "Security Scheme Object: invalid 'in' (location) value passed: " + inLoc;
        }
        else if (type == "oauth2") {
            required_field(objType, oh, "flow", NT_STRING, \flow);
            if (flow == "accessCode") {
                required_field(objType, oh, "authorizationUrl", NT_STRING, \authorizationUrl);
                required_field(objType, oh, "tokenUrl", NT_STRING, \tokenUrl);
            }
            else if (flow == "application" || flow == "password") {
                required_field(objType, oh, "tokenUrl", NT_STRING, \tokenUrl);
            }
            else if (flow == "implicit") {
                required_field(objType, oh, "authorizationUrl", NT_STRING, \authorizationUrl);
            }
            else {
                throw "INVALID-FLOW", "Security Scheme Object: invalid OAuth2 flow value passed: " + flow;
            }

            hash scopesObj;
            required_field(objType, oh, "scopes", NT_HASH, \scopesObj);
            scopes = new ScopesObject(scopesObj);
        }
        else if (type != "basic") {
            throw "INVALID-SCHEME-TYPE", "Security Scheme Object: invalid security scheme type passed: " + type;
        }
        optional_field(objType, oh, "description", (NT_STRING: True, NT_NOTHING: True), \desc);
    }
}

#! Lists the available scopes for an OAuth2 security scheme.
public class ScopesObject inherits ObjectBase {
    public {
        #! Maps between a name of a scope to a short description of it (as the value of the property).
        /**
            Hash of string values.
         */
        hash<string, string> fields;
    }

    #! Constructor.
    /**
        @param oh deserialized hash from the source schema description describing the available scopes for an OAuth2 security scheme

        @throws INVALID-FIELD-TYPE field has invalid type
     */
    public constructor(hash oh) : ObjectBase(oh) {
        foreach hash item in (oh.pairIterator()) {
            if (item.key !~ /^x-/) { # if not vendor extension
                if (item.value.typeCode() != NT_STRING)
                    throw "INVALID-FIELD-TYPE",
                        sprintf("Scopes Object: %y field has invalid type %y, instead of 'string'",
                            item.key, item.value.type());
                fields{item.key} = item.value;
            }
        }
    }
}

} # end public namespace swagger

# private namespace for internal definitions
namespace Priv {
    const SwaggerListToSet = -1;
    const SwaggerListToHashOfStrings = -2;

    const TypeMap = (
        NT_INT: "int",
        NT_STRING: "string",
        NT_FLOAT: "float",
        NT_LIST: "list",
        NT_HASH: "hash",
        NT_NOTHING: "nothing",
        NT_BOOLEAN: "bool",
        SwaggerListToSet: "list<string>",
    );

    #! Check and assign a required field.
    /**
        @param objType type of object (e.g. "External Documentation")
        @param oh Object hash
        @param name field name
        @param typeCode field typeCode
        @param target where to assign the field's value

        @throws INVALID-FIELD-TYPE field has invalid type
        @throws REQUIRED-FIELD-MISSING required field is missing
    */
    sub required_field(string objType, hash oh, string name, int typeCode, reference<any> target) {
        if (!oh.hasKey(name))
            throw "REQUIRED-FIELD-MISSING", sprintf("%s Object: %y field is missing; fields present: %y", objType, name, keys oh);
        any val = oh{name};
        check_type_code(objType, name, val, typeCode);
        get_value(objType, name, typeCode, val, \target);
    }

    #! Check and assign a field.
    /**
        @param objType type of object (e.g. "External Documentation" or "Parameter")
        @param oh Object hash
        @param name field name
        @param typeCode field typeCode
        @param target where to assign the field's value

        @return whether the field was assigned

        @throws INVALID-FIELD-TYPE field has invalid type
    */
    bool sub optional_field(string objType, hash oh, string name, int typeCode, reference<any> target) {
        if (!oh.hasKey(name))
            return False;
        any val = oh{name};
        check_type_code(objType, name, val, typeCode);
        get_value(objType, name, typeCode, val, \target);
        return True;
    }

    #! Check and assign a field.
    /**
        @param objType type of object (e.g. "External Documentation" or "Parameter")
        @param oh Object hash
        @param name field name
        @param typeCodes possible field typeCodes
        @param target where to assign the field's value

        @return whether the field was assigned

        @throws INVALID-FIELD-TYPE field has invalid type
    */
    bool sub optional_field(string objType, hash oh, string name, hash<string, bool> typeCodes, reference<any> target) {
        if (!oh.hasKey(name))
            return False;
        any val = oh{name};
        if (!typeCodes{val.typeCode()})
            throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y field has invalid type %y", objType, name, val.type());
        get_value(objType, name, val.typeCode(), val, \target);
        return True;
    }

    #! verifies the type of a field
    sub check_type_code(string objType, string name, any val, int typeCode) {
        int vtc = val.typeCode();
        if ((typeCode == SwaggerListToSet || typeCode == SwaggerListToHashOfStrings) && vtc == NT_LIST)
            return;
        if (vtc != typeCode)
            throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y field has invalid type %y; expecting %y", objType, name, val.type(), TypeMap{typeCode});
    }

    #! assigns a value to a field
    sub get_value(string objType, string name, int typeCode, any val, reference<any> target) {
        if (typeCode == SwaggerListToSet) {
            foreach any v in (val) {
                if (v.typeCode() != NT_STRING)
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d in %y list value has type %y; expecting \"string\"", objType, name, $# + 1, val.size(), v.type());
                target{v} = True;
            }
        }
        else if (typeCode == SwaggerListToHashOfStrings) {
            foreach any v in (val) {
                int pos = $# + 1;
                if (v.typeCode() != NT_HASH)
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d value has type %y; expecting \"hash\"", objType, name, pos, val.size(), v.type());
                if (v.size() > 1)
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d value has a hash with more than one key: %y; expecting a hash with a single key", objType, name, pos, val.size(), v);
                string key = v.firstKey();
                if (target.hasKey(key))
                    throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d has duplicate key %y", objType, name, pos, val.size(), key);
                foreach any fv in (v.firstValue()) {
                    if (fv.typeCode() != NT_STRING)
                        throw "INVALID-FIELD-TYPE", sprintf("%s Object: %y element %d/%d in %y list value has type %y in position %d/%d; expecting \"string\"", objType, name, pos, val.size(), key, fv.type(), $# + 1, fv.lsize());
                }
                target += v;
            }
        }
        else
            target = val;
    }
}