/** @page description Language Description

    @section desc_contents Contents of this Section
    - @ref desc_overview
    - @ref environment_variables
    - @ref conditional_parsing
    - @ref modules
    - @ref include_files
    - @ref identifiers
    - @ref comments
    - @ref variables
    - @ref basic_data_types
      - @ref boolean
      - @ref string
      - @ref integer
      - @ref float
      - @ref date
      - @ref binary
      - @ref null
      - @ref nothing
    - @ref container_data_types
      - @ref list
      - @ref hash
      - @ref object
    - @ref data_type_declarations
    - @ref overloading
    - @ref time_zones
    - @ref character_encoding
    - @ref expressions
    - @ref operators
    - @ref qore_regex
    - @ref date_time_arithmetic
    - @ref statements
    - @ref functions
    - @ref namespaces
    - @ref constants
    - @ref classes
    - @ref threading
    - @ref exception_handling
    - @ref signal_handling
    
    @section desc_overview Language Overview

    A %Qore program is composed of a series of declarations, statements, function definitions, and/or class definitions. Non-block statements are terminated by a semi-colon ";". Block statements are grouped by using curly brackets ("{" and "}"), as in C, C++, Java, and Perl.

    Programmers familiar with C, C++, Java, and/or Perl should find the standard %Qore syntax intuitive and should be productive fairly quickly with the language. However %Qore has unique features that differentiate it from other languages, and these features must be mastered in order to leverage the full power of %Qore.

    %Qore programs/scripts are free form. Formatting does not affect the execution of the program; formatting is at the discretion of the programmer and should be used to enhance readability and clarity of the source code.

    %Qore was created as a weakly typed language. That means that @ref variables "variables" (without type restrictions) can hold values of any type and functions (without a return type restriction or parameter type descriptions) can return any data type and take arguments of any type. Furthermore list elements can be of any type (they do not have to be uniform), and multidimensional lists can have a different number of elements in each list. The same type flexibility holds true of hashes, objects, and all combinations of container types.

    %Qore also allows variable, parameter, class member, and return types to be declared, so that APIs can be formally defined or the programmer can decide to declare types to catch more errors at parse time (which is often preferable to discovering a type error at runtime).

    %Qore can be used as a traditional function-based scripting language or as a pure object-oriented language, where the application is defined as a class. Aside from traditional local and global variables, constants, and functions, %Qore also supports nested @ref namespaces "namespaces", @ref classes "classes", @ref inheritance "multiple inheritance", overriding base class constructor arguments, public and private @ref class_members "members" and @ref class_methods "methods", @ref static_class_methods "static class methods", and @ref static_class_variables "static class variables".

    All elements of %Qore are designed to work together: @ref Qore::Datasource "database access", @ref Qore::Socket "socket communication", @ref Qore::Program "embedding logic in subprograms", @ref regular_expressions "regular expressions", @ref operators "operators", @ref function_library "functions", and all other elements are thread-safe and built on an execution engine that was designed for SMP scalability.

    %Qore automatically converts data types when necessary when evaluating operators. The goal is to provide the expected result for the programmer without requiring the programmer to explicitly convert data types. Please see @ref operators for more information.

    %Qore supports @ref signal_handling "signal handling" by executing %Qore-language signal handlers in special @ref signal_handling "single-handling thread".

    UNIX operating systems allow an executable script to specify their interpreter. This is done by setting the first line in the program to a special string indicating the location of the %Qore binary. For the purposes of this document, the location for the %Qore binary is assumed to be \c /usr/bin/qore. The first line of %Qore scripts in this case should look as follows:

    @code
#!/usr/bin/qore
    @endcode

    If another installation directory is used (such as \c /usr/local/bin), then the correct path must be reflected in the first line of the %Qore script.

    %Qore convention dictates that %Qore script file names end with \c ".q".

    @section environment_variables Environment Variables

    This section will outline the environment variables that are used by %Qore.

    <b>%Qore Environment Variables</b>
    |!Environment Variable|!Description
    |\c QORE_AUTO_MODULE_DIR|This environment variable should contain a colon-separated list of directories which will be searched for %Qore modules when %Qore starts. If any modules are found in any of these directories, they are loaded automatically before any parsing starts.
    |\c QORE_MODULE_DIR|This environment variable should contain a colon-separated list of directories which will be searched when modules are loaded with the @ref requires "%requires" parse directive
    |\c QORE_INCLUDE_DIR|This variable should be a colon-separated list of directories where the %Qore binary should look for include files
    |\c QORE_CHARSET|If this variable is set, then the default character encoding name for the process will be the value of this variable. This variable takes precedence over the \c LANG variable, but can be overridden by the command line using option \c --charset (see @ref character_encoding for more information on this option)
    |\c LANG|If this variable is set and includes a character encoding specification, then, if the \c QORE_CHARSET variable is not set (and no character encoding was specified on the command line), this character encoding will be the default for the process.

    @section conditional_parsing Conditional Parsing and Parse Defines

    %Qore supports conditional parsing with parse defines similar to the C/C++ preprocessor. In the current version of %Qore, the implementation is very simple; only the following parse directives are supported: @ref define "%define", @ref else "%else", @ref endif "%endif", @ref ifdef "%ifdef", and @ref ifndef "%ifndef".

    Basically, the above allow for the existence (or lack thereof) of a parse define to affect which code is parsed into the program at parse time.

    Parse defines are defined on the command-line (or through the C++ API when executed in embedded code), as well as created automatically based on sytem options; all library options (if the option is \c True, then it is defined as \c True, if the option is \c False, then it is not defined at all).

    Note that \c "Unix" is defined on all Unix platforms (also on Cygwin), while \c "Windows" is defined on native Windows ports (but not on Cygwin, as this is treated as Unix when compiling, as all Unix features are available).

    Additionally, the following options are defined in every program (however they are not yet useful when parsing as the value of parse options cannot be used yet at parse time; only the existence or lack thereof can affect parsing in this version of %Qore when parsing at least).

    <b>%Qore Parse Defines</b>
    |!Define|!Value
    |\c %QoreVersionString|Version string for the %Qore library
    |\c %QoreVersionMajor|Major version for the %Qore library
    |\c %QoreVersionMinor|Minor version for the %Qore library
    |\c %QoreVersionSub|Sub version for the %Qore library
    |\c %QoreVersionBuild|Build version for the %Qore library
    |\c %QoreVersionBits|32 or 64 depending on the library target
    |\c %QorePlatformCPU|The CPU targeted by the library
    |\c %QorePlatformOS|The OS targeted by the library

    Additionally, only if the %Qore library was compiled with debugging support, the following parse define is present (otherwise it is not defined):

    <b>%Qore Optional Parse Defines</b>
    |!Define|!Value
    |\c %QoreDebug|\c True

    Here is an example of using parse defines in a program:

    @code
%ifndef HAVE_TERMIOS
printf("This program requires UNIX TermIOS features to be present; it does not run on platforms without this feature (current platform: %s); exiting...\n", Qore::PlatformOS);
exit(1);
%endif
    @endcode

    Furthermore, parse defines can be manipulated in embedded code using the following functions:
    - Qore::Program::define()
    - Qore::Program::getDefine()
    - Qore::Program::isDefined()
    - Qore::Program::undefine()

    @section modules Qore Modules
    
    %Qore modules allow the %Qore language to be extended at run-time. %Qore modules must conform to the %Qore Module API and have the file extension \c "*.qmod". %Qore modules normally depend on other shared libraries and therefore can only be loaded if the libraries they require are present on the system and can be found in the library path.

    Please note that as of version 0.7.0 onwards, modules are no longer delivered with the %Qore library. Modules must be downloaded separately; see <a href="http://www.qore.org">%Qore's home page</a> for more information.

    To load a module at parse time (normally required for most modules), use the @ref requires "%requires" parse directive. If the named feature is not already present in %Qore, %Qore looks for a module with this name in the directories listed in the \c QORE_MODULE_DIR environment variable (see @ref environment_variables).

    Use the load_module() function to load %Qore modules at run-time; however, note that any module providing parse support (classes, constants, functions, etc) must be loaded at parse time using the @ref requires "%requires" directive.

    From %Qore 0.7.1 onwards, you can specify a comparison operator (one of < <=, =, >=, or >) and version information after the module name as well. Version numbers are compared via integer comparisons of each element, where elements are separated by a '.'. If one of the versions does not have as many elements as another, the missing elements are assumed to be '0' (i.e. version \c "1.0" compared with version \c "1.0.1" will be exteneded to "1.0.0").

    Also note that DBI drivers are loaded on demand by the @ref Qore::Datasource and @ref Qore::DatasourcePool classes.

    At the time of writing this documentation, the following modules exist for %Qore:

    <b>%Qore Modules</b>
    |!Module|!Description
    |\c asn1|Provides ASN.1 functionality to %Qore
    |\c xml|Provides XML, XPath, etc functionality to %Qore.
    |\c xmlsec|Provides xmldsig and xmlenc functionality to %Qore.
    |\c json|Provides JSON functionality to %Qore.
    |\c ssh2|Provides SSH2 and SFTP functionality to %Qore.
    |\c tibrv|Provides TIBCO Rendezvous(R) (TIBCO, Inc) functionality to %Qore.
    |\c tibae|Provides TIBCO ActiveEnterprise(TM) (TIBCO, Inc) functionality to %Qore.
    |\c tuxedo|Provides Oracle (ex Bea) Tuxedo functionality to %Qore.
    |\c mysql|Provides a MySQL DBI driver to %Qore.
    |\c pgsql|Provides a PostgreSQL DBI driver to %Qore.
    |\c sqlite3|Provides a SQLite3 DBI driver to %Qore.
    |\c sybase|Provides a Sybase DBI driver to %Qore.
    |\c freetds|Provides a FreeTDS-based DBI driver to %Qore.
    |\c oracle|Provides an Oracle DBI driver to %Qore.
    |\c db2|Provides an IBM DB2 driver to %Qore.
    |\c glut|Provides GLUT functionality to %Qore.
    |\c opengl|Provides an OpenGL API to %Qore.
    |\c qt4|Provides Nokia (formerly Trolltech) QT4 APIs for GUI development in %Qore.
    |\c ncurses|Provides curses APIs to %Qore.
    |\c yaml|Provides YAML functionality to %Qore.

    @section include_files Include Files

    A %Qore program can include other program code to be used and executed in the current program by using the @ref include "%include" directive. The @ref include "%include" directive must be the first text on the line, and the file name to include must follow. All text on the line after the @ref include "%include" directive will be used for the file name to include. The file name should not be quoted.

    Here is an example:

    @code
#!/usr/bin/qore
%include /usr/qore/lib/functions.ql
    @endcode

    After this, any variable, function, namespace, constant, or object declared in the above file can be used by the %Qore program.

    The \c QORE_INCLUDE_DIR environment variable determines the search path for include files (see @ref environment_variables).

    @section identifiers Identifiers

    %Qore identifiers must start with an alphabetic character, and then may contain any number of alphabetic, numeric, or "_" characters. There is no length limit on %Qore identifiers.

    All %Qore identifiers are case-sensitive, therefore the identifier \c hello_there is not the same as \c Hello_There or \c HELLO_THERE.

    The following are examples of valid %Qore identifiers:

    <b>Examples of Valid %Qore Identifiers</b>
    |!Identifier|!Description
    |\c i|Simple one-character identifier
    |\c foo21|Identifier with number
    |\c this_is_a_long_identifier|Long identifier with underline characters
    |\c Total_318|Identifier with underline and number
    |\c AVeryBigNumber|Mixed case identifier name
    |\c CAPS|Identifier in all capital letters

    The following are invalid identifiers:

    <b>Examples of Invalid %Qore Identifiers</b>
    |!Identifier|!Description
    |\c 1a|Does not start with an alphabetic character
    |\c this-and-that|Contains "-" characters
    |\c Start#10|Contains "#" character

    @section comments Comments

    Comments are allowed in %Qore scripts; line comments are preceded by a hash \c "#", and block comments are made C-style, ex:

    @code
# this is a line comment
/* 
   this is a block comment 
*/
    @endcode

    For line comments, all text following a hash until the end-of-line character \c "\n" is considered a part of the comment.

    For block comments, all text in the block comment is ignored by the parser.

    Here is an example %Qore script containing comments:

    @code
#!/usr/bin/env qore
#
# these are line comments
# another line comment

/*
   --- this text is in block comments
   print("hello"); <- this won't get executed 
   --- because it's in the block comment
*/
    @endcode

    @section variables Variables

    Unless parse option @ref allow-bare-refs "%allow-bare-refs" or @ref new-style "%new-style" are set, variables are %Qore identifiers prefixed by a \c "$" sign, similar to <a href="http://www.perl.org">Perl</a>. If a variable is declared without any type restriction, then it is assumed to have type @ref any_type "any". In this case, variables so declared can hold any data type.

    @subsection special_variables

    A few variables are set by the %Qore language during the execution of %Qore programs. These are normal variables that can be reassigned to other values by the user if necessary.

    <b>Special %Qore Variables</b>
    |!Variable|!Scope|!Data Type|!Explanation
    |\c $argv|Local|List|automatically assigned local variable containing the list of function or method arguments that were not assigned to parameter variables (see @ref functions_and_implicit_arguments for more information)
    |\c $ARGV|Global|List|script command-line arguments (use the @ref Qore::GetOpt class to parse command-line arguments)
    |\c $QORE_ARGV|Global|List|complete qore command-line arguments
    |\c $ENV|Global|Hash|UNIX program environment

    @note As of version 0.5.0, \c $STDERR and \c $STDOUT have been removed from %Qore. Use the I/O constants @ref stderr, @ref stdout, and @ref stdin constants of the @ref Qore::File class instead.

    @subsection variable_declarations Variable Declarations and Lexical Scope

    Unless the @ref assume-local "%assume-local" parse directive is used, variables not in a parameter list automatically have global scope unless the first reference is prefixed with @ref my. Variable names in a parameter list are always local to their associated function, method, or catch block. Global variables can be explicitly declared with @ref our. The @ref our keyword is required if the parse option @ref require-our "%require-our" (\c -O or \c --require-our command-line option) is set for the parent program. See @ref parse_options for more information.

    When the @ref assume-local "%assume-local" parse directive is used, variables without an explicit scope declaration (i.e. @ref my or @ref our) are assumed to be local variables.

    Variables may be assigned any value unless restricted with a type declaration. If no type declaration is given, then the variable is assumed to be type @ref any_type "any". Note that type declarations are required for all variables (and for function and method parameters and class members) when the @ref require-types "%require-types" parse option is set.

    Local variables are not shared between threads (local variables have a distinct value in each thread), however global variables are. See @ref threading (and in particular @ref threading_and_variables) for more information.

    For example (in the following script, the @ref our keyword is optional):

    @code
#!/usr/bin/qore
#
# variable scoping example

our int $a = 1;                    # this is a global variable
our (string $b, any $c, hash $d);  # list of global variables

if ($a == 1) {
    my int $a = 2; 
    my (string $b, any $c);
    # $a, $b, and $c are local variables, 
    # the use of which will not affect the 
    # global variables of the same name
    print("local a = %d\n", $a); 
}

print("global a = %d\n", $a); 
    @endcode

    The first print() statement will output:
    @verbatim
local a = 2@endverbatim

    The second print() statement will output:
    @verbatim
global a = 1@endverbatim

    @note If parse option @ref allow-bare-refs "%allow-bare-refs" is set, then variable references <b>must</b> be made without the "$" character.

    @section basic_data_types Basic Data Types

    The following are the basic data types in %Qore (see @ref container_data_types for container data types):

    <b>Basic Data Types</b>
    |!Type|!Description|!Example|!Default Value
    |@ref boolean|\c True or \c False value|\c True|\c False
    |@ref string|A sequence of characters with an encoding|\c "string"|Empty string (i.e. \c "")
    |@ref integer|A 64-bit signed integer|\c 1|\c 0
    |@ref float|A double-precision floating-point number|\c 1.00023|\c 0.0
    |@ref date|A date/time value with an optional time zone component, with resolution to the microsecond|\c 2010-05-10T18:35:21.001456-07:00|\c 1970-01-01Z
    |@ref binary|An opaque binary object|<tt><23deadbeef></tt>|an empty object of size 0
    |@ref null|Corresponds to a \c NULL value in a database query (not equivalent to @ref nothing|\c NULL|\c NULL
    |@ref nothing|Represents the state of a variable having no value or function returning no value (not equivalent to @ref null)|\c NOTHING|\c NOTHING

    <hr>
    @subsection boolean Boolean

    The Boolean type can have two values, \c True and \c False.

    When converting other types to a Boolean, any value that converts to a non-zero integer will be evaluated as \c True. Otherwise the result of the conversion will be \c False.

    @see @ref bool_type, @ref softbool_type

    <hr>
    @subsection string String

    String values are specified with text between double or single quotes. Text between double quotes is subject to interpretation of escape characters; text between single quotes is not with the exception of the single quote character, which may be escaped (ex: <tt>'hello \'there\''</tt>).

    Strings are assumed by default to have the encoding given by the \c QORE_CHARSET or the \c LANG environment variable (see @ref environment_variables). If neither of these variables is set, then all strings will be assumed to have \c UTF-8 encoding.

    For detailed information on %Qore character encoding handling, please see @ref character_encoding.

    It is legal to specify a string literal with newline characters like the following:

    @code
$str = "this string
on more than 1 line";
    @endcode

    Internally, strings are stored as a pointer to the string data, an unsigned integer giving the length of the string, and a pointer to an encoding object, giving the string's character encoding.

    @see @ref string_type, @ref softstring_type

    <hr>
    @subsection integer Integer

    %Qore integers are 64-bit signed integers.

    @see @ref int_type, @ref softint_type

    <hr>
    @subsection float Float

    %Qore floats are double precision floating-point numbers (C/C++ type double), normally a 64-bit value.

    @see @ref float_type, @ref softfloat_type

    <hr>
    @subsection date Date

    %Qore dates have a time component supporting a resolution to the microsecond and can be either absolute or relative.

    @see @ref date_and_time_functions for a list of functions related to date/time processing.

    @subsection absolute_dates Absolute Date/Time Values
    Absolute date/time values specify a specific point in time in a certain time zone, such as January 1, 2005 10:35:00 +01:00. They are stored interally as a 64-bit signed offset from the %Qore epoch (\c 1970-01-01Z), a positive 4-byte integer for microseconds, and a pointer to a time zone description object that provides the UTC offset and daylight savings time information (see @ref time_zones for more information). Note that all absolute date/time values in %Qore are stored internally in UTC and are converted for display purposes to the representation of wall time in their tagged time zone.

    Absolute date/time values can be specified with a syntax based on ISO-8601 date formats as follows:

    @verbatim
YYYY-MM-DD[THH:mm:SS[.n*]][Z|[+-]HH[:mm[:SS]]]@endverbatim

    Note that if no time zone information is given, the local time zone will be assumed. If a time zone UTC offset is given, it is given in units of time east of UTC (i.e. \c +05:00 means five hours east of UTC).

    Or an alternative format (with a '-' instead ofa 'T' to separate the time component):

    @verbatim
YYYY-MM-DD[-HH:mm:SS[.n*]][Z|[+-]HH[:mm[:SS]]]@endverbatim

    for example, for just the date in UTC, without a time component:
    - \c 2010-05-26

    or, for just the time, without a date component (note that in this case the date component will be set to Jan 1, 1970, in order for time arithmetic to function properly and will also be tagged with the local time zone):
    - \c 20:05:10.458342

    Some further examples (note that the date/time values without a time zone specification here are tagged with the local time zone):

    @code
prompt% qore -X '2005-03-29-18:12:25'
2005-03-29 18:12:25 Tue +02:00 (CEST)
prompt% qore -X '0512-01-01T01:49:59.002213Z'
0512-01-01 01:49:59.002213 Fri Z (UTC)
prompt% qore -X '2005-03-29'
2005-03-29 00:00:00 Tue +02:00 (CEST)
prompt% qore -X '18:35:26+08:00'
1970-01-01 18:35:26 Thu +08:00 (+08)
    @endcode

    The year must be a four-digit number, and all other values except microseconds must be two-digit numbers. If microseconds are present, at least one and up to 6 digits may be given after the decimal point. Pad the numbers with leading zeros if the numbers are smaller than the required number of digits. The hour component must be in 24-hour time format. Except for the month and day values, all other values start with 0 (hour = 00 - 23, minute and second: 00 - 59). Any deviation from this format will cause a parse exception.

    When a date/time value is converted to an integer or vice-versa, a 64-bit offset in seconds from the start of the "epoch" is used for the conversion. %Qore's "zero date" (the start of %Qore's "epoch") is January 1, 1970 UTC. When calculating second offsets from this date, a 64-bit integer is used.

    @note The default local time zone for qore is set when the qore library is initialized; see @ref time_zones for more information.

    @subsection relative_dates Relative Date/Time Values (Durations)
    Relative dates (durations) are normally used for date addition and subtraction. See @ref date_time_arithmetic for more information.

    Internally, durations are stored as a set of seven discrete signed integer values, one each for years, months, days, hours, minutes, seconds, and microseconds.

    There are 3 different formats understood by the %Qore parser for describing literal durations in %Qore.

    <b>Single Relative Time Format</b>\n
    A single relative date/time value (or a duration) may be specified as follows (note that this format is specific to %Qore and not based on ISO-8601):
    - @verbatim <integer><date component specifier>@endverbatim

    <b>Date Specifiers For Single Values For Relative Dates (non-ISO-8601 syntax)</b>
    |!Component|!Meaning|!Example|!Description
    |\c Y|Years|\c 2Y|2 Years
    |\c M|Months|\c 3M|3 Months
    |\c D|Days|\c 10D|10 Days
    |\c h|Hours|\c 15h|15 hours
    |\c m|Minutes|\c 25m|25 minutes
    |\c s|Seconds|\c 19s|19 seconds
    |\c ms|Milliseconds|\c 250ms|250 milliseconds
    |\c us|Microseconds|\c 21194us|21194 microseconds

    <b>Short Relative Time Format</b>\n
    This and the next duration format for composite relative date/time values are both based on ISO-8601.

    This first format has the following syntax:
    - \c PnYnMnDTnHnMnSnu

    Each element above is optional, but at least one element must be present. Note that "M" means months when before the "T" and minutes when found after the "T". The other elements are years, days, hours, seconds, and, as an extension to ISO-8601, "u" for microseconds. Additionally, the values may be negative.

    Here are some examples (using qore's -X command-line option to evaluate and expression and print out the result):

    @code
prompt% qore -X 'P1Y3MT4S'
<time: 1 year 3 months 4 seconds>
prompt% qore -X 'PT4M551u'
<time: 4 minutes 551 microseconds>
prompt% qore -X 'P3DT21H'
<time: 3 days 21 hours>
    @endcode

    <b>Long Relative Time Format</b>\n
    The second ISO-8601-based format for specifing complex durations with multiple time units has the following syntax:
    - \c PYYYY-MM-DDTHH:mm:SS

    This format is more limited than the first format, in that all values must be positive, and furthermore, all values must be present (although they may be zero).

    Here are some examples of the second format (equivalent to the first examples):

    @code
prompt% qore -X 'P0001-03-00T00:00:04'
<time: 1 year 3 months 4 seconds>
prompt% qore -X 'P0000-00-00T00:04:00.000551'
<time: 4 minutes 551 microseconds>
prompt% qore -X 'P0000-00-03T21:00:00'
<time: 3 days 21 hours>
    @endcode

    @see @ref date_type, @ref softdate_type

    <hr>
    @subsection binary Binary

    The binary data type is used to hold binary arbitrary binary data. Internally it is represented by a pointer to a memory location for the data and a size indicator.

    Binary data can be concatenated with the + and += operators.

    This data can be manipulated by being written and read from @ref Qore::File, @ref Qore::Socket, @ref Qore::Datasource, @ref Qore::DatasourcePool, or @ref Qore::SQLStatement objects, or converted and parsed to/from base64 encoded strings using the makeBase64String() and parseBase64String() functions, or compressed and decompressed using the compress(), gzip(), bzip2(), etc. functions, and processed by most cryptographic funtions, among others.

    Binary objects can be read from a @ref Qore::File object using the Qore::File::readBinary() method and can be written using the Qore::File::write() method. Please see the @ref Qore::File class for more information.

    Binary objects can be read from a @ref Qore::Socket object using the Qore::Socket::recvBinary() method and can be written using the Qore::Socket::send() method. Please see the @ref Qore::Socket class for more information.

    The @ref Qore::Datasource, @ref Qore::DatasourcePool, and @ref Qore::SQLStatement classes can also be used to read and write binary objects as BLOBs.

    Note that this is not an exhaustive list; see the function and class library documentation for more examples.

    @see @ref binary_type

    <hr>
    @subsection null NULL

    This data type represents an SQL \c NULL value. Note that \c NULL is not equivalent to @ref nothing.

    <hr>
    @subsection nothing NOTHING

    This special data type represents no value.

    @note The exists operator will return \c False when given \c NOTHING as an argument; for example: @verbatim prompt% qore -X 'exists NOTHING'
False@endverbatim

    @subsection conversions Data Conversions

    Boolean, string, integer, date, and floating point data types can be freely converted from one type to the other, although data loss is possible depending on the conversion (particularly when converting to the boolan type as only two possible values are supported).

    The special types @ref null and @ref nothing are not equivalent and cannot be converted to or from any other type.

    When date types are converted from strings, any of the following formats can be used: \c "YYYYMMDDHHmmSS[.us][Z|+-HH[:MM[:SS]]]", \c "YYYY-MM-DD HH:mm:SS.us", \c "YYYY-MM-DDTHH:mm:SS", \c "YYYY-MM-DDTHH:mm:SS[.us][Z|+-HH[:MM[:SS]]]", and most reasonable combinations thereof. If the time zone component is missing, then the local time zone will be assumed (see @ref time_zones).

    When dates are converted to and from integer values, the a 64-bit second offset from January 1, 1970 in the local time zone is used for the conversion. For example @code int(2006-01-01)@endcode gives \c 1136073600 (regardless of the local time zone the date is in). To get the second offset of a date from \c 1970-01-01Z (i.e. the true epoch offset), call get_epoch_seconds() instead.

    When an expression requires a certain data type and the source data type cannot be converted to the desired data type, the default value for the desired data type will be used. The default values are given in @ref basic_data_types.

    @section container_data_types Container Data Types

    %Qore supports three types of container types: @ref list "lists", @ref hash "hashes" (associative arrays), and @ref object "objects" (see @ref object and @ref classes for more information). These container types can be combined to make arbitrarily complex data structures.

    The data type of any element can be any basic type or another aggregate type. The types do not have to be uniform in one container structure.

    <hr>
    @subsection list Lists

    Lists (or arrays) are simply ordered containers of values. A list element can be any %Qore type (even another list, @ref hash "hash", or @ref object "object").

    Lists are specified by giving expressions separated by commas as follows:

    @code
$list = (expression, expression [, expression ...]);
    @endcode

Here is a concrete example:

    @code
my list $list = (1, 2, "three", 4.0, 5, 6, 2001-01-15Z);
    @endcode

    @note Trailing commas can be left on the end of a list (or a hash, for that matter). This makes it easier to comment-out the last element of a multi-line list without having to worry about removing the trailing comma.

    List elements are dereferenced using square brackets: \c "[" and \c "]". The first element in a list has index zero.

    @code
$element3 = $list[2];
    @endcode

    The following operators perform special processing on lists: @ref elements "elements", @ref shift "shift", @ref unshift "unshift", @ref push "push", @ref pop "pop", @ref splice "splice", @ref list_element_operator "[]", @ref plus_operator "+", @ref plus_equals_operator "+=", @ref map "map", @ref foldl "foldl", @ref foldr "foldr", and @ref select "select".

    @see @ref list_type, @ref softlist_type

    <hr>
    @subsection hash Hashes

    Hashes are containers that associate values to a string key.

    @note %Qore hashes preserve the insertion order in order to be able to guarantee the order of keys when hashes are serialized to XML strings, therefore the keys operator will always return the hash keys in insertion/creation order.

    Hashes are specified using the following syntax:

    @code
$hash = ( "key1" : expression,
          "key2" : expression,
	  ... );
    @endcode

    Here is a concrete example:

    @code
my hash $hash = ( "apple" : 1 + 1,
                  "pear"  : "good" );
    @endcode

    Hashes are dereferenced in one of two ways, either using curly brackets: \c "{" and \c "}", where any valid %Qore expression can be used, or using the dot "." hash member dereferencing operator, where literal strings can be used.

    @code
$element3 = $hash{"pe" + "ar"};
    @endcode

    Is equivalent to:

    @code
$element3 = $hash.pear;
    @endcode

    and:

    @code
$element3 = $hash."pear";
    @endcode

    and:

    @code
$element3 = $hash.("pe" + "ar");
    @endcode

    Hash members can have the names of keywords, but in this case to dereference them, you cannot use the dot operator with a literal string, otherwise a parse error will be raised. Use quotes around the member name when dereferencing hash members with the same name as a qore keyword as follows:

    @code
$element3 = $hash."keys";
$element3 = $hash{"keys"};
    @endcode

    A literal string after the dot "." hash member dereferencing operator must be a valid %Qore identifier; therefore if you want to use a hash key that's not a valid identifier, enclose the string in quotes.

    If you want to use the result of an expression to dereference the hash, then either the curly bracket syntax must be used or the expression must be enclosed in parentheses.

    Note that hash keys can also be given by constants (as long as the constant resolves to a string) when using curly brackets.

    @see @ref hash_type

    <hr>
    @subsection object Objects

    %Qore objects are instantiations of a @ref classes "class". They have members (like a hash; values associated to string keys), and methods. The @ref classes "class definition" specifies the methods that run on objects of that class, public and private members, static methods and variables, etc associated with the class (however note that static methods do not run in the scope of an object).  See @ref classes for information on how to create a class in %Qore.

    The recommend way to instantiate an object is to declare its type and give constructor arguments after the variable name in parentheses as follows:

    @code
my class_name_or_path $var_name([argument list])
    @endcode

    For example (for a constructor taking no arguments or having only default values for the aguments, the list is empty):
    @code
my Mutex $m();
    @endcode

    If parse option @ref new-style "%new-style" is set, the above example declaring a local variable of class @ref Qore::Mutex would look as follows:

    @code
Mutex m();
    @endcode

    Objects can also be instantiated using the @ref new "new operator" as follows.

    @code
new class_identifier([argument list])
    @endcode

    For example:

    @code
my Mutex $m = new Mutex();
    @endcode

    Or, with parse option %new-style:

    @code
Mutex m = new Mutex();
    @endcode

    Objects have named data members that are referenced like hash elements, although this behavior can be modified for objects using the memberGate() method. Object members are accessed by appending a dot '.' and the member name to the object reference as follows:

    @code
object_reference.member_name
    @endcode

    For more information, see @ref class_members.

    Object methods are called by appending a dot '.' and a method name to the object reference as follows:

    @code
object_reference.method_name([argument_list])
    @endcode

    Or, from within the class code itself to call another method from inside the same class hierarchy:

    @code
$.method_name([argument_list])
    @endcode

    Or, with parse option %new-style, the method call is made without the "$.":

    @code
method_name([argument_list])
    @endcode

    For more information, see @ref object_method_calls.

    The object references above are normally variable references holding an object, but could be any expression that returns an object, such as a @ref new "new expression" or even a function call.

    @note Objects are treated differently than other %Qore data types; they are only explicitly copied (see @ref object_references for more informaion). Any object instantiated with the @ref new "new operator" will remain unique until deleted or explicitly copied. An explicit copy is made with the copy method, and does not always guarantee an exact copy of the source object (it depends on the definition of the copy method for the class in question).

    Objects exist until they go out of scope, are explicitly deleted, or their last thread exits. For detailed information, see @ref classes.

    @see @ref object_type

    @subsection object_references Object References

    In %Qore objects are treated differently from all other data types in that they are by default passed as arguments to functions and methods by passing a copy of a reference to the object (similar to Java's handling of objects). That means that passing an object to a function that modifies the object will by default modify the original object and not a copy, however reassigning a local parameter variable assigned an object passed as an argument (that is only assigned to a local variable in the calling function) will not result in deleting the object, but rather decrement its scope reference count (note that if the object were created as a part of the call and reassigning the variable would cause the object's scope reference count to reach zero, then the object would be deleted in this case).

    Assigning an object to a variable has the same effect; a copy of a reference to the object is assigned to the variable. This results in prolonging the object's scope (by owning a new copy of a reference to the object).

    An example:
    @code
sub test2(any $x) {
   # we can modify the original object like so:
   $x.member = "tree";

   # here we re-assign $x, but since the object is also assigned
   # to $o in the calling function, the object's scope is still
   # valid, and therefore nothing happens so the object
   $x = 1;
}

sub test() {
   my TestObject $o();

   # here we pass a copy of a reference to the object in $o
   test2($o);

   # this will print out "ok\n", because the object is still
   # valid and the member has been set by test2()
   if ($o.member == "tree")
      print("ok\n");
}
# when test() exits, the object in $o will go out of scope
# and be deleted
    @endcode

    If, however, an object is passed by reference, then the local variable of the called function that accepts the object owns the scope reference of the calling functions's variable.

    An example:
    @code
sub test2(any $x) {
   # we can modify the original object like so:
   $x.member = "tree";

   # here we re-assign $x, and since we own the only scope 
   # reference to the object, the object will go out of 
   # scope here and be deleted
   $x = 1;
}

sub test() {
   my TestObject $o();

   # here we pass a reference to the object in $o
   test2(\$o);

   # the object has already been deleted in test2() and
   # therefore nothing will be printed out
   if ($o.member == "tree")
      print("ok\n");
}
    @endcode

    @note that when parse option @ref allow-bare-refs "%allow-bare-refs" is set, then variable references as in the above examples are made without the \c "$" character.

    @subsection object_scope Object Scope

    Objects are automatically deleted when their scope-relevant reference count reaches zero (note that objects can be deleted manually at any time by using the @ref delete "delete operator"). Whenever an object is deleted, the object's class' destructor method is run on the object.

    The following affect objects' scope:
    - variable assignments: an object's automatic scope is prolonged as long as the object is assigned to a local variable
    - existence of a closure created Within the object: any closures created from within the object encapsulate the object's state (along with any local variables referenced within the closure) and also prolong the object's automatic scope as long as the closure exists.
    - object method thread launched within the object: if a member function thread was launched from within the object using the @ref background "background operator", the object's automatic scope is prolonged to the life of the new thread. Object threads started externally to the object (i.e. not directly from an expression with the @ref background "background operator" within a method) will not prolong the scope of the object.

    @note If an object with running threads is explicitly deleted, and this case is not handled in the object's destructor() method (by ensuring that all other running threads terminate gracefully), exceptions will be thrown in other threads at any attempt to access the already-deleted object.\n\n
    The fact that object threads and closures can prolong object scope means, for example, that objects assigned to local variables can exist for longer than the scope of their host variable if they have one or more methods running in other threads or if closures created from within the object still exist at the time the local variable goes out of scope.\n\n
    For more information about threading, please see @ref threading

    @subsection copying_objects Copying Objects

    To explicitly generate a copy of an object, the \c copy() constructor must be called. This is a special method that exists implicitly for every class even if it is not explicitly defined (like \c constructor() and \c destructor() methods). The implicit behavior of the \c copy() constructor is to create a new object with new members that are copies of the original members (except objects are created as copies of references to the object). Then, if any \c copy() method exists, it will be executed in the new object, passing a copy of a reference to the old object as the first argument to the \c copy() method.

    @note In a class hierarchy copy() methods are called in the same order as constructor() methods.\n\n
    Not all built-in classes can be copied. Classes not supporting copying will throw an exception when the \c copy() methods are called. See the documentation for each class for more information.

    @section data_type_declarations Data Type Declarations and Restrictions

    Starting in %Qore 0.8.0, it is possible to restrict variables, class members, and function and method parameters to certain data types. This allows programmers to write safer code, as many more errors can be caught at parse time that would otherwise be caught at run time. Furthermore, providing type information to the parser allows %Qore to implement performance optimizations by performing lookups and resolutions once at parse time rather than every time a variable or class member is accessed at run time.

    When types are declared in a parameter list, functions and methods can be overloaded as well.

    The types in the following table can be used as well as any class name or \c '*classname' (i.e. an asterix followed by the class name), meaning either the given class or @ref nothing (no value).

    <b>Data Type Declaration Names</b>
    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |@ref int_type "int"|@ref integer|@ref integer|Restricts values @ref integer values
    |@ref float_type "float"|@ref float|@ref float|Restricts values to @ref float values
    |@ref bool_type "bool"|@ref boolean|@ref boolean|Restricts values to @ref boolean values
    |@ref string_type "string"|@ref string|@ref string|Restricts values to @ref string values
    |@ref date_type "date"|@ref date|@ref date|Restricts values to @ref date values; values may be either @ref absolute_dates "absolute" or @relative_dates "relative"
    |@ref binary_type "binary"|@ref binary|@ref binary|Restricts values to @ref binary values
    |@ref hash_type "hash"|@ref hash|@ref hash|Restricts values to @ref hash values
    |@ref list_type "list"|@ref list|@ref list|Restricts values to @ref list values
    |@ref object_type "object"|@ref object|@ref object|Restricts values to @ref object values
    |@ref classname_type "<classname>"|@ref object|@ref object|Restricts values to objects of the specific class given; either the class name can be given (ex: @ref Qore::Mutex "Mutex" or a qualified path to the class: @ref Qore::Mutex)
    |@ref null_type "null"|@ref null|@ref null|Restricts values to %Qore's @ref null type; this type has few (if any) practical applications and has been included for completeness' sake
    |@ref nothing_type "nothing"|@ref nothing|@ref nothing|Restricts values to %Qore's @ref nothing type; this type is mostly useful for declaring that a function or method returns no value
    |@ref timeout_type "timeout"|@ref integer, @ref date|@ref integer|Accepts @ref integer, @ref date and converts dates to an integer value representing milliseconds and returns the integer; incoming integers are assumed to represent milliseconds
    |@ref softint_type "softint"|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref integer|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-integer values to an integer and returns the integer
    |@ref softfloat_type "softfloat"|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref float|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-float values to a float and returns the new value
    |@ref softbool_type "softbool"|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref boolean|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-boolean values to a boolean and returns the new value
    |@ref softstring_type "softstring"|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref string|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-string values to a string and returns the new value
    |@ref softdate_type "softdate"|@ref integer, @ref float, @ref boolean, @ref string, @ref date, @ref null|@ref date|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref date, and @ref null and converts non-date values to a date and returns the new value
    |@ref softlist_type "softlist"|all types|@ref list|Accepts all types; @ref nothing is returned as an empty list; a list is returned unchanged, and any other type is returned as the first element of a new list
    |@ref data_type "data"|@ref string or @ref binary|same as received|Restricts input to @ref string and @ref binary and returns the same type
    |@ref code_type "code"|@ref closure, @ref call_reference|same as received|Restricts values to @ref closure "closures" and @ref call_reference "call references"
    |@ref reference_type "reference"|@ref lvalue_references|@ref lvalue_references|Restricts values to references to lvalues; currently only usable in function or method parameters
    |@ref int_or_nothing_type "*int"|@ref integer or @ref nothing|same as received|Restricts values to %Qore's @ref integer or @ref nothing types
    |@ref float_or_nothing_type "*float"|@ref float or @ref nothing|same as received|Restricts values to %Qore's @ref float or @ref nothing types
    |@ref bool_or_nothing_type "*bool"|@ref boolean or @ref nothing|same as received|Restricts values to %Qore's @ref boolean or @ref nothing types
    |@ref string_or_nothing_type "*string"|@ref string or @ref nothing|same as received|Restricts values to %Qore's @ref string or @ref nothing types
    |@ref date_or_nothing_type "*date"|@ref date or @ref nothing|same as received|Restricts values to %Qore's @ref date or @ref nothing type; values may be either absolute or relative date/time values
    |@ref binary_or_nothing_type "*binary"|@ref binary or @ref nothing|same as received|Restricts values to %Qore's @ref binary or @ref nothing types
    |@ref hash_or_nothing_type "*hash"|@ref hash or @ref nothing|same as received|Restricts values to %Qore's @ref hash or @ref nothing types
    |@ref list_or_nothing_type "*list"|@ref list or @ref nothing|same as received|Accepts either a @ref list or @ref nothing
    |@ref data_or_nothing_type "*data"|@ref string, @ref binary, or @ref nothing|same as received|Restricts input to @ref string, @ref binary, or @ref nothing and returns the same type
    |@ref code_or_nothing_type "*code"|@ref closure, @ref call_reference, @ref nothing|same as received|Restricts values to @ref closure "closures", @ref call_reference "call references" and @ref nothing
    |@ref timeout_or_nothing_type "*timeout"|@ref integer, @ref date or @ref nothing|@ref integer or @ref nothing|Accepts @ref integer, @ref date and converts dates to an integer value representing milliseconds and returns the integer; incoming integers are assumed to represent milliseconds. If no value is passed, then @ref nothing is returned
    |@ref softint_or_nothing_type "*softint"|@ref integer, @ref float, @ref boolean, @ref string, @ref null or @ref nothing|@ref integer or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-integer values to an integer and returns the integer. If no value is passed, then @ref nothing is returned
    |@ref softfloat_or_nothing_type "*softfloat"|@ref integer, @ref float, @ref boolean, @ref string, @ref null or @ref nothing|@ref float or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-float values to a float and returns the new value. If no value is passed, then @ref nothing is returned
    |@ref softbool_or_nothing_type "*softbool"|@ref integer, @ref float, @ref boolean, @ref string, @ref null or @ref nothing|@ref boolean or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-boolean values to a boolean and returns the new value. If no value is passed, then @ref nothing is returned
    |@ref softstring_or_nothing_type "*softstring"|@ref integer, @ref float, @ref boolean, @ref string, @ref null or @ref nothing|@ref string or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref null and converts non-string values to a string and returns the new value. If no value is passed, then @ref nothing is returned
    |@ref softdate_or_nothing_type "*softdate"|@ref integer, @ref float, @ref boolean, @ref string, @ref date, @ref null or @ref nothing|@ref date or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref date, and @ref null and converts non-date values to a date and returns the new value. If no value is passed, then @ref nothing is returned
    |@ref softlist_or_nothing_type "*softlist"|all types|@ref list or @ref nothing|Accepts all types; @ref nothing and list values are returned as the same value; any other type is returned as the first element of a new list
    |@ref any_type "any"|any|same as received|Provides no restrictions on the type of value it receives and returns the same value

    @subsection int_type "int" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c int|@ref integer|@ref integer|Restricts values to %Qore's @ref integer type

    @par Example
    @code
my int $i = 0;
    @endcode

    @subsection float_type "float" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c float|@ref float|@ref float|Restricts values to %Qore's @ref float type

    @par Example
    @code
my float $pi = M_PI;
    @endcode

    @subsection bool_type "bool" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c bool|@ref boolean|@ref boolean|Restricts values to %Qore's @ref boolean type

    @par Example
    @code
my float $pi = M_PI;
    @endcode

    @subsection string_type "string" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c string|@ref string|@ref string|Restricts values to %Qore's @ref string type

    @par Example
    @code
my string $str = "foo";
    @endcode

    @subsection date_type "date" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c date|@ref date|@ref date|Restricts values to %Qore's @ref date type; date/time values can be either @ref absolute_dates "absolute" or @ref relative_dates "relative"

    @par Example
    @code
my date $now = now_us;
    @endcode

    @subsection binary_type "binary" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c binary|@ref binary|@ref binary|Restricts values to %Qore's @ref binary type

    @par Example
    @code
my string $str = "foo";
    @endcode

    @subsection hash_type "hash" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c hash|@ref hash|@ref hash|Restricts values to %Qore's @ref hash type

    @par Example
    @code
my hash $str = ("foo": "bar", "x": 2);
    @endcode

    @subsection list_type "list" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c list|@ref list|@ref list|Restricts values to %Qore's @ref list type

    @par Example
    @code
my list $l = ("foo", "bar");
    @endcode

    @subsection object_type "object" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c object|@ref object|@ref object|Restricts values to %Qore's @ref object type; note that any class name can also be used as a type restriction directly

    @par Example
    @code
my object $o = new Mutex();
    @endcode

    @subsection classname_type "<classname>" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |<tt><any class name></tt>|@ref object of the particular class given|@ref object of the particular class given|Restricts values to objects of the particular class given; subclasses are also accepted

    @par Example
    @code
my Qore::Mutex $o = new Mutex();
    @endcode

    @subsection null_type "null" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c null|@ref null|@ref null|Restricts values to %Qore's @ref null type; this type has few (if any) practical applications and has been included for completeness' sake

    @par Example
    @code
my null $n = NULL;
    @endcode

    @subsection nothing_type "nothing" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c nothing|@ref nothing|@ref nothing|Restricts values to %Qore's @ref nothing type; this type is mostly useful for declaring that a function or method returns no value

    @par Example
    @code
nothing sub bar() {
    printf("foo\n");
}
    @endcode

    @subsection timeout_type "timeout" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c timeout|@ref integer, @ref date|@ref integer|Accepts @ref integer, @ref date values and converts dates to an integer value representing milliseconds and returns the integer; incoming integers are assumed to represent milliseconds

    @par Example
    @code
my timeout $to = 1250ms;
    @endcode

    @subsection softint_type "softint" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c softint|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref integer|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-integer values to an integer and returns the integer

    @par Example
    @code
my softint $i = "1000";
    @endcode

    @subsection softfloat_type "softfloat" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c softfloat|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref float|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-float values to a float and returns the float

    @par Example
    @code
my softfloat $f = "1000.0";
    @endcode

    @subsection softbool_type "softbool" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c softbool|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref boolean|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-boolean values to a boolean and returns the boolean

    @par Example
    @code
my softbool $b = "0.5";
    @endcode

    @subsection softstring_type "softstring" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c softstring|@ref integer, @ref float, @ref boolean, @ref string, @ref null|@ref string|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-string values to a string and returns the string

    @par Example
    @code
my softstring $str = 200;
    @endcode

    @subsection softdate_type "softdate" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c softdate|@ref integer, @ref float, @ref boolean, @ref string, @ref date, @ref null|@ref date|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref date, and @ref null values and converts non-date values to a date and returns the date

    @par Example
    @code
my softdate $d = "2001-10-10T20:00:05 +04:00";
    @endcode

    @subsection softlist_type "softlist" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c softlist|all data types|@ref list|Accepts all data types; @ref nothing is returned as an empty list; a list is returned unchanged, and any other type is returned as the first element of a new list

    @par Example
    @code
my softlist $d = $v;
    @endcode

    @subsection data_type "data" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c data|@ref string or @ref binary|same as received|Restricts values to @ref string and @ref binary

    @par Example
    @code
sub foo(data $d) {
}
    @endcode

    @subsection code_type "code" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c code|@ref closure, @ref call_reference|same as received|Restricts values to @ref closure and @ref call_reference

    @par Example
    @code
sub foo(code $c) {
}
    @endcode

    @note that also \c "closure" and \c "callref" are accepted as synonyms for \c "code" (they are not more specific than \c "code" but rather provide identical type restrictions)

    @subsection reference_type "reference" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c reference|@ref reference|@ref reference|Requires a reference to an lvalue to be assigned; this type is only usable in parameter lists

    @par Example
    @code
sub foo(reference $f) {
}
    @endcode

    @subsection int_or_nothing_type "*int" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *int|@ref integer or @ref nothing|same as received|Restricts values to @ref integer and @ref nothing

    @par Example
    @code
sub foo(*int $i) {
}
    @endcode

    @subsection float_or_nothing_type "*float" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *float|@ref float or @ref nothing|same as received|Restricts values to @ref float and @ref nothing

    @par Example
    @code
sub foo(*float $f) {
}
    @endcode

    @subsection bool_or_nothing_type "*bool" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *bool|@ref float or @ref nothing|same as received|Restricts values to @ref bool and @ref nothing

    @par Example
    @code
sub foo(*bool $b) {
}
    @endcode

    @subsection string_or_nothing_type "*string" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *string|@ref string or @ref nothing|same as received|Restricts values to @ref string and @ref nothing

    @par Example
    @code
sub foo(*string $str) {
}
    @endcode

    @subsection date_or_nothing_type "*date" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *date|@ref date or @ref nothing|same as received|Restricts values to @ref date and @ref nothing

    @par Example
    @code
sub foo(*date $str) {
}
    @endcode

    @subsection binary_or_nothing_type "*binary" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *binary|@ref binary or @ref nothing|same as received|Restricts values to @ref binary and @ref nothing

    @par Example
    @code
sub foo(*binary $b) {
}
    @endcode

    @subsection hash_or_nothing_type "*hash" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *hash|@ref hash or @ref nothing|same as received|Restricts values to @ref hash and @ref nothing

    @par Example
    @code
sub foo(*hash $h) {
}
    @endcode

    @subsection list_or_nothing_type "*list" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *list|@ref list or @ref nothing|same as received|Restricts values to @ref list and @ref nothing

    @par Example
    @code
sub foo(*list $h) {
}
    @endcode

    @subsection data_or_nothing_type "*data" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *data|@ref string, @ref binary, or @ref nothing|same as received|Restricts values to @ref string, @ref binary, and @ref nothing

    @par Example
    @code
sub foo(*data $d) {
}
    @endcode

    @subsection code_or_nothing_type "*code" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *code|@ref closure, @ref call_reference, or @ref nothing|same as received|Restricts values to @ref closure, @ref call_reference, and @ref nothing

    @par Example
    @code
sub foo(*code $c) {
}
    @endcode

    @subsection timeout_or_nothing_type "*timeout" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *timeout|@ref integer, @ref date, or @ref nothing|same as received|Restricts values to @ref integer, @ref date, and @ref nothing

    @par Example
    @code
sub foo(*timeout $c) {
}
    @endcode

    @subsection softint_or_nothing_type "*softint" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *softint|@ref integer, @ref float, @ref boolean, @ref string, @ref null, @ref nothing|@ref integer or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-integer values to an integer and returns the integer; also accepts @ref nothing and returns @ref nothing

    @par Example
    @code
sub foo(*softint $i) {
}
    @endcode

    @subsection softfloat_or_nothing_type "*softfloat" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *softfloat|@ref integer, @ref float, @ref boolean, @ref string, @ref null, @ref nothing|@ref float or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-float values to a float and returns the float; also accepts @ref nothing and returns @ref nothing

    @par Example
    @code
sub foo(*softfloat $f) {
}
    @endcode

    @subsection softbool_or_nothing_type "*softbool" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *softbool|@ref integer, @ref float, @ref boolean, @ref string, @ref null, @ref nothing|@ref boolean or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-boolean values to a boolean and returns the boolean; also accepts @ref nothing and returns @ref nothing

    @par Example
    @code
sub foo(*softbool $b) {
}
    @endcode

    @subsection softstring_or_nothing_type "*softstring" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *softstring|@ref integer, @ref float, @ref boolean, @ref string, @ref null, @ref nothing|@ref string or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, and @ref null values and converts non-string values to a string and returns the string; also accepts @ref nothing and returns @ref nothing

    @par Example
    @code
sub foo(*softstring $str) {
}
    @endcode

    @subsection softdate_or_nothing_type "*softdate" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *softdate|@ref integer, @ref float, @ref boolean, @ref string, @ref date, @ref null, @ref nothing|@ref string or @ref nothing|Accepts @ref integer, @ref float, @ref boolean, @ref string, @ref date, and @ref null values and converts non-date values to a date and returns the date; also accepts @ref nothing and returns @ref nothing

    @par Example
    @code
sub foo(*softdate $d) {
}
    @endcode

    @subsection softlist_or_nothing_type "*softlist" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c *softlist|all data types|@ref list or @ref nothing|Accepts all data types; @ref nothing is returned as @ref nothing directly; a list is returned unchanged, and any other type is returned as the first element of a new list

    @par Example
    @code
my *softlist $d = $v;
    @endcode

    @subsection any_type "any" Type Restriction

    |!Name|!Accepts %Qore Type(s)|!Returns %Qore Type(s)|!Description
    |\c any|all data types|all data types|Accepts all data types and returns the same data type

    @par Example
    @code
my any $v = $bar;
    @endcode

    @note Complex types (hash of lists, reference to string, etc) are currently not possible to declare but support may be added in future versions of %Qore for this.

    @section overloading Overloading

    Functions and methods can be overloaded if parameter types are declared as in the following example:

    @code
int sub example(int $i) {
    printf("i=%d\n", $i);
    return $i + 1;
}

string sub example(string $str) {
    printf("str=%s\n", $str);
    return $str + "foo";
}
    @endcode

    In this case, the first version (<tt>example(int)</tt>) will be executed if called with an integer argument, and the second (<tt>example(string)</tt>) if called with a string argument.

    Class methods may also be overloaded, but note that @ref destructors "destructor()", @ref copy_methods "copy()", @ref methodGate_methods "methodGate()", @ref memberGate_methods "memberGate()", and @ref memberNotification_methods "memberNotification()" methods may not be overloaded (see @ref classes for more information).

    @section time_zones Time Zone Handling
    
    %Qore assumes a default time zone for all programs when it starts up. The rules for determining the default time zone are similar to those for the C library in most UNIX or UNIX-like operating systems.

    @subsection unix_time_zones UNIX Time Zone Handling

    If the \c TZ environment variable is defined, then the contents of that variable are used to find a zoneinfo file that contains the time zone definition. If this file cannot be found, then the default time zone will default to \c UTC.

    If the \c TZ environment variable is not defined or is empty, then the %Qore library tries to find the default zoneinfo definition file (normally \c /etc/localtime). If found, this file is read in and provides the information about the local time zone. If not found, the default time zone will default to \c UTC.

    When a zoneinfo file is found, information about local time zone names and daylight savings time is available for times tagged with that time zone.

    Note that posix-style time zone rules are not understood if assigned to the \c TZ environment variable, only file names to a zoneinfo file can be processed at the moment. Furthermore if the zoneinfo file contains leap second information, it is currently ignored.

    @subsection windows_time_zones Windows Time Zone Handling

    Time zone information is read in from binary time zone data in the Windows registry under:\n
    - <tt>HKEY_LOCAL_MACHINE SOFTWARE\\Microsoft\\Windows NT\\CurrentVersion\\Time Zones</tt>

    Time zone region names must correspond to registry keys under the above key or the time zone information will not be loaded.

    The region name reported by Qore::TimeZone::region() will be the display name for the time zone, as found in the registry.

    For example:

    @verbatim
O:\bin>qore -ne "TimeZone tz('Central Europe Standard Time'); printf(\"%s\n\", tz.region());"
(GMT+01:00) Belgrade, Bratislava, Budapest, Ljubljana, Prague@endverbatim

    This differs from UNIX where the region name passed to the TimeZone constructor is the same region name that appears in the @ref Qore::TimeZone::region() output; this is because Windows uses \c "Standard Time" in the key name in the registry, even though the underlying zone definition is for both standard and daylight savings time.

    @note Please be aware that the region names may differ in localized versions of Windows

    @subsection time_zone_examples More Time Zone Information and Examples

    See the @ref Qore::TimeZone class for information about retrieving, setting, and querying time zone information; see @ref date_and_time_functions for a list of functions related to date/time processing.

    Here are some examples using %Qore's '-X' option for evaluating an expression and displaying the result immediately:

    @verbatim
prompt% TZ=America/Chicago qore -X 'now_us()'
2010-05-11 06:14:28.845857 Tue -05:00 (CDT)
prompt% TZ=Europe/Rome qore -X 'now_us()'
2010-05-11 13:14:35.070568 Tue +02:00 (CEST)
prompt% TZ=Australia/Sydney qore -X 'now_us()'
2010-05-11 21:14:45.422222 Tue +10:00 (EST)
prompt% TZ=Asia/Tokyo qore -X 'now_us()'
2010-05-11 20:14:59.609249 Tue +09:00 (CJT)@endverbatim

    @section character_encoding Strings and Character Encoding

    @subsection character_encoding_overview Overview

    The %Qore language is character-encoding aware. All strings are assumed to have the default character encoding, unless the program explicitly specified another encoding for certain objects and operations. Every %Qore string has a character encoding ID attached to it, so, when another encoding is required, the %Qore language will attempt to do an encoding translation.

    %Qore uses the operating system's \c iconv library functions to perform any encoding conversions.

    %Qore supports character encodings that are backwards compatible with 7-bit \c ASCII. This includes all \c ISO-8859-* character encodings, \c UTF-8, \c KOIR-8, \c KOIU-8, and \c KOI7, among others (see the table below: @ref known_encodings "Known Character Encodings").

    However, mutibyte character encodings are currently only properly supported for \c UTF-8. For \c UTF-8 strings, the length(), index(), rindex(), substr(), reverse(), the @ref splice "splice operator", @ref printf_formatting "print formatting" (regarding field lengths) functions and methods taking format strings, and regular expression operators and functions, all work with character offsets, which may be different than byte offsets. For all character encodings other than \c UTF-8, a 1 byte=1 character relationship is assumed.

    %Qore will accept any encoding name given to it, even if it is not a known encoding name or alias. In this case, %Qore will tag the strings with this encoding, and pass this user-defined encoding name to the \c iconv library when encodings must be converted. This allows programmers to use encodings known by the system's \c iconv library, but unknown to %Qore. In this case, %Qore will assume that the strings are backwards compatible with \c ASCII, meanin that that one character is represented by one byte and that the strings are null-terminated.

    Note that when %Qore matches an encoding name to a code or alias in the following table, the comparison is not case-sensitive.

    @subsection known_encodings Character Encodings Known to Qore

    |!Code|!Aliases|!Description
    |\c ISO-8859-1|\c ISO88591, \c ISO8859-1, \c ISO-88591, \c ISO8859P1, \c ISO81, \c LATIN1, \c LATIN-1|latin-1, Western European character set
    |\c ISO-8859-2|\c ISO88592, \c ISO8859-2, \c ISO-88592, \c ISO8859P2, \c ISO82, \c LATIN2, \c LATIN-2|latin-2, Central European character set
    |\c ISO-8859-3|\c ISO88593, \c ISO8859-3, \c ISO-88593, \c ISO8859P3, \c ISO83, \c LATIN3, \c LATIN-3|latin-3, Southern European character set
    |\c ISO-8859-4|\c ISO88594, \c ISO8859-4, \c ISO-88594, \c ISO8859P4, \c ISO84, \c LATIN4, \c LATIN-4|latin-4, Northern European character set
    |\c ISO-8859-5|\c ISO88595, \c ISO8859-5, \c ISO-88595, \c ISO8859P5, \c ISO85|Cyrillic character set
    |\c ISO-8859-6|\c ISO88596, \c ISO8859-6, \c ISO-88596, \c ISO8859P6, \c ISO86|Arabic character set
    |\c ISO-8859-7|\c ISO88597, \c ISO8859-7, \c ISO-88597, \c ISO8859P7, \c ISO87|Greek character set
    |\c ISO-8859-8|\c ISO88598, \c ISO8859-8, \c ISO-88598, \c ISO8859P8, \c ISO88|Hebrew character set
    |\c ISO-8859-9|\c ISO88599, \c ISO8859-9, \c ISO-88599, \c ISO8859P9, \c ISO89, \c LATIN5, \c LATIN-5|latin-5, Turkish character set
    |\c ISO-8859-10|\c ISO885910, \c ISO8859-10, \c ISO-885910, \c ISO8859P10, \c ISO810, \c LATIN6, \c LATIN-6|latin-6, Nordic character set
    |\c ISO-8859-11|\c ISO885911, \c ISO8859-11, \c ISO-885911, \c ISO8859P11, \c ISO811|Thai character set
    |\c ISO-8859-13|\c ISO885913, \c ISO8859-13, \c ISO-885913, \c ISO8859P13, \c ISO813, \c LATIN7, \c LATIN-7|latin-7, Baltic rim character set
    |\c ISO-8859-14|\c ISO885914, \c ISO8859-14, \c ISO-885914, \c ISO8859P14, \c ISO814, \c LATIN8, \c LATIN-8|latin-8, Celtic character set
    |\c ISO-8859-15|\c ISO885915, \c ISO8859-15, \c ISO-885915, \c ISO8859P15, \c ISO815, \c LATIN9, \c LATIN-9|latin-9, Western European with euro symbol
    |\c ISO-8859-16|\c ISO885916, \c ISO8859-16, \c ISO-885916, \c ISO8859P16, \c ISO816, \c LATIN10, \c LATIN-10|latin-10, Southeast European character set
    |\c KOI7|n/a|Russian: Kod Obmena Informatsiey, 7 bit characters
    |\c KOI8-R|\c KOI8R|Russian: Kod Obmena Informatsiey, 8 bit
    |\c KOI8-U|\c KOI8U|Ukrainian: Kod Obmena Informatsiey, 8 bit
    |\c US-ASCII|\c ASCII, USASCII|7-bit ASCII character set
    |\c UTF-8|\c UTF8|variable-width universal character set

    @subsection default_encoding Default Character Encoding

    The default character encoding for %Qore is determined by environment variables.

    First, the \c QORE_CHARSET environment variable is checked. If it is set, then this character encoding will be the default character encoding for the process. If not, then the \c LANG environment variable is checked. If a character encoding is specified in the \c LANG environment variable, then it will be used as the default character encoding. Otherwise, if no character encoding can be derived from the environment, \c UTF-8 is assumed.

    Character encodings are automatically converted by the %Qore language when necessary. Encoding conversion errors will cause a %Qore exception to be thrown. The character encoding conversions supported by %Qore depend on the operating system's \c iconv library function.

    @subsection encoding_examples Character Encoding Usage Examples

    The following is a non-exhaustive list of examples in %Qore where character encoding processing is performed.

    Character encodings can be explicitly performed with the convert_encoding() function, and the encoding attached to a string can be checked with the get_encoding() function. If you have a string with incorrect encoding and want to change the encoding tag of the string (without changing the actual bytes of the string), use the force_encoding() function.

    The @ref Qore::Datasource, @ref Qore::DatasourcePool, and @ref Qore::SQLStatement classes will translate character encodings to the encoding required by the database if necessary as well (this is actually the responsibility of the DBI driver for the database in question).

    The @ref Qore::File and @ref Qore::Socket classes translate character encodings to the encoding specified for the object if necessary, as well as tagging strings received or read with the object's encoding.

    The @ref Qore::HTTPClient class will translate character encodings to the encoding specified for the object if necessary, as well as tag strings received with the object's encoding. Additionally, if an HTTP server response specifies a specific encoding to use, the encoding of strings read from the server will be automatically set to this encoding as well.

    @section expressions Expressions

    An expression can be any of the following (note that expressions are also recursively defined):

    <b>Expressions</b>
    |!Type|!Description|!Examples
    |An immediate value|Qore values that can be expressed directly (see @ref basic_data_types and @ref container_types for more information)|@code True@endcode @code1.2@endcode @code "a string"@endcode @code 2005-10-27@endcode @code NULL@endcode @code NOTHING@endcode @code ("key" : $val)@endcode
    |A variable reference|@ref variables<br>see also @ref allow-bare-refs "%allow-bare-refs"|@code $var@endcode
    |A variable declaration|@ref variable_declarations, @ref variables<br>see also @ref assume-local "%assume-local"|@code my int $var@endcode
    |An in-class object member reference|References to members of an object from within the class<br>see @ref class_members<br>see also allow-bare-refs "%allow-bare-refs"|@code $.member@endcode
    |An lvalue assignment|Assigns a value to a lvalue (see @ref assignment_operator)|@code $var = 1@endcode @code ($a, $b, $c, $date) = (1, "two", 3.3, 2005-10-28)@endcode
    |A function call|Qore function calls (see @ref functions)|@code calculate($var1, $var2, "string", 4)@endcode
    |A method call|Qore object method calls (see @ref object_method_calls)<br>see also @ref allow-bare-refs "%allow-bare-refs"|@code $object.method("argument")@endcode
    |An in-class method call|Qore in-class object method calls (see @ref object_method_calls)<br>see also @ref allow-bare-refs "%allow-bare-refs"|@code $.method("argument")@endcode
    |A @ref static_method_call "static method call"|Qore static method calls (see @ref static_methods)|@code ClassName::static_method("argument")@endcode
    |Expressions with operators|Use of @ref operators "Qore operators"|@code 1 + 2@endcode @code $a || $b@endcode @code background my_function()@endcode
    |An expression in parentheses|Use of parentheses for clarity or to specify evaluation precedence|@code (3 * (2 + $a))@endcode
    |A @ref find "find expression"|Finds a value or values in a hash of lists, such as returned by the Qore::Datasource::select() or Qore::SQLStatement::fetchColumns() method|@code find %name, %id in $data where (%name =~ /Smith/)@endcode
    |A context reference (<tt>%name</tt>)|A contextual reference to the value of a key of the current row being iterated by a @ref context "context", @ref summarize "summarize", @ref subcontext "subcontext" statement, or a @ref find "find expression"|@code %name@endcode
    |A context row reference (<tt>%%</tt>)|A contextual reference to the current row being iterated by a @ref context "context", @ref summarize "summarize", @ref subcontext "subcontext" statement, or a @ref find "find expression"; this expression returns a hash of the current row|@code %%@endcode
    |A @ref call_reference "call reference"|A reference to a function or object method call (similar to a function pointer in C or C++). Function references are resolved in the second phase of parsing (commit phase), while object method references are resolved at run-time|@code \function_call()@endcode @code \$object_expression.method_name()@endcode
    |A @ref closure "closure"|An anonymous function used a value; technically a closure must have at least one bound variable, but in %Qore a closure is any function used as a value, whether or not it encloses local variables from the scope in which it was created or not|@code string sub (string $a) { return $a + $b; }@endcode
    |A call reference call|An expression executing a @ref call_reference "call reference" or @ref closure "closure"|@code $my_closure($arg1, $arg2)@endcode
    |An @ref implicit_arguments "implicit argument" reference (\c $1)|References an implicit argument|@code $1@endcode
    |A reference to the entire @ref implicit_arguments "implicit argument" list (\c $$)|References the implicit argument list|@code $$@endcode
    |An @ref implicit_index "implicit index" reference|Gives the list index position when implicitly iterating a list|@code $#@endcode

    <hr>
    @subsection static_method_calls Static Method Calls

    @par Synopsis
    Calls to static class methods are made by giving the class name followed by two colons and then the method name. The method name must be implemented and accessible (i.e. not private and accessed outside the class) somewhere within the class hierarchy and must be static or a parse exception will occur.

    @par Syntax
    \a class_name::method_name <tt>(</tt><em>[argument_expressions...]</em><tt>)</tt>

    @par Description
    \a class_name \n
    The name of the class implementing the static method.\n\n
    \a method_name \n
    The name of the static method to call.\n\n
    <em>[argument_expressions...]</em>\n
    Expressions passing arguments to the static method.

    @par Example
    @code TimeZone::setRegion("Europe/Prague");@endcode

    <hr>
    @subsection find Find Expressions

    @par Synopsis
    The find expression can be used to quickly find data in a hash of lists (such as a query result set returned by the Qore::Datasource::select() or Qore::SQLStatement::fetchColumns() methods). The find expression will loop through a data structure, and for each element in the structure where the \c where expression is \c True, it will evaluate and return a result expression.\n\n
    If the \a where_expression only is \c True for one element in the list, it will return the result of evaluating the result expression directly, otherwise if the \a where_expression is \c True more than once, then a list of the results of evaluting the result expression for each element is returned.\n\n
    In each expression in the find expression, column values can be referred to by preceding the name with a \c "%" character (as with @ref context "context statements").

    @par Syntax
    \c \b find \a result_expression \c \b in \a data_expression <tt>\b where (</tt>\a where_expression<tt>)</tt>

    @par Description
    \a result_expression \n
    This expression will be evaluated and returned when the \a where_expression evaluates to \c True.\n\n
    \a data_expression \n
    This expression must evaluate to a hash of lists, so that the internal context can be set up for the find loop.\n\n
    \a where_expression \n
    This expression will be evaluated for each row in the \a data_expression. Each time it evaluates to \c True, the \a result_expression will be evaulated and used for the return value for the find expression.

    @par Example
    @code $rlist = find %fname, %id in $data where (%lname =~ /^Smith/);@endcode

    <hr>
    @subsection call_reference Call References

    @par Synopsis
    References to functions or object methods are called call references. A call reference can be used like a function pointer; a call reference is a %Qore data type that can be returned by functions or methods or assigned to variables.\n\n
    Note that the empty parentheses after the call are required to identify the expression as a call reference.

    @par Syntax
    <tt>\\</tt><em>function_name</em><tt>()</tt>\n
    <tt>\\</tt><em>class</em><tt>::</tt><em>static_method</em><tt>()</tt>\n
    <tt>\\</tt><em>object.method</em><tt>()</tt>

    @par Description
    <tt>\\</tt> \a function_name <tt>()</tt>\n
    This makes a call reference to a function. Call references to functions are resolved at parse time; if the function does not exist a parse exception will be thrown.\n\n
    <tt>\\</tt> \a class <tt>::</tt> \a static_method <tt>()</tt>\n
    This makes a call reference to a static method. Call references to static methods are resolved at parse time; if the static method does not exist a parse exception will be thrown.\n\n
    <tt>\\</tt> \a object <tt>.</tt> \a method <tt>()</tt>\n
    - \a object: can be any valid %Qore expression that evaluates to an object
    - \a method: must be an unquoted string (see example below) and must represent a valid method name of the object's class.
    .
    This makes a call reference to an object method call, binding the object and the method in the call reference. Call references to object methods are executed and resolved at run time; if the object expression does not evaluate to an object at run-time, an \c OBJECT-METHOD-REFERENCE-ERROR exception will be thrown. If the method does not exist, a \c METHOD-DOES-NOT-EXIST run-time exception will be thrown.\n\n
    When called, a call reference to an object method will be executed in the context of the object originally referenced. Object method call references do not prolong the lifetime of an object; if the object is deleted (for example, by going out of scope), then if called the call reference will cause an \nOBJECT-ALREADY-DELETED exception to be thrown.

    @par Example
    @code my code $c = \printf(); @endcode
    @code my code $c = \MyClass::method(); @endcode
    @code my code $c = \$obj.method(); @endcode

    @note The backslash at the beginning and the empty parentheses at the end; these are required when specifying a call reference.

    <hr>
    @subsection closure Closures

    @par Synopsis
    A closure is an anonymous function used as a value. Closures can be returned from functions or methods, assigned to variables, or passed as arguments to other functions.

    @par Syntax
    <em>@ref data_type_declarations "[return_type]"</em> <tt>\b sub ([</tt><em>@ref data_type_declarations "[type]" variable1</em><tt>, ...]) {</tt> <em>[code]</em> <tt>}</tt>\n\n
    or the alternate (deprecated) syntax with the \c returns keyword after the parameters:\n\n
    <tt>\b sub ([</tt> <em>@ref data_type_declarations "[type]" variable1</em><tt>, ...]) \b returns</tt> <em>@ref data_type_declarations "return_type"</em> <tt>{</tt> <em>[code]</em> <tt>}</tt>

    @par Description
    Closures encapsulate the state and value of local variables of the outer code block referenced from within the closure when the closure is created. Whenever local variables are bound within a closure, these variables are subject to concurrent thread access protection (locking) just as with global variables, in order to allow closures to be used in any context without restriction and to preseve thread-safety regarding bound local variables.\n\n
    Note that returning a closure from within an object method encapsulates the state of the object as well (it's legal to refer to \c $self and <tt>$.<variable></tt> from within closures created from objects) and additionally prolongs the scope of the object for the lifetime of the closure.\n\n
    Note that parameter and return types are required when the @ref PO_REQUIRE_TYPES or @ref PO_REQUIRE_PROTOTYPES parse options are set.

    @par Example
    @code
# if $b is a local variable in the function where the closure is created
# then $b will be bound to the closure when the closure is created
my code $closure = int sub (int $a) { return $a + $b; };
    @endcode

    <hr>
    @subsection implicit_arguments Implicit Argument References

    @par Synopsis
    Implicit arguments are arguments not captured by parameter variables as well as automatic arguments in list-processing operator expressions. A special syntax to reference these arguments is documented here.

    @par Syntax
    <tt>$</tt><em>int</em>   (for a single implicit argument; \a int is the argument number, where \c 1 is the first argument)\n
    <tt>$$</tt>              (for the entire implicit argument list)

    @par Description
    Implicit arguments can be directly referenced using the dollar sign (<tt>$</tt>) and either a number from \c 1 onwards (giving the position in the argument list, where \c 1 is the first element) or a double dollar sign (<tt>$$</tt>) giving the entire implicit argument list.\n\n
    For unassigned arguments to functions or methods, this syntax supplements the automatic $argv variable holding all function arguments not assigned to parameter variables.\n\n
    This syntax is particularly useful when writing expressions for the @ref map "map", @ref foldl "foldl", @ref foldr "foldr", and @ref select "select" operators, where implicit argument references are the only way the operator expressions can reference the current list values that are populated as implicit arguments as the operators traverse the list.

    @par Example
    @code
# extract a list of even numbers from a list
my list $l = select $list, !($1 % 2);
    @endcode

    <hr>
    @subsection implicit_index Implicit Index

    @par Synopsis
    The current list index position when implicitly iterating through lists can be referenced using the implicit index reference characters: <tt>$#</tt>.

    @par Syntax
    <tt>$#</tt>

    @par Description
    The implicit index reference expression (<tt>$#</tt>) can be used whenever a list is iterated implicitly, such as with @ref foreach "foreach statements" and the @ref map "map", @ref foldl "foldl", @ref foldr "foldr", and @ref select "select" operators.

    @par Example
    @code
# create a list of indexes with negative values
my list $l = map $#, $list, ($1 < 0);
    @endcode

    @section operators Operators

    The following table lists all %Qore operators in order of precedence, starting with the highest precedence. The lower the precedence number, the higher the precedence, therefore the operators with precedence level 1 (\c "{}", \c "[]", \c ".") have the highest precedence of all %Qore operators. The precedence levels in %Qore are roughly equal to the precedence levels of C language operators. To explicitly specify the precedence for expression evaluation, use parentheses <tt>()</tt>.

    <b>Operators</b>
    |!Operator|!Prec.|!Description|!Example
    |@ref backquote_operator "``"|\c 1|@ref backquote_operator "backquote/backtick operator"|@code `ls -l`@endcode
    |@ref hash_element_operator "{}"|\c 1|@ref hash_element_operator "hash element or object member expression dereference operator"|@code $hash{"na" + "me"}@endcode
    |@ref dot_operator "."|\c 1|@ref dot_operator "hash element or object member literal dereference operator"|@code $hash.name@endcode @code $obj.method()@endcode
    |@ref list_element_operator "[]"|\c 1|@ref list_element_operator "list element, string, and binary dereference operator"|@code $list[1]@endcode
    |@ref pre_increment_operator "++"|\c 2|@ref pre_increment_operator "pre-increment operator"|@code ++$a@endcode
    |@ref post_increment_operator "++"|\c 2|@ref post_increment_operator "post-increment operator"|@code $a++@endcode
    |@ref pre_decrement_operator "--"|\c 2|@ref pre_decrement_operator "pre-decrement operator"|@code --$a@endcode
    |@ref post_decrement_operator "--"|\c 2|@ref post_decrement_operator "post-decrement operator"|@code $a--@endcode
    |@ref new "new"|\c 3|@ref new "class instantiation/new object operator"|@code new Socket()@endcode
    |@ref background "background"|\c 3|@ref background "background/thread creation operator"|@code background mainThread()@endcode
    |@ref delete "delete"|\c 3|@ref delete "delete operator"|@code delete $var@endcode
    |@ref remove "remove"|\c 3|@ref remove "remove operator"|@code remove $var@endcode
    |@ref cast "cast<>()"|\c 3|@ref cast "cast<>() operator"|@code cast<SubClass>($var)@endcode
    |@ref logical_negation_operator "!"|\c 4|@ref logical_negation_operator "logical negation operator"|@code if (!($a > 10)) {}@endcode
    |@ref binary_not_operator "~"|\c 5|@ref binary_not_operator "binary not/bit inversion operator"|@code $var = ~$var@endcode
    |@ref unary_minus_operator "- (unary minus)"|\c 6|@ref unary_minus_operator "unary minus operator"|@code $var = -$var@endcode
    |@ref shift "shift"|\c 7|@ref shift "shift list element operator"|@code shift $list@endcode
    |@ref pop "pop"|\c 7|@ref pop "pop list element operator"|@code pop $list@endcode
    |@ref chomp "chomp"|\c 7|@ref chomp "chomp end-of-line character operator"|@code chomp $string@endcode
    |@ref trim "trim"|\c 7|@ref trim "trim characters operator"|@code trim $string@endcode
    |@ref elements "elements"|\c 8|@ref elements "number of elements operator (list, hash, string, binary)"|@code elements $list@endcode
    |@ref keys "keys"|\c 8|@ref keys "hash key list operator"|@code keys $hash@endcode
    |@ref multiplication_operator "*"|\c 9|@ref multiplication_operator "multiplication operator"|@code $var = $a * 10@endcode
    |@ref division_operator "/"|\c 9|@ref division_operator "division operator"|@code $var = $a / 10@endcode
    |@ref modula_operator "%"|\c 10|@ref modula_operator "modula operator"|@code $var = $a % 10@endcode
    |@ref plus_operator "+"|\c 11|@ref plus_operator "plus operator: string, binary, list, and hash concatenation, integer and float addition"|@code $a + 10@endcode @code "hello" + "there"@endcode @code $list + "new value"@endcode @code $hash + ( "newkey" : 100 )@endcode
    |@ref minus_operator "-"|\c 11|@ref minus_operator "minus operator (arithmetic subtraction, hash key removal)"|@code $a - 10@endcode
    |@ref shift_right_operator ">>"|\c 12|@ref shift_right_operator "bitwise shift right operator"|@code 0xff00 >> 8@endcode
    |@ref shift_left_operator "<<"|\c 12|@ref shift_left_operator "bitwise shift left operator"|@code 0xff00 << 8@endcode
    |@ref exists "exists"|\c 13|@ref exists "exists value operator"|@code exists $var@endcode
    |@ref instanceof "instanceof"|\c 13|@ref instanceof "instanceof class operator"|@code instanceof Qore::Mutex@endcode
    |@ref logical_less_than_operator "<"|\c 14|@ref logical_less_than_operator "Logical less than operator"|@code $a < 10@endcode
    |@ref logical_greater_than_operator ">"|\c 14|@ref logical_greater_than_operator "Logical greater than operator"|@code $a > 10@endcode
    |@ref logical_equality_operator "=="|\c 14|@ref logical_equality_operator "Logical equality operator"|@code $a == 10@endcode
    |@ref logical_inequality_operator "!="|\c 14|@ref logical_inequality_operator "logical inequality operator"|@code $a != 10@endcode
    |@ref logical_less_than_or_equals_operator "<="|\c 14|@ref logical_less_than_or_equals_operator "Logical less then or equals operator"|@code $a <= 10@endcode
    |@ref logical_greater_than_or_equals_operator ">="|\c 14|@ref logical_greater_than_or_equals_operator "logical greater than or equals operator"|@code $a >= 10@endcode
    |@ref logical_comparison_operator "<=>"|\c 14|@ref logical_comparison_operator "logical comparison operator"|@code $a <=> $b@endcode
    |@ref logical_absolute_equality_operator "==="|\c 14|@ref logical_absolute_equality_operator "absolute logical equality operator"|@code $a === 10@endcode
    |@ref logical_absolute_inequality_operator "!=="|\c 14|@ref logical_absolute_inequality_operator "absolute logical inequality operator"|@code $a !== 10@endcode
    |@ref regex_match_operator "=~ //"|\c 14|@ref regex_match_operator "regular expression match operator"|@code $a =~ /text/@endcode
    |@ref regex_no_match_operator "!~ //"|\c 14|@ref regex_no_match_operator "regular expression no match operator"|@code $a !~ /text/@endcode
    |@ref regex_subst_operator "=~ s///"|\c 14|@ref regex_subst_operator "regular expression substitution operator"|@code $a =~ s/text/text/@endcode
    |@ref regex_extract_operator "=~ x//"|\c 14|@ref regex_extract_operator "regular expression pattern extraction operator"|@code $a =~ x/(\w+):(\w+)/@endcode
    |@ref transliteration_operator "=~ tr"|\c 14|@ref transliteration_operator "transliteration operator"|@code $a =~ tr/a-z/A-Z/@endcode
    |@ref bitwise_and_operator "&"|\c 15|@ref bitwise_and_operator "bitwise/binary AND operator"|@code $a & 0xff@endcode
    |@ref bitwise_or_operator "|"|\c 15|@ref bitwise_or_operator "bitwise/binary OR operator"|@code $a | 0xff@endcode
    |@ref bitwise_xor_operator "^"|\c 15|@ref bitwise_xor_operator "bitwise/binary XOR operator"|@code $a ^ 0xff@endcode
    |@ref logical_and_operator "&&"|\c 16|@ref logical_and_operator "logical AND operator"|@code ($a = 1) && ($b < 10)@endcode
    |@ref logical_or_operator "||"|\c 16|@ref logical_or_operator "logical OR operator"|@code ($a = 1) || ($b < 10)@endcode
    |@ref conditional_operator "? :"|\c 17|@ref conditional_operator "conditional operator"|@code $a == 2 ? "yes" : "no"@endcode
    |@ref comma_operator ","|\c 18|@ref comma_operator "comma operator"|@code 1, 2, 3, 4, 5@endcode
    |@ref unshift "unshift"|\c 19|@ref unshift "unshift list element operator"|@code unshift $list, $val@endcode
    |@ref push "push"|\c 19|@ref push "push list element operator"|@code push $list, $val@endcode
    |@ref splice "splice"|\c 19|@ref splice "splice list or string operator"|@code splice $list, 2, 2, (1, 2, 3)@endcode
    |@ref extract "extract"|\c 19|@ref extract "extract list or string operator"|@code my $sublist = extract $list, 2, 2, (1, 2, 3)@endcode
    |@ref map "map"|\c 19|@ref map "map operator"|@code map $closure($1), $list@endcode
    |@ref foldl "foldl"|\c 19|@ref foldl "fold left to right operator"|@code foldl $closure($1 - $2), $list@endcode
    |@ref foldr "foldr"|\c 19|@ref foldr "fold right to left operator"|@code foldr $closure($1 - $2), $list@endcode
    |@ref select "select"|\c 19|@ref select "select elements from list operator"|@code select $list, $1 > 1@endcode
    |@ref assignment_operator "="|\c 20|@ref assignment_operator "assignment operator"|@code $var = 1@endcode
    |@ref plus_equals_operator "+="|\c 21|@ref plus_equals_operator "plus-equals (add-to) operator"|@code $var += 5@endcode
    |@ref minus_equals_operator "-="|\c 21|@ref minus_equals_operator "minus-equals (subtract-from) operator"|@code $var -= 5@endcode
    |@ref and_equals_operator "&="|\c 21|@ref and_equals_operator "and-equals operator"|@code $var &= 0x2000@endcode
    |@ref or_equals_operator "|="|\c 21|@ref or_equals_operator "or-equals operator"|@code $var |= 0x2000@endcode
    |@ref modula_equals_operator "%="|\c 21|@ref modula_equals_operator "modula-equals operator"|@code $var %= 100@endcode
    |@ref multiply_equals_operator "*="|\c 21|@ref multiply_equals_operator "multiply-equals operator"|@code $var *= 10@endcode
    |@ref divide_equals_operator "/="|\c 21|@ref divide_equals_operator "divide-equals operator"|@code $var /= 10@endcode
    |@ref xor_equals_operator "^="|\c 21|@ref xor_equals_operator "xor-equals operator"|@code $var ^= 0x2000@endcode
    |@ref shift_left_equals_operator "<<="|\c 21|@ref shift_left_equals_operator "shift-left-equals operator"|@code $var <<= 0x2000@endcode
    |@ref shift_right_equals_operator ">>="|\c 21|@ref shift_right_equals_operator "shift-right-equals operator"|@code $var >>= 0x2000@endcode

    @note All Qore operators perform thread-atomic actions with respect to the immediate arguments of the operator. If the operators are used in a complex expression, the entire expression is not thread-atomic unless explicit user-level locking is used. For example: <tt>$a += 5</tt> is a thread-atomic action, but <tt>$a += $b--</tt> is not atomic, but rather made up of two atomic actions.\n\n
    When an operator taking more than one argument is used with arguments of different data types, Qore automatically converts one or both data types to a data type supported by the operator in order to evaluate the result, according to the precedence lists given for each operator. That is; when an operator operates on mixed types, the types listed first in the following sections have precedence over types listed farther down in the lists. The result type will always be equal to the final operation type after any conversions due to type precedence per operator. If no type of either argument matches a supported data type for the operator, both types will be converted to the highest precedence data type for the operator and then the operator will evaluate the result. For explicit type conversion, please see the boolean(), string(), date(), int(), float(), etc functions.

    <hr>
    @subsection backquote_operator Backquote Operator (``)

    @par Synopsis
    Executes the shell command in a separate process and returns the stdout as a string. To perform the same action using a %Qore expression, see the backquote() function.

    @par Syntax
    <tt>`</tt><em>shell_command</em><tt>`</tt>

    @par Return Type
    @ref string_type "string"

    @par Example
    @code my string $dir = `ls -l`@endcode

    <b>Arguments Processed by ``</b>
    |!Argument|!Returns|!Processing
    |unquoted @ref string "string" \a shell_command|@ref string_type "string"|The shell command will be executed and the \c stdout is returned as a string

    @throw BACKQUOTE-ERROR An error occurred in fork() or creating the output pipe

    <hr>
    @subsection hash_element_operator Hash Element or Object Member Expression Dereference Operator ({})

    @par Synopsis
    Retrieves the value of hash key or object member by evaulating an expression.

    @par Syntax
    \a container_expression <tt>{</tt> \a expression <tt>}</tt>

    @par Return Type
    @ref any_type "any"

    @par Example
    @code printf("%s\n", $hash{getName()});@endcode

    <b>Arguments Processed by {}</b>
    |!Argument|!Processing
    |\a container_expression|This expression must evaluate to a @ref hash "hash" or an @ref object "object"; if not, the operator returns no value (@ref nothing)
    |\a expression|- @ref list "list": if the expression evaluates to a list, then a slice of the hash or object is returned as a hash containing keys given in the list that are present in the hash or object. If the key as given in the list (converted to a string if necessary) is not present in the hash or object, then it is also not present in the hash returned; of none of the given keys exist in the hash, an empty hash is returned.\n- anything other than @ref list "list": the expression is converted to a string (if necessary); the value of the hash key corresponding to this string will be returned; if the key or member does not exist, then no value is returned

    @throw PRIVATE-MEMBER Attempt to access a private member outside the class

    <hr>
    @subsection dot_operator Hash Element or Object Member Literal Dereference Operator (.)

    @par Synopsis
    Retrieves the value of a hash key or object member using a literal identifier or an expression.

    @par Syntax
    \a hash_or_object_expression <tt>.</tt> \a identifier\n
    \a object_expression <tt>.</tt> \a method_name<tt>(</tt><em>[args ...]</em><tt>)</tt>\n
    \a hash_or_object_expression <tt>.</tt> \a expression\n

    @par Return Type
    @ref any_type "any"

    @par Example
    @code printf("%s\n", $hash.name);@endcode
    @code $obj.method("argument");@endcode

    <b>Arguments Processed by .</b>
    |!Argument|!Processing
    |\a hash_or_object_expression|This expression must evaluate to a hash or an object; if not, then the operator returns no value
    |\a identifier|An unquoted string taken as the literal name of the hash key or object member. If no such key exists, then no value is returned. In order to use hash keys that are not valid Qore identifiers, please use the {} operator. If the member is a private member and access is made outside the class, a run-time exception will be thrown.  Also note that constants or static class member names will not be resolved, in this case the string given is used as the literal name of the hash key or object member
    \n
    |!Argument|!Processing
    |\a object_expression|The \a object_expression must evaluate to an object or a run-time exception is thrown. If the method does not exist in the class a run-time exception is thrown. Otherwise the method is called with any optional arguments given and the return value of the method is returned.
    \n
    |!Argument|!Processing
    |\a hash_or_object_expression|This expression must evaluate to a hash or an object; if not, then the operator returns no value
    |\a expression|- @ref list "list": if the expression evaluates to a list, then a slice of the hash or object is returned as a hash containing keys given in the list that are present in the hash or object. If the key as given in the list (converted to a string if necessary) is not present in the hash or object, then it is also not present in the hash returned; of none of the given keys exist in the hash, an empty hash is returned.\n- anything other than @ref list "list": the expression is converted to a string (if necessary); the value of the hash key corresponding to this string will be returned; if the key or member does not exist, then no value is returned
    
    @throw PRIVATE-MEMBER Attempt to access a private member outside the class
    @throw METHOD-DOES-NOT-EXIST Attempt to access a method not defined for this class
    @throw METHOD-IS-PRIVATE Attempt to access a private method from outside the class
    @throw BASE-CLASS-IS-PRIVATE Attempt to access a method of a privately-inherited base class from outside the class
    @throw OBJECT-METHOD-EVAL-ON-NON-OBJECT Attempt to execute a method on a non-object

    <hr>
    @subsection list_element_operator List, String, and Binary Dereference Operator ([])

    @par Synopsis
    Retrieves the value of a list element, the given character of a string, or the integer value of a byte for a binary object. If the index value is not valid for the argument, @ref nothing is returned. Note that this operator only works as a list dereferencing operator in lvalue expressions; you cannot assign a character or a byte value to strings or binaries using this operator.

    @par Syntax
    <em>list_expression</em><tt>[</tt>\a offset_expression<tt>]</tt>
    <em>string_expression</em><tt>[</tt>\a offset_expression<tt>]</tt>
    <em>binary_expression</em><tt>[</tt>\a offset_expression<tt>]</tt>

    @par Return Type
    @ref any_type "any"

    @par Example
    @code printf("%s\n", $list[2]);@endcode
    @code printf("%s\n", $str[2]);@endcode
    @code printf("0x%x\n", $binary[2]);@endcode

    <b>Arguments Processed by []</b>
    |!Argument|!Processing
    |\a list_expression|If the expression evaluates to a list, then the \a offset_expression will be used to return the given element from the list
    |\a string_expression|If the expression evaluates to a string, then the \a offset_expression will be used to return the given character from the list; note that multi-byte characters with UTF-8 are properly respected with this operator
    |\a binary_expression|If the expression evaluates to a binary, then the \a offset_expression will be used to return the integer value of the byte given from the binary object
    |\a offset_expression|The expression is evaluated and converted to an integer if necessary. Then the value of the given element given is returned according to the type of the first expression (as listed above; elements start at position 0)

    This operator does not throw any exceptions; if the first expression does not evaluate to either a list, string, or binary, then no value (@ref nothing) is returned.

    <hr>
    @subsection pre_increment_operator Integer Pre-Increment Operator (++)

    @par Synopsis
    Increments an lvalue and returns the incremented value.

    @par Syntax
    <tt>++</tt><em>lvalue</em>

    @par Return Type
    @ref int_type "int"

    @par Example
    @code ++$i;@endcode

    <b>Arguments Processed by ++ (pre-increement)</b>
    |!Argument|!Processing
    |@ref integer|First converts the value of \a lvalue to an integer if necessary, then increments \a lvalue and returns the result

    This operator does not throw any exceptions.

    <hr>
    @subsection post_increment_operator Integer Post-Increment Operator (++)

    @par Synopsis
    Increments an lvalue and returns the value before the increment.

    @par Syntax
    <em>lvalue</em><tt>++</tt>

    @par Return Type
    @ref any_type "any"

    @par Example
    @code $i++;@endcode

    <b>Arguments Processed by ++ (post-increment)</b>
    |!Argument|!Processing
    |@ref integer|First converts the value of \a lvalue to an integer if necessary, then saves this value as the result, then increments \a lvalue, then returns the saved original value of \a lvalue

    This operator does not throw any exceptions.

    <hr>
    @subsection pre_decrement_operator Integer Pre-Decrement Operator (--)

    @par Synopsis
    Decrements an lvalue and returns the decremented value.

    @par Syntax
    <tt>--</tt><em>lvalue</em>

    @par Return Type
    @ref int_type "int"

    @par Example
    @code --$i;@endcode

    <b>Arguments Processed by -- (pre-decrement)</b>
    |!Argument|!Processing
    |@ref integer|First converts the value of \a lvalue to an integer if necessary, then decrements it and returns the result

    This operator does not throw any exceptions.

    <hr>
    @subsection post_decrement_operator Integer Post-Decrement Operator (--)

    @par Synopsis
    Decrements an lvalue and returns the value before the decrement.

    @par Syntax
    <em>lvalue</em><tt>--</tt>

    @par Return Type
    @ref any_type "any"

    @par Example
    $i--;

    <b>Arguments Processed by -- (post-decrement)</b>
    |!Argument|!Processing
    |@ref integer|First converts the value of \a lvalue to an integer if necessary, then saves this value as the result, then decrements \a lvalue, then returns the saved original value of lvalue

    This operator does not throw any exceptions.

    <hr>
    @subsection new New Object Operator (new)

    @par Synopsis
    Creates an instance of a class by running the class' constructor on the new class (if any exists) and returns the new object.\n\n
    Note that if possible it is normally better to declare an object with its type and use the abbreviated form to construct the object as follows:\n
    @code my Mutex $m();@endcode
    This provides type information to the parser which allows more errors to be caught at parse time (instead of at run time), and furthermore allows Qore improve performance by performing more work once at parse time rather than for every time the object is accessed at run time (for example, method and variant resolution), and normally requires less typing.

    @par Syntax
    \c \b new <em>class_identifier</em><tt>(</tt><em>constructor_args ...</em><tt>)</tt>

    @par Return Type
    an object of the specific class given

    @par Example
    @code my Mutex $obj = new Qore::Mutex();@endcode

    <b>Arguments Processed by new</b>
    |!Argument|!Processing
    |\a class_identifier|The class_identifier must be an existing class name; if so, the operator instantiates an object of this class, executes the constructor for the class (if any exists, along with any base class constructors, if applicable) on the new object, and returns the object (for constructor execution order in an inherited class, see @inheritance). If an exception is thrown in the constructor, the object is deleted immediately.

    @note See class documentation for possible exceptions

    <hr>
    @subsection background Background Operator (background)

    @par Synopsis
    Start a background thread and return the TID (thread ID).

    @note
    - expressions that have no effect cannot be used with the background operator (a parse exception will be thrown)
    - it is illegal to make changes to a local variable anywhere in a background expression (a parse exception will be thrown)
    - local variables and find expressions are evaluated before the new thread is started and the result of the evaluation is used in the expression in the new thread
    - it is not possible to pass local variables by reference anywhere in a background expression (a parse exception will be thrown)

    @par Syntax
    \c \b background \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code my int $tid = background startThread();@endcode

    <b>Arguments Processed by background</b>
    |!Argument|!Processing
    |\a expression|The \a expression given as an argument will be executed in a new thread. The TID of the new thread will be returned as the return value of the operator

    @throw THREAD-CREATION-FAILURE If the thread table is full or if the operating system returns an error while starting the thread, this exception is thrown

    <hr>
    @subsection delete Delete Operator (delete)

    @par Synopsis
    The delete operator deletes the contents of an lvalue. If the delete operator is called on an object, the object will be destroyed unconditionally. The delete operator does not return any value.\n\n
    When called on a hash key, the key is removed from the hash entirely; when called on a list element, the element is assigned @ref nothing (i.e. the list size does not change).\n\n
    The delete operator will delete multiple keys from a hash (i.e. delete a slice from a hash) when called on a hash dereferenced by a list of strings, giving the keys to delete (see example below).\n\n
    In the case the delete operator operates on an object, any exception can be thrown that is thrown by the class' destructor.\n\n
    For a similar operator that returns the value that is removed from the data structure, and does not delete objects, see the @ref remove_operator "remove operator".

    @par Syntax
    \c \b delete \a lvalue_expression

    @par Return Type
    Does not return any value

    @par Example
    @code
# delete a single key from a hash
delete $value;
# delete multiple values from a hash
delete $h.("a", "b", "c");
    @endcode

    This operator does not throw any exceptions, however exceptions could be thrown in an object's destructor method when deleted by this operator.

    <hr>
    @subsection remove Remove Operator (remove)

    @par Synopsis
    The remove operator removes a value from a data structure, or, in the case the operand of the remove operator is a simple value, the value itself is removed from the variable and returned. The remove operator returns the value removed from the lvalue.\n\n
    When called on a hash key, the key is removed from the hash entirely, and the value returned is the value of the key removed from the hash; when called on a list element, the element is assigned @ref nothing (i.e. the list size does not change).\n\n
    The remove operator will remove and return a slice from a hash when called on a hash dereferenced by a list of strings, giving the keys to remove (see example below).\n\n
    The remove operator does not call destructors when operating on objects, but if removing an object from an lvalue or from a data structure within the lvalue causes the object to go out of scope, it will be destroyed, and then its destructor could throw an exception.\n\n
    For a similar operator that deletes the value that is removed from the data structure, see the @ref delete_operator "delete operator".

    @par Syntax
    \c \b remove \a lvalue_expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code
# remove a single value from a hash
my any $var = remove $hash.value;
# remove a slice from a hash
my hash $nh = remove $h.("a", "b", "c");
    @endcode

    This operator does not throw any exceptions, however exception could be thrown in an object's destructor if it goes out of scope due to the action of this operator.

    <hr> 
    @subsection cast Cast Operator (cast<>())

    @par Synopsis
    The cast<>() operator provides a way to tell the parser that the type of object is not actually the declared type but rather a subclass as given between the angle brackets.

    @par Syntax
    <tt><b>cast</b></tt>\<<em>class_identifier</em><tt>\>(</tt><em>object_expression</em><tt>)</tt>

    @par Return Type
    the specific class given

    @par Example
    @code cast<SubClass>($obj).method();@endcode

    <b>Arguments Processed by cast<>()</b>
    |!Argument|!Processing
    |\a class_identifier|This must be a literal unquoted string giving a class name or a namespace-qualified path to a class (ex: \c Namespace::MyClass)
    |\a object_expression|This must be an expression that evaluates to an object that can be cast to the given class; this is mostly useful at parse time to avoid @ref non-existent-method-call "non-existent-method-call warnings"

    @throw RUNTIME-CAST-ERROR The expression given does not evaluate to an object that can be cast to the given class

    <hr>
    @subsection logical_negation_operator Logical Not Operator (!)

    @par Synopsis
    Reverses the logical sense of an expression (\c True becomes \c False and \c False becomes \c True).

    @par Syntax
    <tt>!</tt><em>expression</em>

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if (!exists $error_code)
    do_something();
    @endcode

    <b>Arguments Processed by !</b>
    |!Argument|!Processing
    |\a expression|The expression is evaluated and converted to a @ref boolean "bool", if necessary. Then the value is logically reversed (\c True becomes \c False, \c False becomes \c True)

    This operator does not throw any exceptions.

    <hr>
    @subsection binary_not_operator Binary Not Operator (~)

    @par Synopsis
    The value of each bit in an integer is reversed (0 becomes 1, 1 becomes 0).

    @par Syntax
    <tt>~</tt><em>expression</em>

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a = ~$b;@endcode

    <b>Arguments Processed by ~</b>
    |!Argument|!Processing
    |\a expression|The argument is converted to an integer (if necessary), and bitwise negation is performed on the argument (ex: <tt>666 & ~27</tt> results in \c 640)

    This operator does not throw any exceptions

    <hr>
    @subsection unary_minus_operator Unary Minus Operator (-)

    @par Synopsis
    Changes the sign of numeric values.

    @par Syntax
    -expression

    @par Return Type
    @ref int_type "int" or @ref float_type "float"

    @par Example
    @code $a = -$b;@endcode

    <b>Arguments Processed by - (unary minus)</b>
    |!Argument|!Processing
    |@ref float|Gives the negative of its argument as a @ref float (ex: <tt>-(-1.1) = 1.1, -(1.1) = -1.1</tt>
    |@ref integer|Gives the negative of its argument as an @ref integer (ex: <tt>-(-1) = 1, -(1) = -1</tt>

    This operator does not throw any exceptions

    <hr>
    @subsection shift Shift Operator (shift)

    @par Synopsis
    Removes the first element from a list and returns that element.

    @par Syntax
    \c \b shift \a lvalue

    @par Return Type
    @ref any_type "any"

    @par Example
    @code my *string $a = shift $ARGV;@endcode

    <b>Arguments Processed by shift</b>
    |!Argument|!Processing
    |\a lvalue|Returns the first element of the list, and the list is modified by having the first element removed from the list.  If the \a lvalue is not a list, no action is performed and the operator returns no value (@ref nothing)

    This operator does not throw any exceptions.

    <hr>
    @subsection pop Pop Operator (pop)

    @par Synopsis
    Removes the last element from a list and returns that element.

    @par Syntax
    \c \b pop \a lvalue

    @par Return Type
    @ref any_type "any"

    @par Example
    @code $a = pop $list;@endcode

    <b>Arguments Processed by pop</b>
    |!Argument|!Processing
    |\a lvalue|Returns the last element of the list, and the list is modified, having the last element removed from the list. If the \a lvalue is not a list, no action is performed and the operator returns no value (@ref nothing)

    This operator does not throw any exceptions.

    <hr>
    @subsection chomp Chomp Operator (chomp)

    @par Synopsis
    Removes the end-of-line marker(s) (\c '\\n' or \c '\\r\\n') from a string, or each string element in a list, or each hash key value in a hash (if the value is a string) and returns the number of characters removed.\n\n
    To perform this operation on a non-lvalue expression, see the chomp() function.

    @par Syntax
    \c \b chomp \a lvalue

    @par Return Type
    @ref int_type "int"

    @par Example
    @code chomp $str;@endcode

    <b>Arguments Processed by chomp</b>
    |!Argument|!Processing
    |\a lvalue (@ref string)|Removes any EOL characters from a string and returns the number of characters removed.
    |\a lvalue (@ref list)|Removes any EOL characters from each string element of the list passed and returns the number of characters removed.
    |\a lvalue (@ref hash)|Removes any EOL characters from each hash key's value (where the value is a string) and returns the number of characters removed.

    This operator does not throw any exceptions.

    <hr>
    @subsection trim Trim Operator (trim)

    @par Synopsis
    Removes whitespace characters from the beginning and end of a string, or each string element in a list, or each hash key value in a hash (if the value is a string) and returns the value processed (string, list, or hash).\n\n
    To perform this operation on a non-lvalue expression, see the trim() function.\n\n
    The following whitespace characters are removed from the beginning and end of strings: <tt>' '</tt> (blank spaces), \c '\\n', \c '\\r', \c '\\t', \c '\\v' (vertical tab, ASCII 11), and \c '\\0' (null character).

    @par Syntax
    \c \b trim \a lvalue

    @par Return Type
    @ref string_type "string", @ref list_type "list", or @ref hash_type "hash"

    @par Example
    @code trim $str;@endcode

    <b>Arguments Processed by trim</b>
    |!Argument|!Processing
    |\a lvalue (@ref string)|Removes whitespace characters from the beginning and end of a string and returns the value processed.
    |\a lvalue (@ref list)|Removes whitespace characters from the beginning and end of each string element of the list passed and returns the list.
    |\a lvalue (@ref hash)|Removes whitespace characters from the beginning and end of each string value of the hash passed and returns the hash.

    This operator does not throw any exceptions.

    <hr>
    @subsection map Map Operator (map)

    @par Synopsis
    Executes (or maps) an expression on a list and returns the result. An optional select expression can be given to filter elements out from the result list.\n\n
    If the second argument is not a list, then \a map_expression is executed on the single value and the result is returned, and any \a select_expression is ignored.

    @par Return Type
    @ref any_type "any"

    @par Syntax
    \c \b map \a map_expression, <em>list_expression [, select_expression]</em>

    @par Example
    @code
# returns (2, 4, 6)
map $1 * 2, (1, 2, 3);
    @endcode

    <b>Arguments Processed by map</b>
    |!Argument|!Processing
    |\a map_expression|The expression to map on the list; the implicit argument <tt>$1</tt> represents the current element being processed.
    |\a list_expression|The data to process; if this is not a list then the \a map_expression is run on the single argument passed
    |<em>[select_expression]</em>|An optional expression than can be used to filter out elements of the list before the map expression is applied; if this expression evaluates to \c False on an element, then the element will be skipped and the \a map_expression will not be applied on that element.

    This operator does not throw any exceptions (however note that exceptions could be thrown by expressions executed by this operator).

    <hr>
    @subsection foldl Fold Left Operator (foldl)

    @par Synopsis
    Folds an operation on a list from left to right and returns the result. The result of each individual operation is used as the first argument in the foldl expression for the next element in the list. The first operation of the fold is made by executing the fold expression on the first and second elements of the list, from this point onwards, the result of each successive operation is used as the first argument for the next operation, the second argument being the next element in the list.\n\n
    If the \a list_expression does not evaluate to a list, then the evaluated argument is returned immediately with no processing by the fold expression.

    @par Syntax
    \c \b foldl \a expression, \a list_expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code
# returns 5
foldl $1 - $2, (10, 4, 1);
    @endcode

    <b>Arguments Processed by foldl</b>
    |!Argument|!Processing
    |\a expression|The expression to fold on the list; the implicit argument <tt>$1</tt> represents the result of the last operation (or the first element in the list when beginning the fold), and <tt>$2</tt> represents the next element of the list.
    |\a list_expression|The list to process

    This operator does not throw any exceptions (however note that exceptions could be thrown by expressions executed by this operator).

    <hr>
    @subsection foldr Fold Right Operator (foldr)

    @par Synopsis
    Folds an operation on a list from right to left and returns the result. The result of each individual operation is used as the first argument in the foldr expression for the next element in the list in reverse order. The first operation of the right fold is made by executing the fold expression on the last and penultimate elements of the list, from this point onwards, the result of each successive operation is used as the first argument for the next operation, the second argument being the next element in the list in reverse order.\n\n
    If the \a list_expression does not evaluate to a list, then the evaluated argument is returned immediately with no processing by the fold expression.

    @par Syntax
    \c \b foldr \a expression, \a list_expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code
# returns -13
foldr $1 - $2, (10, 4, 1);
    @endcode

    <b>Arguments Processed by foldr</b>
    |!Argument|!Processing
    |\a expression|The expression to fold on the list; the implicit argument <tt>$1</tt> represents the result of the last operation (or the last element in the list when beginning the fold), and <tt>$2</tt> represents the next element of the list in reverse order.
    |\a list_expression|The list to process

    This operator does not throw any exceptions (however note that exceptions could be thrown by expressions executed by this operator).

    <hr>
    @subsection select Select From List Operator (select)

    @par Synopsis
    Selects elements from a list that meet the given criteria and returns the new list.\n\n
    If the list expression does not evaluate to a list, then the select expression is evaluated using the value of the list expression as an argument, if it evalutes to true, then the value is returned, otherwise, no value is returned.

    @par Syntax
    \b \c select \a list_expression, \a expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code
# returns (2, 4, 6)
select (1, 2, 3, 4, 5, 6), !($1 % 2);
    @endcode

    <b>Arguments Processed by select</b>
    |!Argument|!Processing
    |\a list_expression|The list to process
    |\a expression|The expression will be evaluated on each element of the list, the implicit argument <tt>$1</tt> represents current element of the list; only if the expression evaluates to \c True will the element appear in the result list

    This operator does not throw any exceptions (however note that exceptions could be thrown by the expression executed by this operator).

    <hr>
    @subsection elements Elements Operator (elements)

    @par Synopsis
    Returns the number of elements in a list, the number of keys in a hash, the number of characters (not bytes) in a string, or the number of bytes in a binary object.

    @par Syntax
    \b \c elements \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code my int $size = elements $list;@endcode

    <b>Arguments Processed by elements</b>
    |!Argument|!Processing
    |\a expression @ref list_type "list"|Returns the number of elements in the list
    |\a expression @ref hash_type "hash"|Returns the number of keys in the hash
    |\a expression @ref string_type "string"|Returns the number of characters in the string (which may be different than the number of bytes for multi-byte character encodings such as \c UTF-8
    |\a expression @ref binary_type "binary"|Returns the number of bytes in the binary object

    This operator does not throw any exceptions.

    <hr>
    @subsection keys Keys Operator (keys)

    @par Synopsis
    Returns a list representing the keys in a hash.

    @par Syntax
    \b \c keys \a hash_expression

    @par Return Type
    @ref list_type "list" or @ref nothing

    @par Example
    @code
foreach my string $key in (keys $hash)
    printf("%s = %s\n", $key, $hash.$key);
    @endcode

    <b>Arguments Processed by keys</b>
    |!Argument|!Processing
    |\a hash_expression|Returns a list of strings giving the keys in \a hash_expression, which must evaluate to a hash. If not, then no value is returned.

    This operator does not throw any exceptions.

    <hr>
    @subsection multiplication_operator Multiply Operator (*)

    @par Synopsis
    Multiplies two arguments.

    @par Syntax
    \a expression1 <tt>*</tt> \a expression2

    @par Return Type
    @ref int_type "int" or @ref float_type "float"

    @par Example
    @code $value = $x * $y;@endcode

    <b>Arguments Processed by * (in order of precedence)</b>
    |!Argument|!Processing
    |@ref float_type "float"|Gives the result of multiplying its arguments; if either of the arguments is a @ref float "float" then the result is also a @ref float "float"
    |@ref int_type "int"|Gives the result of multiplying its arguments
    |any other type|Converts argument to a float and performs the multiplication

    This operator does not throw any exceptions.

    <hr>
    @subsection division_operator Divide Operator (/)

    @par Synopsis
    Divides a number by another.

    @par Syntax
    \a expression1 <tt>/</tt> \a expression2

    @par Return Type
    @ref int_type "int" or @ref float_type "float"

    @par Example
    @code $value = $x / $y;@endcode

    <b>Arguments Processed by / (in order of precedence)</b>
    |!Argument|!Processing
    |@ref float_type "float"|Gives the result of dividing its arguments; if either of the arguments is a @ref float "float" then the result is also a @ref float "float"
    |@ref int_type "int"|Gives the result of dividing its arguments
    |any other type|Converts argument to a float and performs the division

    @throw DIVISION-BY-ZERO division by zero error

    <hr>
    @subsection modula_operator Modula Operator (%)

    @par Synopsis
    Gives the integer remainder after division of one number by another.

    @par Syntax
    \a expression1 <tt>%</tt> \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $mod = $x % $y;@endcode

    <b>Arguments Processed by %</b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives \a expression1 modula \a expression2 (ex: <tt>12 % 10</tt> result in \c 2). Arguments are converted to integers if necessary.

    This operator does not throw any exceptions.

    <hr>
    @subsection plus_operator Plus (Addition and Concatentation) Operator (+)

    @par Synopsis
    Numeric addition, list, string, binary, and hash concatenation operator.

    @par Syntax
    \a expression1 <tt>+</tt> \a expression2

    @par Return Type
    @ref int_type "int", @ref float_type "float", @ref date_type "date", @ref list_type "list", @ref string_type "string", @ref binary_type "binary", or @ref hash_type "hash"

    @par Example
    @code $a = 1 + 2;@endcode
    @code $string = "hello" + "-there";@endcode
    @code $list = (1, 2) + ("three", "four", "five");@endcode
    @code $hash = ( "key1" : 1, "key2" : 2) + ( "key3" : "three", "key4": "four");@endcode
    @code $bin = $bin1 + $bin2;@endcode

    <b>Arguments Processed by + (in order of precedence)</b>
    |!Argument|!Processing
    |@ref list_type list|Gives the result of concatenating its arguments, i.e. <tt>(1, 2) + (3, 4) = (1, 2, 3, 4)</tt>
    |@ref string_type "string"|Gives the result of concatenating its arguments
    |@ref date_type "date"|Gives the result of adding date/time values (see @ref date_time_arithmetic)
    |@ref float_type "float"|Gives the result of adding its arguments
    |@ref int_type "int"|Gives the result of adding its arguments
    |@ref hash_type "hash"|Gives the result of concatenating/merging its arguments. Any common keys will be overwritten by the values in the second hash (\a expression2)

    This operator does not throw any exceptions.

    <hr>
    @subsection minus_operator Minus Operator (-)

    @par Synopsis
    With float or integer arguments, subtracts one number from another.\n\n
    With date arguments, subtracts one date from another; if both date arguments are absolute dates, the result is a relative date (duration) giving the time between them; if the first date argument is an absolute date and the second is a relative date (duration), then the result is an absolute date. If both date arguments are relative dates, then the result is a relative date. If the first argument is a relative date and the second date is an absolute date, the result is an absolute date as if the operands were reversed.\n\n
    However, if the left-hand side is a hash, and the right-hand side is a string, then the hash key represented by the string will be removed from the hash. If the left-hand side is a hash and the right-hand side is a list, then each element in the list will be converted to a string and any hash key with that name will be deleted from the hash.

    @par Syntax
    \a expression1 <tt>-</tt> \a expression2

    @par Return Type
    @ref int_type "int", @ref float_type "float", @ref date_type "date", or @ref hash_type "hash"

    @par Example
    @code $num = $x - $y;@endcode
    @code $date = 2010-05-13 - P3MT14H10M;@endcode
    @code $hash = $hash - "key";@endcode
    @code $hash = $hash - ("key1", "key2", "key3");@endcode

    <b>Arguments Processed by - (in order of precedence)</b>
    |!Argument|!Processing
    |@ref date_type "date"|date subtraction: \a expression1 - \a expression2
    |@ref float_type "float"|arithmetic subtraction: \a expression1 - \a expression2
    |@ref int_type "int"|arithmetic subtraction: \a expression1 - \a expression2
    |@ref hash_type "hash" - @ref string_type "string"|hash key deletion: \a expression1 - \a expression2
    |@ref hash_type "hash" - @ref list_type "list"|hash key deletion: \a expression1 - \a expression2; all elements of the list are converted to strings (if necessary) and any keys with those names are deleted from the hash.

    This operator does not throw any exceptions.

    <hr>
    @subsection shift_right_operator Shift Right Operator (>>)

    @par Synopsis
    Shifts bits in an integer towards zero (divides an integer by a power of 2)

    @par Syntax
    \a expression1 <tt>\>\></tt> \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a = $x >> $y;@endcode

    <b>Arguments Processed by >></b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives the result of shifting \a expression1 right by \a expression2 bits. Arguments are converted to integers if necesssary.

    This operator does not throw any exceptions.

    <hr>
    @subsection shift_left_operator Shift Left Operator (<<)

    @par Synopsis
    Shifts bits in an integer towards infinity (multiplies an integer by a power of 2)

    @par Syntax
    \a expression1 <tt>\<\<</tt> \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a = $x << $y;@endcode

    <b>Arguments Processed by <<</b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives the result of shifting \a expression1 left by \a expression2 bits. Arguments are converted to integers if necessary.

    This operator does not throw any exceptions.

    <hr>
    @subsection instanceof Class Instance Operator (instanceof)

    @par Synopsis
    Tests if an expression is an instance of a given class or not.

    @par Syntax
    \a expression \c \b instanceof \a class_identifier

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($obj instanceof Qore::Mutex)
    print("object is Mutex\n");
    @endcode

    <b>Arguments Processed by instanceof</b>
    |!Argument|!Processing
    |\a expression|If expression is an instance of the named class, then the operator returns \c True, otherwise returns \c False. The operator will return \c True if the class is a base class, also even if it is privately inherited.

    This operator does not throw any exceptions.

    <hr>
    @subsection exists Exists Operator (exists)

    @par Synopsis
    Tests if an expression represents a value or not.

    @par Syntax
    \c \b exists \a expression

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if (exists $a)
    printf("a = $n\n", $a);
    @endcode

    <b>Arguments Processed by exists</b>
    |!Argument|!Processing
    |\a expression|If \a expression evaluates to a value, then the operator returns \c True, otherwise returns \c False.

    This operator does not throw any exceptions.

    <hr>
    @subsection logical_less_than_operator Less Than Operator (<)

    @par Synopsis
    Tests if a value is less than another; types are converted if necessary (ex: <tt>("1" < 2)</tt> is \c True).

    @par Syntax
    \a expression1 < \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x < $y)
    printf("%n is less than %n\n", $x, $y);
    @endcode

    <b>Arguments Processed by < (in order of precedence)</b>
    |!Argument|!Processing
    |@ref float_type "float"|If \a expression1 is numerically less than \a expression2, returns \c True, otherwise returns \c False
    |@ref int_type "int"|If \a expression1 is numerically less than \a expression2, returns \c True, otherwise returns \c False
    |@ref string_type "string"|If \a expression1 comes before \a expression2 in string sort order, returns \c True, otherwise returns \c False
    |@ref date_type "date"|If \a expression1 is before (or a shorter amount of time than of the arguments are @ref relative_dates) \a expression2, returns \c True, otherwise returns \c False

    This operator does not throw any exceptions.

    <hr>
    @subsection logical_greater_than_operator Greater Than Operator (>)

    @par Synopsis
    Tests if a value is greater than another; types are converted if necessary (ex: <tt>("2" > 1)</tt> is \c True).

    @par Syntax
    \a expression1 > \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x > $y)
    printf("%n is less than %n\n", $x, $y);
    @endcode

    <b>Arguments Processed by > (in order of precedence)</b>
    |!Argument|!Processing
    |@ref float_type "float"|If \a expression1 is numerically greater than \a expression2, returns \c True, otherwise returns \c False
    |@ref int_type "int"|If \a expression1 is numerically greater than \a expression2, returns \c True, otherwise returns \c False
    |@ref string_type "string"|If \a expression1 comes after \a expression2 in string sort order, returns \c True, otherwise returns \c False
    |@ref date_type "date"|If \a expression1 is after \a expression2, returns \c True, otherwise returns \c False

    This operator does not throw any exceptions.

    <hr>
    @subsection logical_equality_operator Equals Operator (==)

    @par Synopsis
    Tests if a value is equal to another; types are converted if necessary (ex: <tt>("1" == 1)</tt> is \c True). For absolute equals, where types must also be equal to return true, see the @ref logical_absolute_equality_operator.

    @par Syntax
    \a expression1 == \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x == $y)
    printf("%n is equal to %n\n", $x, $y);
    @endcode

    <b>Arguments Processed by == (in order of precedence)</b>
    |!Argument|!Processing
    |@ref string_type "string"|If \a expression1 is equal to \a expression2, returns \c True, otherwise \c False
    |@ref float_type "float"|If \a expression1 is equal to \a expression2, returns \c True, otherwise \c False
    |@ref int_type "int"|If \a expression1 is equal to \a expression2, returns \c True, otherwise \c False
    |@ref date_type "date"|If \a expression1 is equal to \a expression2, returns \c True, otherwise \c False
    |@ref list_type "list"|If each element in the each list where order is relevant satisfies this operator, the operator returns \c True, otherwise it returns \c False
    |@ref hash_type "hash"|If each hash has the same keys and the value of each equal key in each hash satisfies this operator, the operator returns \c True, otherwise it returns \c False
    |@ref binary_type "binary"|If \a expression1's memory contents and size are equal to \a expression2's, then returns \c True, otherwise \c False
    |@ref object_type "object"|If \a expression1 is a reference to the same object as \a expression2, then returns \c True, otherwise \c False
    |@ref null|If both expressions are @ref null, returns \c True, otherwise returns \c False
    |@ref nothing|If neither expression has a value, returns \c True, otherwise returns \c False

    This operator does not throw any exceptions.

    <hr>
    @subsection logical_inequality_operator Not Equals Operator (!=)

    @par Synopsis
    Tests if a value is not equal to another; types are converted if necessary (ex: <tt>("1" != 1)</tt> is \c False).

    @par Syntax
    \a expression1 != \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x != $y)
    printf("%n is not equal to %n\n", $x, $y);
    @endcode

    <b>Arguments Processed by != (in order of precedence)</b>
    |!Argument|!Processing
    |@ref string_type "string"|If \a expression1 is not equal to \a expression2, returns \c True, otherwise \c False
    |@ref float_type "float"|If \a expression1 is not equal to \a expression2, returns \c True, otherwise \c False
    |@ref int_type "int"|If \a expression1 is not equal to \a expression2, returns \c True, otherwise \c False
    |@ref date_type "date"|If \a expression1 is not equal to \a expression2, returns \c True, otherwise \c False
    |@ref list_type "list"|If each element in the each list where order is relevant satisfies this operator, the operator returns \c True, otherwise it returns \c False
    |@ref hash_type "hash"|If the hashes have different keys or the value of each equal key in each hash satisfies this operator, the operator returns \c True, otherwise it returns \c False
    |@ref binary_type "binary"|If \a expression1's memory contents or size are not equal to \a expression2's, then returns \c True, otherwise \c False
    |@ref object_type "object"|If \a expression1 is not a reference to the same object as \a expression2, then returns \c True, otherwise \c False
    |@ref null|If either expressions is not @ref null, returns \c True, otherwise returns \c False
    |@ref nothing|If one of the expressions has a value, returns \c True, otherwise returns \c False

    This operator does not throw any exceptions.

    <hr>
    @subsection logical_less_than_or_equals_operator Less Than Or Equals Operator (<=)

    @par Synopsis
    Tests if a value is less than or equals to another value; types are converted if necessary (ex: <tt>("1" <= 2)</tt> is \c True).

    @par Syntax
    \a expression1 <= \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x <= $y)
    printf("%n is less than or equal to %n\n", $x, $y);
    @endcode

    <b>Arguments Processed by <= (in order of precedence)</b>
    |!Argument|!Processing
    |@ref float_type "float"|If \a expression1 is numerically less than or equal to \a expression2, returns \c True, otherwise returns \c False
    |@ref int_type "int"|If \a expression1 is numerically less than or equal to \a expression2, returns \c True, otherwise returns \c False
    |@ref string_type "string"|If \a expression1 comes before in string sort order or is the same as \a expression2, returns \c True, otherwise returns \c False
    |@ref date_type "date"|If \a expression1 is before or is the same exact date and time as \a expression2, returns \c True, otherwise returns \c False

    This operator does not throw any exceptions.

    <hr>
    @subsection logical_greater_than_or_equals_operator Greater Than Or Equals Operator (>=)

    @par Synopsis
    Tests if a value is greater than or equals to another value; types are converted if necessary (ex: <tt>("2" >= 1)</tt> is \c True).

    @par Syntax
    \a expression1 >= \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x >= $y)
    printf("%n is greater than or equal to %n\n", $x, $y);
    @endcode

    <b>Arguments Processed by >= (in order of precedence)</b>
    |!Argument|!Processing
    |@ref float_type "float"|If \a expression1 is numerically greater than or equal to \a expression2, returns \c True, otherwise returns \c False
    |@ref int_type "int"|If \a expression1 is numerically greater than or equal to \a expression2, returns \c True, otherwise returns \c False
    |@ref string_type "string"|If \a expression1 comes after in string sort order or is the same as \a expression2, returns \c True, otherwise returns \c False
    |@ref date_type "date"|If \a expression1 is after or is the same exact date and time as \a expression2, returns \c True, otherwise returns \c False

    This operator does not throw any exceptions.

    <hr>
    @subsection logical_comparison_operator Comparison (<=>) Operator

    @par Synopsis
    Tests if the left-hand value is less than, equal, or greater than the right-hand value; types are converted if necessary (ex: ("1" <=> 2) returns -1).

    @par Syntax
    \a expression1 <=> \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code
switch ($x <=> $y) {
    case -1: 
        print("$x is less than $y\n");
        break;

    case 0: 
        print("$x is equal to $y\n");
        break;

    case 1: 
        print("$x is greater than $y\n");
        break;
}
    @endcode

    <b>Arguments Processed by <=> (in order of precedence)</b>
    |!Argument|!Processing
    |@ref string_type "string"|If \a expression1 comes after in string sort order as \a expression2, returns \c 1, otherwise if they are equal, returns \c 0, otherwise if \a expression1 comes before \a expression2, returns \c -1
    |@ref float_type "float"|If \a expression1 is numerically greater than \a expression2, returns \c 1, otherwise if they are equal returns \c 0, otherwise returns \c -1
    |@ref int_type "int"|If \a expression1 is numerically greater than \a expression2, returns \c 1, otherwise if they are equal returns \c 0, otherwise returns \c -1
    |@ref date_type "date"|If \a expression1 is after \a expression2, returns \c 1, otherwise if they are equal returns \c 0, otherwise returns \c -1

    This operator does not throw any exceptions.

    <hr>
    @subsection logical_absolute_equality_operator Absolute Equals Operator (===)

    @par Synopsis
    Checks two values for equality without doing any data type conversions; if the types do not match, then the result is \c False.

    @par Syntax
    \a expression1 === \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x === $y)
    printf("%n is equal to %n and has the same data type as well\n", $x, $y);
    @endcode

    <b>Arguments Processed by ===</b>
    |!Argument|!Processing
    |All|This operator returns \c True only if the types and values of both sides of the operator are exactly equal, otherwise returns \c False. No type conversions are done.

    This operator does not throw any exceptions.

    <hr>
    @subsection logical_absolute_inequality_operator Absolute Not Equals Operator (!==)

    @par Synopsis
    Checks two values for inequality without doing any data type conversions. If the data types do not match, then returns \c True.

    @par Syntax
    \a expression1 !== \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x !== $y)
    printf("%n is not equal to %n and may not have the data type as well\n", $x, $y);
    @endcode

    <b>Arguments Processed by !==</b>
    |!Argument|!Processing
    |All|This operator returns \c True if either the types or the values of the arguments are different, otherwise it retuns \c False. No type conversions are done.

    This operator does not throw any exceptions.

    <hr>
    @subsection regex_match_operator Regular Expression Match Operator (=~)

    @par Synopsis
    Checks for a regular expression match; returns \c True if the expression matches the string, \c False if not. See @ref regex_options for the meaning of the \c i, \c s, \c x, and \c m options after the regular expression.\n\n
    See @ref regular_expressions for more information about regular expression support in %Qore.

    @par Syntax
    \a expression <tt>=~ [m]/</tt><em>regex</em><tt>/[isxm]</tt>

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($str =~ /hello/)
    printf("%s contains 'hello'\n", $str);
    @endcode

    <b>Arguments Processed by =~</b>
    |!Argument|!Processing
    |@ref string_type "string"|This operator returns \c True if the regular expression in \a regex matches the string in \a expression.

    This operator does not throw any exceptions.

    <hr>
    @subsection regex_no_match_operator Regular Expression No Match Operator (!~)

    @par Synopsis
    Checks for a regular expression non match; returns \c True if the expression does not match the string, \c False if it does. See @ref regex_options for the meaning of the \c i, \c s, \c x, and \c m options after the regular expression.\n\n
    See @ref regular_expressions for more information about regular expression support in %Qore.

    @par Syntax
    \a expression <tt>!~ [m]/</tt><em>regex</em><tt>/[isxm]</tt>

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($str !~ /hello/)
    printf("%s does not contain 'hello'\n", $str);
    @endcode

    <b>Arguments Processed by !~</b>
    |!Argument|!Processing
    |@ref string_type "string"|This operator returns \c True if the regular expression in \a regex does not match the string in \a expression.

    This operator does not throw any exceptions.

    <hr>
    @subsection regex_subst_operator Regular Expression Substitution Operator

    @par Synopsis
    Looks for a regular expression match in a string, and, if found, substitutes the matched string with a new string. Subpattern backreferences are supported in the target string, <tt>$1</tt>=first subpattern, <tt>$2</tt>=second subpattern, etc... See @regex_options for the meaning of the \c i, \c s, \c x, and \c m options after the regular expression.\n\n
    See @ref regular_expressions for more information about regular expression support in %Qore.

    @par Syntax
    \a lvalue <tt>=~ s/</tt><em>regex_pattern</em><tt>/</tt><em>target_string</em><tt>/[isxmg]</tt>

    @par Return Type
    @ref string_type "string" or @ref nothing (if the lvalue does not hold a string)

    @par Example
    @code
$str =~ s/hello/goodbye/i;
$str =~ s/(\w+) +(\w+)/$2, $1/;
    @endcode

    <b>Arguments Processed by =~ s///</b>
    |!Argument|!Processing
    |@ref string_type "string"|This operator substitutes text in the \a lvalue string if the regular expression matches. Subpattern backreferences are supported in \a target_string, <tt>$1</tt>=first subpattern, <tt>$2</tt>=second subpattern, etc..

    This operator does not throw any exceptions.

    <hr>
    @subsection regex_extract_operator Regular Expression Pattern Extraction Operator

    @par Synopsis
    Matches regular expression patterns (enclosed in parentheses) in a string and returns a list giving the text matched for each pattern. If the regular expression does not match, then no value (@ref nothing) is returned. See @regex_options for the meaning of the \c i, \c s, \c x, and \c m options after the regular expression.\n\n
    See @ref regular_expressions for more information about regular expression support in %Qore.

    @par Syntax
    \a string <tt>=~ x/</tt><em>regex_with_patterns</em><tt>/[isxm]</tt>

    @par Return Type
    @ref list_type "list" or @ref nothing (if the lvalue does not hold a string or if the pattern is not matched)

    @par Example
    @code
$list =~ x/(\w+):(\w+)/;
$list =~ x/(.*)\.(.*)/;
    @endcode

    <b>Arguments Processed by =~ x//</b>
    |!Argument|!Processing
    |@ref string_type "string"|This operator extracts strings from \a string based on patterns enclosed in parentheses in the regular expression.

    This operator does not throw any exceptions.

    <hr>
    @subsection transliteration_operator Transliteration Operator

    @par Synopsis
    Makes character substitutions in an lvalue; character ranges can also be used.

    @par Syntax
    \a lvalue <tt>=~ tr/</tt><em>source_chars</em><tt>/</tt><em>target_chars</em><tt>/</tt>

    @par Return Type
    @ref string_type "string" or @ref nothing (if the lvalue does not hold a string)

    @par Example
    @code $str =~ tr/a-z/A-Z/;@endcode

    <b>Arguments Processed by =~ tr//</b>
    |!Argument|!Processing
    |@ref string_type "string"|This operator substitutes characters in the \a lvalue string. Note that if there are more characters in \a source_chars than in \a target_chars, then the last character in \a target_chars will be used for any source matches where the source character position is greater than the length of \a target_chars.

    This operator does not throw any exceptions.

    <hr>
    @subsection bitwise_and_operator Bitwise/Binary And Operator (&)

    @par Synopsis
    Performs a bitwise (binary) AND operation on two integers.

    @par Syntax
    \a expression1 & \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a = $x & $y;@endcode

    <b>Arguments Processed by &</b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives the result of the binary (bitwise) AND operation between \a expression1 and \a expression2 (ex: <tt>0xffb2 & 0xa1 = 0xa1</tt>); operands are converted to integers if necessary.

    This operator does not throw any exceptions.

    <hr> 
    @subsection bitwise_or_operator Bitwise/Binary Or Operator (|)

    @par Synopsis
    Performs a bitwise (binary) OR operation on two integers.

    @par Syntax
    \a expression1 | \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a = $x | $y;@endcode

    <b>Arguments Processed by |</b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives the result of the binary (bitwise) OR operation between \a expression1 and \a expression2 (ex: <tt>0xb001 | 0xfea = 0xbfeb</tt>); operands are converted to integers if necessary

    This operator does not throw any exceptions.

    <hr>
    @subsection bitwise_xor_operator Bitwise/Binary Xor Operator (^)

    @par Synopsis
    Performs a bitwise (binary) XOR operation on two integers.

    @par Syntax
    \a expression1 ^ \a expression2

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a = $x ^ $y;@endcode

    <b>Arguments Processed by ^</b>
    |!Argument|!Processing
    |@ref int_type "int"|Gives the result of the binary (bitwise) EXCLUSIVE OR operation between \a expression1 and \a expression2 (ex: <tt>0xaef1 & 0xfb32 = 0x55c3</tt>); operands are converted to integers if necessary

    This operator does not throw any exceptions.

    <hr>
    @subsection logical_and_operator Logical And Operator (&&)

    @par Synopsis
    Checks to see if two expressions are \c True with logical short-circuiting.

    @par Syntax
    \a expression1 && \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x && $y)
    printf("%n and %n are both True\n", $x, $y);
    @endcode

    <b>Arguments Processed by &&</b>
    |!Argument|!Processing
    |@ref bool_type "bool"|Returns \c True if both expressions are \c True, \c False if otherwise. Logical short-circuiting is implemented; if \a expression1 is \c False, then \a expression2 is not evaluated, and the operator returns \c False.

    This operator does not throw any exceptions.

    <hr>
    @subsection logical_or_operator Logical Or Operator (||)

    @par Synopsis
    Returns \c True if either of the arguments are \c True with logical short-circuiting.

    @par Syntax
    \a expression1 || \a expression2

    @par Return Type
    @ref bool_type "bool"

    @par Example
    @code
if ($x || $y)
    printf("either %n or %n or both are True\n", $x, $y);
    @endcode

    <b>Arguments Processed by ||</b>
    |!Argument|!Processing
    |@ref bool_type "bool"|Returns \c True if either or both expressions evaluate to \c True, \c False if otherwise. Logical short-circuiting is implemented; if \a expression1 is \c True, then \a expression2 is not evaluated, and the operator returns \c True.

    This operator does not throw any exceptions.

    <hr>
    @subsection conditional_operator Conditional Operator (? :)

    @par Synopsis
    Evaluates and returns the value of one of two expressions depending on the value of a conditional expression.

    @par Syntax
    \a expression ? \a if_true_expression : \a if_false_expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code $a = ($z > 100 ? "Big" : "Small");@endcode

    <b>Arguments Processed by ? :</b>
    |!Argument|!Processing
    |All|If \a expression is evaluated to be \c True, then the \a if_true_expression is evaluated and returned. Otherwise the \a if_false_expression is evaluated and returned.

    This operator does not throw any exceptions.

    <hr>
    @subsection comma_operator Comma Operator (,)

    @par Synopsis
    Makes a list from more than one element.

    @par Syntax
    \a expression1, \a expression2

    @par Return Type
    @ref list_type "list"

    @par Example
    @code $a = 1, 2, "three";@endcode

    <b>Arguments Processed by ,</b>
    |!Argument|!Processing
    |All|The comma operator builds lists of arguments

    This operator does not throw any exceptions.

    <hr>
    @subsection unshift Unshift Operator (unshift)

    @par Synopsis
    Inserts an element into the first position of a list and moves all other elements up one position.

    @par Syntax
    \c \b unshift \a lvalue, \a expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code unshift $list, "one";@endcode

    <b>Arguments Processed by unshift</b>
    |!Argument|!Processing
    |All|Inserts the value of \a expression as the first element in the list given by \a lvalue. All other elements in the list are moved forward.

    <hr>
    @subsection push Push Operator (push)

    @par Synopsis
    Adds one element to the end of a list and returns the list processed (or @ref nothing if the \a lvalue is not a list).

    @par Syntax
    \c \b push \a lvalue, \a expression

    @par Return Type
    @ref list_type "list" or @ref nothing (if the lvalue is not a list)

    @par Example
    @code push $list, "last";@endcode

    <b>Arguments Processed by push</b>
    |!Argument|!Processing
    |All|Appends the value of the \a expression as the last element in the list given by \a lvalue. If \a expression evaluates to a list, this list will be appended as the last element of \a lvalue. To concatenate lists, use the @ref plus_operator "plus operator".

    <hr>
    @subsection splice Splice Operator (splice)

    @par Synopsis
    Removes and optionally inserts elements in lists and strings and returns the lvalue after processing. For a similar operator that returns the values removed, see the @ref extract "extract operator".\n\n
    Works on either strings or lists in a similar way; removes elements from a list or characters from a string and optionally inserts new ones. If no \a length_expression is given, splice removes all elements/characters from the list or string starting at \a offset_expression (list and string offsets begin at 0). Otherwise, a number of elements/characters equal to \a length_expression is removed (or up to the end of the list/string if applicable). If \a substitution_expression is present, then the removed elements/characters are substituted with the elements/string given by this expression.\n\n
    Note that string splice takes character offsets, which may not be the same as byte offsets for multi-byte character encodings, such as \c UTF-8

    @par Syntax
    \c \b splice \a lvalue, \a offset_expression<em>, [length_expression, [substitution_expression]]</em>

    @par Return Type
    @ref list_type "list" or @ref string_type "string" (returns \a lvalue after processing)

    @par Example
    @code splice $list, 2, 2;@endcode
    @code splice $string, 2, 2, "-text-";@endcode

    <b>Arguments Processed by splice</b>
    |!Argument|!Processing
    |\a lvalue (@ref list_type "list" or @ref string_type "string")|If the lvalue is a list, list elements are processed, otherwise, if it is a string, characters in the string are processed. For any other data type, no action is taken.
    |\a offset_expression|The start element/character position for removing elements/characters from the list or string.
    |\a length_expression|The number of elements/characters to remove. If this expression is not present, then all elements/characters from the offset to the end of the list/string are removed. If this expression is present and evaluates to 0, no characters/elements are removed.
    |\a substitution_expression|For list splice, an optional element or list to substitute for the removed elements (to insert a list in a single element's position, make sure that the list to be inserted is the first and only element of another list used as the argument in this position; in other words, pass a list within a single-element list). For string splice, an optional string to substitute for the removed characters.

    <hr>
    @subsection extract Extract Operator (extract)

    @par Synopsis
    Removes and optionally inserts elements in lists and strings. For a similar operator that removes values from an lvalue and returns the lvalue (instead of the value removed), see the @ref splice "splice operator".\n\n
    Works on either strings or lists in a similar way; removes elements from a list or characters from a string and optionally inserts new ones. If no length_expression is given, extract removes all elements/characters from the list or string starting at \a offset_expression (list and string offsets begin at 0). Otherwise, a number of elements/characters equal to \a length_expression is removed (or up to the end of the list/string if applicable). If \a substitution_expression is present, then the removed elements/characters are substituted with the elements/string given by this expression.\n\n
    When operating on lists, a list is returned of any elements extracted (if no elements are extracted, then an empty list is returned); when operating on strings, a string is extracted of all characters extracted from the string (if no characters are extracted, then an empty string is returned).\n\n
    Note that string extract takes character offsets, which may not be the same as byte offsets for multi-byte character encodings, such as \c UTF-8

    @par Syntax
    \c \b extract \a lvalue, \a offset_expression<em>, [length_expression, [substitution_expression]]</em>

    @par Return Type
    @ref list_type "list" or @ref string_type "string" (the value(s) removed from \a lvalue)

    @par Example
    @code my list $sublist = extract $list, 2, 2;@endcode
    @code my string $substring = extract $string, 2, 2, "-text-";@endcode

    <b>Arguments Processed by extract</b>
    |!Argument|!Processing
    |\a lvalue (@ref list_type "list" or @ref string_type "string")|If the lvalue is a list, list elements are processed, otherwise, if it is a string, characters in the string are processed. For any other data type, no action is taken.
    |\a offset_expression|The start element/character position for removing elements/characters from the list or string.
    |\a length_expression|The number of elements/characters to remove. If this expression is not present, then all elements/characters from the offset to the end of the list/string are removed. If this expression is present and evaluates to 0, no characters/elements are removed.
    |\a substitution_expression|For list splice, an optional element or list to substitute for the removed elements (to insert a list in a single element's position, make sure that the list to be inserted is the first and only element of another list used as the argument in this position; in other words, pass a list within a single-element list). For string splice, an optional string to substitute for the removed characters.

    <hr>
    @subsection assignment_operator Assignment Operator (=)

    @par Synopsis
    Assigns a value to an lvalue and returns the value assigned.

    @par Syntax
    \a lvalue <tt>=</tt> \a expression

    @par Return Type
    @ref any_type "any"

    @par Example
    @code $a = 1;@endcode

    <b>Arguments Processed by =</b>
    |!Argument|!Processing
    |All|Assigns the value of \a expression to \a lvalue

    <hr>
    @subsection plus_equals_operator Plus Equals Operator (+=)

    @par Synopsis
    Increments and concatentates an lvalue with the value of an expression depending on the data type of the lvalue, unless the lvalue is @ref nothing, in which case this operator acts like the assignment operator (simply assigns the value of the right hand side to the lvalue).

    @par Syntax
    \a lvalue <tt>+=</tt> \a expression

    @par Return Type
    @ref int_type "int", @ref float_type "float", @ref date_type "date", @ref list_type "list", @ref string_type "string", @ref binary_type "binary", @ref hash_type "hash", or @ref object_type "object"

    @par Example
    @code $a += 10;@endcode
    @code $date += P1M2DT45M;@endcode
    @code $list += $new_element;@endcode
    @code $string += ".foo";@endcode
    @code $binary += <0c67a374>@endcode
    @code $hash += ("new-key" : 1, "other" : "two");@endcode
    @code $object += $hash;@endcode

    <b>Arguments Processed by +=</b>
    |!Argument|!Processing
    |\a lvalue (@ref list_type "list")|
the expression will be evaluated and concatenated to the lvalue. If \a expression is a list, the lists will be concatenated, to ensure adding a single element to a list, use the @push "push operator"
    |\a lvalue (@ref hash_type "hash" or (@ref object_type "object")|the \a expression will be evaluated, and, if it is a hash or object, then it's members will be added to the \a lvalue, any duplicate elements in the \a lvalue will be overridden by elements in the \a expression.
    |\a lvalue (@ref string_type "string")|the \a expression will be evaluated and converted to a string if necessary and concatenated to the \a lvalue.
    |\a lvalue (@ref float_type "float")|the \a expression will be evaluated and converted to a float if necessary and added to the \a lvalue.
    |\a lvalue (@ref binary_type "binary")|the \a expression will be evaluated and converted to a binary if necessary and added to the \a lvalue.
    |\a lvalue (@ref date_type "date")|the \a expression will be evaluated and converted to a date if necessary and added to the \a lvalue.
    |\a lvalue (@ref nothing)|the \a lvalue will be assigned to the value of \a expression.
    |\a lvalue (all other types)|the \a lvalue's type will be converted to an integer, and the \a expression will be evaluated and converted to an integer if necessary, and then the result will be added to the \a lvalue.

    <hr>
    @subsection minus_equals_operator Minus Equals Operator (-=)

    @par Synopsis
    For a float or integer argument, decrements the value of an \a lvalue by the value of an \a expression. However if the \a lvalue is a hash or object and the \a expression is a string, removes the key represented by the string from the hash or object.

    @par Syntax
    \a lvalue <tt>-=</tt> \a expression

    @par Return Type
    @ref int_type "int", @ref float_type "float", @ref date_type "date", @ref hash_type "hash", or @ref object_type "object"

    @par Example
    @code $a -= 10;@endcode
    @code $date -= PT45H213S;@endcode
    @code $hash -= "key";@endcode
    @code $hash -= ("key1", "key2");@endcode
    @code $object -= "key";@endcode
    @code $object -= $list_of_keys;@endcode

    <b>Arguments Processed by -=</b>
    |!Argument|!Processing
    |\a lvalue (@ref float_type "float")|the \a expression will be evaluated and converted to a float if necessary and subtracted from the \a lvalue
    |\a lvalue (@ref date_type "date")|the \a expression will be evaluated and converted to a date if necessary and subtracted from the \a lvalue
    |\a lvalue (@ref hash_type "hash" or (@ref object_type "object"), \a expression (@ref string_type "string")|the hash key represented by \a expression will be removed from the \a lvalue
    |\a lvalue (@ref hash_type "hash" or (@ref object_type "object"), \a expression (@ref list_type "list")|each element in the list will be converted to a string (if necessary) and the key represented by each string will be removed from the hash or object
    |\a lvalue (@ref nothing), \a expression (any type)|the \a expression will be assigned to \a lvalue
    |\a lvalue (all other types)|the \a lvalue's type will be converted to an integer (if necessary), and the \a expression will be evaluated and converted to an integer (if necessary), and then the result will be subtracted from the \a lvalue

    <hr>
    @subsection and_equals_operator And Equals Operator (&=)

    @par Synopsis
    Performs a bitwise (binary) AND operation on an \a lvalue using the value of an \a expression and returns the new value.

    @par Syntax
    \a lvalue <tt>&=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a &= 0xfe;@endcode

    <b>Arguments Processed by &=</b>
    |!Argument|!Processing
    |All|the \a lvalue's type will be converted to an integer if necessary, and the \a expression will be evaluated and converted to an integer as well if necessary, and then the result will be binary and'ed to the lvalue

    <hr>
    @subsection or_equals_operator Or Equals Operator (|=)

    @par Synopsis
    Performs a bitwise (binary) OR operation on an \a lvalue using the value of an \a expression and returns the new value.

    @par Syntax
    \a lvalue <tt>|=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a |= 0xba;@endcode

    <b>Arguments Processed by |=</b>
    |!Argument|!Processing
    |All|the \a lvalue's type will be converted to an integer if necessary, and the \a expression will be evaluated and converted to an integer as well if necessary, and then the result will be binary or'ed to the \a lvalue

    <hr>
    @subsection modula_equals_operator Modula Equals Operator (%=)

    @par Synopsis
    Performs a modula calculation on an lvalue using the value of an expression and returns the new value.

    @par Syntax
    \a lvalue <tt>%=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a %= 100;@endcode

    <b>Arguments Processed by %=</b>
    |!Argument|!Processing
    |All|the \a lvalue's type will be converted to an integer if necessary, and the \a expression will be evaluated and converted to an integer as well if necessary, and then the result will be used to divide the \a lvalue's value and the remainder will be saved to the \a lvalue

    <hr>
    @subsection multiply_equals_operator Multiply Equals Operator (*=)

    @par Synopsis
    Performs a multiplication operation on an lvalue using the value of an expression and returns the value assigned.

    @par Syntax
    \a lvalue <tt>*=</tt> \a expression

    @par Return Type
    @ref int_type "int" or @ref float_type "float"

    @par Example
    @code $a *= 10;@endcode

    <b>Arguments Processed by *=</b>
    |!Argument|!Processing
    |All|If either side of the operator is a float, the result will be a float as well. Otherwise the result is an integer value. The \a expression will be evaluated and multiplied by the \a lvalue, and the result will be saved to the \a lvalue.

    <hr>
    @subsection divide_equals_operator Divide Equals Operator (/=)

    @par Synopsis
    Performs a division operation on an lvalue using the value of an expression and returns the value assigned.

    @par Syntax
    \a lvalue <tt>/=</tt> \a expression

    @par Return Type
    @ref int_type "int" or @ref float_type "float"

    @par Example
    @code $a /= 10;@endcode

    <b>Arguments Processed by /=</b>
    |!Argument|!Processing
    |All|If either side of the operator is a float, the result will be a float as well. Otherwise the result is an integer value. The \a expression will be evaluated and used to divide the \a lvalue, and the result will be saved to the \a lvalue.

    @throw DIVISION-BY-ZERO If the divisor expression evaluates to zero, this exception is thrown

    <hr>
    @subsection xor_equals_operator Xor Equals Operator (^=)

    @par Synopsis
    Performs an exclusive-or operation on an lvalue using the value of an expression.

    @par Syntax
    \a lvalue <tt>^=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a ^= 0xf9034ba7;@endcode

    <b>Arguments Processed by ^=</b>
    |!Argument|!Processing
    |All|Values are converted to integers if necessary. The \a expression will be evaluated and exclusive-or'ed with the \a lvalue, and the result will be saved to the \a lvalue

    <hr>
    @subsection shift_left_equals_operator Shift Left Equals Operator (\<\<=)

    @par Synopsis
    Performs a shift-left operation on an lvalue using the value of an expression and returns the value assigned.

    @par Syntax
    \a lvalue <tt>\<\<=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example
    @code $a <<= 3;@endcode

    <b>Arguments Processed by \<\<=</b>
    |!Argument|!Processing
    |All|Values are converted to integers if necessary. The \a expression will be evaluated and this value will determine how many bits the \a lvalue will be shifted left. The result will be saved to the \a lvalue.

    <hr>
    @subsection shift_right_equals_operator Shift Right Equals Operator (\>\>=)

    @par Synopsis
    Performs a shift-right operation on an lvalue using the value of an expression and returns the value assigned.

    @par Syntax
    \a lvalue <tt>\>\>=</tt> \a expression

    @par Return Type
    @ref int_type "int"

    @par Example$
    @code $a >>= 3;@endcode

    <b>Arguments Processed by >>=</b>
    |!Argument|!Processing
    |All|Values are converted to integers if necessary. The \a expression will be evaluated and this value will determine how many bits the \a lvalue will be shifted right. The result will be saved to the \a lvalue.

    @section qore_regex Regular Expressions

    Regular expression functionality in %Qore is provided by <a href="http://www.pcre.org">PCRE: Perl-Compatible Regular Expression library</a>.

    Using this library, %Qore implements regular expression pattern matching using the same syntax and semantics as <a href="http://www.perl.org">Perl 5</a>.

    The following is a list of operators based on regular expressions (or similar to regular expressions in the case of the transliteration operator).

    <b>Regular Expression Operators</b>
    |!Operator|!Description
    |@ref regex_match_operator|Returns \c True if the regular expression matches a string
    |@ref regex_no_match_operator|Returns \c True if the regular expression does not match a string
    |@ref regex_subst_operator|Substitutes text in a string based on matching a regular expression
    |@ref regex_extract_operator|Returns a list of substrings in a string based on matching patterns defined by a regular expression
    |@ref transliteration_operator|Not a regular expression operator; transliterates one or more characters to other characters in a string

    See the table below for valid regular expression options.

    @anchor regex_options
    <b>Regular Expression Options</b>
    |!Option|!Description
    |\c i|Ignores case when matching
    |\c m|makes start-of-line (<tt>^</tt>) or end-of-line (<tt>$</tt>) match after or before any newline in the subject string
    |\c s|makes a dot (<tt>.</tt>) match a newline character
    |\c x|ignores whitespace characters and enables comments prefixed by <tt>#</tt>
    |\c g|makes global substitutions (only applicable with the substitution operator)

    The following is a list of functions providing regular expression functionality where the pattern may be given at run-time:

    <b>Regular Expression Functions</b>
    |!Function|!Description
    |regex()|Returns \c True if the regular expression matches a string
    |regex_subst()|Substitutes a pattern in a string based on regular expressions and returns the new string
    |regex_extract()|Returns a list of substrings in a string based on matching patterns defined by a regular expression

    @section date_time_arithmetic Date/Time Arithmetic

    Date/time arithmetic is relatively straightforward and should normally produce the expected results. However with leap years, months with different lengths, and daylights savings time the situation can be confusing; this section will clarify how %Qore does date arithmetic considering these special cases.

    @subsection date_time_arithmetic_adding_years_months Adding and Subtracting Years and Months

    Adding or subtracting years and months (ex: <tt>$date += 2Y + 3M</tt>) will give you the same day on the desired month in the desired year. If the target month has fewer days than the source month, then you will get the last day of the month in that year. For example:

    @verbatim
prompt% qore -X '2004-02-29Z - 1Y'
2003-02-28 00:00:00 Fri Z (UTC)@endverbatim

    @subsection date_time_arithmetic_days Adding and Subtracting Days

    Adding or subtracting days means adding or subtracting 24h periods; i.e. you will get the same time in the result of subtracting days, for example:

    @verbatim
prompt% qore -X '2004-02-29T10:15:00Z - 10D'
2004-02-19 10:15:00 Thu Z (UTC)@endverbatim

    @subsection date_time_arithmetic_difference Finding the Difference Between Two Dates

    Subtracting one @ref absolute_dates "absolute date" from another will result in a @ref relative_dates "relative date", normalized to the hour (that is, microseconds over 999,999 are converted to seconds, seconds over 59 to minutes, and minutes over 59 to hours; days, months, and years will not appear in the result as they do not indicate a fixed period of time but rather can vary in length depending on the absolute date/time starting point. For example:

    @verbatim
prompt% qore -X '2007-02-29T10:15:03.255Z - 2004-02-29T10:14:02.100Z'
<time: 26304 hours 1 minute 1 second 155 milliseconds>@endverbatim

    To find the difference in seconds between two dates, convert each date value to an integer and subtract as follows:

    @verbatim
prompt% qore -X 'int(2004-02-29Z) - int(2004-02-28Z)'
86400@endverbatim

    Or use the get_duration_seconds() function as follows:

    @verbatim
prompt% qore -X 'get_duration_seconds(2004-02-29Z - 2004-02-28Z)'
86400@endverbatim

    @subsection date_time_arithmetic_zones Timezones and Daylight Savings Time

    Time zones and daylight savings time information is supplied by the system's zoneinfo database (if any exists; see @ref time_zones for more information).

    To find out if the current time zone has daylight savings time, execute the following:

    @verbatim
prompt% qore -X 'TimeZone::get().hasDST()'
True@endverbatim

    See the Qore::TimeZone class for more information on time zone information.

    @subsection date_time_arithmetic_leap_years Leap Years and the Gregorian Calendar

    %Qore is capable of representing and performing calculations on dates before the adoption of the Gregorian calendar (proposed in 1582 and adopted at various times in Europe after this point). However all calculations are made as if the Gregorian calendar were always in effect (%Qore implements a <a href="http://en.wikipedia.org/wiki/Proleptic_Gregorian_calendar">proleptic Gregorian calendar</a>).

    @section statements Statements

    Non-block statements in %Qore are always terminated by a semi-colon \c ";" as in Perl, C, C++, or Java. Statements can be grouped into blocks, which are delimited by curly brackets \c "{" and \c "}" containing zero or more semi-colon delimited statements, as in C or Java. Like C, C++, and Java, but unlike perl, any %Qore statement taking a statement modifier will accept a single statement or a statement block.

    A statement can be any of the following (note that statements are also recursively defined):

    <b>%Qore Statements</b>
    |!Type|!Examples|!Reference
    |An expression that changes an lvalue|@code $var = 1;@endcode @code $var += 5;@endcode @code $var[1].count++;@endcode @code shift $var.key[$i];@endcode|@ref expressions
    |An expression with the @ref new "new operator"|@code new ObjectClass(1, 2, 3);@endcode|@ref new
    |An expression with the @ref background "background operator"|@code background function();@endcode|@ref background
    |A @ref call_reference "call reference" or @ref closure "closure" call|@code $call_reference($arg1, $arg2);@endcode|@ref call_reference, @ref closure
    |A @ref object_method_call "method call"|@code $object.method(1, 2, 3);@endcode|@ref classes
    |An @ref if "if statement"|@code if ($var == 3) {}@endcode|@ref if
    |An @ref if "if ... else" statement|@code if ($var == 3) {} else {}@endcode|@ref if
    |A @ref while "while statement"|@code while ($var < 10) {}@endcode|@ref while
    |A @ref do "do while statement"|@code do {} while (True);@endcode|@ref do
    |A @ref for "for statement"|@code for (my int $i = 0; $i < 10; ++ $i) {}@endcode|@ref for
    |A @ref foreach "foreach statement"|@code foreach my softint $i in ($list) {}@endcode|@ref foreach
    |A @ref switch "switch statement"|@code switch ($var) { case =~ /error/: throw "ERROR", $var; default: printf("%s\n", $var); }@endcode|@ref switch
    |A @ref return "return statement"|@code return $val;@endcode|@ref return
    |A @ref variable_declarations "local variable declaration"|@code my string $var;@endcode @code my (int $a, string $b, bool $c);@endcode|@ref variables, @ref variable_declarations
    |A @ref variable_declarations "global variable declaration"|@code our int $var;@endcode @code our (float $a, int $b, hash $c);@endcode|@ref variables, @ref variable_declarations
    |A @ref function_calls "function call"|@code calculate($this, $that, $the_other);@endcode|@ref function_library
    |A @ref continue "continue statement"|@code continue;@endcode|@ref continue
    |A @ref break "break statement"|@code break;@endcode|@ref break
    |A statement block|@code {}@endcode|zero or more statements enclosed in curly brackets
    |A @ref throw "throw statement"|@code throw "ERROR", $description;@endcode|@ref throw
    |A @ref try "try and catch statement"|@code try { func(); } catch (hash $ex) { printf("%s:%d: %s: %s\n", $ex.file, $ex.line, $ex.err, $ex.desc); }@endcode|@ref try
    |A @ref rethrow "rethrow statement"|@code rethrow;@endcode|@ref rethrow
    |A @ref thread_exit "thread_exit statement"|@code thread_exit;@endcode|@ref thread_exit
    |A @ref context "context statement"|@code context top ($q) {}@endcode|@ref context
    |A @ref summarize "summarize statement"|@code summarize ($q) by (%date) where (%id != NULL) {}@endcode|@ref summarize
    |A @ref subcontext "subcontext statement"|@code subcontext where (%type == "INBOUND" ) {}@endcode|@ref subcontext
    |An @ref on_exit "on_exit statement"|@code on_exit $l.unlock();@endcode|@ref on_exit
    |An @ref on_success "on_success statement"|@code on_success $ds.commit();@endcode|@ref on_success
    |An @ref on_error "on_error statement"|@code on_error $ds.rollback();@endcode|@ref on_error

    <hr>
    @subsection if if and else Statements

    @par Synopsis
    The \c \b if statement allows for conditional logic in a %Qore program's flow; the syntax is similar to that of C, C++, or Java.

    @par Syntax
    \b \c if <tt>(</tt><em>@ref expressions "expression"</em><tt>)</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement"</em>\n
    <tt>[\b else</tt> \n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement"</em><tt>]</tt>

    @par Description
    %Qore if statements work like if statements in C or Java. If the result of evaluating the expression converted to a @ref boolean value is \c True, then the first statement (which can also be a block) is executed. If the result is \c False, and there is an \c \b else keyword after the first statement, the following statement is executed.

    @note Any expression that evaluates to a non-zero integer value will be converted to a @ref boolean \c True. Any expression that evaluates to zero value is interpreted as \c False. This is more like C and Java's behavior and not like Perl's (where any non-null string except "0" is \c True).

    <hr>
    @subsection for for Statements

    @par Synopsis
    The %Qore \b \c for statement is most similar to the for statement in C and Java, or the non array iterator for statement in Perl. This statement is ideal for loops that should execute a given number of times, then complete. Each of the three expressions in the for statement is optional and may be omitted. To iterate through a list without directly referencing list index values, see the @ref foreach "foreach statement".

    @par Syntax
    \b \c for <tt>(</tt> <em>@ref expressions "[initial_expression]"</em><tt>;</tt> <em>@ref expressions "[test_expression]"</em><tt>;</tt> <em>@ref expressions "[iterator_expression]"</em>)\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement"</em>

    @par Description
    <em>@ref expressions "[initial_expression]"</em>\n
    The \a initial_expression is executed only once at the start of each for loop. It is typically used to initialize a loop variable.\n\n
    <em>@ref expressions "[test_expression]"</em>\n
    The \a test_expression is executed at the start of each for loop iteration. If this expression evaluates to @ref boolean \c False, the loop will terminate.\n\n
    <em>@ref expressions "[iterator_expression]"</em>\n
    The \a iterator_expression is executed at the end of each for loop iteration. It is typically used to increment or decrement a loop variable that will be used in the test_expression.

    @par Example
    Here is an example of a for loop using a local variable:\n
    @code 
for (my int $i = 0; $i < 10; $i++)
    print("%d\n", $i);@endcode

    <hr>
    @subsection foreach foreach Statements

    @par Synopsis
    The %Qore \b \c foreach statement is most similar to the for or foreach array iterator statement in Perl. To iterate an action until a condition is \c True, use the @ref for "for statement" instead.

    @par Syntax
    \c \b foreach <tt>[\b my|\b our] [</tt><em>@ref data_type_declarations "type"</em><tt>]</tt> $variable \b \c in <tt>(</tt><em>@ref expressions "expression"</em><tt>)</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement"</em>

    @par Description
    If \a expression does not evaluate to a list, then the variable will be assigned the value of the expression evaluation and the statement will only execute one time. Otherwise the variable will be assigned to each value of the list and the statement will be called once for each value.\n\n
    If \a expression evalutes to @ref nothing (no value); then the loop is not executed at all.

    @par Example
    Here is an example of a foreach loop using a local variable:\n
    @code
# if $str_list is a list of strings, this will remove all whitespace from the
# strings; the reference in the list expression ensures that changes
# to the iterator variable are written back to the list
foreach my string $str in (\$str_list)
    trim $str;@endcode

    @note If a reference (<tt>\\$lvalue_expression</tt>) is used as the list expression, any changes made to the \b \c foreach iterator variable will be written back to the list.

    <hr>
    @subsection switch switch Statements

    @par Synopsis
    The %Qore switch statement is similar to the switch statement in C and C++, except that the case values can be any expression that does not need run-time evaluation and can also be expressions with simple relational operators or regular expressions using the switch value as an implied operand.

    @par Syntax
    \b \c switch <tt>(</tt><em>@ref expressions "expression"</em><tt>) {</tt>\n 
    &nbsp;&nbsp;\b \c case <em>case_expression</em><tt>:</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "[statement(s)...]"</em>\n
    &nbsp;&nbsp;<tt>[\b default:</tt> \n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "[statement(s)...]"</em><tt>]</tt>\n
    <tt>}</tt>

    @par Example
    @code 
switch ($val) {
    case < -1: 
        printf("less than -1\n");
	break;
    case "string":
        printf("string\n");
	break;
    case > 2007-01-22T15:00:00: 
        printf("greater than 2007-01-22 15:00:00\n");
	break;
    case /abc/:
        printf("string with 'abc' somewhere inside\n");
	break;
    default:
        printf("default\n");
	break;
}@endcode

    @par Description
    The first \a expression is evaluated and then compared to the value of each \a case_expression in declaration order until one of the \a case_expressions matches or is evaluated to \c True. In this case all code up to a @ref break "break statement" is executed, at which time execution flow exits the \c \b switch statement.\n\n
    Unless relational operators are used, the comparisons are "hard" comparisons; no type conversions are done, so in order for a match to be made, both the value and types of the expressions must match exactly. When relational operators are used, the operators are executed exactly as they are in the rest of %Qore, so type conversions may be performed if nesessary.\n\n
    To use soft comparisons, you must explicitly specify the soft equals operator as follows:\n
    @code
switch (1) {
    case == "1": print("true\n"); break;
}@endcode \n
    If no match is found and a default label has been given, then any statements after the default label will be executed. If a match is made, then the statements following that case label are executed.\n\n
    To break out of the switch statement, use the @ref break "break statement".\n\n
    As with C and C++, if no @ref break "break" or @ref return "return" statement is encountered, program control will continue to execute through other \c \b case blocks until on of the previous statements is encountered or until the end of the \c \b switch statement.

    @anchor case_expressions
    <b>Valid Case Expression Operators</b>
    |!Operator|!Description
    |<tt>\></tt>|@ref logical_greater_than_operator
    |<tt>\>=</tt>|@ref logical_greater_than_or_equals_operator
    |<tt>\<</tt>|@ref logical_less_than_operator
    |<tt>\<=</tt>|@ref logical_less_than_or_equals_operator
    |<tt>==</tt>|@ref logical_equality_operator (with type conversions)
    |<tt>~=</tt>|@ref regex_match_operator (in this case the regular expression may be optionally given without the operator)
    |<tt>!~</tt>|@ref regex_no_match_operator

    <hr>
    @subsection while while Statements

    @par Synopsis
    \b \c while statements in %Qore are similar to while statements in Perl, C and Java. They are used to loop while a given condition is \c True.

    @par Syntax
    \b \c while <tt>(</tt><em>@ref expressions "expression"</em><tt>)</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement"</em>

    @par Description
First the expression will be evaluated; if it evaluates to \c True, then statement will be executed. If it evaluates to \c False, the loop terminates.

    @par Example
    @code 
my int $a = 1;
while ($a < 10)
    $a++;@endcode

    <hr>
    @subsection do do while Statements

    @par Synopsis
do while statements in %Qore are similar to do while statements in C. They are used to guarantee at least one iteration and loop until a given expression evaluates to \c False.

    @par Syntax
    <b><tt>do</tt></b>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement"</em> \n
    \b \c while <tt>(</tt><em>@ref expressions "expression"</em><tt>);</tt>

    @par Description
    First, the \a statement will be executed, then the \a expression will be evaluated; if it evaluates to \c True, then the loop iterates again. If it evaluates to \c False, the loop terminates.\n\n
    The difference between \c \b do \c \b while statements and @ref while "while statements" is that the \c \b do \c \bwhile statement evaluates its loop expression at the end of the loop, and therefore guarantees at least one iteration of the loop.

    @par Example
    @code 
$a = 1;
do 
    $a++;
while ($a < 10);@endcode

    <hr>
    @subsection continue continue Statements

    @par Synopsis
Skips the rest of a loop and jumps right to the evaluation of the iteration expression.

    @par Syntax
    \b \c continue;

    @par Description
    The \b \c continue statement affects loop processing; that is; it has an affect on @ref for "for", @ref foreach "foreach", @ref while "while", @ref do "do while", @ref context "context", @ref summarize "summarize", and @ref subcontext "subcontext" loop processing.\n\n
    When this statement is encountered while executing a loop, execution control jumps immediately to the evaluation of the iteration expression, skipping any other statements that might otherwise be executed.

    <hr>
    @subsection break break Statements

    @par Synopsis
    Exits immediately from a loop statement or @ref switch "switch" block.

    @par Syntax
    \b \c break;

    @par Description
    The \b \c break statement affects loop processing; that is; it has an affect on @ref for "for", @ref foreach "foreach", @ref while "while", @ref do "do while", @ref context "context", @ref summarize "summarize", and @ref subcontext "subcontext" loop processing as well as on @ref switch "switch" block processing.\n\n
    When this statement is encountered while executing a loop, the loop is immediately exited, and execution control passes to the next statement outside the loop.

    <hr>
    @subsection throw throw Statements

    @par Synopsis
    In order to throw an exception explicitly, the \b \c throw statement must be used.

    @par Syntax
    \b \c throw expression;

    @par Description
    The expression will be passed to the \b \c catch block of a @ref try "try/catch statement", if the \b \c throw is executed in a @ref try "try block". Otherwise the default system exception handler will be run and the currently running thread will terminate.\n\n
    %Qore convention dictates that a direct list is thrown with at least two string elements, the error code and a description. All system exceptions have this format.\n\n
    See @ref try "try/catch statements" for information on how to handle exceptions, and see @ref exception_handling for information about how throw arguments are mapped to the exception hash.

    <hr>
    @subsection try try and catch Statements

    @par Synopsis
    Some error conditions can only be detected and handled using exception handlers. To catch exceptions, \c \b try and \b \c catch statements have to be used. When an exception occurs while executing the \c \b try block, execution control will immediately be passed to the \b \c catch block, which can capture information about the exception.

    @par Syntax
    \b \c try\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement"</em>\n
    \b \c catch ([$exception_hash_variable])\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement"</em>

    @par Description
    A single variable can be specified in the catch block to be instantiated with the exception hash, giving information about the exception that has occurred. For detailed information about the exception hash, see @ref exception_handling.\n\n
    If no variable is given in the \c \b catch declaration, it will not be possible to access any information about the exception in the <b><tt>catch</tt></b> block. However, the @ref rethrow "rethrow statement" can be used to rethrow exceptions at any time in a \c \b catch block.

    <hr>
    @subsection rethrow rethrow Statements

    @par Synopsis
    A \c \b rethrow statement can be used to rethrow an exception in a \c\b catch block. In this case a entry tagged as a rethrow entry will be placed on the exception call stack.

    @par Syntax
    \b \c rethrow;

    @par Description
    The rethrown exception will be either passed to the next higher-level \c\b catch block, or to the system default exception handler, as with a @ref throw "throw statement".\n\n
    This statement can be used to maintain coherent call stacks even when exceptions are handled by more than one \c\b catch block (for detailed information about the exception hash and the format of call stacks, see @ref exception_handling).\n\n
    Note that it is an error to use the \c \b rethrow statement outside of a \c \b catch block.

    <hr>
    @subsection thread_exit thread_exit Statements

    @par Synopsis
    \c \b thread_exit statements cause the current thread to exit immediately. Use this statement instead of the exit() function when only the current thread should exit.

    @par Syntax
    \b \c thread_exit;

    @par Description
    This statement will cause the current thread to stop executing immediately.
 
    <hr>
    @subsection context context Statements

    @par Synopsis
    To easily iterate through multiple rows in a hash of arrays (such as a query result set returned by the Qore::Datasource::select() or Qore::SQLStatement::fetchColumns() methods), the \c \b context statement can be used. Column names can be referred to directly in expressions in the scope of the context statement by preceding the name with a \c "%" character.

    @par Syntax
    \b \c context <em>[name]</em> <tt>(</tt><em>@ref expressions "data_expression"</em><tt>)</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>[\b where (</tt><em>@ref expressions "where_expression"</em><tt>)]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>[\b sortBy (</tt><em>@ref expressions "sort_expression"</em><tt>)]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>[\b sortDescendingBy (</tt><em>@ref expressions "sort_descending_expression"</em><tt>)]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement"</em>

    @par Description
    <em>@ref expressions "data_expression"</em>\n
    This must evaluate to a hash of arrays in order for the \c \b context statement to execute.\n\n
    <em>@ref expressions "where_expression"</em>\n
    An optional \b\c where expression may be given, in which case for each row in the hash, the expression will be executed, and if the where expression evaluates to \c True, the row will be iterated in the context loop. If this expression evaluates to \c False, then the row will not be iterated. This option is given so the programmer can create multiple views of a single data structure (such as a query result set) in memory rather than build different data structures by hand (or retrieve the data multiple times from a database).\n\n
    <em>@ref expressions "sort_expression"</em>\n
    An optional \c \b sortBy by expression may also be given. In this case, the expression will be evaluated for each row of the query given, and then the result set will be sorted in ascending order by the results of the expressions according to the resulting type of the evaluated expression (i.e. if the result of the evaluation of the expression gives a string, then string order is used to sort, if the result of the evaluation is an integer, then integer order is used, etc).\n\n
    <em>@ref expressions "sort_descending_expression"</em>\n
    Another optional modifier to the \c\b context statement that behaves the same as above except that the results are sorted in descending order.

    @par Example
    @code 
# note that "%service_type" and "%effective_start_date" represent values
# in the $service_history hash of arrays.
context ($service_history) where (%service_type == "voice")
sortBy (%effective_start_date) {
   printf("%s: start date: %s\n", %msisdn, format_date("YYYY-MM-DD HH:mm:SS", %effective_start_date));
}@endcode

    <hr>
    @subsection summarize summarize Statements

    @par Synopsis
    \c\b summarize statements are like context statements with one important difference: results sets are grouped by a by expression, and the statement is executed only once per discrete by expression result. This statement is designed to be used with the @ref subcontext "subcontext statement".

    @par Syntax
    \c\b summarize <tt>(</tt><em>@ref expressions "data_expression"</em><tt>) \b by (</tt><em>@ref expressions "by_expression"</em><tt>)</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>[\b where (</tt><em>@ref expressions "where_expression"</em><tt>)]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>[\b sortBy (</tt><em>@ref expressions "sort_expression"</em><tt>)]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>[\b sortDescendingBy (</tt><em>@ref expressions "sort_descending_expression"</em><tt>)]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement"</em>

    @par Description
    \c\b summarize statements modifiers have the same effect as those for the @ref context "context statement", except for the following:\n\n
    <tt>\b by (</tt><em>@ref expressions "by_expression"</em><tt>)</tt>\n
    The \c\b by expression is executed for each row in the data structure indicated. The set of unique results defines groups of result rows. For each group of result rows, each row having an identical result of the evaluation of the by expression, the statement is executed only once.

    @par Example
    @code 
# note that "%service_type" and "%effective_start_date" represent values 
# in the $services hash of arrays.
summarize ($services) 
    by (%effective_start_date) 
    where (%service_type == "voice") 
    sortBy (%effective_start_date) {
    printf("account has %d service(s) starting on %s\n", 
           context_rows(),
           format_date("YYYY-MM-DD HH:mm:SS", %effective_start_date));
}@endcode

    <hr>
    @subsection subcontext subcontext Statements

    @par Synopsis
    Statement used to loop through values within a @ref summarize "summarize statement".

    @par Syntax
    \c\b subcontext \n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>[\b where (</tt><em>@ref expressions "where_expression"</em><tt>)]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>[\b sortBy (</tt><em>@ref expressions "sort_expression"</em><tt>)]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>[\b sortDescendingBy (</tt><em>@ref expressions "sort_descending_expression"</em><tt>)]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement"</em>

    @par Description
    The \c\b subcontext statement is used in conjunction with @ref summarize "summarize statements". When result rows of a query should be grouped, and then each row in the result set should be individually processed, the %Qore programmer should first use a @ref summarize "summarize statement", and then a \c \b subcontext statement. The @ref summarize "summarize statement" will group rows, and then the nested \c\b subcontext statement will iterate through each row in the current summary group.

    @par Example
    @code 
summarize ($services) 
    by (%effective_start_date) 
    where (%service_type == "voice") 
    sortBy (%effective_start_date) {
    printf("account has %d service(s) starting on %s\n", 
           context_rows(),
           format_date("YYYY-MM-DD HH:mm:SS", %effective_start_date));
    subcontext sortDescendingBy (%effective_end_date) {
        printf("\tservice %s: ends: %s\n", %msisdn, format_date("YYYY-MM-DD HH:mm:SS", %effective_end_date));
    }
}@endcode

    <hr>
    @subsection return return Statements

    @par Synopsis
    \c\b return statements causes the flow of execution of the function, method or program to stop immediately and return to the caller. This statement can take an optional expression to return a value to the caller as well.

    @par Syntax
    \c\b return <em>@ref expressions "[expression]"</em>;

    @par Description
    This statement causes execution of the current function, method, or program to returns to the caller, optionally with a return value.

    @par Example
    @code 
string sub getName() {
   return "Barney";
}
my string $name = getName();@endcode
 
    <hr>
    @subsection on_exit on_exit Statements

    @par Synopsis
    Queues a statement or statement block for unconditional execution when the block is exited, even in the case of exceptions or @ref return "return statements". For similar statement that queue code for execution depending on the exception status when the block exits, see @ref on_success "on_success statements" and @ref on_error "on_error statements".

    @par Syntax
    \c\b on_exit \n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement"</em>

    @par Description
    The \c\b on_exit statement provides a clean way to do exception-safe cleanup within %Qore code. Any single statment (or statement block) after the \c\b on_exit keyword will be executed when the current block exits (as long as the statement itself is reached when executing - \c\b on_exit statements that are never reached when executing will have no effect).\n\n
    The position of the \c\b on_exit statement in the block is important, as the immediate effect of this statement is to queue its code for execution when the block is exited. Even if an exception is raised or a @ref return "return statement" is executed, any \c\b on_exit code that is queued will be executed. Therefore it's ideal for putting cleanup code right next to the code that requires the cleanup.\n\n
    Note that if this statement is reached when executing in a loop, the \c\b on_exit code will be executed for each iteration of the loop.\n\n
    By using this statement, programmers ensure that necessary cleanup will be performed regardless of the exit status of the block (exception, @ref return "return", etc).

    @par Example
@code
{
    $mutex.lock();
    # here we queue the unlock of the mutex when the block exits, even if an exception is thrown below
    on_exit $mutex.unlock();
    if ($error)
        throw "ERROR", "Scary error happened";
    print("everything's OK!\n");
    return "OK";
}
# when the block exits for any reason, the mutex will be unlocked@endcode

    <hr>
    @subsection on_success on_success Statements

    @par Synopsis
    Queues a statement or statement block for execution when the block is exited in the case that no exception is active. Used often in conjunction with the @ref on_error "on_error statement" and related to the @ref on_exit "on_exit statement".

    @par Syntax
    \c\b on_success \n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement"</em>

    @par Description
    The \c \b on_success statement provides a clean way to do block-level cleanup within %Qore code in the case that no exception is thrown in the block. Any single statment (or statement block) after the \c\b on_success keyword will be executed when the current block exits as long as no unhandled exception has been thrown (and as long as the statement itself is reached when executing - \c\b on_success statements that are never reached when executing will have no effect).\n\n
    The position of the \c\b on_success statement in the block is important, as the immediate effect of this statement is to queue its code for conditional execution when the block is exited. Even if a @ref return "return statement" is executed later in the block, any \c\b on_success code that is queued will be executed as long as there is no active (unhandled) exception. Therefore it's ideal for putting cleanup code right next to the code that requires the cleanup, along with @ref on_error "on_error statements", which are executed in a manner similar to \c\b on_success statements, except \c\b on_error statements are only executed when there is an active exception when the block is exited.\n\n
    Note that if this statement is reached when executing in a loop, the \c\b on_success code will be executed for each iteration of the loop (as long as there is no active exception).

    @par Example
@code
{
    $db.beginTransaction();
    # here we queue the commit in the case there are no errors
    on_success $db.commit();
    # here we queue a rollback in the case of an exception
    on_error $db.rollback();
    $db.select("select * from table where id = %v for update", $id);
    # .. more code

    return "OK";
}
# when the block exits. the transaction will be either committed or rolled back, 
# depending on if an exception was raised or not@endcode

    <hr>
    @subsection on_error on_error Statements

    @par Synopsis
    Queues a statement or statement block for execution when the block is exited in the case that no exception is active. Used often in conjunction with the @ref on_success "on_success statement" and related to the @ref on_exit "on_exit statement".

    @par Syntax
    \c\b on_error \n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement"</em>

    @par Description
    The \c\b on_error statement provides a clean way to do block-level cleanup within %Qore code in the case that an exception is thrown in the block. Any single statment (or statement block) after the \c\b on_error keyword will be executed when the current block exits as long as an unhandled exception has been thrown (and as long as the statement itself is reached when executing - \c\b on_error statements that are never reached when executing will have no effect).\n\n
    The position of the \c\b on_error statement in the block is important, as the immediate effect of this statement is to queue its code for conditional execution when the block is exited. Even if a @ref return "return statement" is executed later in the block, any \c\b on_error code that is queued will be executed as long as there is an active (unhandled) exception. Therefore it's ideal for putting cleanup code right next to the code that requires the cleanup, along with @ref on_success "on_success statements", which are executed in a manner similar to \c\b on_error statements, except @ref on_success "on_success statements" are only executed when there is no active exception when the block is exited.\n\n
    Note that the code in this statement can only be executed once in any block, as a block (even a block within a loop) can only exit the loop once with an active exception (in contrast to @ref on_success "on_success" and @ref on_exit "on_exit statements", which are executed for every iteration of a loop).

    @par Example
@code{
    $db.beginTransaction();
    # here we queue the commit in the case there are no errors
    on_success $db.commit();
    # here we queue a rollback in the case of an exception
    on_error $db.rollback();
    $db.select("select * from table where id = %v for update", $id);
    # .. more code

    return "OK";
}
# when the block exits. the transaction will be either committed or rolled back, 
# depending on if an exception was raised or not@endcode

    @section functions Functions

    A function is declared in %Qore by using the key word \c\b sub (for subroutine) as follows.

    @par Function Declaration Syntax
    <tt>[synchronized]</tt> <em>@ref data_type_declarations "[return_type]"</em> \c\b sub <em>function_name</em><tt>(</tt><em>@ref data_type_declarations "[param_type]"</em> <tt>$</tt><em>var_name</em> ...<tt>]) {</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement(s)..."</em>\n
    }\n\n
    or the deprecated alternate syntax with the \c\b returns keyword:\n
    <tt>[synchronized]</tt> \c\b sub <em>function_name</em><tt>(</tt><em>@ref data_type_declarations "[param_type]"</em> <tt>$</tt><em>var_name</em> ...<tt>]) \b returns</tt> <em>@ref data_type_declarations "return_type"</em> <tt>{</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>@ref statements "statement(s)..."</em>\n
    }\n\n

    @par Function Declarations
    Variables listed in parentheses after the function name are the parameters to the function and automatically get local lexical scoping. In order to process a variable number of arguments to a function, the <tt>$argv</tt> variable (local variable) is instantiated as a list with the remaining arguments passed to the function. Type declarations optionally precede the parameter variable and will restrict any arguments passed to the type declared. The same function can be declared multiple times if each declaration has different parameter types; this is called @ref overloading "overloading" the function.\n\n
    Functions use the @ref return "return statement" to provide a return value. Function names must be valid Qore identifiers.\n\n
    The return type of the function can be given by placing a type declaration before the \c\b sub keyword (the older syntax with the \c\b returns keyword after the parameter list is still accepted as well).\n\n
    Note that parameter and return types are required when the @ref PO_REQUIRE_TYPES or @ref PO_REQUIRE_PROTOTYPES parse options are set.\n\n
    Functions can return values to the calling expression by using the @ref return "return statement".\n
    Here is an example function declaration returning a value:\n
    @code
#!/usr/bin/qore
# function declaration example

int sub print_string(string $string) {
    print("%s\n", $string);
    return 1;
}@endcode \n
    Functions may also be recursive. Here is an example of a recursive Qore function implementing the Fibonacci function:\n
    @code
#!/usr/bin/qore
#
# recursive function example

int sub fibonacci(int $num) {
    if ($num == 1)
        return 1;
    return $num * fibonacci($num - 1);
}@endcode \n
    @note Function names are resolved during the second parse pass; therefore functions do not need to be declared before being referenced. This allows an easy definition of 2 or more self-referencing functions.\n\n
    Variables passed as function arguments are passed by value by default, unless the caller places a \c "\" character before an lvalue in the argument list in the function call. In this case the function must have a parameter defined to accept the variable passed by reference. Any changes to the local variable will be reflected in the original variable for variables passed by reference. Also note that it is illegal to pass an argument by reference in a @ref background "background" expression.

    @section namespaces Namespaces

    @par Description
    Namespaces allow @ref constants "constants", @ref classes "classes", and even other namespaces to co-exist in the same program by defining them in separate namespaces. Constants, classes, and sub-namespaces can be declared to belong to a particular namespace either by defining them in-line within a namespace declaration, or by including the namespace name/path prepended to the constant, class, or namespace declaration separated by two colons \c "::".\n\n
    If the user does not specify the parent namespace with a namespace path in constant, class, or namespace declarations, the declaration will be by default in the unnamed default root namespace.

    @anchor namespace_declarations
    @par In-Line Namespace Declaration
    \c\b namespace <em>[namespace_path::]namespace_identifier</em> <tt>{</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>[constant_declarations]</em>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>[class_declarations]</em>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<em>[namespace_declarations]</em>\n
    <tt>}</tt>

    @par Out of Line Namespace Declaration
    \c\b namespace <em>[namespace_path::]namespace_identifier</em><tt>;</tt>

    @anchor namespace_resolution
    @par Namespace Resolution
    Namespaces can either be resolved by giving a path to the constant, class, or namespace desired, or by leaving out the namespace path and allowing the system to search for the constant, class, or namespace. In either case, a depth-first search of the namespace tree is made for a match.\n\n
    If a namespace path is included, then the tree is searched for the first namespace match. and, if the rest of the declaration cannot be matched, the search continues in the entire namespace tree until a complete match is found.

    @anchor namespace_paths
    @par Namespace Paths
    Namespace paths look like the following:\n
    - <em>starting_namespace::[sub_namespace(s)s::]constant|class|namespace</em>

    @par Example
    @code
namespace MyNamspace {
    const MyConst = 1;
    class MyClass {
    }
    namespace MySubNamespace;
}
    @endcode

    @note No semicolon (\c ";") is required to terminate a namespace declaration (in fact using a semicolon would raise a parse exception).

    @section constants Constants

    @par Description
    Constant definitions allow programmers to refer to values with %Qore identifiers rather than using the value or the expression that generates the value.

    @par Constant Declaration Syntax
    \c\b const <em>@ref namespace_paths "[namespace_path::]"constant_identifier</em> <tt>=</tt> <em>@ref expressions "initialization_expression"</em>;

    @par Example
    @code
const PI_SQUARED = pow(Qore::M_PI, 2);
    @endcode

    @since 0.8.1 The expression used to initialize a constant can be any valid @ref expressions "Qore expression" as long as no variables are referenced. 

    @note It is bad programming practice to assign a constant with an expression that has side effects. Furthermore if an expression used to initialize a constant throws an exception, that exception cannot be caught in the program being defined.\n\n
    The order that constants are initialized and assigned does not necessarily correspond to declaration order, however constants may be defined using the values of other constants; if a circular reference is detected a parse exception is raised.\n\n
    Constants are resolved in the second stage of parsing (during the parse commit stage, see also @ref Qore::Program::parseCommit() "Program::parseCommit()"\n\n
    Classes can also declare constants; see @ref class_constants for more information.

    @section classes Classes

    @subsection class_overview Class Overview
    Classes define types of %Qore @ref object "objects". Classes can define members and methods, which are attributes of the class and functions that operate only on the objects of that class, respectively.  Furthermore access to class members and methods can be restricted (see @ref class_protection), and classes can be @ref inheritance "subclassed" to support polymorphism.

    @par In-Line Class Declaration Syntax
    <tt>\b class [</tt><em>@ref namespace_paths "namespace_path"</em><tt>::...]</tt><em>class_identifier</em><tt>] [<b>inherits</b> [<b>private</b>|<b>public</b>] [</tt><em>@ref namespace_paths "namespace_path"</em><tt>::...]</tt><em>parent_class_identifier</em><tt>[, ...]] {</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>[[<b>private</b>] $.</tt><em>member_name</em><tt>[, ...];]</tt>\n\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>[<b>private</b>|<b>public</b> {</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>[[</tt><em>@ref data_type_declarations "member_type"</em><tt>] $.</tt><em>member_name</em> <tt>[= </tt><em>@ref expressions "initialization_expression"</em><tt>];]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>[<b>static</b> [</tt><em>@ref data_type_declarations "static_member_type"</em><tt>] </tt><em>static_member_name</em> <tt>[= </tt><em>@ref expressions "initialization_expression"</em><tt>];]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<tt>[<b>const</b> </tt><em>constant_name</em> <tt>=</tt> <em>@ref expressions "initialization_expression"</em><tt>;]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>}]</tt>\n\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>[[<b>private</b>|<b>public</b>] <b>constructor</b>([</tt><em>@ref data_type_declarations "[param_type]"</em> <tt>$</tt><em>param_name</em> <tt>[=</tt> <em>@ref expressions "default_initialization_expression"</em><tt>], ...]) [: </tt><em>parent_class_name</em><tt>(</tt><em>args...</em><tt>), ...] {</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>}]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>[[<b>static</b>] [<b>synchronized</b>] [<b>private</b>|<b>public</b>]</tt> <em>method_name</em><tt>([</tt><em>@ref data_type_declarations "[param_type]"</em> <tt>$</tt><em>param_name</em> <tt>[=</tt> <em>@ref expressions "default_initialization_expression"</em><tt>], ...]) {</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>}]</tt>\n
    &nbsp;&nbsp;&nbsp;&nbsp;<tt>...</tt>\n
    <tt>}</tt>

    @par In-Line Class Declaration Example
    @code
class MyClass inherits MyBaseClass {
    public {
         string $.pub_attr = "hello";
	 const pub_const = "foo";
	 static pub_static_var = "bar";
    }

    constructor(string $arg) : MyBaseClass($arg + 1) {
    }

    softstring myMethod(softint $i) {
        return $i + 2;
    }
}
    @endcode

    @note No semicolon (\c ";") is required to terminate a class declaration (in fact using a semicolon would raise a parse exception).    

    @par Out-Of-Line Class Declaration Syntax
    Alternatively class declarations and method declarations can be defined out of line as follows:\n
    <tt>\b class [</tt><em>@ref namespace_paths "namespace_path"</em><tt>::...]</tt><em>class_identifier</em><tt> [<b>inherits</b> [<b>private</b>|<b>public</b>] [</tt><em>@ref namespace_paths "namespace_path"</em><tt>::...]</tt><em>parent_class_identifier</em><tt>[, ...]];</tt>\n\n
    <tt>[[<b>private</b>|<b>public</b>] [</tt><em>@ref namespace_paths "namespace_path"</em><tt>::...]</tt>class_identifier</em><tt>::<b>constructor</b>([</tt><em>@ref data_type_declarations "[param_type]"</em> <tt>$</tt><em>param_name</em> <tt>[=</tt> <em>@ref expressions "default_initialization_expression"</em><tt>], ...]) [: </tt><em>parent_class_name</em><tt>(</tt><em>args...</em><tt>), ...] {</tt>\n
    <tt>}]</tt>\n\n
    <tt>[[<b>static</b>] [<b>synchronized</b>] [<b>private</b>|<b>public</b>] [</tt><em>@ref namespace_paths "namespace_path"<tt>::...]</tt>class_identifier</em><tt>::</tt><em>method_name</em><tt>([</tt><em>@ref data_type_declarations "[param_type]"</em> <tt>$</tt><em>param_name</em> <tt>[=</tt> <em>@ref expressions "default_initialization_expression"</em><tt>], ...]) {</tt>\n
    <tt>}]</tt>

    @par Out-Of-Line Class Declaration Example
    @code
class MyNamespace::MyClass inherits MyBaseClass;

MyNamespace::MyClass::constructor(string $arg) : MyBaseClass($arg + 1) {
}

softstring MyNamespace::MyClass::myMethod(softint $i) {
    return $i + 2;
}
    @endcode

    @note Because method definitions are allowed out-of-line, this means that builtin classes may be extended with new user methods, however user constructor, destructor, and copy methods cannot be added to builtin classes; to customize the behavior of these methods for builtin classes, subclass the class instead.\n\n
    When parse option @ref allow-bare-refs "%allow-bare-refs" is enabled, no \c "$" or \c "$." prefixes can be used with variable or method or member names as in the specifications above.
    Class members, class constants, and static class variables can only be declared in an in-line class definition (the first example above). If a class has at least one public member declared (or inherits a class with at least one public member declared), then only those members declared as public can be accessed from outside the class, and from within the class only members explicitly declared can be accessed as well (unless the class also defines a memberGate() method). In this way typographical errors in member names can be caught (at parse time if types are declared).\n\n
    In a class hierarchy, base class constructor methods can be explicitly specified using a special syntax unique to subclass constructor methods. Please see @ref inheritance for more information.\n\n
    It's possible to write purely object-oriented scripts/programs in %Qore by defining an application class and using the \c "-x" or \c "--exec-class" command-line arguments to tell %Qore to instantiate the class instead of doing normal top-level execution (in fact, the \c "--exec-class" argument disallows the use of top-level statements entirely). For more information, please see @ref command_line_parsing and @ref parse_directives.

    @subsection class_methods Class Methods

    @anchor private_methods
    @par Private Methods
    Methods declared with the \c\b private keyword can only be called by other member functions of the same class. Any attempt to call these methods from outside the class will result in a run-time exception.

    @anchor synchronized_methods
    @par Synchronized Methods
    Methods declared with the \c\b synchronized keyword will only run in one thread at a time.

    @anchor static_methods
    @par Static Methods
    Methods declared with the \c\b static keyword are like regular functions that are attached to the class. These methods are not associated with a particular object's state and therefore are not allowed to refer to object members or call non-static methods. Also, no reference to the special <tt>$self</tt> variable is allowed within static methods.\n\n
    Static methods may be declared \c\b private or \c\b public or \c\b synchronized like non-static methods; static methods can also access private members of a class (through an object of the class for non-static members).\n\n
    Static method calls take a special syntax as documented in @ref static_method_calls.\n

    @anchor class_special_methods
    @par Constructors, Destructors, and Other Special Methods
    All class methods are optional, but some methods have a special meaning.\n\n
    <b>Special Methods</b>
    |!Name|!Description
    |<tt>constructor(</tt><em>[params...]</em>) {}</tt>|Called when objects are created when instantiated by a variable declaration with a class type and constructor arguments or explicitly with the new operator. User code may not explicitly call \c constructor() methods directly. In a class tree, \c constructor() methods are called for base classes first in left-to-right, depth-first declaration order.\n\n\c constructor() methods may be overloaded and also private constructors may be defined. Private constructors can only be called from within the class.
    |<tt>copy() {}</tt>|When a user explicitly calls a copy method, %Qore will generate a new object with references to the same members as the source object. Then, if there are any base classes, base class \c copy() methods are called in the same order as the \c constructor() methods. If a \c copy() method is defined, it will be run in the new object with a reference to the old object passed as the first argument. Any other arguments passed to the \c copy() method are ignored.\n\n\c copy() methods cannot be overloaded and cannot be private.
    |<tt>destructor() {}</tt>|Called when objects go out of scope or are explicitly deleted. User code may not explicitly call \c destructor() methods. In a class tree, \c destructor() methods are called for base classes in the opposite order in which the constructors are called.\n\n\c destructor() methods cannot be overloaded and cannot be private.
    |@ref any_type "any" <tt>@ref memberGate_methods "memberGate"(</tt>@ref string_type "string" <tt>$</tt><em>member_param_name</em><tt>) {}</tt>|If this method is implemented in the class, it is called when read access is attempted to private member or members that do not exist in the current object; the return value of this method is returned as the value of the member.\n\n\c memberGate() methods cannot be overloaded and are not inherited by subclasses.
    |@ref any_type "any" <tt>methodGate(</tt>@ref string_type "string" <tt>$</tt><em>method_param_name</em><tt>, ...) {}</tt>|If this method is implemented in the class, it is called when methods are called on the object that do not exist in the current object and the return value of this method is returned as the value of the method call.\n\n\c methodGate() methods cannot be overloaded and are not inherited by subclasses.
    |<tt>@ref memberNotification_methods "memberNotification"(</tt>@ref string_type "string" <tt>$</tt><em>member_param_name</em><tt>) {}</tt>|If this method is implemented in the class, it is called when an object member is updated outside the class with the member name as the argument. Note that this method is called after the member has been updated and without locking; the call is not atomic respective to other threads that also may update the same member simultaneously.\n\n\c memberNotification() methods cannot be overloaded and are not inherited by subclasses.

    @anchor class_constants
    @par Class Constants
    Class constants, like non-class constants, allow programmers to refer to values with %Qore identifiers rather than using the value or the expression that generates the value.\n\n
    See @ref class_overview for a description of the syntax required to declare a class constant.\n\n
    Like other attributes of classes, class constants may be declared \c\b private or \c\b public. The following is an example of a class constant definition:\n
    @code
class Test {
    public {
        const Version = "1.0";
    }

    private {
        const Limit = 100;
    }
}
    @endcode

    @note Class constant cannot have the same names as @ref static_class_variables "static class variables".

    @anchor static_class_variables
    @par Static Class Variables
    Static class variables are like global variables that belong to a class. They are not associated with any particular object.\n\n
    See @ref class_overview for a description of the syntax required to declare a static class variable.\n\n
    Like other attributes of classes, static class variables may be declared \c\b private or \c\b public. The following is an example of a static class variable definition:\n
    @code
class Test {
    public {
        static string lastFile = "none";
    }

    private {
        static int numProcessed = 0;
    }
}
    @endcode

    @note Static class variables cannot have the same same as class constants.

    @subsection class_members Class Members

    @par Class Member References
    When defining a class, members of instantiated objects are referred to with a special syntax as follows:\n
    <tt>$.</tt><em>member_name</em>\n\n
    Furthermore, the automatic variable <tt>$self</tt> is instantiated in every non-static method, representing the current object (similar to <tt>this</tt> in C++ or Java). Therefore if you need to access hash members which are not valid %Qore identifiers, then enclose the member name in double quotes after the dot operator as follows:\n
    @code $self."&member-name"@endcode

    @anchor memberGate_methods
    @par memberGate() Method
    If the class implements a \c memberGate() method, then whenever a non-existent member of the class is accessed (read), this method will be called with the name of the member as the sole argument, so that the class can create the member (or react in some other way) on demand. This method is also called when methods of the same class try to access (read) non-existent methods, but is not called from within the \c memberGate() method itself.

    @anchor memberNotification_methods
    @par memberNotification() Methods
    To monitor writes to the object, the class can implement a \c memberNotification() method, which is called whenever an object member is modified from outside class member code. In this case, the \c memberNotification() method is called with the name of the member that was updated so that an object can automatically react to changes to its members (writes to members) from outside the class. This method is not called when members are updated from within class member code.

    @par Classes With Public Member Declarations
    If a class has at least one public member declared (or inherits a class with at least one public member declared), then only those members declared as public can be accessed from outside the class, and from within the class only members explicitly declared can be accessed as well (unless the class also defines a @ref memberGate_methods "memberGate() method"). In this way typographical errors in member names can be caught (at parse time if types are declared).

    @par Member Initialization
    Members that have intialization expressions in the class definition are initialized before the constructor is executed (but after any base class constructors have run).  An exception raised in a member initialization expression will cause the constructor to fail and for the object to be deleted immediately.

    @note The automatic <tt>$argv</tt> local variable is instantiated as usual in all class methods where there are more arguments than variables declared in the method declaration.\n\n

    @subsection object_method_calls Object Method Calls

    @par In-Class Method Call Syntax
    Within a class method definition, calls to methods in the same class hierarchy (of the current class or a base class) can be made as follows:\n
    <tt>[[</tt><em>@ref namespace_paths "namespace_path"</em><tt>::...]</tt><em>parent_class_name</em><tt>::]$.</tt><em>method_name</em><tt>([</tt><em>args</em><tt>, ...])</tt>

    @par In-Class Method Call Example
    @code
# to call a specific method in a base class
Thread::Mutex::$.lock();
# to call lock() in the current (or lower base) class
$.lock();
    @endcode

    @par In-Class Method Calls with %allow-bare-refs
    When the @ref allow-base-refs "%allow-bare-refs" parse directive is set, then object methods are called without the \c "$." prefix as in the following example:\n
    @code
# to call a specific method in a base class
Thread::Mutex::lock();
# to call lock() in the current (or lower base) class
lock();
    @endcode\n
    Calls to object methods can be made outside the class by using the above syntax as well. If the object's class is not known at parse time, then the call is resolved at run-time, and if a call is attempted to a private function outside the defining class, then a run-time \c METHOD-IS-PRIVATE (if the method is private) or \c BASE-CLASS-IS-PRIVATE (if the method resolves to a privately-inherited base class) exception is raised.

    @subsection inheritance Class Inheritance

    Class inheritance is a powerful concept for easily extending and resuing object-oriented code, but is also subject to some limitations. This section will explain how class inheritance works in %Qore.

    Classes inherit the methods of a parent class by using the inherits as specified above. Multiple inheritance is supported; a single %Qore class can inherit one or more classes. When a class is inherited by another class, it is called a base class. Private inheritance is speficied by including the keyword \c\b private before the inherited class name. When a class is privately inherited, it means that the inherited class' public members are treated as private members in the context of accesses outside the class.

    Inheritance is \c\b public by default, to inherit a class privately, use the \c\b private keyword before the class name or class path to inherit as follows:
    @code
class ChildClass inherits private ParentClass {
}
    @endcode

    It is not legal to directly inherit the same class directly more than once; that is; it is not legal to list the same class more than once after the \c\b inherits keyword. However, it is possible that a base class could appear more than once in the inheritance tree if that class is inherited separately by two or more classes in the tree. In this case, the base class will actually only be inherited once in the subclass, even though it appears in the inheritance tree more than once. This must be taken into consideration when designing class hierarchies, particularly if base class constructor parameters for that class are explicitly provided in a different way by the inheriting classes.

    @note Class members only exist once for each object; therefore if classes in an inheritance tree have different uses for members with the same name, then a class hierarchy built of such classes will probably not function properly.

    Subclasses can give explicit arguments to their base class constructors using a special syntax (only available to subclass constructors) similar to the C++ syntax for the same purpose as follows:\n
    <tt>[[<b>private</b>|<b>public</b>] <b>constructor</b>([</tt><em>@ref data_type_declarations "[param_type]"</em> <tt>$</tt><em>param_name</em> <tt>[=</tt> <em>@ref expressions "default_initialization_expression"</em><tt>], ...]) [: </tt><em>parent_class_name</em><tt>(</tt><em>args...</em><tt>), ...] {</tt>\n
    <tt>}]</tt>\n
    Here is a concrete example of giving arguments to an inherited base class:
    @code
class XmlRpcClient inherits Qore::HTTPClient {
    # calls the base class HTTPClient constructor, overrides the "protocols" key to "xmlrpc"
    constructor(hash $opts = hash()) : Qore::HTTPClient($opts + ( "protocols" : "xmlrpc" )) {
    }
}
    @endcode

    Because base class constructors are executed before subclass constructors, the only local variables in the constructor that can be referenced are those declared in the subclass constructor declaration (if any). What this means is that if you declare local variables in the expressions giving base class arguments, these local variables are not accessible from the constructor body.

    @note Base classes that give explicit arguments to their base class constructors can be overridden by subclasses by simply listing the base class in the base class constructor list and providing new arguments.

    @section threading Threading

    A thread is an independent sequence of execution of Qore code within a Qore program or script. Each thread has a thread ID or TID.

    The first thread of execution in a Qore program has TID 1. TID 0 is always reserved for the special @ref signal_handling "signal handler thread".

    The %Qore language is designed to be thread-safe and %Qore programs should not crash the %Qore executable due to threading errors. Threading errors should only cause exceptions to be thrown or application errors to occur.

    Threading functionality in %Qore is provided by the operating system's POSIX threads library.

    @subsection creating_and_terminating_threads Creating and Terminating Threads

    New threads are created with the @ref background "background operator". This operator executes the expression given as an argument in a new thread and returns the TID (integer thread ID) of the new thread to the calling thread. This is most useful for calling user functions or object methods designed to run in a separate thread.

    To terminate a thread, the @ref thread_exit "thread_exit statement" should be called, as calling the exit() function will terminate the entire process (and therefore all threads) immediately.

    @subsection threading_and_variables Threading and Variables

    All global variables are shared in %Qore programs, while local variables (declared with \c\b my) are generally local to each thread (and thus accessed without any mutual-exclusion locking), regardless of location. This means that if a variable is declared with \c\b my at the top level, it will actually have global scope, but also each thread will have its own copy of the variable. In effect, declaring a top-level local variable with \c\b my actually creates a global thread-local variable.

    The following code gives an example of declaring a global thread-local variable by using \c\b my at the top-level:

    @code
%require-our
sub t() {
    printf("x=%y\n", $x);
}
my int $x = 2;
t();
background t();
    @endcode

    This will print out:
    @verbatim
x=2
x=null@endverbatim

    Note that the second time the local variable is accessed in the background thread, it has no value.

    Due to the way %Qore's local variables work, it is illegal to declare a top-level local variable after first block is parsed in the program; that is; if any call to parse() or Qore::Program::parse() is made in an existing program (where a top-level block already exists), and an attempt to declare a new top-level local variable is made, then a \c ILLEGAL-TOP-LEVEL-LOCAL-VARIABLE parse exception will be raised.

    Access to global variables in qore is wrapped in mutual-exclusion locks to guarantee safe access to global variable data in a multithreaded context. Local variables are thread-local and therefore not locked, except when referenced in a @ref closure "closure", in which case the local variable's scope is extended to that of the @ref closure "closure's", and all accesses to the bound local variable are made within mutual-exclusion locks as these variables may be used in multithreaded contexts.

    An alternative to global thread-local variables is offered by the save_thread_data() and get_thread_data() functions (documented in @ref threading_functions).

    @subsection thread_synchronization Thread Synchronization and Inter-Thread Communication

    @anchor synchronized
    @par synchronized
    The \c\b synchronized keyword can be used before function or class method definitions in order to guarantee that the function or method call will only be executed in one thread at a time. As in Java, this keyword can also be used safely with recursive functions and methods (internally a recursive mutual exclusion lock that participates in %Qore's deadlock detection framework is used to guarantee thread-exclusivity and allow recursion).

    @par Classes Useful With Threading
    The following classes are useful when developing multi-threaded %Qore programs:\n
    |!Class|!Description
    |@ref Qore::Thread::Mutex "Mutex"|A mutual-exclusion thread lock
    |@ref Qore::Thread::Gate "Gate"|A recursive thread lock
    |@ref Qore::Thread::RWLock "RWLock"|A read-write thread lock
    |@ref Qore::Thread::Condition "Condition"|Allows %Qore programs to block until a certain condition becomes true
    |@ref Qore::Thread::Counter "Counter"|A blocking counter class
    |@ref Qore::Thread::Queue "Queue"|A thread-safe, blocking queue class (useful for message passing)
    |@ref Qore::Thread::Sequence "Sequence"|A simple, thread-atomic sequence object (increment-only)
    |@ref Qore::Thread::AutoLock "AutoLock"|A helper class to automatically release Mutex locks when the AutoLock object is deleted
    |@ref Qore::Thread::AutoGate "AutoGate"|A helper class to automatically exit Gate locks when the AutoGate object is deleted
    |@ref Qore::Thread::AutoReadLock "AutoReadLock"|A helper class to automatically release read locks when the AutoReadLock object is deleted
    |@ref Qore::Thread::AutoWriteLock "AutoWriteLock"|A helper class to automatically release read locks when the AutoWriteLock object is deleted

    @par Functions Useful With Threading
    The following functions assist writing safe and efficient multi-threaded %Qore programs:\n
    |!Function|!Description
    |save_thread_data()|Saves a thread-local value against a key.
    |get_all_thread_data()|Retrieves the entire thread-local hash.
    |get_thread_data()|Retrieves a thread-local value based on a key.
    |delete_all_thread_data()|Deletes the entire thread-local data hash.
    |delete_thread_data()|Delete the value of a key in the thread-local data hash.
    |gettid()|Gets the thread's TID (thread identifier)
    |thread_list()|Returns a list of TIDs of running threads
    |num_threads()|Returns the number of running threads
    |throwThreadResourceExceptions()|runs thread-resource cleanup routines and throws the associated exceptions

    @subsection deadlocks Deadlocks

    %Qore supports deadlock detection in complex locking scenarios and will throw a \c THREAD-DEADLOCK exception rather than allow an operation to be performed that would cause a deadlock. Deadlock detection is implemented for internal locking (global variable and object access), @ref synchronized "synchronized" methods and functions, etc, as well as for all %Qore threading classes.

    %Qore can only detect deadlocks when a lock resource acquired by one thread is required by another who holds a lock that the first thread also needs. Other errors such as forgetting to unlock a global lock and trying to acquire that lock in another thread cannot be differentiated from valid use of threading primitives and will result in a process that never terminates (a deadlocked process). However, common threading errors such as trying to lock the same @ref Qore::Thread::Mutex "Mutex" twice in the same thread without unlocking it between the two @ref Qore::Thread::Mutex::lock() "Mutex::lock()" calls are caught in %Qore and exceptions are thrown. Additionally, locks are tracked as thread resources, so if a thread terminates while holding a lock, an exception will be thrown and the lock will be automatically released.  

    @subsection exception_handling Exception Handling

    Exceptions are errors that can only be handled using a @ref try "try catch block". Any exception that is thrown in a @ref try "try block" will immediately cause execution of that thread to begin with the first statement of the @ref try "catch block", regardless of the position of the program pointer of the running thread, even if nested function or object method calls have been made.

    Exceptions can be thrown by the %Qore system for a number of reasons, see the documentation for each function and object method for details.

    Programmers can also throw exceptions explicitly by using the @ref throw "throw" and @ref rethrow "rethrow" statements.

    Information about the exception, including the context in which the exception occurred, is saved in the exception hash, which can be retrieved by using a parameter variable in the @ref try "catch block".

    The exception hash contains the following members:

    @anchor exception_hash
    <b>Exception Hash Keys</b>
    |!Name|!Type|!Description
    |\c type|@ref string_type "string"|\c "System" or \c "User" depending on exception type
    |\c file|@ref string_type "string"|File name of file where exception occurred
    |\c line|@ref int_type "int"|Line number where exception occurred
    |\c callStack|@ref list_type "list" of @ref hash_type "hashes"|@ref callstack "Backtrace information"
    |\c err|@ref any_type "any"|This key is populated with the value of the first expression of the @ref throw "throw statement". For system exceptions, this is a string giving the exception code.
    |\c desc|@ref any_type "any"|This key is populated with the value of the second expression of the @ref throw "throw statement" (if a list was thrown). For system exceptions, this is a string giving a text description of the error.
    |\c arg|@ref any_type "any"|This key is populated with the value of the third expression of the @ref throw "throw statement" (if a list was thrown). For system exceptions, this is populated for some exceptions where additional information is provided.
    
    @anchor callstack
    <b>Call Stack Description</b>
    |!Name|!Type|!Description
    |\c function|@ref string_type "string"|function name of the source where the exception was raised (if known)
    |\c line|@ref int_type "int"|line number of the source where the exception was raised (if known, for user exceptions only)
    |\c file|@ref string_type "string"|file name of the source where the exception was raised (if known, for user exceptions only)
    |\c type|@ref string_type "string"|Exception Type (\c ET_*) constants; see @ref exception_constants for values.
    |\c typecode|@ref int_type "int"|Call Type (\c CT_*) constants; see @ref exception_constants for values.

    System exceptions always throw at least 2 values, populating the \c "err" and \c "desc" keys of the exception hash, giving the exception string code and the exception description string, respectively, and occassionally, depending on the function, the \c "arg" key may be populated with supporting information. User exceptions have no restrictions, any values given in the @ref throw "throw statement" will be mapped to exception keys as per the table above.

    See the @ref on_exit "on_exit", @ref on_success "on_success" statement, and @ref on_error "on_error" statement for statements that allow for exception-safe and exception-dependent cleanup in %Qore code.

    Classes that assist in exception-safe lock handling are the @ref Qore::Thread::AutoLock "AutoLock class", the @ref Qore::Thread::AutoGate "AutoGate class", the @ref Qore::Thread::AutoReadLock "AutoReadLock class", and the @ref Qore::Thread::AutoWriteLock "AutoWriteLock class".

    @section signal_handling Signal Handling

    %Qore implements safe signal handling on UNIX platforms (not available on native Microsoft Windows ports). Signals do not interrupt %Qore threads, rather %Qore uses a special signal handling thread with TID 0, dedicated to handling signals. The signal handling thread uses very few resources; it stays blocked (using no processor time and very little memory) until a signal with a %Qore signal handler is raised; it then executes the handler and resumes waiting for signals.

    Because the signal Qore's signal handling thread is not a normal thread, it does not affect num_threads() and does not appear in the list returned by thread_list().

    Internally, %Qore masks (blocks) all signals in every thread except the signal handling thread. In the signal handling thread, all signals are unmasked, except those with %Qore-language handlers, then an internal call to <tt>sigwait() (3)</tt> is made to receive and process signals raised one at a time.

    Qore-language signal handlers are installed by passing a signal constant and a @ref closure "closure" or @ref call_reference "call reference" to the code to execute when the signal is raised to the set_signal_handler() function. Signal handlers are removed by passing a signal constant to the remove_signal_handler() function.

    When a signal has been raised and the signal handler is called, the signal number is passed as the sole argument to the signal handler code.

    <b>Signal Handling Functions</b>
    |!Function Name|!Description
    |set_signal_handler()|Sets up a %Qore signal handler using a signal number and a call reference.
    |remove_signal_handler()|Removes a %Qore signal handler using a signal number.

    See @ref signal_constants for a list of signal constants and @ref signal_mapping_hash_constants for two hash constants that can be used to map signal names to numbers and vice-versa. Note that signal constants are system-dependent; not all signals will be available in all systems; in case of doubt, see your system documentation for information on which signals are available.

    The above functions are atomic, meaning that when they return to the caller, the signal handling thread has already acknowledged the changes.

    It is not possible to set signal masks per thread; all signals are delivered to the signal handling thread. Signals not handled with a %Qore signal handler are handled with their default action. It is not possible to catch \c SIGPIPE. \c SIGPIPE is always ignored in Qore.

    Some issues to be aware of in signal handlers:
    - Thread-local storage is not persistent in signal handlers; it is deleted after every signal handler is run.
    - A signal handler that does not terminate will block the execution of further signal handlers and will block signal handling changes (such as updating the signal mask), resulting in a %Qore process that must be killed manually. Because all %Qore signal handling code is executed serially in a single thread, %Qore signal handlers should execute and return quickly to give time to execute other handlers.
    - Signal handlers may install or remove signal handlers using set_signal_handler() or remove_signal_handler(), however in this case, changes to signal handling are made after the signal handler returns.
    - Signal handlers cannot call fork(); any attempt to call fork() in a signal handler will result in an an exception.
    - fork() (called externally to a signal handler) is handled as follows: the signal handling thread is terminated, fork() is executed, all signals are masked in the primary thread in the new process, then the signal handling thread is resumed in both processes. No signals can be received or handled while the signal handling thread is terminated. After the fork(), the new process will have exactly the same signal handlers and signal masks as the parent process.
    - Unhandled exceptions in signal handlers will simply be displayed on @ref stderr "stderr" as an unhandled exception and will have no other effect on %Qore or %Qore code (in particular, unhandled exceptions will not cause the signal handling thread to terminate).
    - If a signal handler executes the @ref thread_exit "thread_exit statement", execution of the signal handler will terminate immediately, but the signal handling thread will not be stopped. Execution of further signal handlers (including that for the same signal being handled when @ref thread_exit "thread_exit" is executed) will not be affected.


*/
