# -*- mode: qore; indent-tabs-mode: nil -*-
# @file SqlUtil.qm Qore user module for working with SQL data

/*  SqlUtil.qm Copyright 2013 Qore Technologies, sro

    Permission is hereby granted, free of charge, to any person obtaining a
    copy of this software and associated documentation files (the "Software"),
    to deal in the Software without restriction, including without limitation
    the rights to use, copy, modify, merge, publish, distribute, sublicense,
    and/or sell copies of the Software, and to permit persons to whom the
    Software is furnished to do so, subject to the following conditions:

    The above copyright notice and this permission notice shall be included in
    all copies or substantial portions of the Software.

    THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
    IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
    FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
    AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
    LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING
    FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER
    DEALINGS IN THE SOFTWARE.
*/

# this module requires Qore 0.8.8 or better
%requires qore >= 0.8.8

# requires the Util module
%requires Util >= 1.0

# don't use "$" signs for variables and class members, assume local variable scope
%new-style

# require type definitions everywhere
%require-types

# enable all warnings
%enable-all-warnings

module SqlUtil {
    version = "1.0";
    desc = "user module for working with SQL data";
    author = "David Nichols <david@qore.org>";
    url = "http://qore.org";
}

/*  Version History
    * 2013-xx-xx v1.0: David Nichols <david@qore.org>
      + the initial version of the SqlUtil module
*/

/** @mainpage SqlUtil Module

    @tableofcontents

    @section sqlutil_intro Introduction

    The %SqlUtil module provides a high level database-independent API for working with database objects and SQL.

    To use this module, use \c "%requires SqlUtil" in your code.
    
    All the public symbols in the module are defined in the SqlUtil namespace

    Major sections of this documentation:
    - @subpage sql_operations "SQL Operations": working with database data (finding, updating, inserting, deleting, merging data, etc)
    - @subpage schema_management "Schema Management": working schema definitions (creating, modifying, aligning tables, functions, types, triggers, etc)

    The %SqlUtil module provides generic functionality and a framework for SQL operations and schema management, and in order
    to use the %SqlUtil module with a particular database, a driver-specific module has to be available as well.

    Currently the following driver-specific modules are available:
    - <a href="../../MysqlSqlUtil/html/index.html">MysqlSqlUtil</a>: for working with MySQL databases
    - <a href="../../OracleSqlUtil/html/index.html">OracleSqlUtil</a>: for working with Oracle databases
    - <a href="../../PgsqlSqlUtil/html/index.html">PgsqlSqlUtil</a>: for working with PostgreSQL databases

    The underlying driver-specific module is automatically loaded and used when required; the classes provided in 
    the %SqlUtil module provide a generic API that uses the driver-specific implementations for the underlying driver-specific
    implementation.

    @section sqlutil_overview Overview of Functionality

    SqlUtil provides API support for the following:
    - @ref sql_operations
      - @ref retrieving_data
      - @ref inserting_data
      - @ref updating_data
      - @ref deleting_data
      - @ref sql_upsert
    - @ref schema_management
      - @ref creating_new_objects
      - @ref retrieving_objects
      - @ref listing_objects
      - @ref interdependent_tables
      - @ref aligning_schemas
      - @ref table_management

    @section relnotes Release Notes
    
    @subsection v10 SqlUtil v1.0
    - initial release of the SqlUtil modules for schema management and SQL operations
*/

/** @page sql_operations SQL Operations

    @tableofcontents

    @section sql_intro Introduction to SQL Operations

    The @ref SqlUtil::Table "Table" class (which is a wrapper for @ref SqlUtil::AbstractTable "AbstractTable") provides methods for SQL operations.

    This class uses knowledge about the internal structure of database tables to create and execute SQL on the database.

    SQL strings are constructed programmatically for the following reasons:
    - to present an abstract, database-independent interface to the programmer
    - to allow for database-specific optimizations to be used without requiring programming expertise for the specific database being used
    - to minimize dynamic SQL and therefore use the database server's SQL statement cache more efficiently (if applicable)
    - to prevent SQL injection attacks

    Also for the above reasons, values are bound by value in all possible cases rather than inserted into SQL strings directly.

    @section retrieving_data Retrieving Data from the Database

    There are many methods in the @ref SqlUtil::Table "Table" class for retrieving data from the database; here is an overview:
    - @ref SqlUtil::Table::find(any): finds a row corresponding to the given single value of the primary key; if not present @ref nothing is returned
    - @ref SqlUtil::Table::find(list): finds all rows corresponding to the given list of values of the primary key; if none are present @ref nothing is returned
    - @ref SqlUtil::Table::find(hash): find a row corresponding to the given hash of column name/value pairs, which must at least reference all columns of the table's primary key; if no row matches, @ref nothing is returned
    - @ref SqlUtil::Table::findSingle(): finds the first (of possibly many) rows that match the @ref where_clauses "where clause hash argument" or returns @ref nothing if no row matches
    - @ref SqlUtil::Table::findAll(): returns all rows that match the @ref where_clauses "where clause hash argument" or returns @ref nothing if no row matches
    - @ref SqlUtil::Table::getRowIterator(): returns an @ref Qore::SQL::SQLStatement "SQLStatement" object iterating rows that match the @ref select_option_hash "select option hash" argument
    - @ref SqlUtil::Table::getSelectSql(): returns an SQL string and bind arguments for the @ref select_option_hash "select option hash" argument
    - @ref SqlUtil::Table::select(): returns a hash keyed by column name of lists (row values) corresponding to the @ref select_option_hash "select option hash" argument
    - @ref SqlUtil::Table::selectRow(): return a hash repersenting a single row corresponding to the @ref select_option_hash "select option hash" argument; if the query returns more than one row an exception will be raised
    - @ref SqlUtil::Table::selectRows(): returns lists of row values corresponding to the @ref select_option_hash "select option hash" argument

    @subsection find_single_row Retrieving a Single Row

    @par From the Primary Key
    To retrieve a single row based on a single primary key value, use @ref SqlUtil::Table::find(any):
    @code
my *hash $row = $table.find($id);
    @endcode 
    If no primary key value matches the given argument, then @ref nothing is returned.\n\n
    To retrieve a single row based on a complex primary key value, or a single primary key value and extra criteria, use @ref SqlUtil::Table::find(hash):
    @code
my *hash $row = $table.find(("account_type": $type, "name": $name));
    @endcode
    If no primary key value matches the given argument hash, then @ref nothing is returned.

    @par At Most One Matching Row From the Table
    To retrieve at most one matching row from the table, use @ref SqlUtil::Table::findSingle():
    @code
my *hash $row = $table.findSingle(("permission_type": op_between("US", "UX")));
    @endcode
    This method can be used to efficiently check the table if at least one record matches the given \c where criteria; even if more rows match,
    only a single row is returned.  If no rows match, then @ref nothing is returned.

    @subsection find_multiple_rows Retrieving Multiple Rows

    @par From the Primary Key
    To retrieve multiple rows from a list of single primary key values, use @ref SqlUtil::Table::find(list)
    @code
my *list $rows = $table.find($list);
    @endcode
    All rows matching the single primary key values in the argument list are returned; if no rows match, @ref nothing is returned.

    @par From Simple Where Criteria
    To find all rows matching simple where criteria, use @ref SqlUtil::Table::findAll():
    @code
my *list $rows = $table.findAll(("id": op_gt(100), "created": op_gt(2013-03-01)));
    @endcode
    See @ref where_clauses for a description of the hash argument; if no rows match, @ref nothing is returned.

    @par From Complex Select Criteria
    To select a hash keyed by column name of lists (row values) based on complex select criteria, use @ref SqlUtil::Table::select():
    @code
my hash $sh = (
    "columns": ("id", "name", "q.*"),
    "where": ("type": "user"),
    "limit": 100,
    "offset": 200,
    "join": join_inner($queues, "q"),
);
my *hash $h = $table.select($sh);
    @endcode
    See @ref select_option_hash for a description of the hash argument; if no rows match, then a hash with column
    names assigned to empty lists is returned.\n\n
    To select a list of row hashes based on complex select criteria, use @ref SqlUtil::Table::selectRows():
    @code
my *list $rows = $table.selectRows($sh);
    @endcode
    If no rows match, then @ref nothing is returned.

    @subsection get_row_iterator Acquiring a Row Iterator for Query Results
    @par From Complex Select Criteria
    To get an iterator for the row values corresponding to a select statement, use @ref SqlUtil::Table::getRowIterator():
    @code
my Table $t($ds, "table_name");
my SQLStatement $i = $table.getRowIterator($sh);
on_exit $table.commit();
map printf("row: %y\n", $1), $i;
    @endcode
    See @ref select_option_hash for a description of the hash argument; if no argument is passed to the method,
    then an iterator for all rows in the table is returned.

    @subsection get_rows_in_batches Retrieving Multiple Rows in Batches
    @par From Complex Select Criteria
    Multiple rows can be retrieved from a single call to an @ref Qore::SQL::SQLStatement object as returned by @ref SqlUtil::Table::getRowIterator():
    @code
my Table $t($ds, "table_name");
my SQLStatement $i = $table.getRowIterator($sh);
on_exit $table.commit();
while (True) {
    my list $l = $i.fetchRows(1000);
    if (!$l)
        break;
    printf("rows read: %d\n", $l.size());
}
    @endcode
    See @ref select_option_hash for a description of the hash argument; if no argument is passed to the method,
    then an iterator for all rows in the table is returned.

    @subsection column_spec Specifying Columns in Query Output
    @par From Complex Select Criteria
    @ref SqlUtil::Table "Table" methods taking a @ref select_option_hash "select option hash argument" support specifying output columns including column operators by assigning a column / column operator list to the @ref select_option_columns "columns" key.
    @code
my *list $rows = $table.selectRows(("columns": ("id", "name", "started", cop_as("warnings", "warning_count"), cop_as("errors", "error_count")), "where": ("type": "user")));
    @endcode
    @see @ref select_option_columns "select option columns" for details about the \c "columns" option of the @ref select_option_hash "select option hash"

    @subsection select_option_hash Complex Select Criteria

    Selecting data is performed by passing a select option hash argument to a suitable method that will build and execute a DB-specific SQL command based on this value; the following methods take a select option hash argument:
    - @ref SqlUtil::Table::getRowIterator()
    - @ref SqlUtil::Table::getSelectSql()
    - @ref SqlUtil::Table::insertFromSelect()
    - @ref SqlUtil::Table::insertFromSelectNoCommit()
    - @ref SqlUtil::Table::select()
    - @ref SqlUtil::Table::selectRow()
    - @ref SqlUtil::Table::selectRows()
    - @ref SqlUtil::Table::upsertFromSelect()
    - @ref SqlUtil::Table::upsertFromSelectNoCommit()

    SQL strings for select statements are constructed programmatically based on a select option hash described below.
    
    @par Select Option Hash Example:
    @code
my hash $soh = (
    "columns": ("id", "name", "q.*"),
    "where": ("type": "user"),
    "limit": 100,
    "offset": 200,
    "join": join_inner($queues, "q"),
);
    @endcode

    The select option hash argument has the following keys; all of which are optional:
    - @ref select_option_columns "columns": describes the output columns and any output column operations; if not present, then all columns are returned directly in the output
    - @ref select_option_where "where": (@ref hash_type "hash") describes how any \c "where" clause will be built; if not present, then there is no \c where clause
    - @ref select_option_orderby "orderby": (@ref list_type "list of strings") describes the ordering of the results; if not present (and no other output ordering is required, such as implied by the @ref select_option_offset "offset" option), then results are returned in the order returned by the database server
    - @ref select_option_desc "desc": (@ref bool_type "bool") specifies descending order for results; if not present or not @ref Qore::True "True" and results are ordered, then the results are returned in ascending order
    - @ref select_option_limit "limit": (@ref int_type "int") specifies the maximum number of results to be returned; if not present, then all results are returned
    - @ref select_option_offset "offset": (@ref int_type "int") specifies the starting offset of the first record to be returned (starting with 0)
    - @ref select_option_join "join": (@ref hash_type "hash") specifies any SQL join operations to return results from multiple tables
    - @ref select_option_groupby "groupby": (@ref list_type "list of strings") specifies grouping for aggregate column functions
    - @ref select_option_having "having": (@ref hash_type "hash") specifies filtering for results with aggregate column functions
 
    @anchor select_option_columns
    @par Select Option "columns"
    <b>Columns Example:</b>
    @code
my list $columns = ("id", "name", "started", cop_as("warnings", "warning_count"), cop_as("errors", "error_count"));
my *list $rows = $table.selectRows(("columns": $columns, "where": ("type": "user")));
    @endcode
    By default, all columns are returned from a query; to limit the columns returned, or to perform column operations on the columns returned, use the \c "columns" option of the @ref select_option_hash "select option hash". \n\n
    This option takes a list, each element of the list can be one of the following.\n\n
    <b>A Simple String Giving a Column Name</b>\n
    ex: \c "name"
    @code
my *list $rows = $table.selectRows(("columns": ("id", "name", "started")));
    @endcode \n
    <b>A String in Dot Notation</b>\n
    This format is for use with @ref select_option_join "joins"; ex: \c "q.name"
    @code
my *list $rows = $table.selectRows(("columns": ("table.id", "t2.customer_name"), "join": join_inner($table2, "t2", ("id": "altid"))));
    @endcode \n
    <b>A Column Operation Specified by a Column Operator Function</b>\n
    ex: <tt>cop_as("column_name", "column_alias")</tt> \n
    See @ref sql_cop_funcs "column operator function" for more information on column operator functions
    @code
my *list $rows = $table.selectRows(("columns": ("id", cop_as("warnings", "warning_count"), cop_as("errors", "error_count"))));
    @endcode
    For @ref sql_cop_funcs "column operator functions" taking a column name, either a string name or a name in dot notation is acceptable\n\n
    <b>The Value \c "*", Meaning All Columns</b>\n
    ex: \c "*"
    @code
my *list $rows = $table.selectRows(("columns": "*"));
    @endcode
    This is the default if no \c "columns" key is included in the @ref select_option_hash "select option hash" \n\n
    <b>An \c "*" in Dot Notation</b>\n
    ex: \c "q.*"
    @code
my *list $rows = $table.selectRows(("columns": ("table.id", "t2.*"), "join": join_inner($table2, "t2", ("id": "altid"))));
    @endcode

    @anchor select_option_where 
    @par Select Option "where"
    <b>Where Example:</b>
    @code
my *list $rows = $table.selectRows(("where": ("type": "user"), "limit": 100, "offset": 200));
    @endcode
    The hash value assigned to this key describes how the \c "where" clause in the query is built.  Because the \c "where" clause logic is common to many SQL methods, this topic is covered in a separate section.  See @ref where_clauses for a detailed description of the value of this key.

    @anchor select_option_orderby
    @par Select Option "orderby"
    <b>Orderby Example:</b>
    @code
my *list $rows = $table.selectRows(("where": ("account_type": "CUSTOMER"), "orderby": "created_date"));
    @endcode
    This option is a list of the following values:
    - a simple string giving a column name; ex: \c "name"
    - a string giving a table or table alias and a column name in dot notation (for use with @ref select_option_join "joins"); ex: \c "q.name"
    @note
    - By using the @ref select_option_offset "offset option" the results will be automatically ordered according to the primary key of the table

    @anchor select_option_desc
    @par Select Option "desc"
    <b>Desc Example:</b>
    @code
my *list $rows = $table.selectRows(("where": ("account_type": "CUSTOMER"), "orderby": "created_date", "desc": True));
    @endcode
    If the value of this key is @ref Qore::True "True" and results are ordered (either due to the @ref select_option_orderby "orderby option" or due to implicit ordering by the primary key due to the use of the @ref select_option_offset "offset option"), then results will be sorted in descending order.\n\n
    Otherwise, ordered results are returned in ascending order by default.

    @anchor select_option_limit
    @par Select Option "limit"
    <b>Limit Example:</b>
    @code
my *list $rows = $table.selectRows(("where": ("type": "user"), "limit": 100, "offset": 200));
    @endcode
    This option will limit the number of rows returned.
    @note
    - This option is required if the @ref select_option_offset "offset option" is non-zero
    - If this option is present and an @ref select_option_orderby "orderby option" is also present, then at least a subset of the @ref select_option_orderby "orderby" columns must correspond to a unique key of the table or an exception is raised

    @anchor select_option_offset
    @par Select Option "offset"
    <b>Offset Example:</b>
    @code
my *list $rows = $table.selectRows(("where": ("type": "user"), "limit": 100, "offset": 200));
    @endcode
    This option specifies the row number offset for the rows returned where the first row is at offset zero.
    @note
    - If this option is present, then either an @ref select_option_orderby "orderby option" must be present of which at least a subset of the @ref select_option_orderby "orderby" columns must correspond to a unique key of the table, or, if no @ref select_option_orderby "orderby option" is used, then the table must have a primary key which is used for the ordering instead.
    - Additionally, this option requires the presence of the @ref select_option_limit "limit option", or an exception will be thrown.
    @see @ref sql_paging

    @anchor select_option_join
    @par Select Option "join"
    <b>Join Example:</b>
    @code
my *list $rows = $table.selectRows(("columns": ("name", "version", "id", cop_as("st.value", "source"), cop_as("st.value", "offset")),
                                    "join": join_left($function_instance_tags, "st", NOTHING, ("st.tag": "_source"))
                                            + join_left($function_instance_tags, "lt", NOTHING, ("st.tag": "_offset"))));
    @endcode
    To join multiple tables in a single query, use the \c "join" option.  The \c "join" hash key should be assigned to a join description hash as returned by one of the @ref sql_jop_funcs or combined join description hash created by concatenating such values (see an example of this above).
    @note the join columns do not need to be specified in the case that a foreign key in one table exists to the primary key of the other table; in this case this information is assumed for the join automatically

    @see @ref joins for more examples

    @anchor select_option_groupby
    @par Select Option "groupby"
    <b>Groupby Example:</b>
    @code
my *list $rows = $table.selectRows(("columns": (cop_as(cop_max("service_type"), "type"), cop_count()), "groupby": "service_type"));
    @endcode
    The \c "groupby" option allows for aggregate SQL column operator functions to be used (ex: @ref cop_max(), cop_min()) in select statements.
    The \c "groupby" hash key should be assigned to a list of column specifiers or a single column specifier.  Column specifies for the \c "groupby"
    key are strings giving column names, optionally in dot notation.    

    @anchor select_option_having
    @par Select Option "having"
    <b>Having Example:</b>
    @code
my *list $rows = $table.selectRows(("columns": (cop_as(cop_max("service_type"), "type"), cop_count()), "groupby": "service_type", "having": ("service_type": (COP_COUNT, op_ge(100)))));
    @endcode
    The \c "having" option allows for query results with aggregate SQL column operator functions to be filtered by user-defined criteria.
    The \c "having" hash key should be assigned to a hash where each key is a column specifier (optionally in dot notation) and the values are lists with two elements; the first element must be a @ref sql_cops "column operator code", and the second element is a column operator description normally provided by using a @ref sql_cop_funcs "column operator function" as in the above example.

    @subsection sql_paging Select With Paging

    There is support for paging query results in the following methods:
    - @ref SqlUtil::Table::getRowIterator()
    - @ref SqlUtil::Table::getSelectSql()
    - @ref SqlUtil::Table::select()
    - @ref SqlUtil::Table::selectRows()

    @note the above list also applies to the corresponding @ref SqlUtil::AbstractTable methods

    Each of these methods takes a @ref select_option_hash "select option hash argument" that allows the \c "limit" and \c "offset" options to be specified to specify the data window for the results.

    If the \c "offset" options is used, then an \c "orderby" option is required which must match some unique constraint or unique index on the table to guarantee the order of results, unless the table has a primary key, in which case the primary key will be used by default if no \c "orderby" option is supplied.

    @par Example:
    Select 100 rows starting at row 200 (the table's primary key will be used for the \c "orderby" option by default): \n
    @code
my *list $rows = $table.selectRows(("where": ("type": "user"), "limit": 100, "offset": 200));
    @endcode
    As an illustration of the different SQL that is generated for different database types; for the above query, here is the SQL generated for Oracle:
    @code
$ds.vselectRows("select * from (select /*+ first_rows(100) *<!--%%-->/ a.*, rownum rnum from (select * from schema.table where type = %v order by type) a where rownum <= %v) where rnum > %v", ("user", 300, 200));
    @endcode
    And for PostgreSQL:
    @code
$ds.vselectRows("select * from public.table where type = %v order by type limit %v offset %v", ("user", 100, 200));
    @endcode

    @subsection check_matching_rows Check For At Least One Matching Row

    Use the @ref SqlUtil::Table::findSingle() method to find at least one matching row: 
    @code
my *hash $h = $table.findSingle(("account_type": "CUSTOMER"));
if ($h)
    printf("found 1 customer row: %y\n", $l[0]);
    @endcode

    Also it's possible to use the \c "limit" option to make an efficient check for at least one matching row as in the following example (which is functionally equivalent to the previous example):
    @code
my *hash $h = $table.selectRow(("where": ("account_type": "CUSTOMER"), "limit": 1));
if ($h)
    printf("found 1 customer row: %y\n", $l[0]);
    @endcode

    @section inserting_data Inserting Data into the Database

    The following methods can be used to insert data into the database:
    - @ref SqlUtil::Table::insert(): inserts a single row into a table and commits the transaction
    - @ref SqlUtil::Table::insertNoCommit(): inserts a single row into a table without committing the transaction
    - @ref SqlUtil::Table::insertFromSelect(): inserts data in a table based on a select statement created from the @ref select_option_hash "select option hash" argument and commits the transaction
    - @ref SqlUtil::Table::insertFromSelectNoCommit(): inserts data in a table based on a select statement created from the @ref select_option_hash "select option hash" argument and without committing the transaction

    @see @ref sql_upsert for information about upserting or merging data

    @subsection inserting_data_explicitly Inserting Data Explicitly

    @par Example:
    @code
$table.insert(("id": $id, "name": $name, "created": now_us()));
    @endcode

    Data can be explicitly inserted into the database with immediate values with @ref SqlUtil::Table::insert() and @ref SqlUtil::Table::insertNoCommit() as in the above example.

    @subsection inserting_data_from_select Inserting Data From a Select Statement

    @par Example:
    @code
my int $rows = $table.insertFromSelect(("id", "name", "created"), $source_table, (("columns": ("cid", "fullname", "created"), "where": ("type": "CUSTOMER")))); 
    @endcode

    Data can be inserted into the database based on the results of a select statement with @ref SqlUtil::Table::insertFromSelect() and @ref SqlUtil::Table::insertFromSelectNoCommit() as in the above example.

    The example above would generate a %Qore SQL command like the following:
    @code
return $ds.vexec("insert into schema.table (id,name,created) select cid,fullname,created from schema.source_table where type = %v", ("CUSTOMER"));
    @endcode

    The return value of these methods is the number of rows inserted.  See @ref select_option_hash "select option hash" for more information about how to form the select criteria in these methods.

    @subsection inserting_data_from_iterator Inserting Data from an Iterator Source

    To insert data from an iterator source (such as an @ref Qore::SQL::SQLStatement object), call @ref SqlUtil::Table::insertFromIterator() or @ref SqlUtil::Table::insertFromIteratorNoCommit() as in the following example:

    @par Example:
    @code
# get the rows to be inserted
my list $l = get_table_rows();
# insert the data and commit after every 5000 rows
$table.insertFromIterator($l.iterator(), ("commit_block": 5000));
    @endcode

    The iterator given to the @ref SqlUtil::Table::insertFromIterator() or @ref SqlUtil::Table::insertFromIteratorNoCommit() methods can be any iterator whose @ref Qore::AbstractIterator::getValue() "getValue()" method returns a @ref hash_type "hash".

    @note the @ref SqlUtil::AbstractTable::InsertOptions "insert option" \c "commit_block" can be used to insert a large amount of data in pieces in order to avoid overwhelming the database server's rollback cache

    @section updating_data Updating Data

    The following methods can be used to update data:
    - @ref SqlUtil::Table::update(): updates a single row and commits the transaction
    - @ref SqlUtil::Table::updateNoCommit(): updates a single row and does not commit the transaction

    @par Example:
    @code
my int $rows_updated = t.update(("permission_type": uop_append("-migrated", uop_lower())));
    @endcode

    The example above generates a %Qore SQL command like the following on Oracle and PostgreSQL for example:
    @code
return $ds.vexec("update schema.table set permission_type = lower(permission_type) || '-migrated');
    @endcode
    And the following on MySQL:
    @code
return $ds.vexec("update schema.table set permission_type = concat(lower(permission_type), '-migrated'));
    @endcode

    @section deleting_data Deleting Data

    The following methods can be used to dekete data:
    - @ref SqlUtil::Table::del(): updates the table based on a @ref where_clauses "where clause" and commits the transaction
    - @ref SqlUtil::Table::delNoCommit(): updates the table based on a @ref where_clauses "where clause" and does not commit the transaction
    - @ref SqlUtil::Table::truncate(): truncates the table and commits the transaction releasing the transaction lock on the underlying datasource object
    - @ref SqlUtil::Table::truncateNoCommit(): truncates the table and does not commit the transaction

    @par Example:
    @code
my int $dcnt = $table.del(("record_type": "OLD-CUSTOMER"));
    @endcode

    The above example would generate a %Qore SQL command like the following:
    @code
return $ds.vexec("delete from schema.table where record_type = %v", ("OLD-CUSTOMER"));
    @endcode

    The @ref SqlUtil::Table::del() and @ref SqlUtil::Table::delNoCommit() methods can be used to delete data from the database.

    See @ref where_clauses for information about specifying the criteria for the rows to be deleted.

    @section joins Joining Tables

    Joining tables is made by providing a join specification to the @ref select_option_join "join select option" in
    a @ref select_option_hash "select option hash" as in the following example:
    @code
my *list $rows = $table.selectRows(("columns": ("table.id", "t2.customer_name"), "join": join_inner($table2, "t2", ("id": "altid"))));
    @endcode
    In the above example, \a table is joined with \a table2 on <tt>table.id = table2.altid</tt>.

    Joins on multiple tables are performed by combining the results of @ref sql_op_funcs "join functions" with the @ref plus_operator "+ operator"
    as follows:
    @code
my *list $rows = $table.selectRows(("join": join_inner($table2, "t2", ("id": "altid")) + join_inner($table3, "t3")));
    @endcode
    In the above example, \a table is joined with \a table2 on <tt>table.id = table2.altid</tt> and with \a table3 on an
    automatically detected primary key to foreign key relationship between the two tables.

    Joins are by default made with the primary table; to join with another join table, then give the alias for the table as the first
    argument to the @ref sql_op_funcs "join function" as in the following example:
    @code
my *list $rows = $table.selectRows(("join": join_inner($table2, "t2", ("id": "altid")) + join_inner("t2", $table3, "t3")));
    @endcode
    In the above example, \a table is joined with \a table2 on <tt>table.id = table2.altid</tt> and \a table2 (aliased as \c t2) is joined
    with \a table3 (aliased as \c t3) on an automatically detected primary key to foreign key relationship between the two tables.

    @see @ref select_option_join "join select option"

    @section where_clauses Where Clauses

    Several methods accept a hash of conditions to build a \c "where" clause to restrict the rows that are operated on or returned; for example:
    - @ref SqlUtil::Table::del()
    - @ref SqlUtil::Table::delNoCommit()
    - @ref SqlUtil::Table::findAll()
    - @ref SqlUtil::Table::findSingle()
    - @ref SqlUtil::Table::getRowIterator()
    - @ref SqlUtil::Table::getSelectSql()
    - @ref SqlUtil::Table::insertFromSelect()
    - @ref SqlUtil::Table::insertFromSelectNoCommit()
    - @ref SqlUtil::Table::select()
    - @ref SqlUtil::Table::selectRow()
    - @ref SqlUtil::Table::selectRows()
    - @ref SqlUtil::Table::update()
    - @ref SqlUtil::Table::updateNoCommit()
    - @ref SqlUtil::Table::upsertFromSelect()
    - @ref SqlUtil::Table::upsertFromSelectNoCommit()

    @note the above list also applies to the corresponding @ref SqlUtil::AbstractTable methods

    The where clause or condition hash is made of keys signifying the column names, and either a direct value meaning that the column value has to match exactly, or SQL operators can be given by using the appropriate operator function as the key value.  Each member of the where hash translates to an expression that is combined with \c "AND" in the SQL query; to combine expressions with \c "OR", then use a list of @ref select_option_hash "select option hashes", which will combine each @ref select_option_hash "select option hash" with \c "OR" as in @ref where_list "this example".\n\n

    The where condition hash has the following format:
    - each key gives a column name or a table/alias with column name in dot notation
    - the values are either direct values, meaning that the equality operator (\c "=") is used, or a @ref sql_op_funcs "SQL operator function" for operators in the where clause

    See @ref sql_op_funcs for a list of operator functions.

    @par Where Hash Example:
    @code
my hash $w = (
    "name": "Smith",
    "account_type": op_like("%CUSTOMER%"),
    "id": op_ge(500),
);
    @endcode \n
    The preceding example results in a where clause equivalent to: \c "name = 'Smith' and type like '%CUSTOMER%' and id >= 500", except
    that bind by value is used, so, if used in a context like the following:
    @code
my Table $t($ds, "table");
my *hash $qh = $t.select(("where": $w));
    @endcode \n
    the complete query would look instead as follows:
    @code
$ds.vselect("select * from table where name = %v and account_type like %v and id >= %v", ("Smith", "%CUSTOMER%", 500));
    @endcode

    @anchor where_list
    @par Where List Example:
    @code
my hash $w1 = (
    "name": "Smith",
    "account_type": op_like("%CUSTOMER%"),
    "id": op_ge(500),
);
my hash $w2 = (
    "name": "Jones",
    "account_type": op_like("%VENDOR%"),
    "id": op_ge(2500),
);
my Table $t($ds, "table");
my *hash $qh = $t.select(("where": ($w1, $w2)));
    @endcode \n
    the complete query would look instead as follows:
    @code
$ds.vselect("select * from table where (name = %v and account_type like %v and id >= %v) or (name = %v and account_type like %v and id >= %v)", ("Smith", "%CUSTOMER%", 500, "Jones", "%VENDOR%", 2500));
    @endcode

    @par Code Examples:
    Find a single row in the table where the \c "permission_type" column is a value between \c "US" and \c "UX":\n
    @code
my *hash $row = $table.findSingle(("permission_type": op_between("US", "UX")));
    @endcode
    resulting in an internal SQL command that looks as follows (depending on the database):
    @code
$ds.vselect("select * from table where permission_type between %v and %v limit %v", ("US", "UX", 1));
    @endcode \n
    Delete all rows in the table where the \c "name" column is like \c "%Smith%":\n
    @code
my int $row_count = $table.del(("name": op_like("%Smith%")));
    @endcode
    resulting in an internal SQL command that looks as follows:
    @code
$ds.vexec("delete from table where name like %v", ("%Smith%"));
    @endcode \n
    Find all rows where \c "id" is greater than \c 100 and \c "created" is after \c 2013-03-01:\n
    @code
my *list $rows = $table.findAll(("id": op_gt(100), "created": op_gt(2013-03-01)));
    @endcode
    resulting in an internal SQL command that looks as follows:
    @code
$ds.vexec("select * from table where id > %v and created > %v", (100, 2013-03-01));
    @endcode \n

    @section sql_upsert Upserting or Merging Data

    This module offers a high-level api for "upserting" or merging data from one table into another table through the following methods:
    - @ref SqlUtil::Table::upsert()
    - @ref SqlUtil::Table::upsertNoCommit()
    - @ref SqlUtil::Table::getUpsertClosure()
    - @ref SqlUtil::Table::getUpsertClosureWithValidation()
    - @ref SqlUtil::Table::upsertFromIterator()
    - @ref SqlUtil::Table::upsertFromIteratorNoCommit()
    - @ref SqlUtil::Table::upsertFromSelect()
    - @ref SqlUtil::Table::upsertFromSelectNoCommit()

    @subsection sql_upsert_single Upsert a Single Row

    @par Example:
    @code
$table.upsert(("id": $id, "name": $name, "account_type": $account_type));
    @endcode

    To upsert or merge a single row in the database, call @ref SqlUtil::Table::upsert() or @ref SqlUtil::Table::upsertNoCommit() with the
    single row to be upserted or merged as a hash as in the preceding example.

    @subsection sql_upsert_many Upserting Many Rows Using An Upsert Closure

    To upsert or merge many rows by using an upsert closure, call @ref SqlUtil::Table::getUpsertClosure() or @ref SqlUtil::Table::getUpsertClosureWithValidation() and provide an example row as an argument to acquire a closure that will be executed on the rest of the rows as in the following example.

    @par Simple Example:
    @code
# get the rows to be inserted
my list $l = get_table_rows();

if ($l) {
    my code $upsert = $table.getUpsertClosure($l[0]);

    on_success $ds.commit();
    on_error $ds.rollback();
 
    # loop through the reference data rows
    map $upsert($1), $l;
}
    @endcode

    @par Complex Example With Callbacks:
    @code
# set the upsert strategy depending on the use case
my int $upsert_strategy = $verbose ? AbstractTable::UpsertSelectFirst : AbstractTable::UpsertAuto;

# hash summarizing changes
my hash $sh;

# get the rows to be inserted
my list $l = get_table_rows();

if ($l) {
    # get the upsert closure to use based on the first row to be inserted
    my code $upsert = $table.getUpsertClosure($l[0], $upsert_strategy);

    on_success $ds.commit();
    on_error $ds.rollback();

    # loop through the reference data rows
    foreach my hash $h in ($l) {
        my int $code = $upsert($h);
        if ($code == AbstractTable::UR_Unchanged)
            continue;

        my string $change = AbstractTable::UpsertResultMap{$code};
        ++$sh{$change};

        if (!$verbose) {
            printf(".");
            flush();
        }
        else if ($verbose > 1)
            printf("*** reference data %s: %y: %s\n", $table.getName(), $h, $change);
    }

    # show table summary
    if ($sh)
        printf("*** reference data %s: %s\n", $table.getName(), (foldl $1 + ", " + $2, (map sprintf("%s: %d", $1.key, $1.value), $sh.pairIterator())));
    else
        printf("*** reference data %s: OK\n", $table.getName());
}
    @endcode

    @subsection sql_upsert_from_iterator Upserting Many Rows from an Iterator Source

    To upsert or merge many rows from an iterator source (such as an @ref Qore::SQL::SQLStatement object), call @ref SqlUtil::Table::upsertFromIterator() or @ref SqlUtil::Table::upsertFromIteratorNoCommit() as in the following example:

    @par Simple Example:
    @code
# get the rows to be inserted
my list $l = get_table_rows();
$table.upsertFromIterator($l.iterator());
    @endcode

    @par Complex Example With Callbacks:
    @code
# set the upsert strategy depending on the use case
my int $upsert_strategy = $verbose ? AbstractTable::UpsertSelectFirst : AbstractTable::UpsertAuto;

# get the rows to be inserted
my list $l = get_table_rows();

my code $callback = sub (string $table_name, hash $row, int $result) { 
    if ($result == AbstractTable::UR_Unchanged)
        return;
    my string $change = AbstractTable::UpsertResultMap{$result};
    if ($verbose)
        printf("*** reference data %s: %y: %s\n", $table_name, $row, $change); 
};

my hash $sh = $table.upsertFromIterator($l.iterator(), $upsert_strategy, False, ("info_callback": $callback, "commit_block": 5000));
if ($sh)
    printf("*** reference data %s: %s\n", $table.getName(), (foldl $1 + ", " + $2, (map sprintf("%s: %d", $1.key, $1.value), $sh.pairIterator())));
else
    printf("*** reference data %s: OK\n", $table.getName());
    @endcode

    The iterator given to the @ref SqlUtil::Table::upsertFromIterator() or @ref SqlUtil::Table::upsertFromIteratorNoCommit() methods can be any iterator whose @ref Qore::AbstractIterator::getValue() "getValue()" method returns a @ref hash_type "hash".

    @note the @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c "commit_block" can be used to insert a large amount of data in pieces in order to avoid overwhelming the database server's rollback cache

    @subsection sql_upsert_from_select Upserting Many Rows from a Select Statement

    To upsert or merge many rows from a select statement, use @ref SqlUtil::Table::upsertFromSelect() or @ref SqlUtil::Table::upsertFromSelectNoCommit() as in the following example:

    @par Simple Example:
    @code
$table.upsertFromSelect($table2, ("where": ("account_type": "CUSTOMER")));
    @endcode

    @par Complex Example With Callbacks:
    @code
# set the upsert strategy depending on the use case
my int $upsert_strategy = $verbose ? AbstractTable::UpsertSelectFirst : AbstractTable::UpsertAuto;

my code $callback = sub (string $table_name, hash $row, int $result) { 
    if ($result == AbstractTable::UR_Unchanged)
        return;
    my string $change = AbstractTable::UpsertResultMap{$result};
    if ($verbose)
        printf("*** reference data %s: %y: %s\n", $table_name, $row, $change); 
};

my hash $sh = $table.upsertFromSelect($table2, ("where": ("account_type": "CUSTOMER")), $upsert_strategy, False, ("info_callback": $callback, "commit_block": 5000));
if ($sh)
    printf("*** reference data %s: %s\n", $table.getName(), (foldl $1 + ", " + $2, (map sprintf("%s: %d", $1.key, $1.value), $sh.pairIterator())));
else
    printf("*** reference data %s: OK\n", $table.getName());
    @endcode

    The source table does not have to be in the same database or even of the same database type (ie you can upsert to and from any database type supported by SqlUtil).

    @note the @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c "commit_block" can be used to insert a large amount of data in pieces in order to avoid overwhelming the database server's rollback cache

    @subsection sql_upsert_with_delete Upserting Many Rows and Deleting Unwanted Rows

    Call any of the batch upsert methods with @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others set to @ref Qore::True "True" to perform a batch upsert / merge operation on a table, and then scan the table and delete any unwanted rows.  If there are no rows to be deleted, these calls have very similar performance to the batch upsert method calls without any deletions, however, if there are rows to be deleted, then the entire source table must be iterated to compare each row to valid data to delete the rows that do not belong.  Therefore for large tables this can be an expensive operation.

    The only difference in the following examples and the preceding ones is that @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True" in these examples.

    @par Simple Example:
    @code
# get the rows to be inserted
my list $l = get_table_rows();
$table.upsertFromSelect($table2, ("where": ("account_type": "CUSTOMER")), AbstractTable::UpsertAuto, ("delete_others": True, "commit_block": 5000));
    @endcode

    @par Complex Example With Callbacks:
    @code
# set the upsert strategy depending on the use case
my int $upsert_strategy = $verbose ? AbstractTable::UpsertSelectFirst : AbstractTable::UpsertAuto;

# get the rows to be inserted
my list $l = get_table_rows();

my code $callback = sub (string $table_name, hash $row, int $result) { 
    if ($result == AbstractTable::UR_Unchanged)
        return;
    my string $change = AbstractTable::UpsertResultMap{$result};
    if ($verbose)
        printf("*** reference data %s: %y: %s\n", $table_name, $row, $change); 
};

my hash $sh = $table.upsertFromSelect($table2, ("where": ("account_type": "CUSTOMER")), $upsert_strategy, ("delete_others": True, "info_callback": $callback, "commit_block": 5000));
if ($sh)
    printf("*** reference data %s: %s\n", $table.getName(), (foldl $1 + ", " + $2, (map sprintf("%s: %d", $1.key, $1.value), $sh.pairIterator())));
else
    printf("*** reference data %s: OK\n", $table.getName());
    @endcode

    @note the @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c "commit_block" can be used to insert a large amount of data in pieces in order to avoid overwhelming the database server's rollback cache

    @subsection sql_upsert_strategies Upsert Strategies
    The approach used is based on one of the following strategies (see @ref upsert_options):
    - @ref SqlUtil::AbstractTable::UpsertAuto "AbstractTable::UpsertAuto": if the target table is empty, then @ref SqlUtil::AbstractTable::UpsertInsertFirst is used, otherwise @ref SqlUtil::AbstractTable::UpsertUpdateFirst is used
    - @ref SqlUtil::AbstractTable::UpsertInsertFirst "AbstractTable::UpsertInsertFirst": first an insert will be attempted, if it fails due to a duplicate key, then an update will be made; this strategy should be used if more inserts will be made than updates
    - @ref SqlUtil::AbstractTable::UpsertUpdateFirst "AbstractTable::UpsertUpdateFirst": first an update will be attempted, if it fails due to missing data, then an insert is performed; this strategy should be used if more updates will be made then inserts
    - @ref SqlUtil::AbstractTable::UpsertSelectFirst "AbstractTable::UpsertSelectFirst": first a select is made on the unique key, if the data to be updated is equal, nothing is done and @ref upsert_results "upsert result" @ref SqlUtil::AbstractTable::UR_Unchanged is returned

    @note @ref SqlUtil::AbstractTable::UpsertSelectFirst "AbstractTable::UpsertSelectFirst" is the only upsert strategy that can return @ref SqlUtil::AbstractTable::UR_Unchanged and @ref SqlUtil::AbstractTable::UR_Updated; the @ref SqlUtil::AbstractTable::UpsertSelectFirst "AbstractTable::UpsertSelectFirst" strategy should be used when verbose reporting is required, particularly if it's necessary to report the actual number of changed rows.
*/

/** @page schema_management Schema Management

    @tableofcontents

    @section schema_management_intro Introduction to Schema Management

    Most schema management is performed by using the @ref SqlUtil::Database "Database" class (which is a wrapper for the @ref SqlUtil::AbstractDatabase "AbstractDatabase" class).

    The most complex object is the @ref SqlUtil::Table "Table", which has its own @ref table_management "section".

    One of the primary goals of schema management in %SqlUtil is to facilitate automatic schema management from a database-independent schema
    description. The idea is that a schema can be described in a generic way and then %SqlUtil can use the generic schema description to align
    the database with the description.  Aligning in %SqlUtil is performed as follows:
    - if the object does not exist, then it is created
    - if the object exists, but does not match the description, it is either:
      - dropped and recreated, or
      - modified in place
    - if the object exists and matches, then nothing is done

    Unfortuntely, it's not currently possible to describe all database objects in a generic way (and it probably never will be); in particular,
    functions, triggers, and other objects based on procedural code or database-specific functionality have to be defined in their 
    database-specific formats.

    The following is a table describing the alignment support for various objects supported by %SqlUtil; for database-specific objects, see the
    database-specific %SqlUtil module:
    - <a href="../../MysqlSqlUtil/html/index.html">MysqlSqlUtil</a>
    - <a href="../../OracleSqlUtil/html/index.html">OracleSqlUtil</a>
    - <a href="../../PgsqlSqlUtil/html/index.html">PgsqlSqlUtil</a>

    |!Database Object|!Alignment Type
    |@ref SqlUtil::AbstractColumn "Columns"|aligned in place
    |@ref SqlUtil::AbstractConstraint "Constraints"|dropped and recreated
    |@ref SqlUtil::AbstractFunction "Functions" and @ref SqlUtil::AbstractFunction "Procedures"|dropped and recreated
    |@ref SqlUtil::AbstractIndex "Indexes"|dropped and recreated
    |@ref SqlUtil::AbstractSequence "Sequences"|dropped and recreated
    |@ref SqlUtil::AbstractTrigger "Triggers"|dropped and recreated
    |@ref SqlUtil::Table "Tables"|aligned in place

    @note
    - For objects that are dropped and recreated, renaming the object is generally supported if the underlying database server supports
    renaming.
    - Schemas (and other objects) can also be dropped based on a generic description (or descriptions derived from the database); see 
    @ref SqlUtil::Database::getDropSchemaSql()

    @section creating_new_objects Creating New Objects

    New objects are generally creating using appropriate methods from the @ref SqlUtil::Database "Database" class, such as the following:
    - @ref SqlUtil::Database::makeFunction() "Database::makeFunction()"
    - @ref SqlUtil::Database::makeProcedure() "Database::makeProcedure()"
    - @ref SqlUtil::Database::makeSequence() "Database::makeSequence()"
    - @ref SqlUtil::Database::makeTable() "Database::makeTable()"

    Tables can also be created by instantiating a @ref SqlUtil::Table "Table" object (see @ref SqlUtil::Table::constructor()).

    Each database driver may provide additional objects (such as types or materialized views, etc); see driver-specific documentation for more
    information.

    @section retrieving_objects Retrieving Objects from the Database

    Existing objects can be retrieved from the database using appropriate methods from the @ref SqlUtil::Database "Database" class,
    such as the following:
    - @ref SqlUtil::Database::getFunction() "Database::getFunction()"
    - @ref SqlUtil::Database::getProcedure() "Database::getProcedure()"
    - @ref SqlUtil::Database::getSequence() "Database::getSequence()"
    - @ref SqlUtil::Database::getTable() "Database::getTable()"

    Each database driver may provide additional objects (such as types or materialized views, etc); see driver-specific documentation for more
    information.
    
    @section listing_objects Listing Objects

    Listing database objects can be performed using appropriate methods from the @ref SqlUtil::Database "Database" class, such as the following:
    - @ref SqlUtil::Database::listFunctions() "Database::listFunctions()"
    - @ref SqlUtil::Database::listProcedures() "Database::listProcedures()"
    - @ref SqlUtil::Database::listSequences() "Database::listSequences()"
    - @ref SqlUtil::Database::listTables() "Database::listTables()"
    - @ref SqlUtil::Database::listViews() "Database::listViews()"
    
    Alternatively, iterators for lists of objects can be acquired with the following methods:
    - @ref SqlUtil::Database::functionIterator() "Database::functionIterator()"
    - @ref SqlUtil::Database::procedureIterator() "Database::procedureIterator()"
    - @ref SqlUtil::Database::sequenceIterator() "Database::sequenceIterator()"
    - @ref SqlUtil::Database::tableIterator() "Database::tableIterator()"
    - @ref SqlUtil::Database::viewIterator() "Database::viewIterator()"

    @section interdependent_tables Working With Interdependent Tables

    The @ref SqlUtil::Tables class manages a group of tables and the foreign key dependencies between the tables.
    This class is useful when managing an entire schema, particularly in the context of manual changes to
    a schema, such as a schema upgrade or downgrade for complex scenarios that are beyond the capabilities of
    the automatic schema and table alignment code.

    Below you can find some examples of what the @ref SqlUtil::Tables "Tables" class can do.

    @par Cache All Tables from a Schema
    To load all tables in a particular schema into an object of class @ref SqlUtil::Tables "Tables":
    @code
my Tables $tables($ds);
    @endcode

    @par Drop All Foreign Constraints to a Table
    The following is an example of how all foreign constraints to a particular table can be dropped:
    @code
my *list $l = $tables.getDropAllForeignConstraintsOnTableSql("table_name", ("sql_callback_executed": True));
{
    on_success $ds.commit();
    on_error $ds.rollback();
    map $ds.execRaw($1), $l;
}
    @endcode
    This can be useful when performing a schema change and a table will be dropped, for example.

    @note by setting the @ref sql_callback_executed "sql_callback_executed option" to @ref Qore::True "True", the affected constraints and linked unique constraints are also updated in the cached table objects, see @ref sql_callback_executed for more information

    @par Drop a Constraint If It Exists
    The following code provides an example of how to unconditionally drop a constraint from a table and update the internal links between unique constraints and foreign constraints (if a foreign constraint is dropped):
    @code
my *string $sql = $tables.getDropConstraintIfExistsSql("table_name", "fk_table_name_other_table", ("sql_callback_executed": True));
if ($sql) {
    on_success $ds.commit();
    on_error $ds.rollback();
    $ds.execRaw($sql);
}
    @endcode

    @note by setting the @ref sql_callback_executed "sql_callback_executed option" to @ref Qore::True "True", the affected constraints and linked unique constraints are also updated in the cached table objects, see @ref sql_callback_executed for more information

    @par Rename a Table
    The following code gives an example of renaming a table and updating all foreign constraint and unique key links in impacted tables if the source table exists and the target name does not exist:
    @code
my *string $sql = $tables.getRenameTableIfExistsSql("old_table_name", "new_table_name", ("sql_callback_executed": True));
if ($sql) {
    on_success $ds.commit();
    on_error $ds.rollback();
    $ds.execRaw($sql);
}
    @endcode

    @note by setting the @ref sql_callback_executed "sql_callback_executed option" to @ref Qore::True "True", the affected constraints and linked unique constraints are also updated in the cached table objects, see @ref sql_callback_executed for more information

    @section aligning_schemas Aligning Schemas With a Template

    A schema template can be created any way required (ie by hand, or by retrieving the description from another database), but typically they will be created from a @ref schema_desc_hash "schema description hash".

    The following code provides an example of creating a schema template and using it to align the schema in the database with the template using callbacks:
    @code
my int $change_count;
my code $info_callback = sub (string $str, int ac, string type, string name, *string table, *string new_name, *string info) {
    if (ac != AbstractDatabase::AC_NotFound && ac != AbstractDatabase::AC_Unchanged)
        ++$change_count;
    if ($verbose)
        printf("*** %s\n", $str);
    else {
        print(AbstractDatabase::ActionLetterMap{ac});
        flush();
    }
};

my code $sql_callback = sub (string $str) {
    if ($verbose > 1)
        printf("%s\n", $str);
    $ds.execRaw($str);
};

my hash $callback_opts = ("info_callback": $info_callback, "sql_callback": $sql_callback, "sql_callback_executed": True);

my Database $db($ds);
my Tables $table_cache();
$db.getAlignSql($schema_template, $callback_opts, $table_cache);
    @endcode

    @subsection schema_desc_hash Schema Description Hash
    
    The schema description hash has the following structure:
    - \c tables: a hash of @ref table_desc_hash "table description hashes" keyed by table name; each entry describes a table
    - \c sequences: a hash of sequence description hashes keyed by sequence name; each entry describes a sequence
    - \c functions: a hash of function description hashes keyed by function name; each entry describes a function
    - \c procedure: a hash of procedure description hashes keyed by procedure name; each entry describes a procedure    
    - \c driver: this key can optionally contain a hash keyed by driver name which contains a hash of values that will be added to the schema description hash before processing; this way a schema description hash can contain all the information required for the schema including driver-specific options; any driver-specific options will overwrite values in the top level of the hash if there are duplicate hash keys

    Each database driver may provide additional objects (such as types or materialized views, packages, etc); see 
    driver-specific documentation for more information.

    The following is an example of a schema description hash:
    @code
const Options = (
    "driver": (
        "oracle": (
            "compute_statistics": True,
            "character_semantics": True,
        ),
    ),
    );

const T_Customers = (
    "columns": (
        "id": (
            "qore_type": Type::Number, 
            "size": 14,
            "notnull": True,
            # this column is normally populated from a sequence by a trigger, but mysql
            # enforces not null constraints before "before insert" triggers are fired, so
            # we can't use our emulated sequences on mysql with a not null constraint on this
            # column, also since this column is a part of the primary key for this table,
            # we can't leave it nullable, so we use auto_increment
            "driver": ("mysql": ("native_type": "bigint", "unsigned": True, "auto_increment": True, "size": NOTHING)),
        ),
        "family_name": (
            "qore_type": Type::String,
            "size": 120,
            "notnull": True,
        ),
        "first_names": (
            "qore_type": Type::String,
            "size": 240,
            "notnull": True,
        ),
        "created": (
            "qore_type": Type::Date,
            "notnull": True,
            # this column is populated by a trigger, but mysql enforces not null
            # constraints before "before insert" triggers are fired, so for mysql only
            # this column must be nullable
            "driver": ("mysql": ("notnull": False)),
        ),
        "modified": (
            "qore_type": Type::Date,
        ),
    ),
    "primary_key": ("name": "pk_customers", "columns": "id"),
    "indexes": (
        "sk_customers_name": ("columns": "family_name"),
    ),
    "driver": (
        "pgsql": (
            "functions": (
                "trig_customers()": "returns trigger language plpgsql as $function$
begin
  if (tg_op = 'INSERT') then
    if new.created is null then
      select current_timestamp into new.created;
    end if;
  end if;
  if new.modified is null  then
    select current_timestamp into new.modified;
  end if;
  return new;
end;
$function$", #",
            ),
        ),
    ),
    "triggers": (
        "driver": (
            "oracle": (
                "trig_customers": "BEFORE INSERT OR UPDATE ON customers
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
begin
  if inserting then
    if :new.id is null then
      select seq_customers.nextval into :new.id from dual;
    end if;
    if :new.created is null then
      :new.created := sysdate;
    end if;
  end if;
  --
  if :new.modified is null or :new.modified = :old.modified then
    :new.modified := sysdate;
  end if;
end;",
            ),
            "pgsql": (
                "trig_customers": "before insert or update on customers for each row execute procedure trig_customers()",
            ),
            "mysql": (
                "trig_customers_insert": "before insert on customers for each row
begin
  if new.created is null then
    set new.created = now();
  end if;
  if new.modified is null then
    set new.modified = now();
  end if;
end",
                "trig_customers_update": "before update on customers for each row
begin
  if new.modified is null or new.modified = old.modified then
    set new.modified = now();
  end if;
end",
            ),
        ),
    ),
);

const SequenceList = (
    "seq_customers": hash(),
    );

const Sequences = (
    "driver": (
        "oracle": SequenceList,
        "pgsql": SequenceList,
    ),
    );

const Tables = (
    "customers": T_Customers,
    );

const Schema = (
    "sequences": Sequences,
    "tables": Tables,
    );
    @endcode

    @section table_management Table Management

    The main class to be used for table management is @ref SqlUtil::Table "Table" (which is a wrapper for @ref SqlUtil::AbstractTable "AbstractTable").  This class can be used both for building a table from scratch or for retrieving the structure of a table from the database.

    @subsection creating_new_tables Creating New Tables

    Tables can be created manually, by creating a @ref SqlUtil::Table "Table object" and then populating the table with columns, indexes, etc, and then calling @ref SqlUtil::Table::create() for example.
    The following methods can be used for adding new attributes to a table:
    - @ref SqlUtil::Table::addColumn()
    - @ref SqlUtil::Table::addPrimaryKey()
    - @ref SqlUtil::Table::addUniqueConstraint()
    - @ref SqlUtil::Table::addIndex()
    - @ref SqlUtil::Table::addForeignConstraint()
    - @ref SqlUtil::Table::addCheckConstraint()
    - @ref SqlUtil::Table::addTrigger()

    Note that if the table is known to be in the database already (for example, if the original table info was read from the database), then calling one of the above methods will also effect the change in the database immediately.

    Alternatively, the following methods can be used to retrieve the SQL that can be executed for the particular database driver that the @ref SqlUtil::Table object is based on:
    - @ref SqlUtil::Table::getAddColumnSql()
    - @ref SqlUtil::Table::getAddPrimaryKeySql()
    - @ref SqlUtil::Table::getAddUniqueConstraintSql()
    - @ref SqlUtil::Table::getAddIndexSql()
    - @ref SqlUtil::Table::getAddForeignConstraintSql()
    - @ref SqlUtil::Table::getAddCheckConstraintSql()
    - @ref SqlUtil::Table::getAddTriggerSql()

    Otherwise a table can be built from a @ref table_desc_hash "table description hash" with one of the following methods:
    - @ref SqlUtil::Table::constructor()
    - @ref SqlUtil::Table::setupTable()
    
    Table description hashes are also used when aligning tables to a template, which can be used to automate schema upgrades; see @ref SqlUtil::Table::getAlignSql(), @ref SqlUtil::Database::getAlignSql(), and @ref table_desc_hash "table description hash" for more information.

    @subsection retrieving_table_info Retrieving Table Information

    The following methods retrieve table information from the database:
    - @ref SqlUtil::Table::cache() "Table::cache()": this method reads in the entire table configuration immediately
    - @ref SqlUtil::Table::describe() "Table::describe()": this method returns an object of class @ref SqlUtil::Columns describing the table's columns 
    - @ref SqlUtil::Table::getPrimaryKey() "Table::getPrimaryKey()": this method returns an object of class @ref SqlUtil::AbstractPrimaryKey describing the table's primary key if it has one
    - @ref SqlUtil::Table::getIndexes() "Table::getIndexes()": this method returns an object of class @ref SqlUtil::Indexes describing the table's indexes 
    - @ref SqlUtil::Table::getForeignConstraints() "Table::getForeignConstraints()": this method returns an object of class @ref SqlUtil::ForeignConstraints describing the table's foreign constraints
    - @ref SqlUtil::Table::getConstraints() "Table::getConstraints()": this method returns an object of class @ref SqlUtil::Constraints describing the table's non-foreign constraints
    - @ref SqlUtil::Table::getTriggers() "Table::getTriggers()": this method returns an object of class @ref SqlUtil::Triggers describing the table's triggers

    The @ref SqlUtil::Table::cache() method can be used to retrieve all table information from the database immediately as in the following example:
    @code
my Table $table($ds, "table_name");
$table.cache();
my string $sql = $table.getCreateSqlString();
    @endcode

    Use the following code to test if a table exists:
    @code
my Table $table($ds, "table_name");
if ($table.checkExistence())
    printf("table exists\n");
    @endcode

    Or the following:
    @code
Database $db($ds);
*AbstractTable $table = $db.getTable("table_name");
    @endcode

    @subsection aligning_tables Aligning Tables With a Template

    Template tables can be created any way required (ie by hand, or by retrieving the description from another database), but typically they will be created from a @ref table_desc_hash "table description hash".

    The following code provides an example of creating a template table and using it to align a table in the database with the template using callbacks:
    @code
my int $change_count;
my code $info_callback = sub (string $str, int ac, string type, string name, *string table, *string new_name, *string info) {
    if (ac != AbstractDatabase::AC_NotFound && ac != AbstractDatabase::AC_Unchanged)
        ++$change_count;
    if ($verbose)
        printf("*** %s\n", $str);
    else {
        print(AbstractDatabase::ActionLetterMap{ac});
        flush();
    }
};

my code $sql_callback = sub (string $str) {
    if ($verbose > 1)
        printf("%s\n", $str);
    $ds.execRaw($str);
};

my hash $callback_opts = ("info_callback": $info_callback, "sql_callback": $sql_callback, "sql_callback_executed": True);

my Table $template_table($ds, $table_desc_hash, "table_name");
my Table $db_table($ds, "table_name");
$db_table.getAlignSql($template_table, $callback_opts);
    @endcode

    @subsection table_desc_hash Table Description Hash
    
    Table description hashes have the following structure:
    - \c columns: (required) a hash of column information keyed by column name; the values are @ref column_desc_hash "column description hashes"
    - \c primary_key: (optional) a @ref pk_desc_hash "primary key description hash" describing the primary key for the table
    - \c indexes: (optional) a hash of index information keyed by index name; the values are @ref index_desc_hash "index description hashes"
    - \c triggers: (optional) a hash of trigger information keyed by trigger name; the values are the trigger source code; since triggers are driver-dependent, a driver-independent table description would include trigger hashes under the \c drivers key and the driver key name under that; see below for an example
    - \c foreign_constraints: (optional) a hash of foreign constraint information keyed by constraint name; the values are @ref fk_desc_hash "foreign constraint hashes"
    - \c unique_constraints: (optional) a hash of unique constraint information keyed by constraint name; the values are @ref uk_desc_hash "unique constraint hashes"
    - \c driver: this key can optionally contain a hash keyed by driver name which contains a hash of values that will be added to the table description hash before processing; this way a table description hash can contain all the information required for the table including driver-specific options; any driver-specific options will overwrite values in the top level of the hash if there are duplicate hash keys, see below for an example

    Here is an example of a table description hash:
    @code
my hash $table_desc = (
    "columns": (
        "domain": (
            "qore_type": Type::String, 
            "size": 240,
            "notnull": True,
        ),
        "keyname": (
            "qore_type": Type::String,
            "size": 240,
            "notnull": True,
        ),
        "value": (
            "qore_type": Type::String,
            "size": 4000,
        ),
        "created": (
            "qore_type": Type::Date,
            "notnull": True,
            "driver": (
                "oracle": (
                    "native_type": "date",
                ),
            ),
        ),
        "modified": (
            "qore_type": Type::Date,
            "driver": (
                "oracle": (
                    "native_type": "date",
                ),
            ),
        ),
    ),
    "primary_key": ("name": "pk_system_properties", "columns": ("domain", "keyname")),
    "indexes": (
        "sk_system_properties_domain": ("columns": "domain"),
        "driver": (
            "oracle": (
                "pk_system_properties": ("columns": ("domain", "keyname"), "unique": True),
            ),
        ),
    ),
    "driver": (
        "pgsql": (
            "functions": (
                "trig_system_properties()": "returns trigger language plpgsql as $function$
begin
  if (tg_op = 'INSERT') then
    if new.created is null then
      select current_timestamp into new.created;
    end if;
  end if;
  if new.modified is null  then
    select current_timestamp into new.modified;
  end if;
  return new;
end;
$function$",
            ),
        ),
    ),
    "triggers": (
        "driver": (
            "oracle": (
                "trig_system_properties": "BEFORE INSERT OR UPDATE ON SYSTEM_PROPERTIES
REFERENCING NEW AS NEW OLD AS OLD
FOR EACH ROW
begin
  if inserting then
    if :new.created is null then
      :new.created := sysdate;
    end if;
  end if;
  --
  if :new.modified is null or :new.modified = :old.modified then
    :new.modified := sysdate;
  end if;
end;",
            ),
            "pgsql": (
                    "trig_system_properties": "before insert or update on system_properties for each row execute procedure trig_system_properties()",
            ),
            "mysql": (
            ),
        ),
    ),
);
    @endcode

    @note
    - some databases will automatically create indexes for you when you create primary keys and unique constraints; some do not (ex: oracle).  In the above example, an index is created explicitly for the primary key constraint for oracle only.
    - the above example includes an additional driver-specific key for the \c "pgsql" driver: \c "functions" which is used by the PgsqlSqlUtil module to create trigger functions used by the table's trigger.

    @subsection column_desc_hash Column Description Hash

    Column description hashes have the following structure:
    - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion
    - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
    - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
    - \c scale: for numeric data types, this value gives the scale
    - \c default_value: the default value for the column
    - \c comment: an optional comment for the column
    - \c notnull: if the column should have a "not null" constraint on it; if missing the default value is @ref Qore::False "False"
    - \c driver: this key can optionally contain a hash keyed by driver name which contains a hash of values that will be added to the column description hash before processing; this way a column description hash can contain all the information required for the column including driver-specific options; any driver-specific options will overwrite values in the top level of the hash if there are duplicate hash keys, see below for an example

    Note that the above structure is an extension of the fields in @ref SqlUtil::AbstractTable::ColumnDescOptions, adding \c notnull and \c driver keys for additional information to create the column in the table.

    Here is an example of a column description hash:
    @code
my hash $date_col_desc = (
    "qore_type": Type::Date,
    "notnull": True,
    "driver": (
        "oracle": (
            "native_type": "date",
        ),
    ),
);
    @endcode

    The above hash describes a column that will be have \c TIMESTAMP type on most databases, but \c DATE on Oracle.

    @subsection pk_desc_hash Primary Key Description Hash

    The primary key description hash has the following keys:
    - \c name: (required) the name of the primary key
    - \c columns: (required) a single column name or a list of column names making up the primary key

    Here is an example of a primary key description hash:
    @code
my hash $pk_desc = (
    "name": "pk_queue",
    "columns": "queueid",
);
    @endcode

    @subsection fk_desc_hash Foreign Constraint Description Hash

    The foreign constraint description hash has the following keys:
    - \c columns: (required) a single column name or a list of column names in the current table making up the foreign constraint
    - \c table: (required) a string giving the name of the table the foreign constraint is on
    - \c target_columns: (optional) this key is only necessary if the columns in the foreign table have different names than in the current table; if so, it must be assigned to a single column name or a list of column names in the foreign table; if this key is present then the same number of columns must appear in each key

    The following is an example of a foreign key description hash:
    @code
my hash $fk_desc = (
    "columns": "queueid",
    "tables": "queues",
);
    @endcode

    @subsection uk_desc_hash Unique Constraint Description Hash

    The unique constraint description hash has the following key:
    - \c columns: (required) a single column name or a list of column names in the current table making up the unique constraint

    The following is an example of a unique constraint description hash:
    @code
my hash $uk_desc = (
    "columns": ("type", "name"),
);
    @endcode

    @subsection index_desc_hash Index Description Hash

    Index description hashes have the following structure:
    - \c columns: (required) a single column or a list of column names making up the index
    - \c unique: a boolean value indicating if the index is unique or not, if missing, then the index is assumed to e not unique

    The following is an example of an index description hash:
    @code
my hash $ix_desc = (
    "columns": ("type", "name"),
    "unique": True,
);
    @endcode

    @section callbacks Callbacks
    
    Most of the SqlUtil methods that return SQL strings also accept an option hash where callbacks an be set.  Callbacks can be used
    to display detailed information about long-running operations, such as schema or data alignment for complex schemas or large
    data sets, or as a generic framework for executing and logging SQL operations.

    @subsection info_callback SQL Info CallBack Closure or Call Ceference

    The \c "info_callback" @ref closure "closure" or @ref call_reference "call reference" is called with information about the current SQL
    operation and can be specified as in the following example:
    @code
my int $change_count;
my code $info_callback = sub (string $str, int ac, string type, string name, *string table, *string new_name, *string info) {
    if (ac != AbstractDatabase::AC_NotFound && ac != AbstractDatabase::AC_Unchanged)
        ++$change_count;
    if ($verbose)
        printf("*** %s\n", $str);
    else {
        print(AbstractDatabase::ActionLetterMap{ac});
        flush();
    }
};

my hash $callback_opts = ("info_callback": $info_callback);
$db.getAlignSql($schema, $callback_opts);
    @endcode

    @subsection sql_callback SQL Raw/DDL CallBack Closure or Call Ceference

    The \c "sql_callback" @ref closure "closure" or @ref call_reference "call reference" is called with an SQL string suitable for raw execution for each SQL command that is returned
    or generated for a particular operation and can be specified as in the following example:
    @code
my code $sql_callback = sub (string $str) {
    $ds.execRaw($str);
    if ($verbose > 1)
        printf("%s\n", $str);
};

my hash $callback_opts = ("sql_callback": $sql_callback, "sql_callback_executed": True);
$db.getAlignSql($schema, $callback_opts);
    @endcode

    @note this callback is used for DDL execution and does not use bound arguments; for SQL data operations, the @ref sqlarg_callback is used instead

    @subsection sql_callback_executed SQL CallBack Executed Flag

    If the \c "sql_callback_executed" flag is set to @ref Qore::True "True" then the called method knows that the changes are made in the database and the internal representation of the affected object(s) is also updated accordingly.  Here is an example:
    @code
my code $sql_callback = sub (string $str) {
    if ($verbose > 1)
        printf("%s\n", $str);
    $ds.execRaw($str);
};

my hash $callback_opts = ("sql_callback": $sql_callback, "sql_callback_executed": True);
$db.getAlignSql($schema, $callback_opts);
    @endcode

    @subsection sqlarg_callback SQL Operation Callback Closure or Call Reference

    The \c "sqlarg_callback" @ref closure "closure" or @ref call_reference "call reference" is called with an SQL string and arguments for each SQL command that is executed
    during SQL data operations and can be specified as in the following example:
    @code
my code $sqlarg_callback = sub (string $str, *list $args) {
    if ($verbose > 1)
        printf("SQL: %s\nargs: %y", $str, $args);
};

$table.insertFromIterator($i, $sqlarg_callback);
    @endcode

    @note this callback is used for data operations and is called with bound arguments; for DLL operations, see @ref sql_callback

    @subsection upsert_info_callback Upsert Info Callback

    The \c "info_callback" upsert option key can be assigned to a @ref closure "closure" or @ref call_reference "call reference" that
    is called whenever an row result is available; this callback takes the following arguments:
    - @ref string_type "string" table_name: the name of the table
    - @ref hash_type "hash" row: the row affected
    - @ref int_type "int" result: the upsert result code (see @ref upsert_results) for possible values

    Here is an example of an upsert callback:
    @code
my code $upsert_callback = sub (string $table_name, hash $row, int $result) {
    # verbosity threshold
    my int $t = 0;
    if ($result != AbstractTable::UR_Unchanged)
        ++$change_count;
    else
        $t = 1;

    if ($opt.verbose > t) {
        if ($dot_count) {
            print("\n");
            $dot_count = 0;
        }
        printf("%s reference data %s: %y: %s\n", t ? "+++" : "***", $table_name, $row, AbstractTable::UpsertResultMap{$result}); 
    }
    else {
        ++$dot_count;
        print(AbstractTable::UpsertResultLetterMap{$result});
        flush();
    }
};

my hash $sh = $table.upsertFromIterator($i, $upsert_strategy, False, ("info_callback": $upsert_callback));
    @endcode

    @subsection insert_info_callback Insert Info Callback

    This option is identical to @ref upsert_info_callback, except the \a result argument is always @ref SqlUtil::AbstractTable::UR_Inserted.
*/

#! the SqlUtil namespace contains all the objects in the SqlUtil module
public namespace SqlUtil {
    /* @defgroup SqlTypeConstants SQL Type Constants
        These constants can be used for the \c "qore_type" values when creating columns to specify additional SQL column types
    */
    #@{
    #! specifies a \c VARCHAR column (equivalent to @ref Qore::Type::String)
    public const VARCHAR = "string";

    #! specifies a numeric column (equivalent to @ref Qore::Type::Number)
    public const NUMERIC = "number";

    #! specifies a \c CHAR column
    public const CHAR = "char";

    #! specifies a large variable-length binary column (ie \c BLOB or \c BYTEA, etc)
    public const BLOB = "blob";

    #! specifies a large variable-length character column (ie \c CLOB or \c TEXT, etc)
    public const CLOB = "clob";
    #@}

    /** @defgroup ColumnSizeOptions Column Size Options
        These constants represent the possible values for column size options
     */
    #@{
    #! the data type does not take a size parameter
    public const SZ_NONE = 0;

    #! the data type takes a mandatory size parameter
    public const SZ_MAND = 1;

    #! the data type takes an optional size parameter
    public const SZ_OPT = 2;

    #! the data type is numeric so takes an optional precision and scale
    public const SZ_NUM = 3;
    #@}

    /** @defgroup sql_cops SQL Column Operators
        These are the operators that can be used in the \c "columns" argument for select statements
     */
    #@{
    #! to rename a column on output
    /** @see cop_as()
    */
    public const COP_AS = "as";

    #! to prepend a string to a column on output
    /** @see cop_prepend()
    */
    public const COP_PREPEND = "prepend";

    #! to append a string to a column on output
    /** @see cop_append()
    */
    public const COP_APPEND = "append";

    #! to append a constant value to use as an output column value
    /** @see cop_value()
    */
    public const COP_VALUE = "value";

    #! to return column value in upper case
    /** @see cop_upper()
    */
    public const COP_UPPER = "upper";

    #! to return column value in lower case
    /** @see cop_lower()
    */
    public const COP_LOWER = "lower";

    #! to return distinct values
    /** @see cop_distinct
    */
    public const COP_DISTINCT = "distinct";

    #! to return the minimum value
    /** @see cop_min
    */
    public const COP_MIN = "min";

    #! to return the maximum value
    /** @see cop_max
    */
    public const COP_MAX = "max";

    #! to return the row count
    /** @see cop_count
    */
    public const COP_COUNT = "count";

    #! a hash of default column operator descriptions
    public const DefaultCopMap = (
        COP_AS: (
            "arg": Type::String,
            "code": string sub (string cve, string arg) {
                return sprintf("%s as %y", cve, arg);
            },
        ),
        COP_PREPEND: (
            "arg": Type::String,
            "sqlvalue": True,
            "code": string sub (string cve, string arg) {
                return sprintf("%s||%s", arg, cve);
            },
        ),
        COP_APPEND: (
            "arg": Type::String,
            "sqlvalue": True,
            "code": string sub (string cve, string arg) {
                return sprintf("%s||%s", cve, arg);
            },
        ),
        COP_VALUE: (
            "sqlvalue": True,
            "nocolumn": True,
            "code": string sub (*string cve, any arg) {
                return arg;
            },
        ),
        COP_UPPER: (
            "code": string sub (string cve, any arg) {
                return sprintf("upper(%s)", cve);
            },
        ),
        COP_LOWER: (
            "code": string sub (string cve, any arg) {
                return sprintf("lower(%s)", cve);
            },
        ),
        COP_DISTINCT: (
            "code": string sub (string cve, any arg) {
                return sprintf("distinct %s", cve);
            },
        ),
        COP_MIN: (
            "code": string sub (string cve, any arg) {
                return sprintf("min(%s)", cve);
            },
            "group": True,
        ),
        COP_MAX: (
            "code": string sub (string cve, any arg) {
                return sprintf("max(%s)", cve);
            },
            "group": True,
        ),
        COP_COUNT: (
            "nocolumn": True,
            "code": string sub (*string cve, any arg) {
                return "count(1)";
            },
        ),
        );
    #@}

    /** @defgroup sql_cop_funcs SQL Column Operator Functions
        These are functions that can be used in the \c "columns" argument for select statements:
        - @ref cop_as(): rename columns
        - @ref cop_prepend(): prepend a string to the output of a column
        - @ref cop_append(): append a string to the output of a column
        - @ref cop_value(): return a constant value in a column
        - @ref cop_upper(): return a column in upper case
        - @ref cop_lower(): return a column in lower case

        Column operator functions can be nested as in the following example:
        @par Example:
        @code
my *hash $rows = t.selectRows(("columns": cop_as(cop_lower("permission_type"), "perm"), "where": ("permission_type": "USER"), "limit": 100, "offset": 200));
        @endcode
     */
    #@{
    #! returns a hash with \c cop, \c column, and \c arg keys
    /** @param cop the column operator (one of @ref sql_cops)
        @param column the column name
        @param arg the argument to the operator

        @return a column operator description hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"

        @note Normally this function is not called directly, but rather by the other column operator functions
    */
    public hash sub make_cop(string cop, any column, any arg) {
        switch (column.typeCode()) {
            case NT_HASH:
            case NT_STRING: return ("cop": cop, "column": column, "arg": arg);
            default: throw "MAKE-COLUMN-OPERATOR-ERROR", sprintf("invalid column value passed to make_cop(); got type %y, expecting \"string\" or \"hash\"", column.type());
        }
    }

    #! returns a hash for the \c "as" operator with the given argument
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("columns": ("id", "name", cop_as("errors", "error_count")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)
        @param arg the new name of the output column

        @return a column operator description hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub cop_as(any column, string arg) {
        return make_cop(COP_AS, column, arg);
    }

    #! returns a hash for the \c "prepend" operator with the given argument
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("columns": ("id", cop_prepend("name", "migrated-")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)
        @param arg the text to prepend to the row values in the output column

        @return a column operator description hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub cop_prepend(any column, string arg) {
        return make_cop(COP_PREPEND, column, arg);
    }

    #! returns a hash for the \c "append" operator with the given argument
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("columns": ("id", cop_append("name", "-migrated")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)
        @param arg the text to append (ie concatenate) to the row values in the output column

        @return a column operator description hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub cop_append(any column, string arg) {
        return make_cop(COP_APPEND, column, arg);
    }

    #! returns a hash for the \c "value" operator with the given argument
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("columns": ("id", "name", cop_value(100)), "where": ("type": "user")));
        @endcode

        @param arg the value to be returned in the column

        @return a column operator description hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub cop_value(any arg) {
        return make_cop(COP_VALUE, "", arg);
    }

    #! returns a hash for the \c "upper" operator with the given argument; returns a column value in upper case
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("columns": ("id", cop_upper("name")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a column operator description hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub cop_upper(any column) {
        return make_cop(COP_UPPER, column);
    }

    #! returns a hash for the \c "lower" operator with the given argument; returns a column value in lower case
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("columns": ("id", cop_lower("name")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a column operator description hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub cop_lower(any column) {
        return make_cop(COP_LOWER, column);
    }

    #! returns a hash for the \c "distinct" operator with the given argument; returns distinct column values
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("columns": ("id", cop_distinct("name")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a column operator description hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub cop_distinct(any column) {
        return make_cop(COP_DISTINCT, column);
    }

    #! returns a hash for the \c "min" operator; returns minimum column values
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("columns": (cop_min("id")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a column operator description hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub cop_min(any column) {
        return make_cop(COP_MIN, column);
    }

    #! returns a hash for the \c "max" operator; returns maximum column values
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("columns": (cop_max("id")), "where": ("type": "user")));
        @endcode

        @param column the column specification for the column (string name or dot notation for use in joins)

        @return a column operator description hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub cop_max(any column) {
        return make_cop(COP_MAX, column);
    }

    #! returns a hash for the \c "count" operator; returns row counts
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("columns": ("account_type", cop_count()), "where": ("type": "user"), "groupby": "account_type"));
        @endcode

        @return a column operator description hash corresponding to the arguments for use in the @ref select_option_columns "columns" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub cop_count() {
        return make_cop(COP_COUNT, "");
    }
    #@}

    /** @defgroup sql_uops SQL Update Operators
        These are the operators that can be used in update statements to process column values automatically
     */
    #! a hash of valid update operators
    public const DefaultUopMap = (
        COP_PREPEND: True,
        COP_APPEND: True,
        COP_UPPER: True,
        COP_LOWER: True,
        );
    #@}

    /** @defgroup sql_uop_funcs SQL Update Operator Functions
        These are functions that can be used as the values of update keys in select statements:
        - @ref uop_prepend(): prepend a string to the output of a column
        - @ref uop_append(): append a string to the output of a column
        - @ref uop_upper(): return a column in upper case
        - @ref uop_lower(): return a column in lower case

        Update operator functions can be nested as in the following example:
        @par Example:
        @code
my int $rows_updated = t.update(("permission_type": uop_append("-migrated", uop_lower())));
        @endcode
     */
    #@{
    #! returns a hash with \c uop, \c arg, and \c nest keys
    /** @param uop the update operator (one of @ref sql_uops)
        @param arg the argument to the operator
        @param nest any nested operation to the operator

        @return an update operator description hash corresponding to the arguments for use in update statements

        @note Normally this function is not called directly, but rather by the other update operator functions
    */
    public hash sub make_uop(string uop, any arg, *hash nest) {
        return ("uop": uop, "arg": arg, "nest": nest);
    }

    #! returns a hash for the \c "prepend" operator with the given argument
    /** @par Example:
        @code
my int $rows_updated = t.update(("permission_type": uop_prepend("migrated-", uop_lower())));
        @endcode

        @param arg the text to prepend to the row values in the output column
        @param nest any nested operation to the operator

        @return an update operator description hash corresponding to the arguments for use in update statements
    */
    public hash sub uop_prepend(string arg, *hash nest) {
        return make_uop(COP_PREPEND, arg, nest);
    }

    #! returns a hash for the \c "append" or concatenate operator with the given argument
    /** @par Example:
        @code
my int $rows_updated = t.update(("permission_type": uop_append("-migrated", uop_lower())));
        @endcode

        @param arg the text to prepend to the row values in the output column
        @param nest any nested operation to the operator

        @return an update operator description hash corresponding to the arguments for use in update statements
    */
    public hash sub uop_append(string arg, *hash nest) {
        return make_uop(COP_APPEND, arg, nest);
    }

    #! returns a hash for the \c "upper" operator with the given argument; returns a column value in upper case
    /** @par Example:
        @code
my int $rows_updated = t.update(("permission_type": uop_upper()));
        @endcode

        @param nest any nested operation to the operator

        @return an update operator description hash corresponding to the arguments for use in update statements
    */
    public hash sub uop_upper(*hash nest) {
        return make_uop(COP_UPPER, nest);
    }

    #! returns a hash for the \c "lower" operator with the given argument; returns a column value in lower case
    /** @par Example:
        @code
my int $rows_updated = t.update(("permission_type": uop_lower()));
        @endcode

        @param nest any nested operation to the operator

        @return an update operator description hash corresponding to the arguments for use in update statements
    */
    public hash sub uop_lower(*hash nest) {
        return make_uop(COP_LOWER, nest);
    }
    #@}

    /** @defgroup sql_jops SQL Join Operators
        These are the operators that can be used in the @ref select_option_join "join" argument in a @ref select_option_hash "select option hash"

        @note these operators are normally not used directly, but rather are used by the @ref sql_jop_funcs
    */
    #@{
    #! for standard inner joins
    /** @see join_inner()
    */
    public const JOP_INNER = "inner";

    #! for left outer joins
    /** @see join_left()
    */
    public const JOP_LEFT = "left";

    #! for right outer joins
    /** @see join_right()
    */
    public const JOP_RIGHT = "right";

    #! a hash of valid column operators
    public const JopMap = (
        JOP_INNER: "inner",
        JOP_LEFT: "left outer",
        JOP_RIGHT: "right outer",
        );
    #@}

    /** @defgroup sql_jop_funcs SQL Join Operator Functions
        These are functions that can be used in the @ref select_option_join "join" argument in a @ref select_option_hash "select option hash":
        - join_inner(): specifies an inner join
        - join_left(): specifies a left outer join
        - join_right(): specifies a right outer join

        @note for join functions, explicit join columns do not need to be specified in the case that a foreign key in one table exists to the primary key of the other table; in this case this information is assumed for the join automatically
     */
    #@{
    #! returns a hash keyed with the table name assigned to a hash with \c jop, \c table, \c jcols, \c cond, \c alias, and \c ta keys
    /**
        @note this function is normally not used directly, but rather is called by the other @ref sql_jop_funcs
    */
    public hash sub make_jop(string jop, AbstractTable table, *string alias, *hash jcols, *hash cond, *string ta, *hash opt) {
        string hk = alias ? alias : table.getSqlName();
        hash h{hk} = ("jop": jop, "table": table, "jcols": jcols, "cond": cond, "alias": alias, "ta": ta, "opt": opt);
        return h;
    }

    #! returns a hash for standard inner joins with the given arguments
    /** @par Example With Explicit Join Columns:
        @code
my *list $rows = $table.selectRows(("join": join_inner($table2, "t2", ("id": "altid"))));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code
my *list $rows = $table.selectRows(("join": join_inner($table2)));
        @endcode

        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub join_inner(AbstractTable table, *string alias, *hash jcols, *hash cond, *hash opt) {
        return make_jop(JOP_INNER, table, alias, jcols, NOTHING, NOTHING, opt);
    }

    #! returns a hash for standard inner joins with the given arguments
    /** @par Example With Explicit Join Columns:
        @code
my *list $rows = $table.selectRows(("join": join_inner($table2, "t2", ("id": "altid"))));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code
my *list $rows = $table.selectRows(("join": join_inner($table2)));
        @endcode

        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub join_inner(Table table, *string alias, *hash jcols, *hash cond, *hash opt) {
        return make_jop(JOP_INNER, table.getTable(), alias, jcols, cond, NOTHING, opt);
    }

    #! returns a hash for standard inner joins with the given arguments for use when joining with a table other than the primary table
    /** @par Example With Explicit Join Columns:
        @code
my *list $rows = $table.selectRows(("join": join_inner($table2, "t2", ("id": "altid")) + join_inner("t2", $table3)));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code
my *list $rows = $table.selectRows(("join": join_inner($table2)));
        @endcode

        @param ta the table name or alias of the other table to join with when not joining with the primary table
        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub join_inner(string ta, AbstractTable table, *string alias, *hash jcols, *hash cond, *hash opt) {
        return make_jop(JOP_INNER, table, alias, jcols, cond, ta, opt);
    }

    #! returns a hash for standard inner joins with the given arguments for use when joining with a table other than the primary table
    /** @par Example With Explicit Join Columns:
        @code
my *list $rows = $table.selectRows(("join": join_inner($table2, "t2", ("id": "altid")) + join_inner("t2", $table3)));
        @endcode

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code
my *list $rows = $table.selectRows(("join": join_inner($table2)));
        @endcode

        @param ta the table name or alias of the other table to join with when not joining with the primary table
        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub join_inner(string ta, Table table, *string alias, *hash jcols, *hash cond, *hash opt) {
        return make_jop(JOP_INNER, table.getTable(), alias, jcols, cond, ta, opt);
    }

    #! returns a hash for left outer joins with the given arguments
    /** @par Example With Explicit Join Columns:
        @code
my *list $rows = $table.selectRows(("join": join_left($table2, "t2", ("id": "altid"), ("tag", op_like("offset%")))));
        @endcode 

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code
my *list $rows = $table.selectRows(("join": join_left($table2, "t2", NOTHING, ("tag", op_like("offset%")))));
        @endcode

        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub join_left(AbstractTable table, *string alias, *hash jcols, *hash cond, *hash opt) {
        return make_jop(JOP_LEFT, table, alias, jcols, cond, NOTHING, opt);
    }

    #! returns a hash for left outer joins with the given arguments
    /** @par Example With Explicit Join Columns:
        @code
my *list $rows = $table.selectRows(("join": join_left($table2, "t2", ("id": "altid"), ("tag", op_like("offset%")))));
        @endcode 

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code
my *list $rows = $table.selectRows(("join": join_left($table2, "t2", NOTHING, ("tag", op_like("offset%")))));
        @endcode

        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub join_left(Table table, *string alias, *hash jcols, *hash cond, *hash opt) {
        return make_jop(JOP_LEFT, table.getTable(), alias, jcols, cond, NOTHING, opt);
    }

    #! returns a hash for left outer joins with the given arguments for use when joining with a table other than the primary table
    /** @par Example With Explicit Join Columns:
        @code
my *list $rows = $table.selectRows(("join": join_left($table2, "t2", ("id": "altid"), ("tag", op_like("offset%"))) + join_left("t2", $table3, "t3")));
        @endcode 

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code
my *list $rows = $table.selectRows(("join": join_left($table2, "t2", NOTHING, ("tag", op_like("offset%"))) + join_left("t2", $table3, "t3")));
        @endcode

        @param ta the table name or alias of the other table to join with when not joining with the primary table
        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub join_left(string ta, AbstractTable table, *string alias, *hash jcols, *hash cond, *hash opt) {
        return make_jop(JOP_LEFT, table, alias, jcols, cond, ta, opt);
    }

    #! returns a hash for left outer joins with the given arguments for use when joining with a table other than the primary table
    /** @par Example With Explicit Join Columns:
        @code
my *list $rows = $table.selectRows(("join": join_left($table2, "t2", ("id": "altid"), ("tag", op_like("offset%"))) + join_left("t2", $table3, "t3")));
        @endcode 

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code
my *list $rows = $table.selectRows(("join": join_left($table2, "t2", NOTHING, ("tag", op_like("offset%"))) + join_left("t2", $table3, "t3")));
        @endcode

        @param ta the table name or alias of the other table to join with when not joining with the primary table
        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub join_left(string ta, Table table, *string alias, *hash jcols, *hash cond, *hash opt) {
        return make_jop(JOP_LEFT, table.getTable(), alias, jcols, cond, ta, opt);
    }

    #! returns a hash for right outer joins with the given arguments
    /** @par Example With Explicit Join Columns:
        @code
my *list $rows = $table.selectRows(("join": join_right($table2, "t2", ("id": "altid"), ("tag", op_like("offset%")))));
        @endcode 

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code
my *list $rows = $table.selectRows(("join": join_right($table2, "t2", NOTHING, ("tag", op_like("offset%")))));
        @endcode

        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub join_right(AbstractTable table, *string alias, *hash jcols, *hash cond, *hash opt) {
        return make_jop(JOP_RIGHT, table, alias, jcols, cond, NOTHING, opt);
    }

    #! returns a hash for right outer joins with the given arguments
    /** @par Example With Explicit Join Columns:
        @code
my *list $rows = $table.selectRows(("join": join_right($table2, "t2", ("id": "altid"), ("tag", op_like("offset%")))));
        @endcode 

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code
my *list $rows = $table.selectRows(("join": join_right($table2, "t2", NOTHING, ("tag", op_like("offset%")))));
        @endcode

        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub join_right(Table table, *string alias, *hash jcols, *hash cond, *hash opt) {
        return make_jop(JOP_RIGHT, table.getTable(), alias, jcols, cond, NOTHING, opt);
    }

    #! returns a hash for right outer joins with the given arguments for use when joining with a table other than the primary table
    /** @par Example With Explicit Join Columns:
        @code
my *list $rows = $table.selectRows(("join": join_right($table2, "t2", ("id": "altid"), ("tag", op_like("offset%"))) + join_right("t2", $table3, "t3")));
        @endcode 

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code
my *list $rows = $table.selectRows(("join": join_right($table2, "t2", NOTHING, ("tag", op_like("offset%"))) + join_right("t2", $table3, "t3")));
        @endcode

        @param ta the table name or alias of the other table to join with when not joining with the primary table
        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub join_right(string ta, AbstractTable table, *string alias, *hash jcols, *hash cond, *hash opt) {
        return make_jop(JOP_RIGHT, table, alias, jcols, cond, ta, opt);
    }

    #! returns a hash for right outer joins with the given arguments for use when joining with a table other than the primary table
    /** @par Example With Explicit Join Columns:
        @code
my *list $rows = $table.selectRows(("join": join_right($table2, "t2", ("id": "altid"), ("tag", op_like("offset%"))) + join_right("t2", $table3, "t3")));
        @endcode 

        @par Example With Implicit Join Columns:
        (using an automatically detected foreign key to primary key constraint)
        @code
my *list $rows = $table.selectRows(("join": join_right($table2, "t2", NOTHING, ("tag", op_like("offset%"))) + join_right("t2", $table3, "t3")));
        @endcode

        @param ta the table name or alias of the other table to join with when not joining with the primary table
        @param table the table to join with
        @param alias the alias for \a table in the query
        @param jcols the columns to use for the join, the keys will be columns in the source table and the values are columns in the \a table argument; if this argument is @ref nothing, then if there is any foreign key in one table pointing to the primary key of the other table, then this information is automatically assumed as the join condition; a foreign constraint in the current table to the primary key in \a table will be used first if it exists
        @param cond additional conditions for the join clause for the \a table argument; see @ref where_clauses for more information
        @param opt optional join options (for example, to specify a partition for the join if supported)

        @return a join description hash corresponding to the arguments for use in the @ref select_option_join "join" argument of a @ref select_option_hash "select option hash"
    */
    public hash sub join_right(string ta, Table table, *string alias, *hash jcols, *hash cond, *hash opt) {
        return make_jop(JOP_RIGHT, table.getTable(), alias, jcols, cond, ta, opt);
    }
    #@}

    /** @defgroup sql_ops SQL Operators
        These are the operators that can be used in where clauses; see @ref where_clauses for more information
     */
    #@{
    #! the SQL "like" operator for use in @ref where_clauses
    /** @see op_like()
    */
    public const OP_LIKE = "like";

    #! the SQL less than (<) operator for use in @ref where_clauses
    /** @see op_lt()
    */
    public const OP_LT = "<";

    #! the SQL less than or equals (<=) operator for use in @ref where_clauses
    /** @see op_le()
    */
    public const OP_LE = "<=";

    #! the SQL greater than operator (>) for use in @ref where_clauses
    /** @see op_gt()
    */
    public const OP_GT = ">";

    #! the SQL greater than or equals operator (>=) for use in @ref where_clauses
    /** @see op_ge()
    */
    public const OP_GE = ">=";

    #! the SQL not equals operator (!= or <>) for use in @ref where_clauses
    /** @see op_ne()
    */
    public const OP_NE = "!=";

    #! the SQL \c "between" operator for use in @ref where_clauses
    /** @see op_between()
    */
    public const OP_BETWEEN = "between";

    #! the SQL \c "in" operator for use in @ref where_clauses
    /** @see op_in()
    */
    public const OP_IN = "in";

    #! the SQL \c "not" operator for use in @ref where_clauses
    /** @see op_not()
    */
    public const OP_NOT = "not";

    #! a hash of valid operators for use in @ref where_clauses
    public const DefaultOpMap = (
        OP_LIKE: (
            "code": string sub (object t, string cn, any arg, reference args) {
                args += arg;
                return sprintf("%s like %v", cn);
            },
        ),
        OP_LT: (
            "code": string sub (object t, string cn, any arg, reference args) {
                args += arg;
                return sprintf("%s < %v", cn);
            },
        ),
        OP_LE: (
            "code": string sub (object t, string cn, any arg, reference args) {
                args += arg;
                return sprintf("%s <= %v", cn);
            },
        ),
        OP_GT: (
            "code": string sub (object t, string cn, any arg, reference args) {
                args += arg;
                return sprintf("%s > %v", cn);
            },
        ),
        OP_GE: (
            "code": string sub (object t, string cn, any arg, reference args) {
                args += arg;
                return sprintf("%s >= %v", cn);                
            },
        ),
        OP_NE: (
            "code": string sub (object t, string cn, any arg, reference args) {
                if (arg === NULL || !exists arg)
                    return sprintf("%s is not null", cn);
                args += arg;
                return sprintf("%s != %v", cn);
            },
        ),
        OP_BETWEEN: (
            "code": string sub (object t, string cn, any arg, reference args) {
                args += arg[0];
                args += arg[1];
                return sprintf("%s between %v and %v", cn);
            },
        ),
        OP_IN: (
            "code": string sub (object t, string cn, any arg, reference args) {
                *string ins = (foldl $1 + "," + $2, (map t.getSqlValue($1), arg));
                return sprintf("%s in (%s)", cn, ins ? ins : "null");
            },
        ),
        OP_NOT: (
            "recursive": True,
            "code": string sub (object t, string cn, any arg, reference args) {
                return sprintf("not (%s)", cn); 
            },
        ),
        );
    #@}

    /** @defgroup sql_op_funcs SQL Operator Functions
        These are the operators that can be used in where clauses; see @ref where_clauses for more information:
        - op_between(): for the \c "between" operator
        - op_ge(): for the \c ">=" operator
        - op_gt(): for the \c ">" operator
        - op_in(): for the \c "in" operator
        - op_like(): for the \c "like" operator
        - op_le(): for the \c "<=" operator
        - op_lt(): for the \c "<" operator
        - op_ne(): for the \c "!=" or \c "<>" operator
        - op_not(): for negating other operators
     */
    #@{
    #! returns a hash with \c op and \c arg keys
    public hash sub make_op(string op, any arg) {
        return ("op": op, "arg": arg);
    }

    #! returns a hash for the \c "like" operator with the given argument for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("where": ("name": op_like("%smith%"))));
        @endcode

        @param str the argument for the operator
        
        @return a where operation description hash for use in @ref where_clauses "where clauses"
    */
    public hash sub op_like(string str) {
        return make_op(OP_LIKE, str);
    }

    #! returns a hash for the \c "<" operator with the given argument for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("where": ("name": op_lt("Zebra"))));
        @endcode

        @param arg the argument for the operator
        
        @return a where operation description hash for use in @ref where_clauses "where clauses"
    */
    public hash sub op_lt(any arg) {
        return make_op(OP_LT, arg);
    }

    #! returns a hash for the \c "<=" operator with the given argument for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("where": ("name": op_le("Zebra"))));
        @endcode

        @param arg the argument for the operator
        
        @return a where operation description hash for use in @ref where_clauses "where clauses"
    */
    public hash sub op_le(any arg) {
        return make_op(OP_LE, arg);
    }

    #! returns a hash for the \c ">" operator with the given argument for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("where": ("name": op_gt("Apple"))));
        @endcode

        @param arg the argument for the operator
        
        @return a where operation description hash for use in @ref where_clauses "where clauses"
    */
    public hash sub op_gt(any arg) {
        return make_op(OP_GT, arg);
    }

    #! returns a hash for the \c ">=" operator with the given argument for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("where": ("name": op_ge("Apple"))));
        @endcode

        @param arg the argument for the operator
        
        @return a where operation description hash for use in @ref where_clauses "where clauses"
    */
    public hash sub op_ge(any arg) {
        return make_op(OP_GE, arg);
    }

    #! returns a hash for the \c "!=" or \c "<>" operator with the given argument for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("where": ("name": op_ne("Smith"))));
        @endcode

        @param arg the argument for the operator
        
        @return a where operation description hash for use in @ref where_clauses "where clauses"
    */
    public hash sub op_ne(any arg) {
        return make_op(OP_NE, arg);
    }

    #! returns a hash for the \c "between" operator with the given arguments, neither of which can be @ref null or @ref nothing; for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("where": ("name": op_between("US", "UX"))));
        @endcode

        @param l the lower bound for the \c "between" operator
        @param r the upper bound for the \c "between" operator
        
        @return a where operation description hash for use in @ref where_clauses "where clauses"

        @throw BETWEEN-ERROR one or both of the required arguments are @ref null or @ref nothing
     */
    public hash sub op_between(any l, any r) {
        if (!exists l || l === NULL)
            throw "BETWEEN-ERROR", sprintf("the first argument is %y; both arguments to op_between() must be values that can be used with the BETWEEN operator (ie not NULL or NOTHING)", l);
        if (!exists r || r === NULL)
            throw "BETWEEN-ERROR", sprintf("the second argument is %y; both arguments to op_between() must be values that can be used with the BETWEEN operator (ie not NULL or NOTHING)", r);
        return make_op(OP_BETWEEN, (l, r));
    }

    #! returns a hash for the \c "in" operator with all arguments passed to the function; for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("where": ("name": op_in(200, 300, 500, 9))));
        @endcode
        
        @return a where operation description hash for use in @ref where_clauses "where clauses"
    */
    public hash sub op_in() {
        return make_op(OP_IN, argv);
    }    

    #! returns a hash for the \c "in" operator with the given argument list as the first argument; for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("where": ("name": op_in($idlist))));
        @endcode

        @param args a list of values for the \c "in" operator
        
        @return a where operation description hash for use in @ref where_clauses "where clauses"
    */
    public hash sub op_in(list args) {
        return make_op(OP_IN, args);
    }

    #! returns a hash for the \c "not" operator; for use in @ref where_clauses "where clauses"
    /** @par Example:
        @code
my *list $rows = $table.selectRows(("where": ("name": opt_not(op_in(200, 300, 500, 9))))_;
        @endcode
        
        @return a where operation description hash for use in @ref where_clauses "where clauses"
    */
    public hash sub op_not(hash arg) {
        return make_op(OP_NOT, arg);
    } 
    #@}

    #! abstract container class that throws an exception if an unknown key is accessed
    public class AbstractHashContainer {
        public {}

        private {
            *hash h;
        }

        #! creates the object with the hash argument passed
        constructor(*hash nh) {
            h = nh;
        }

        #! creates a "deep copy" of the object
        copy(AbstractHashContainer old) {
            map h.$1 = old.h.$1.copy(), old.h.keyIterator();
        }

        #! returns the value of the given key in the contained hash if it exists, otherwise throws a \c KEY-ERROR exception
        /** @par Example:
            @code
my any $v = $c.name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        any memberGate(string k) {
            if (!h.hasKey(k))
                throw "KEY-ERROR", sprintf("cannot access unknown %s %y; expecting one of: %y", getElementName(), k, h.keys());
            return h{k};
        }

        #! purges the contained data
        /** @par Example:
            @code
$c.clear();
            @endcode

        */
        clear() {
            delete h;
        }

        #! removes the given key from the contained hash and returns the value
        abstract any take(string k);

        #! renames the given key; maintains the key order
        renameKey(string old_name, string new_name) {
            hash nh;
            foreach hash kh in (h.pairIterator())
                nh{kh.key == old_name ? new_name : kh.key} = kh.value;

            h = nh;
        }

        #! returns the hash contained by this object
        *hash getHash() {
            return h;
        }

        #! returns @ref Qore::True "True" if the hash argument has the same keys (in any order), @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $c.matchKeys($h);
            @endcode

            @param h1 the hash to compare

            @return @ref Qore::True "True" if the hash argument has the same keys (in any order), @ref Qore::False "False" if not
        */
        bool matchKeys(hash h1) {
            if (h.size() != h1.size())
                return False;

            foreach string k in (h.keyIterator()) {
                if (!h1.hasKey(k))
                    return False;
            }

            return True;
        }

        #! returns @ref Qore::True "True" if the list argument has the same list of key strings as the keys in the object (in any order), @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $c.matchKeys($l);
            @endcode

            @param l the hash to compare

            @return @ref Qore::True "True" if the list argument has the same list of key strings as the keys in the object (in any order), @ref Qore::False "False" if not
        */
        bool matchKeys(list l) {
            if (h.size() != l.size())
                return False;

            foreach string k in (l.iterator()) {
                if (!h.hasKey(k))
                    return False;
            }

            return True;
        }

        #! returns @ref Qore::True "True" if the container argument has the same keys (in any order), @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $c.matchKeys($c1);
            @endcode

            @param c the container to compare

            @return @ref Qore::True "True" if the container argument has the same keys (in any order), @ref Qore::False "False" if not
        */
        bool matchKeys(AbstractHashContainer c) {
            return matchKeys(c.h);
        }

        #! returns @ref Qore::True "True" if the hash argument has at least the same keys (in any order, can have more keys), @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $c.partialMatchKeys($h);
            @endcode

            @param h1 the hash to compare

            @return @ref Qore::True "True" if the hash argument has at least the same keys (in any order, can have more keys), @ref Qore::False "False" if not
        */
        bool partialMatchKeys(hash h1) {
            if (h.size() > h1.size())
                return False;

            foreach string k in (h.keyIterator()) {
                if (!h1.hasKey(k))
                    return False;
            }

            return True;
        }

        #! returns @ref Qore::True "True" if the list argument has at least the same keys (in any order, can have more keys), @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $c.partialMatchKeys($l);
            @endcode

            @param l the list of strings to compare

            @return @ref Qore::True "True" if the list argument has at least the same keys (in any order, can have more keys), @ref Qore::False "False" if not
        */
        bool partialMatchKeys(list l) {
            if (h.size() > l.size())
                return False;
            
            # make a hash of the list for quick searching
            hash h1;
            map h1.$1 = True, l;

            foreach string k in (h.keyIterator()) {
                if (!h1.hasKey(k))
                    return False;
            }

            return True;
        }

        #! returns @ref Qore::True "True" if the container argument has at least the same keys (in any order, can have more keys), @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $c.partialMatchKeys($c1);
            @endcode

            @param c the container to compare

            @return @ref Qore::True "True" if the container argument has at least the same keys (in any order, can have more keys), @ref Qore::False "False" if not
        */
        bool partialMatchKeys(AbstractHashContainer c) {
            return partialMatchKeys(c.h);
        }

        #! Returns @ref Qore::False "False" if the contained hash has no keys, @ref Qore::True "True" if it does
        /** @par Example:
            @code
my bool $b = $h.val();
            @endcode

            The opposite of empty()

            @return @ref Qore::False "False" if the contained hash has no keys, @ref Qore::True "True" if it does
        */
        bool val() {
            return h.val();
        }

        #! Returns a list of key names of the contained hash
        /** @par Example:
            @code
my list $l = $h.keys();
            @endcode

            @return a list of key names of the contained hash
        */
        list keys() {
            return h.keys();
        }

        #! Returns a list of values of the contained hash
        /** @par Example:
            @code
my list $l = $h.values();
            @endcode

            @return a list of values of the contained hash
        */
        list values() {
            return h.values();
        }

        #! Returns a @ref Qore::HashIterator "HashIterator" object for the contained hash
        /** @par Example:
            @code
map printf("+ %y\n", $1.value), $h.iterator();
            @endcode

            @return a @ref Qore::HashIterator "HashIterator" object for the contained hash
        */
        Qore::AbstractIterator iterator() {
            return h.iterator();
        }

        #! Returns a @ref Qore::HashKeyIterator "HashKeyIterator" object for the contained hash
        /** @par Example:
            @code
map printf("+ %s\n", $1), $h.keyIterator();
            @endcode

            @return a @ref Qore::HashKeyIterator "HashKeyIterator" object for the contained hash
        */
        Qore::AbstractIterator keyIterator() {
            return h.keyIterator();
        }

        #! Returns a @ref Qore::HashPairIterator "HashPairIterator" object for the contained hash
        /** @par Example:
            @code
map printf("+ %s: %y\n", $1.key, $1.value), $h.pairIterator();
            @endcode

            @return a @ref Qore::HashPairIterator "HashPairIterator" object for the contained hash
        */
        Qore::AbstractIterator pairIterator() {
            return h.pairIterator();
        }

        #! returns @ref Qore::True "True" if the container is empty, @ref Qore::False "False" if not
        bool empty() {
            return h.empty();
        }

        #! Returns the number of keys in the contained hash
        /** @par Example:
            @code
my int $num = $h.size();
            @endcode

            @return the number of keys in the contained hash
        */
        int size() {
            return h.size();
        }

        #! Returns @ref Qore::True "True" if the key exists in the contained hash (may or may not be assigned a value), @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $h.hasKey($key);
            @endcode

            @param k the key name to check

            @return @ref Qore::True "True" if the key exists in the contained hash (may or may not be assigned a value), @ref Qore::False "False" if not
        */
        bool hasKey(string k) {
            return h.hasKey(k);
        }

        #! Returns @ref Qore::True "True" if the key exists in the contained hash and is assigned a value, @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $h.hasKeyValue($key);
            @endcode

            @param k the key name to check

            @return @ref Qore::True "True" if the key exists in the contained hash and is assigned a value, @ref Qore::False "False" if not
        */
        bool hasKeyValue(string k) {
            return h.hasKeyValue(k);
        }

        #! Returns the first key name in the contained hash or @ref nothing if the contained hash has no keys
        /** @par Example:
            @code
my *string $n = $h.firstKey();
            @endcode

            @return the first key name in the contained hash or @ref nothing if the contained hash has no keys

            @see lastKey()
        */
        *string firstKey() {
            return h.firstKey();
        }

        #! Returns the last key name in the contained hash or @ref nothing if the contained hash has no keys
        /** @par Example:
            @code
my *string $n = $h.lastKey();
            @endcode

            @return the last key name in the contained hash or @ref nothing if the contained hash has no keys

            @see firstKey()
        */
        *string lastKey() {
            return h.lastKey();
        }

        #! must return the name of the contained element
        abstract string getElementName();
    }

    #! abstract container class that throws an exception if an unknown key is accessed
    public class AbstractListContainer {
        public {}

        private {
            softlist l;
        }

        #! creates the object with the list argument passed
        constructor(softlist nl) {
            l = nl;
        }

        #! returns the value of the given element in the contained list if it exists, otherwise throws an \c ELEMENT-ERROR exception
        /** @par Example:
            @code
my any $v = $c.get(2);
            @endcode

            @param i the index of the element to access

            @return the value of the given index in the contained list if it exists

            @throw ELEMENT-ERROR the given element does not exist in the contained list
        */
        abstract any get(softint i);

        #! adds the given value to the list
        add(any val) {            
            l += val;
        }

        #! removes the given element from the contained list and returns the value
        any take(int i) {
            checkIndex(i);
            return extract l, i, 1;
        }

        #! returns the list contained by this object
        list getList() {
            return l;
        }

        #! Returns @ref Qore::False "False" if the contained list is empty, @ref Qore::True "True" if not
        /** @par Example:
            @code
my bool $b = $l.val();
            @endcode

            The opposite of empty()

            @return @ref Qore::False "False" if the contained list is empty, @ref Qore::True "True" if not
        */
        bool val() {
            return l.val();
        }

        #! Returns a @ref Qore::ListIterator "ListIterator" object for the contained list
        /** @par Example:
            @code
map printf("+ %s: %y\n", $1), $h.iterator();
            @endcode

            @return a @ref Qore::HashIterator "HashIterator" object for the contained hash
        */
        Qore::ListIterator iterator() {
            return l.iterator();
        }

        #! returns @ref Qore::True "True" if the container is empty, @ref Qore::False "False" if not
        bool empty() {
            return l.empty();
        }

        #! Returns the number of elements in the contained list
        /** @par Example:
            @code
my int $num = $l.size();
            @endcode

            @return the number of elements in the contained list
        */
        int size() {
            return l.size();
        }

        #! must return the name of the contained element
        abstract string getElementName();

        private checkIndex(int i) {
            if (i < 0 || i >= l.size())
                throw "ELEMENT-ERROR", sprintf("cannot access %s element %d; total elements: %d", getElementName(), i, l.size());
        }
    }

    #! the table container class stores a collection of tables in a schema
    public class Tables inherits AbstractHashContainer {
        #! creates an empty object
        constructor() {
        }

        #! creates and populates the object from a hash description
        constructor(AbstractDatasource ds, hash tables, *hash opt) {
            populate(ds, tables, opt);
        }

        #! creates and populates the object from tables in the database
        constructor(AbstractDatasource ds) {
            populate(ds);
        }

        #! adds the given value to the hash with the given key name
        add(string k, Table val) {
            h{k} = val.getTable();
        }

        #! adds the given value to the hash with the given key name
        add(string k, AbstractTable val) {
            h{k} = val;
        }

        #! adds the given value to the hash with the given key name
        add(Table val) {
            h{val.getName()} = val.getTable();
        }

        #! adds the given value to the hash with the given key name
        add(AbstractTable val) {
            h{val.getName()} = val;
        }

        #! removes the given key from the contained hash and returns the value
        AbstractTable take(string k) {
            return remove h{k};
        }

        #! populates the object from a hash description
        populate(AbstractDatasource ds, hash tables, *hash opt) {            
            delete h;
            AbstractDatabase::checkDriverOptions(\tables, ds.getDriverName());
            foreach string name in (tables.keyIterator()) {
                if (h.hasKey(name))
                    continue;
                hash th = tables{name} - "rename";
                # create table template
                Table t(ds, th, name, opt + ("table_cache": self));
                # store in table_cache
                h{name} = t.getTable();
            }
        }

        #! populates the object from tables in the database
        populate(AbstractDatasource ds) {
            delete h;
            Database db(ds);
            foreach string name in (db.tableIterator()) {
                if (h{name}) {
                    h{name}.cache();
                    continue;
                }
                Table t(ds, name);
                t.cache(("table_cache": self));
                h{name} = t.getTable();
            }
        }

        #! returns a list of SQL strings that can be used to drop all the foreign constraints on a particular table
        /** @par Example:
            @code
my *list $l = $tables.getDropAllForeignConstraintsOnTableSql($name);
            @endcode

            Make sure that all relevant tables are cached before calling this method; if the table is not cached, then @ref nothing is returned

            @param name the name of the table to find all the foreigjn constraints for
            @param opt a hash of options for the SQL strings; see @ref AbstractDatabase::DropSchemaOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to drop all the foreign constraints on a particular table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getDropAllForeignConstraintsOnTableSql(string name, *hash opt) {
            if (!h{name})
                return;

            AbstractTable t = h{name};

            list l = ();
            foreach AbstractUniqueConstraint uk in (t.getUniqueConstraintIterator()) {
                foreach hash sch in (uk.getSourceConstraintIterator()) {
                    l += AbstractDatabase::doCallback(opt, sch.fk.getDropSql(sch.table), AbstractDatabase::AC_Drop, "foreign constraint", sch.fk.getName(), sch.table);
                    string tn = sch.table;
                    tn =~ s/.*\.//;
                    if (opt.sql_callback_executed && h{tn})
                        h{tn}.removeForeignConstraint(sch.fk.getName());
                }
            }

            return l;            
        }

        #! returns the AbstractTable object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code
my AbstractTable $t = $tables.table_name;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        AbstractTable memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        #! returns \c "table" since this object stores AbstractTable objects
        string getElementName() {
            return "table";
        }

        #! gets a table from the database or from the cache if already cached; if the table does not exist, then @ref nothing is returned
        *AbstractTable getIfExists(AbstractDatasource ds, string name) {
            if (h{name})
                return h{name};
            
            Table t(ds, name);
            if (!t.checkExistence())
                return;
            t.cache(("table_cache": self));
            return h{name} = t.getTable();
        }

        #! gets a table from the database or from the cache if already cached
        AbstractTable get(AbstractDatasource ds, string name) {
            if (h{name})
                return h{name};
            
            Table t(ds, name);
            t.cache(("table_cache": self));
            return h{name} = t.getTable();
        }

        #! returns an SQL string that can be used to rename the given table if it exists and the target does not exist, otherwise returns @ref nothing
        /** @par Example:
            @code
my *string $sql = $tables.getRenameTableIfExistsSql($old_name, $new_name);
            @endcode

            If the @ref sql_callback_executed "sql_callback_executed option key" is @ref Qore::True "True", this
            method also takes care of renaming internal foreign constraint references and source constraint references
            from unique keys for the renamed table (see @ref sql_callback_executed for more information).

            @param old_name the current name of the table
            @param new_name the new name of the table
            @param opts optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return an SQL string that can be used to rename the given table if it exists and the target does not exist, otherwise returns @ref nothing
         */
        *string getRenameTableIfExistsSql(string old_name, string new_name, *hash opts) {
            if (!h{old_name} || h{new_name})
                return;

            AbstractTable t = h{old_name};
            string oldsn = t.getSqlName();
            *string sql = t.getRenameSql(new_name, opts);
            if (opts.sql_callback_executed)
                tableRenamedIntern(old_name, new_name, oldsn);

            return sql;
        }

        #! updates table names and internal references for renamed tables
        /** @par Example:
            @code
$tables.tableRenamed($old, $new);
            @endcode

            @param old_name the current name of the table
            @param new_name the new name of the table
            @param old_sql_name the old full SQL name of the table (ie the value returned by @ref SqlUtil::AbstractTable::getSqlName())

            @return @ref Qore::True "True" if the table was renamed internally, @ref Qore::False "False" if not
        */
        bool tableRenamed(string old_name, string new_name, string old_sql_name) {
            if (!h{old_name} || h{new_name})
                return False;
            tableRenamedIntern(old_name, new_name, old_sql_name);
            return True;
        }

        private tableRenamedIntern(string old_name, string new_name, string oldsn) {
            renameKey(old_name, new_name);
            AbstractTable t = h{new_name};

            # search through all unique keys and rename foreign keys in source tables
            foreach AbstractUniqueConstraint uk in (t.getUniqueConstraintIterator()) {
                foreach hash sch in (uk.getSourceConstraintIterator()) {
                    sch.fk.target.table = t.getName();
                }
            }

            if (!t.getForeignConstraints().empty()) {
                string newsn = t.getSqlName();

                # search through all foreign constraints and try to rename source constraints
                foreach AbstractForeignConstraint fk in (t.getForeignConstraints().iterator()) {
                    if (h{fk.target.table}) {
                        AbstractTable tt = h{fk.target.table};
                        foreach AbstractUniqueConstraint uk in (tt.getUniqueConstraintIterator())
                            uk.renameSourceConstraintTable(oldsn, newsn);
                    }
                }
            }
        }

        #! returns an SQL string that can be used to drop an existing constraint on a table, if the table is not already cached or the constraint does not exist, then @ref nothing is returned
        /** @par Example:
            @code
my *string $sql = $tables.getDropConstraintIfExistsSql("table", "pk_table");
            @endcode

            If the @ref sql_callback_executed "sql_callback_executed option key" is @ref Qore::True "True" and
            if the constraint to be dropped is a foreign constraint, then if any unique constraint is linked
            to this foreign constraint, the link is removed (see @ref sql_callback_executed for more information).

            @param tname the name of the table
            @param cname the name of the constraint to drop if it exists
            @param opts optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return an SQL string that can be used to drop an existing constraint on a table, if the table is not already cached or the constraint does not exist, then @ref nothing is returned
        */
        *string getDropConstraintIfExistsSql(string tname, string cname, *hash opts) {
            if (!h{tname})
                return;

            AbstractTable t = h{tname};
            AbstractConstraint c;
            *string sql = t.getDropConstraintIfExistsSql(cname, opts, \c);
            if (!sql)
                return;
            if (opts.sql_callback_executed && c instanceof AbstractForeignConstraint) {
                AbstractForeignConstraint fk = c;
                if (h{fk.target.table}) {
                    AbstractTable tt = h{fk.target.table};
                    list cols = fk.target.columns.keys();
                    foreach AbstractUniqueConstraint uk in (tt.getUniqueConstraintIterator())
                        uk.removeSourceConstraint(t.getSqlName(), cols);
                }
            }
            return sql;
        }

        list getCreateList() {
            # foreign dependency hash: table -> hash: source table (ie table with foreign constraint on key)
            hash tdh;
            # source dependency hash: table -> list: foreign table (key has foreign constraint on value)
            hash sdh;
            getDependencies(\tdh, \sdh);

            hash th = h;

            #printf("TDH: %N\nSDH: %N\nNT: %y", tdh, sdh, nt);exit(1);

            # make a list of tables in dependency order
            list l = ();
            while (True) {
                bool found = False;
                foreach AbstractTable t in (th.iterator()) {
                    if (!sdh{t.getName()}) {
                        l += t;
                        found = True;
                        remove th{t.getName()};
                        map remove sdh.$1{t.getName()}, tdh{t.getName()}.keyIterator();
                        remove tdh{t.getName()};
                    }
                }
                if (!found)
                    break;
            }

            return l;
        }

        Qore::AbstractIterator createIterator() {
            return getCreateList().iterator();
        }

        #! returns a list of cached table names in the order that can be used to drop the tables, taking into account foreign constraint dependencies
        /** @par Example:
            @code
my list $l = $tables.getDropList();
map $1.drop(), $l;
            @endcode

            @return a list of cached table names in the order that can be used to drop the tables, taking into account foreign constraint dependencies
        */
        list getDropList() {
            if (!h)
                return ();

            # foreign dependency hash: table -> hash: source table (ie table with foreign constraint on key)
            hash tdh;
            # source dependency hash: table -> list: foreign table (key has foreign constraint on value)
            hash sdh;
            # table hash
            hash th = h;
            getDependencies(\tdh, \sdh, \th);

            #printf("TDH: %N\nSDH: %N\nNT: %y", tdh, sdh, nt);exit(1);

            # make a list of tables in dependency order
            list l = ();
            while (True) {
                bool found = False;
                foreach AbstractTable t in (th.iterator()) {
                    if (!tdh{t.getName()}) {
                        if (t.checkExistence())
                            l += t;
                        found = True;
                        remove th{t.getName()};
                        map remove tdh.$1{t.getName()}, sdh{t.getName()}.keyIterator();
                        remove sdh{t.getName()};
                    }
                }
                if (!found)
                    break;
            }

            return l;
        }

        #! returns an iterator for a list of cached table names in the order that can be used to drop the tables, taking into account foreign constraint dependencies
        /** @par Example:
            @code
map $1.drop(), $tables.getDropIterator();
            @endcode

            @return an iterator for a list of cached table names in the order that can be used to drop the tables, taking into account foreign constraint dependencies
        */
        Qore::AbstractIterator dropIterator() {
            return getDropList().iterator();
        }

        private getDependencies(reference tdh, reference sdh, *reference th) {
            # list of tables not in DB
            list nt = ();
            foreach AbstractTable t in (h.iterator()) {
                if (th && !t.checkExistence()) {
                    nt += t.getName();
                    continue;
                }
                foreach AbstractForeignConstraint fk in (t.getForeignConstraints().iterator()) {
                    # skip constraints on the same table
                    if (fk.target.table == t.getName())
                        continue;
                    # make dependency map entries
                    sdh{t.getName()}{fk.target.table} = True;
                    tdh{fk.target.table}{t.getName()} = True;
                }
            }

            # process tables not in DB
            foreach string name in (nt) {
                remove th{name};
                map remove tdh.$1{name}, sdh{name}.keyIterator();
                remove sdh{name};
            }
        }
    }

    #! column container class that throws an exception if an unknown column is accessed
    public class Columns inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! adds the given value to the hash with the given key name
        add(string k, AbstractColumn val) {
            h{k} = val;
        }

        #! removes the given key from the contained hash and returns the value
        AbstractColumn take(string k) {
            return remove h{k};
        }

        #! returns the AbstractColumn object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code
my AbstractColumn $c = $cols.id;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        AbstractColumn memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        #! returns a subset of the current columns according to the list argument
        Columns subset(softlist l) {
            hash nh = h{l};
            if (nh.size() != l.size())
                throw "SUBSET-ERROR", sprintf("subset requested: %y is not possible, can only provide: %y", l, nh.keys());
            return new Columns(nh);
        }

        #! returns \c "column" since this object stores column objects
        string getElementName() {
            return "column";
        }

        #! returns @ref Qore::True "True" if the argument has the same columns in the same order as the current object, @ref Qore::False "False" if not
        bool equal(Columns cols) {
            AbstractIterator i = cols.iterator();
            foreach AbstractColumn c in (iterator()) {
                if (!i.next())
                    return False;
                if (!c.equal(i.getValue()))
                    return False;
            }
            return True;
        }
    }

    #! the base class for column information
    public class AbstractColumn {
        public {
            #! the name of the column
            string name;

            #! the native type name of the column
            string native_type;

            #! the equivalent qore type name of the column if known
            *string qore_type;

            #! the size of the column
            int size;

            #! @ref Qore::True "True" if the column can hold a NULL value, @ref Qore::False "False" if not
            bool nullable; 

            #! default value for column
            *string def_val;

            #! comment on the column
            *string comment;
        }

        constructor(string n, string nt, *string qt, int sz, bool nul, *string dv, *string c) {
            name = n;
            native_type = nt;
            qore_type = qt;
            size = sz;
            nullable = nul;
            def_val = dv;
            comment = c;
        }

        #! returns the string describing the native type that can be used in SQL (for example to add the colunn to a table or when creating the table)
        string getNativeTypeString() {
            string sql = native_type;
            if (size)
                sql += sprintf("(%d)", size);
            return sql;
        }

        #! returns an sql string that can be used to add the column to a table
        string getCreateSql() {
            string sql = sprintf("%s %s", name, getNativeTypeString());
            if (exists def_val)
                sql += " default " + def_val + "";
            if (!nullable)
                sql += " not null";
            return sql;
        }

        #! returns a list of sql strings that can be used to add the column to an existing table
        /** @par Example:
            @code
my list $l = $col.getCreateSql($t);
            @endcode

            @param t the AbstractTable object to modify

            @return a list of sql strings that can be used to add the column to an existing table
         */
        abstract list getCreateSql(AbstractTable t);

        #! returns a string that can be used to drop the column from the table
        string getDropSql(string table_name) {
            return sprintf("alter table %s drop column %s", table_name, name);
        }

        #! returns a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $col.getModifySql($t, $newcol);
            @endcode

            The column names are assumed to be equal.

            @param t the AbstractTable object to modify
            @param c the new column definition

            @return a list of sql strings that can be used to modify the column to the new definition; if the column definitions are identical then an empty list is returned
         */
        abstract list getModifySql(AbstractTable t, AbstractColumn c);

        #! returns a string that can be used to rename the column
        /** @par Example:
            @code
my string $str = $col.getRenameSql($t, "new_name");
            @endcode

            @param t the AbstractTable object to modify
            @param new_name the new name for the column

            @return a string that can be used to rename the column
        */
        abstract string getRenameSql(AbstractTable t, string new_name);

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equal(AbstractColumn c) {
            if (self.className() != c.className() || name != c.name || native_type != c.native_type || size != c.size || nullable != c.nullable || def_val != c.def_val || comment != c.comment) {
                #printf("L: %N\nXXXXXXXXXXXXXXX\nR: %N\n\n", self, c);
                return False;
            }

            return equalImpl(c);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        private abstract bool equalImpl(AbstractColumn c);
    }

    #! the base class to use to extend AbstractColumn to implement numeric columns
    public class NumericColumnInfo {
        public {
            #! the scale for numeric columns
            int scale;
        }

        constructor(softint n_scale = 0) {
            scale = n_scale;
        }
 
        #! returns the string describing the native type that can be used in SQL (for example to add the column to a table or when creating the table)
        string getNativeTypeString(string native_type, int precision) {
            string sql = native_type;
            if (precision) {
                sql += sprintf("(%d", precision);
                if (scale)
                    sql += sprintf(",%d", scale);
                sql += ")";
            }
            return sql;
        }
   }
    
    #! index container class that throws an exception if an unknown index is accessed
    public class Indexes inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! adds the given value to the hash with the given key name
        add(string k, AbstractIndex val) {
            h{k} = val;
        }

        #! find an index with columns equal to the index passed
        *AbstractIndex findEqual(AbstractIndex ix) {
            foreach AbstractIndex ix2 in (h.iterator()) {
                if (ix2.equalExceptName(ix))
                    return ix2;
            }
        }
        
        #! removes the given key from the contained hash and returns the value
        AbstractIndex take(string k) {
            return remove h{k};
        }

        #! returns the AbstractIndex object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code
my AbstractIndex $ix = $indexes.pk_jobs;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        AbstractIndex memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "index";
        }
    }

    #! the abstract base class for index information
    public class AbstractIndex {
        public {
            #! the name of the index
            string name;
            
            #! @ref Qore::True "True" if the index is a unique index, @ref Qore::False "False" if not
            bool unique;

            #! an object of class Columns representing the columns in the index
            Columns columns;
        }

        private {
            #! the AbstractUniqueConstraint that this index supports, if any
            *AbstractUniqueConstraint constraint;
        }

        #! creates the object from the name, a unique flag, and a hash of column information
        constructor(string n, bool u, hash c) {
            name = n;
            unique = u;
            columns = new Columns(c);
        }

        #! returns the index name
        string getName() {
            return name;
        }

        #! returns @ref Qore::True "True" if the constraint references the named column
        bool hasColumn(string cname) {
            return columns.hasKey(cname);
        }

        #! returns a string that can be used to create the index in the database
        abstract string getCreateSql(string table_name, *hash opt);

        #! returns a string that can be used to drop the index from the database
        string getDropSql(string table_name) {
            return sprintf("drop index %s", name);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current index, @ref Qore::False "False" if not
        bool equal(AbstractIndex ix) {
            if (ix.className() != self.className())
                return False;

            if (name != ix.name || unique != ix.unique || (columns.keys() != ix.columns.keys()))
                return False;
            
            return equalImpl(ix);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current index with the exception of the name, @ref Qore::False "False" if not
        bool equalExceptName(AbstractIndex ix) {
            if (ix.className() != self.className())
                return False;

            if (unique != ix.unique || (columns.keys() != ix.columns.keys()))
                return False;
            
            return equalImpl(ix);
        }        

        #! returns @ref Qore::True "True" if the argument is equal to the current index, @ref Qore::False "False" if not
        abstract bool equalImpl(AbstractIndex ix);

        #! returns a string that can be used to rename the index in the database
        abstract string getRenameSql(string table_name, string new_name);

        #! tags the index with a unique constraint that the index supports
        setSupportingConstraint(AbstractUniqueConstraint c) {
            constraint = c;
        }

        #! clears the supporting constraint
        setSupportingConstraint() {
            remove constraint;
        }

        #! returns the supporting constraint, if any
        *AbstractUniqueConstraint getSupportingConstraint() {
            return constraint;
        }

        #! returns a list of strings to drop and recreate the current index; if there are dependent constraints, the list contains commands to disable the constraints before dropping the index and also contains commands to re-enable the contraints after re-creating the index
        list getRecreateSql(AbstractDatasource ds, string table_name, *hash opt) {
            list l = ();
            list enl;
            # get drop SQL and disable any dependent constraints plus a list of strings to re-enable the constraints
            if (constraint) {
                hash drh = constraint.getDisableReenableSql(ds, table_name, opt);
                l += drh.disable;
                enl = drh.enable;
            }

            ## drop current index
            l += getDropSql(table_name);

            # add new index to table
            l += getCreateSql(table_name, opt);

            # re-enable any constraints disabled when dropping the index
            if (enl)
                l += enl;

            return l;
        }
    }

    #! constraint container class that throws an exception if an unknown constraint is accessed
    public class Constraints inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! adds the given value to the hash with the given key name
        add(string k, AbstractConstraint val) {
            h{k} = val;
        }

        #! removes the given key from the contained hash and returns the value
        AbstractConstraint take(string k) {
            return remove h{k};
        }

        #! finds a unique constraint with the same columns as the unique constraint passed
        *AbstractUniqueConstraint findEqualUniqueConstraint(AbstractUniqueConstraint uk) {
            foreach AbstractConstraint c in (h.iterator()) {
                if (!(c instanceof AbstractUniqueConstraint))
                    continue;
                AbstractUniqueConstraint uk2 = c;
                if (uk2.matchKeys(uk))
                    return uk2;
            }
        }

        #! returns the AbstractConstraint object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code
my AbstractConstraint $ix = $constraints.uk_jobs;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        AbstractConstraint memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "constraint";
        }
    }

    #! abstract base class for constraints
    public class AbstractConstraint {
        public {}

        private {
            #! the name of the constraint
            string name;
        }
        
        #! creates the object and sets its name
        constructor(string n) {
            name = n;
        }

        #! returns the constraint name
        string getName() {
            return name;
        }

        #! renames the constraint
        rename(string n) {
            name = n;
        }

        #! returns a string that can be used to create the constraint in the database
        abstract string getCreateSql(string table_name, *hash opt);        

        #! returns a string that can be used to drop the constraint from the database
        string getDropSql(string table_name) {
            return sprintf("alter table %s drop constraint %s", table_name, name);
        }

        #! returns a list of SQL strings that can be used to rename the constraint in the database
        abstract list getRenameSql(string table_name, string new_name);

        #! returns a string that can be used to temporarily disable the constraint from the database; if disabling constraints is not supported, then the constraint will be dropped
        string getDisableSql(string table_name) {
            return getDropSql(table_name);
        }

        #! returns a string that can be used to enable the constraint in the database; if disabling constraints is not supported, then the constraint will be dropped
        string getEnableSql(string table_name, *hash opt) {
            return getCreateSql(table_name, opt);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equal(AbstractConstraint c) {
            if (c.className() != self.className() || name != c.name)
                return False;

            return equalImpl(c);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        private abstract bool equalImpl(AbstractConstraint c);

        #! returns @ref Qore::True "True" if the object supports an index property and is set, @ref Qore::False "False" if not
        abstract bool setIndexBase(string ix);

        #! clears any index base for the constraint
        abstract clearIndex();

        #! returns @ref Qore::True "True" if the constraint references the named column
        bool hasColumn(string cname) {
            return False;
        }
    }

    #! abstract class for check constraints
    public class AbstractCheckConstraint inherits AbstractConstraint {
        public {
            #! the source of the check clause
            string src;
        }

        #! creates the object and sets its name and the check clause source
        constructor(string n, string n_src) : AbstractConstraint(n) {
            name = n;
            src = n_src;
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        private bool equalImpl(AbstractConstraint c) {
            return src != cast<AbstractCheckConstraint>(c).src ? False : True;
        }

        #! returns @ref Qore::True "True" if the object supports an index property and is set, @ref Qore::False "False" if not
        bool setIndexBase(string ix) {
            return False;
        }

        #! clears any index base for the constraint
        clearIndex() {
        }
    }

    #! represents a unique column constraint
    public class AbstractUniqueConstraint inherits AbstractConstraint, Columns {
        private {
            #! a hash of ForeignConstraintSources, keyed by table name, the value is a hash of foreign constraints keyed by constraint name
            hash sourceConstraints;

            #! the index supporting the constraint
            *string index;
        }

        #! creates the object from the name an a hash of column information
        constructor(string n, *hash c, *string n_index) : AbstractConstraint(n), Columns(c) {
            index = n_index;
        }

        #! returns a string that can be used to create the constraint in the database
        abstract string getCreateSql(string table_name, *hash opts);

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        private bool equalImpl(AbstractConstraint c) {
            return (self.keys() != cast<AbstractUniqueConstraint>(c).keys()) ? False : True;
        }

        #! returns an iterator through all known source foreign constraints on the current table
        /** each element is a hash with the following keys:
            - \c fk: the AbstractForeignConstraint object
            - \c table: the table name
        */
        Qore::AbstractIterator getSourceConstraintIterator() {
            list l = ();
            foreach hash sch in (sourceConstraints.pairIterator()) {
                map l += ("fk": $1, "table": sch.key), sch.value.iterator();
            }

            return l.iterator();
        }

        #! returns lists of SQL strings to disable this constraint plus any dependent constraints and another list of SQL strings to reenable the same constraints; used when updating indexes that depend on constraints
        hash getDisableReenableSql(AbstractDatasource ds, string table_name, *hash opts) {
            hash ch = (
                "disable": (),
                "enable": (),
                );

            foreach hash sch in (sourceConstraints.pairIterator()) {
                # make sure table actually exists before disabling constraints
                Table t(ds, sch.key);
                if (!t.checkExistence())
                    continue;
                foreach AbstractForeignConstraint fk in (sch.value.iterator()) {
                    ch.disable += fk.getDisableSql(sch.key);
                    unshift ch.enable, fk.getEnableSql(sch.key, opts);
                }
            }
            
            ch.disable += getDisableSql(table_name);
            unshift ch.enable, getEnableSql(table_name, opts);

            return ch;
        }

        #! find an index that matches the constraint and marks both objects as related
        findMatchingIndex(*Indexes indexes) {
            if (index) {
                if (indexes.hasKey(index))
                    indexes{index}.setSupportingConstraint(self);
                return;
            }

            # see if the primary key corresponds to a unique index with the same name & columns
            if (indexes.hasKey(name)) {
                AbstractIndex ix = indexes{name};
                if (ix.columns.matchKeys(h) && setIndexBase(ix.name))
                    ix.setSupportingConstraint(self);
            }
            else {
                # search for an index with matching columns
                foreach AbstractIndex ix in (indexes.iterator()) {
                    if (ix.columns.matchKeys(h)) {
                        if (setIndexBase(ix.name))
                            ix.setSupportingConstraint(self);
                        break;
                    }
                }
            }
        }

        #! adds a foreign constraint source to the unique constraint
        /** @par Example:
            @code
$uk.addSourceConstraint($table_name, constraint_name);
            @endcode

            @param tname the name of the source table
            @param fk the source constraint

            @throw SOURCE-CONSTRAINT-ERROR a different source constraint with the given name already exists
        */
        addSourceConstraint(string tname, AbstractForeignConstraint fk) {
            if (sourceConstraints{tname}{fk.getName()})
                throw "SOURCE-CONSTRAINT-ERROR", sprintf("unique constraint %y: already has a source constraint from table %y from foreign constraint %y", name, tname, fk.getName());
            sourceConstraints{tname}{fk.getName()} = fk;
            #printf("added source constraint to %y: %s.%s\n", name, tname, fk.getName());
        }

        #! removes a source constraint
        removeSourceConstraint(string tname, list cols) {
            if (matchKeys(cols))
                remove sourceConstraints{tname};
        }

        #! renames a table in a source constraint
        renameSourceConstraintTable(string old_name, string new_name) {
            if (sourceConstraints{old_name})
                sourceConstraints{new_name} = remove sourceConstraints{old_name};
        }

        #! returns @ref Qore::True "True" if the constraint references the named column
        bool hasColumn(string cname) {
            return h.hasKey(cname);
        }
    }

    #! represents a primary key
    public class AbstractPrimaryKey inherits AbstractUniqueConstraint {
        constructor(string n, *hash c) : AbstractUniqueConstraint(n, c) {
        }
    }

    #! foreign constraint container class that throws an exception if an unknown constraint is accessed
    public class ForeignConstraints inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! adds the given value to the hash with the given key name
        add(string k, AbstractForeignConstraint val) {
            h{k} = val;
        }

        #! removes the given key from the contained hash and returns the value
        AbstractForeignConstraint take(string k) {
            return remove h{k};
        }

        #! find an index with columns equal to the index passed
        *AbstractForeignConstraint findEqual(AbstractForeignConstraint fk) {
            foreach AbstractForeignConstraint fk2 in (h.iterator()) {
                if (fk2.columns.matchKeys(fk.columns) && fk2.target.table == fk.target.table && fk2.target.columns.matchKeys(fk.target.columns))
                    return fk2;
            }
        }
        
        #! returns the AbstractForeignConstraint object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code
my AbstractForeignConstraint $ix = $fcs.fk_jobs_job_defs;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        AbstractForeignConstraint memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        #! returns either a hash of AbstractColumn information or @ref nothing if no foreign constraint can be found that matches the arguments
        *hash findConstraintOn(string table, softlist cols) {
            foreach AbstractForeignConstraint fk in (h.iterator()) {
                if (fk.target.table == table && fk.target.columns.matchKeys(cols))
                    return fk.columns.getHash();
            }
        }

        #! returns \c "foreign constraint" for the type of object encapsulated
        string getElementName() {
            return "foreign constraint";
        }
    }

    #! a class describing a foreign constraint target
    public class ForeignConstraintTarget {
        public {
            #! the name of the target table
            string table;

            #! columns in the target table
            Columns columns;
        }

        #! creates the object and sets the target table name and the target columns
        constructor(string t, Columns c) {
            table = t;
            columns = c;
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equal(ForeignConstraintTarget targ) {
            return table != targ.table || (columns.keys() != targ.columns.keys()) ? False : True;
        }
    }

    #! the base class for foreign key constraint information
    public class AbstractForeignConstraint inherits AbstractConstraint {
        public {
            #! an object of class Columns giving the source table that make up the constraint
            Columns columns;

            #! a ForeignConstraintTarget object to describe the target table and columns
            ForeignConstraintTarget target;
        }

        constructor(string n, Columns c, ForeignConstraintTarget t) : AbstractConstraint(n) {
            columns = c;
            target = t;
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        private bool equalImpl(AbstractConstraint con) {
            AbstractForeignConstraint c = cast<AbstractForeignConstraint>(con);
            return (columns.keys() != c.columns.keys())
                || !target.equal(c.target)
                ? False : True;
        }

        #! returns @ref Qore::True "True" if the constraint references the named column
        bool hasColumn(string cname) {
            return columns.hasKey(cname);
        }

        #! returns @ref Qore::True "True" if the object supports an index property and is set, @ref Qore::False "False" if not
        bool setIndexBase(string ix) {
            return False;
        }

        #! clears any index base for the constraint
        clearIndex() {
        }
    }

    #! base class for sequences
    public class AbstractSequence {
        public {
            #! the name of the sequence
            string name;

            #! the starting number
            number start;

            #! the increment
            number increment;
            
            #! the ending number
            *number max;
        }

        #! creates the object from the arguments
        constructor(string n_name, number n_start = 1, number n_increment = 1, *softnumber n_max) {
            name = n_name;
            start = n_start;
            increment = n_increment;
            max = n_max;
            if (!increment)
                throw "SEQUENCE-ERROR", sprintf("sequence %y: increment cannot be zero", name);
            if (max) {
                if (increment > 0 && max < start)
                    throw "SEQUENCE-ERROR", sprintf("ascending sequence %y increment %d: max value %d is less than the starting value: %d", name, increment, max, start);
                if (increment < 0 && max > start)
                    throw "SEQUENCE-ERROR", sprintf("descending sequence %y increment %d: max value %d is less than the starting value: %d", name, increment, max, start);
            }
        }

        #! returns a string that can be used to create the sequence in the database
        abstract string getCreateSql(*hash opt);        

        #! returns a string that can be used to drop the sequence from the database
        string getDropSql() {
            return sprintf("drop sequence %s", name);
        }

        #! returns a string that can be used to rename the sequence in the database
        abstract string getRenameSql(string new_name);
    }

    #! base class for function or objects with code
    public class AbstractFunctionBase {
        public {
            #! the name of the object
            string name;

            #! the type of object
            string type;
            
            #! the source of the object
            string src;
        }

        #! creates the object from the arguments passed
        /** @param n the name of the object
            @param n_type the type of object
            @param n_src the source of the object
         */
        constructor(string n, string n_type, string n_src) {
            name = n;
            type = n_type;
            src = n_src;
        }
        
        #! returns the type of object
        string getType() {
            return type;
        }
        
        # FIXME: not appropriate for pgsql triggers for example
        #! returns a string that can be used to drop the function from the database
        string getDropSql() {
            return sprintf("drop %s %s", type, name);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        bool equal(AbstractFunctionBase t) {
            if (self.className() != t.className() || name != t.name || type != t.type) {
                return False;
            }

            string src1 = src;
            src1 =~ s/\n/ /g;
            string src2 = t.src;
            src2 =~ s/\n/ /g;

            if (src1 != src2) {
                #printf("%s\nXXXXXXXXXXXXXXX\n%s\n", src1, src2);
                return False;
            }
            #printf("%s\nXXXXXX EQUAL XXXXXXXXX\n%s\n", src1, src2);
            
            return equalImpl(t);
        }

        #! returns @ref Qore::True "True" if the argument is equal to the current object, @ref Qore::False "False" if not
        private abstract bool equalImpl(AbstractFunctionBase t);
    }

    #! base class for functions
    public class AbstractFunction inherits AbstractFunctionBase {
        #! creates the object from the arguments passed
        /** @param n the name of the object
            @param n_type the type of object
            @param n_src the source of the object
         */
        constructor(string n, string n_type, string n_src) : AbstractFunctionBase(n, n_type, n_src) {
        }

        #! returns a list of SQL strings that can be used to create the function in the database
        abstract list getCreateSql(*hash opt);

        #! returns a string that can be used to rename the function in the database
	abstract list getRenameSql(string new_name);

        #! sets the new name of the object
        setName(string new_name) {
            name = new_name;
        }
    }

    #! function container class that throws an exception if an unknown function is accessed
    public class Functions inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! adds the given value to the hash with the given key name
        add(string k, AbstractFunction val) {
            h{k} = val;
        }

        #! removes the given key from the contained hash and returns the value
        AbstractFunction take(string k) {
            return remove h{k};
        }

        #! returns the AbstractFunction object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code
my AbstractFunction $f = $funcs.func1;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        AbstractFunction memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "function";
        }
    }

    #! the base class for triggers
    public class AbstractTrigger inherits AbstractFunctionBase {
        #! creates the object and sets its name and the trigger source
        constructor(string n, string n_src) : AbstractFunctionBase(n, "trigger", n_src) {
        }

        #! returns a string that can be used to create the trigger in the database
        abstract list getCreateSql(string table_name, *hash opt);        

        #! returns a string that can be used to rename the trigger in the database
	abstract list getRenameSql(string table_name, string new_name);

        #! returns a string that can be used to drop the trigger in the database
	abstract list getDropSql(string table_name);
    }

    #! trigger container class that throws an exception if an unknown trigger is accessed
    public class Triggers inherits AbstractHashContainer {
        constructor(*hash c) : AbstractHashContainer(c) {
        }

        #! adds the given value to the hash with the given key name
        add(string k, AbstractTrigger val) {
            h{k} = val;
        }

        #! removes the given key from the contained hash and returns the value
        AbstractTrigger take(string k) {
            return remove h{k};
        }

        #! returns the AbstractTrigger object corresponding to the key given or throws a KEY-ERROR exception
        /** @par Example:
            @code
my AbstractTrigger $trig = $trigs.job_trig;
            @endcode

            @param k the name of the key to access

            @return the value of the given key in the contained hash if it exists

            @throw KEY-ERROR the given key does not exist in the contained hash

            @note this method is called automatically when an unknown or inaccessible member name is accessed from outside the class
            
            @see @ref memberGate_methods
        */
        AbstractTrigger memberGate(string k) {
            return AbstractHashContainer::memberGate(k);
        }

        string getElementName() {
            return "trigger";
        }
    }

    #! represents a database; this class embeds an AbstractDatabase object that is created automatically in the constructor based on the database driver for the AbstractDatasource object providing the database connection
    /** Driver-specific modules that provide the AbstractDatabase implementation embedded in this class are loaded on demand based on the driver's name.
        The driver-specific module's name is generated based on the db-driver's name with the first letter capitalized then with \c "SqlUtil" appended.

        For example:
        - \c "oracle": <a href="../../OracleSqlUtil/html/index.html">OracleSqlUtil</a>
        - \c "pgsql": <a href="../../PgsqlSqlUtil/html/index.html">PgsqlSqlUtil</a>
        - \c "mysql": <a href="../../MysqlSqlUtil/html/index.html">MysqlSqlUtil</a>

        etc.
    */
    public class Database {
        private {
            #! the embedded AbstractDatabase object that actually provides the functionality for this class
            AbstractDatabase db;
        }

        #! creates the Database object
        /** @par Example:
            @code
my Database $db($ds);
            @endcode

            @param ds the AbstractDatasource object used to provide the DB connection
            @param opts a hash of options for the function creation string; see @ref AbstractDatabase::DatabaseOptions for common options; each driver can support additional driver-specific options

            @throw DATABASE-DRIVER-ERROR no database-specific module can be loaded 
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        constructor(AbstractDatasource ds, *hash opts) {
            db = AbstractDatabase::getDatabase(ds, opts);
        }

        #! creates the AbstractDatabase object
        /** @par Example:
            @code
my AbstractDatabase $db("pgsql:user/pass@db%host");
            @endcode

            @param ds a datasource description string in the format that can be parsed by parse_datasource()
            @param opts a hash of options for the function creation string; see @ref AbstractDatabase::DatabaseOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        constructor(string ds, *hash opts) {
            db = AbstractDatabase::getDatabase(ds, opts);
        }
        
        #! creates the AbstractDatabase object
        /** @par Example:
            @code
my AbstractDatabase $db("pgsql:user/pass@db%host");
            @endcode

            @param ds a hash giving parameters for the new datasource with the following possible keys (the \c "type" key is mandatory, also usable with the output of the parse_datasource() function):
            - \c type: (@ref string_or_nothing_type "*string") The name of the database driver to use; this key is mandatory; if not present, an exception will be raised. See @ref sql_constants for builtin constants for DBI drivers shipped with Qore, or see the DBI driver documentation to use an add-on driver (this string should be the name of the driver to be loaded)
            - \c user: (@ref string_or_nothing_type "*string") The user name for the new connection
            - \c pass: (@ref string_or_nothing_type "*string") The password for the new connection
            - \c db: (@ref string_or_nothing_type "*string") The database name for the new connection
            - \c charset: (@ref string_or_nothing_type "*string") The database-specific name of the character encoding to use for the new connection. Also see Qore::SQL::Datasource::setDBCharset() for a method that allows this parameter to be set after the constructor. If no value is passed for this parameter, then the database character encoding corresponding to the default character encoding for the %Qore process will be used instead.
            - \c host: (@ref string_or_nothing_type "*string") The host name for the new connection
            - \c port: (@ref softint_type "softint") The port number for the new connection
            - \c options: (@ref hash_or_nothing_type "*hash") Any options for the new connection
            @param opts a hash of options for the table creation string; see @ref AbstractDatabase::DatabaseOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        constructor(hash ds, *hash opts) {
            db = AbstractDatabase::getDatabase(ds, opts);
        }

        #! executes some SQL with optional arguments so that if an error occurs the current transaction state is not lost
        /** @par Example: 
            @code
$t.tryExec("drop table tmp_table");
            @endcode

            Include any arguments in the parameter list after the \a sql argument

            @param sql the SQL to execute

            @return any return value from the SQL command executed
         */
        any tryExec(string sql) {
            return db.tryExecArgs(sql, argv);
        }

        #! executes some SQL with optional arguments so that if an error occurs the current transaction state is not lost
        /** @par Example: 
            @code
$t.tryExec("delete from tmp_table where id = %v and name = %v", $arglist);
            @endcode

            @param sql the SQL to execute
            @param args the bind / placeholder or other arguments corresponding to the SQL string

            @return any return value from the SQL command executed
         */
        any tryExecArgs(string sql, *softlist args) {
            return db.tryExecArgs(sql, args);
        }

        #! executes some SQL so that if an error occurs the current transaction state is not lost
        /** @par Example: 
            @code
$t.tryExecRaw("drop table tmp_table");
            @endcode

            Include any arguments in the parameter list after the \a sql argument

            @param sql the SQL to execute

            @return any return value from the SQL command executed
         */
        any tryExecRaw(string sql) {
            return db.tryExecRaw(sql);
        }

        #! accepts a hash argument describing a database schema and returns a list of SQL strings that can be used to align the structure and configuration of the current schema with that of the argument; if the objects described are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $db.getAlignSql($schema_hash);
            @endcode

            @param schema_hash the schema template hash that decribes the target state of the schema
            @param opt a hash of options for the SQL creation strings; see @ref AbstractDatabase::AlignSchemaOptions for common options; each driver can support additional driver-specific options
            @param table_cache an optional object of class Tables to return the cache of AbstractTable objects keyed by table name for the schema template (ie target table definitions)

            @return a list of SQL strings that can be used to align the structure and configuration of the current schema with that of the argument; if the objects described are identical then an empty list is returned

            @throw SCHEMA-DESCRIPTION-ERROR the schema description hash has an error or a required object does not exist
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        list getAlignSql(hash schema_hash, *hash opt, *Tables table_cache) {
            return db.getAlignSql(schema_hash, opt, table_cache);
        }

        #! accepts a hash argument describing a database schema and returns a list of SQL strings that can be used to drop any existing objects described in the schema; if none of the described objects exist, then an empty list is returned
        /** @par Example:
            @code
my list $l = $db.getDropSchemaSql($schema_hash);
            @endcode

            @param schema_hash the schema template hash that decribes the state of the schema
            @param opt a hash of options for the SQL strings; see @ref AbstractDatabase::DropSchemaOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to drop any existing objects in the database; if none of the described objects exist, then an empty list is returned

            @throw SCHEMA-DESCRIPTION-ERROR the schema description hash has an error
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        list getDropSchemaSql(hash schema_hash, *hash opt) {
            return db.getDropSchemaSql(schema_hash, opt);
        }

        #! gets the underlying AbstractDatasource
        Qore::SQL::AbstractDatasource getDatasource() {
            return db.getDatasource();
        }

        #! executes a method on the contained AbstractDatabase object
        any methodGate(string meth) {
            return callObjectMethodArgs(db, meth, argv);
        }

        #! creates a database-specific AbstractSequence object corresponding to the arguments
        /** @par Example:
            @code
my AbstractSequence $seq = $db.makeSequence("seq_queues");
            @endcode

            @param name the name of the sequence
            @param start the starting value of the sequence
            @param increment the increment value of the sequence
            @param end the endinf value of the sequence, omit for no ending value
            @param opts an optional hash of options for the creation of the sequence; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw SEQUENCE-ERROR end not compatible with start and increment, increment is zero
        */
        AbstractSequence makeSequence(string name, number start = 1, number increment = 1, *softnumber end, *hash opts) {
            return db.makeSequence(name, start, increment, end, opts);
        }

        #! creates a database-specific AbstractTable object corresponding to the arguments
        /** @par Example:
            @code
my AbstractTable $table = $db.makeTable("table", $th);
            @endcode

            @param name the name of the table
            @param desc a @ref table_desc_hash "table description hash" describing the table
            @param opts an optional hash of options for the table creation string; see @ref SqlUtil::AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed

            @see SqlUtil::Table::constructor()
        */
        AbstractTable makeTable(string name, hash desc, *hash opts) {
            return db.makeTable(name, desc, opts);
        }

        #! creates a database-specific AbstractFunction object corresponding to the arguments
        /** @par Example:
            @code
my AbstractFunction $f = $db.makeFunction("update_queue", $src);
            @endcode

            @param name the name of the function
            @param src the database-specific source code of the function (see the database-specific documentation for information about the format of this parameter; generally it's simply the normal source code for the function required by the database)
            @param opt an optional hash of options for the creation of the function; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        AbstractFunction makeFunction(string name, string src, *hash opt) {
            return db.makeFunction(name, src, opt);
        }

        #! creates a database-specific AbstractFunction object for a stored procedure corresponding to the arguments
        /** @par Example:
            @code
my AbstractFunction $f = $db.makeProcedure("get_queue_info", $src);
            @endcode

            @param name the name of the stored procedure
            @param src the database-specific source code of the stored procedure (see the database-specific documentation for information about the format of this parameter; generally it's simply the normal source code for the stored procedure required by the database)
            @param opt an optional hash of options for the creation of the stored procedure; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        AbstractFunction makeProcedure(string name, string src, *hash opt) {
            return db.makeProcedure(name, src, opt);
        }

        #! drops the given function if it exists; returns @ref Qore::True "True" if the function was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropFunctionIfExists($name);
            @endcode

            @param name the name of the function
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info
            
            @return @ref Qore::True "True" if the function was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropFunctionIfExists(string name, *hash opt) {
            return db.dropFunctionIfExists(name, opt);
        }

        #! drops the given procedure if it exists; returns @ref Qore::True "True" if the procedure was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropProcedureIfExists($name);
            @endcode

            @param name the name of the procedure
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return @ref Qore::True "True" if the procedure was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropProcedureIfExists(string name, *hash opt) {
            return db.dropProcedureIfExists(name, opt);
        }

        #! drops the given sequence if it exists; returns @ref Qore::True "True" if the sequence was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropSequenceIfExists($name);
            @endcode

            @param name the name of the sequence
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return @ref Qore::True "True" if the sequence was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropSequenceIfExists(string name, *hash opt) {
            return db.dropSequenceIfExists(name, opt);
        }

        #! drops the given table if it exists; returns @ref Qore::True "True" if the table was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropTableIfExists($name);
            @endcode

            @param name the name of the table
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return @ref Qore::True "True" if the table was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropTableIfExists(string name, *hash opt) {            
            return db.dropTableIfExists(name, opt);
        }

        #! returns a list of SQL strings that can be used to update a function in the database to the function definition passed as an argument
        /** @par Example:
            @code
my list $l = $db.getAlignFunctionSql($f);
            @endcode

            @param f the template or target version of the function to compare to the database version
            @param opt an optional hash of options for the generation of the SQL strings; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to update a function in the database to the function definition passed as an argument

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        list getAlignFunctionSql(AbstractFunction f, *hash opt) {
            return db.getAlignFunctionSql(f, opt);
        }

        #! returns a list of SQL strings that can be used to update a stored procedure in the database to the stored procedure definition passed as an argument
        /** @par Example:
            @code
my list $l = $db.getAlignProcedureSql($f);
            @endcode

            @param f the template or target version of the stored procedure to compare to the database version
            @param opt an optional hash of options for the generation of the SQL strings; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to update a stored procedure in the database to the stored procedure definition passed as an argument

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        list getAlignProcedureSql(AbstractFunction f, *hash opt) {
            return db.getAlignProcedureSql(f, opt);
        }

        #! returns an AbstractTable argument for the given table name or @ref nothing if the table cannot be found
        /** @par Example:
            @code
my *AbstractTable $table = $db.getTable("queues");
            @endcode

            @param name the uniquely-identifying name of the table to retrieve

            @return an AbstractTable argument for the given table name or @ref nothing if the table cannot be found
         */
        *AbstractTable getTable(string name) {
            return db.getTable(name);
        }

        #! returns an AbstractSequence argument for the given sequence name or @ref nothing if the sequence cannot be found
        /** @par Example:
            @code
my *AbstractSequence $seq = $db.getSequence("seq_queues");
            @endcode

            @param name the uniquely-identifying name of the sequence to retrieve

            @return an AbstractSequence argument for the given sequence name or @ref nothing if the sequence cannot be found
         */
        *AbstractSequence getSequence(string name) {
            return db.getSequence(name);
        }

        #! returns an AbstractFunction argument for the given function name or @ref nothing if the function cannot be found
        /** @par Example:
            @code
my *AbstractFunction $f = $db.getFunction("update_queue");
            @endcode

            @param name the uniquely-identifying name of the function to retrieve

            @return an AbstractFunction argument for the given function name or @ref nothing if the function cannot be found

            @note for databases that support overloaded functions, the arguments must be passed in parentheses after the name to match overloaded functions properly
         */
        *AbstractFunction getFunction(string name) {
            return db.getFunction(name);
        }

        #! returns an AbstractFunction argument for the given stored procedure name or @ref nothing if the stored procedur  cannot be found
        /** @par Example:
            @code
my *AbstractFunction $f = $db.getProcedure("update_queue");
            @endcode

            @param name the uniquely-identifying name of the stored procedure to retrieve

            @return an AbstractFunction argument for the given stored procedure name or @ref nothing if the stored procedure cannot be found

            @note for databases that support overloaded stored procedures, the arguments must be passed in parentheses after the name to match overloaded stored procedures properly
         */
        *AbstractFunction getProcedure(string name) {
            return db.getProcedure(name);
        }

        #! returns the next value in the given sequence
        /** @par Example:
            @code
my number $n = $db.getNextSequenceValue("seq_customers");
            @endcode

            @param name the name of the sequence

            @return the next value in the given sequence
        */
        int getNextSequenceValue(string name) {
            return db.getNextSequenceValue(name);
        }

        #! returns an SQL string corresponding to the list of commands in the argument
        /** @par Example:
            @code
my string $sql = $t.getSqlFromList($list);
            @endcode

            @param l a list of SQL commands
            
            @return an SQL string corresponding to the list of commands in the argument
        */
        string getSqlFromList(list l) {
            return db.getSqlFromList(l);
        }

        #! returns @ref Qore::True "True" if the database supports sequences
        bool supportsSequences() {
            return db.supportsSequences();
        }

        #! returns a list of string table names in the database
        list listTables() {
            return db.listTables();
        }
        
        #! returns an iterator listing the string table names in the database
        Qore::ListIterator tableIterator() {
            return db.tableIterator();            
        }
 
        #! returns a list of string function names in the database
        list listFunctions() {
            return db.listFunctions();
        }
        
        #! returns an iterator listing the string function names in the database
        Qore::ListIterator functionIterator() {
            return db.functionIterator();            
        }

        #! returns a list of string procedure names in the database
        list listProcedures() {
            return db.listProcedures();
        }
        
        #! returns an iterator listing the string procedure names in the database
        Qore::ListIterator procedureIterator() {
            return db.procedureIterator();            
        }

        #! returns a list of string sequence names in the database
        list listSequences() {
            return db.listSequences();
        }
        
        #! returns an iterator listing the string sequence names in the database
        Qore::ListIterator sequenceIterator() {
            return db.sequenceIterator();            
        }

        #! returns a list of string view names in the database
        list listViews() {
            return db.listViews();
        }
        
        #! returns an iterator listing the string view names in the database
        Qore::ListIterator viewIterator() {
            return db.viewIterator();
        }
    }

    #! base class for abstract SqlUtil classes
    public class AbstractSqlUtilBase {
        private {
            #! the connection to the database server
            AbstractDatasource ds;
            #! datasource description
            string dsdesc;
            #! mutex for atomic actions
            Mutex l();
            #! option hash
            *hash opts;
        }

        #! creates the object; private constructor
        /** @param nds the AbstractDatasource for the connection to the database
            @param nopts a hash of options for the table creation string; see @ref SqlUtil::AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        private constructor(AbstractDatasource nds, *hash nopts) {
            opts = nopts;
            ds = nds;

            # ensure datasource is open
            ds.getServerVersion();
            dsdesc = sprintf("%s:%s@%s", ds.getDriverName(), ds.getUserName(), ds.getDBName());
            if (ds.getHostName())
                dsdesc += "%" + ds.getHostName();
            if (ds.getPort())
                dsdesc += sprintf(":%d", ds.getPort());
        }

        private validateOptionsIntern(string err, hash ropt, reference opt, string tag) {
            # make sure driver-specific options take precedence over generic options            
            string dn = getDriverName();
            if (opt.driver{dn})
                opt += remove opt.driver{dn};
            delete opt.driver;

            # check valid options and option value types
            foreach string k in (opt.keyIterator()) {
                if (!ropt.hasKey(k))
                    throw err, sprintf("%s: unknown key %y; valid keys for %y: %y", tag, k, self.className(), ropt.keys());
                
                if (!exists opt{k}) {
                    delete opt{k};
                    continue;
                }

                AbstractSqlUtilBase::validateOptionIntern(err, ropt{k}, \opt{k}, k, tag);
            }
        }

        private static validateOptionIntern(string err, string type, reference opt, string k, string tag) {
            switch (type) {
                case Type::Int: {
                    if (opt.type() != type) {
                        if (!opt.intp())
                            throw err, sprintf("%s: key %y has type %y, expecting \"int\" (value: %y)", tag, k, opt.type(), opt);
                        opt = opt.toInt();
                    }
                    break;
                }
                case Type::Number: {
                    if (opt.type() != type) {
                        if (!opt.intp())
                            throw err, sprintf("%s: key %y has type %y, expecting \"number\" (value: %y)", tag, k, opt.type(), opt);
                        opt = number(opt);
                    }
                    break;
                }
                case Type::Boolean: {
                    if (opt.type() != type) {
                        if (!opt.intp())
                            throw err, sprintf("%s: key %y has type %y, expecting \"boolean\" (value: %y)", tag, k, opt.type(), opt);
                        opt = opt.toBool();
                    }
                    break;
                }
                case Type::String: {
                    if (opt.type() != type) {
                        if (!opt.strp())
                            throw err, sprintf("%s: key %y has type %y, expecting \"string\" (value: %y)", tag, k, opt.type(), opt);
                        opt = opt.toString();
                    }
                    break;
                }
                case "softstringlist": {
                    softlist l = opt;
                    foreach any v in (l) {
                        if (v.typeCode() != NT_STRING)
                            throw err, sprintf("%s: key %y element %d/%d (first is 0) has type %y, expecting \"string\" (value: %y)", tag, k, $#, l.size(), v.type(), opt);
                    }

                    opt = l;
                    break;
                }
                case "hash/list": {
                    if (opt.typeCode() == NT_LIST) {
                        foreach any v in (opt) {
                            if (v.typeCode() != NT_HASH)
                                throw err, sprintf("%s: key %y element %d/%d (first is 0) has type %y, expecting \"hash\" (value: %y)", tag, k, $#, opt.size(), v.type(), opt);                            
                        }
                    }
                    else if (opt.typeCode() != NT_HASH)
                        throw err, sprintf("key %y requires type \"list\" or \"hash\" but type %y was passed (%y)", k, opt.type(), opt);
                    break;
                }
                case "Tables": {
                    if (!(opt instanceof Tables))
                        throw err, sprintf("%s: key %y has type %s, expecting class \"Tables\"", tag, k, opt.typeCode() == NT_OBJECT ? sprintf("class \"%s\"", opt.className()) : sprintf("\"%s\"", opt.type()));
                    break;
                }

                # no validation for NOTHING
                case Type::NothingType: break;
                
                case "code": if (opt.typeCode() == NT_CLOSURE || opt.typeCode() == NT_CALLREF)
                    break;
                
                # throw an exception if the type is not supported
                default: 
                    if (opt.type() != type)
                        throw err, sprintf("key %y requires type %y but type %y was passed (%y)", k, type, opt.type(), opt);
            }
        }

        #! gets the underlying AbstractDatasource
        Qore::SQL::AbstractDatasource getDatasource() {
            return ds;
        }

        #! returns the database driver name 
        string getDriverName() {
            return ds.getDriverName();
        }

        #! returns a descriptive string for the datasource
        string getDatasourceDesc() {
            return dsdesc;
        }
    }

    #! the base abstract class for the database implementation
    public class AbstractDatabase inherits AbstractSqlUtilBase {
        public {
            #! database options
            /** The following keys can be set for this option:
                - \c native_case: (@ref bool_type) if @ref Qore::True "True" then objects will be returned in the case the database server returns them in even if the database server uses case-insensitive names; normally in this case %SqlUtil will convert the names to lower-case
            */
            const DatabaseOptions = (
                "native_case": Type::Boolean,
                );

            #! generic cache options
            /** The following keys can be set for this option:
                - \c table_cache: (@ref SqlUtil::Tables "Tables") an optional table cache for maintaining cached tables and foreign key relationships between tables
            */
            const CacheOptions = (
                "table_cache": "Tables",
                );

            #! generic callback options
            /** The following keys can be set for this option:
                - \c info_callback: see @ref info_callback
                - \c sql_callback: see @ref sql_callback
                - \c sql_callback_executed: see @ref sql_callback_executed
            */
            const CallbackOptions = (
                "info_callback": "code",
                "sql_callback": "code",
                "sql_callback_executed": Type::Boolean,
                );

            /** @defgroup info_actions Info Callback Action Codes
                These are the action codes used with the @ref info_callback in schema and table alignment
                @see
                - @ref ActionMap
                - @ref ActionDescMap
                - @ref ActionLetterMap
             */
            #@{
            #! used when an existing object matches the template and no changes are made
            const AC_Unchanged = 0;

            #! used when a new object is created
            const AC_Create = 1;

            #! used when an object is dropped
            const AC_Drop = 2;

            #! used when an object is renamed
            const AC_Rename = 3;

            #! used when an object is modified in place
            const AC_Modify = 4;

            #! used when a table is truncated
            const AC_Truncate = 5;

            #! used when an element is added to an existing object
            const AC_Add = 6;

            #! used when an object is recreated (usually dropped and recreated in place)
            const AC_Recreate = 7;

            #! used when data is inserted in a table
            const AC_Insert = 8;

            #! used when data is updated in a table
            const AC_Update = 9;

            #! used when data is deleted in a table
            const AC_Delete = 10;

            #! used when dropping object but the object is not present
            const AC_NotFound = 11;
            #@}

            #! maps from action codes to action descriptions
            const ActionMap = (
                AC_Unchanged: "unchanged",
                AC_Create: "create",
                AC_Drop: "drop",
                AC_Rename: "rename",
                AC_Modify: "modify",
                AC_Truncate: "truncate",
                AC_Add: "add",
                AC_Recreate: "recreate",
                AC_Insert: "insert",
                AC_Update: "update",
                AC_Delete: "delete",
                AC_NotFound: "not found",
            );

            #! maps from action descriptions to action codes
            const ActionDescMap = (
                "unchanged": AC_Unchanged,
                "create": AC_Create,
                "drop": AC_Drop,
                "rename": AC_Rename,
                "modify": AC_Modify,
                "truncate": AC_Truncate,
                "add": AC_Add,
                "recreate": AC_Recreate,
                "insert": AC_Insert,
                "update": AC_Update,
                "delete": AC_Delete,
                "not found": AC_NotFound,
            );

            #! maps from action codes to action letter codes
            const ActionLetterMap = (
                AC_Unchanged: ".",
                AC_Create: "C",
                AC_Drop: "D",
                AC_Rename: "N",
                AC_Modify: "M",
                AC_Truncate: "T",
                AC_Add: "A",
                AC_Recreate: "R",
                AC_Insert: "I",
                AC_Update: "U",
                AC_Delete: "X",
                AC_NotFound: ".",
            );

            #! default generic creation options
            /** This option is comprised of @ref AbstractDatabase::CallbackOptions plus the following keys:
                - \c replace: (@ref bool_type) if @ref Qore::True "True" and supported by the underlying db driver "create or replace" text is used when creating objects
                - \c table_cache: (@ref SqlUtil::Tables "Tables") an optional table cache for maintaining cached tables and foreign key relationships between tables
                - \c data_tablespace: (@ref string_type) a string giving the data tablespace to use for tables
                - \c index_tablespace: (@ref string_type) a string giving the index tablespace to use for indexes
            */
            const CreationOptions = CallbackOptions + (
                "replace": Type::Boolean,
                "table_cache": "Tables",
                "data_tablespace": Type::String,
                "index_tablespace": Type::String,
                );

            #! default generic schema description / alignment options
            /** Currently this option is identical to @ref AbstractDatabase::CreationOptions
            */
            const AlignSchemaOptions = CreationOptions;

            #! default generic drop schema options
            /** Currently this option is identical to @ref AbstractDatabase::CallbackOptions
            */
            const DropSchemaOptions = CallbackOptions;

            #! default generic schema description keys
            /** The following keys can be set in schema description hashes:
                - \c tables: a hash keyed by table name set to @ref table_desc_hash "table description hash" values
                - \c table_map: a hash for automatically renaming tables; if the source name (key) exists and the target name (value) does not exist, then the source table is automatically renamed
                - \c sequences: a hash keyed by sequence name set to @ref AbstractDatabase::SequenceDescriptionOptions "sequence hash description" values
                - \c sequence_map: a hash for automatically renaming sequences; if the source name (key) exists and the target name (value) does not exist, then the source sequence is automatically renamed
                - \c functions: a hash keyed by function name set to function source string values
                - \c function_map: a hash for automatically renaming functions; if the source name (key) exists and the target name (value) does not exist, then the source function is automatically renamed
                - \c procedures: a hash keyed by procedure name set to procedure source string values
                - \c procedure_map: a hash for automatically renaming procedures; if the source name (key) exists and the target name (value) does not exist, then the source procedure is automatically renamed

                @see @ref schema_desc_hash for more information
            */
            const SchemaDescriptionOptions = (
                "tables": Type::Hash,
                "table_map": Type::Hash,

                "sequences": Type::Hash,
                "sequence_map": Type::Hash,

                "functions": Type::Hash,
                "function_map": Type::Hash,

                "procedures": Type::Hash,
                "procedure_map": Type::Hash,

                #"views": Type::Hash,
                #"view_map": Type::Hash,
                );

            #! default generic sequence description keys
            /** The following keys can be set in sequence description hashes:
                - \c start: (@ref int_type) the starting value for the sequence
                - \c increment: (@ref int_type) the increment value for the sequence
                - \c end: (@ref int_type) the ending value for the sequence
            */
            const SequenceDescriptionOptions = (
                "start": Type::Int,
                "increment": Type::Int,
                "end": Type::Int,
                );
        }

        private {
            #! native case option
            bool native_case = False;
        }

        #! creates the object; private constructor
        /** @param nds the AbstractDatasource for the connection to the database
            @param nopts a hash of options for the function creation string; see @ref AbstractDatabase::DatabaseOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        private constructor(AbstractDatasource nds, *hash nopts) : AbstractSqlUtilBase(nds, nopts) {
            validateOptionsIntern("OPTION-ERROR", getDatabaseOptions(), \nopts);
            if (nopts.native_case)
                native_case = True;
        }

        static doOkCallback(*hash opt, int ac, string type, string name, *string table, *string info) {
            if (opt.info_callback) {
                bool c = (type == "column");
                if (c)
                    name = sprintf("%s.%s", table, name);

                string str = sprintf("%s %s", type, name);
                if (table && !c)
                    str += sprintf(" on %s", table);

                if (ac == AC_Unchanged)
                    str += " does not need updating";
                else if (ac == AC_NotFound)
                    str += " does not exist or has already been dropped";

                if (info)
                    str += sprintf(" (%s)", info);

                opt.info_callback(str, ac, type, name, table, NOTHING, info);
            }
        }

        static *string doCallback(*hash opt, *string sql, int ac, string type, string name, *string table, *string new_name, *string info) {
            if (!sql)
                return;
            if (opt.info_callback) {
                bool c = (type == "column");
                if (c)
                    name = sprintf("%s.%s", table, name);
                string str = sprintf("%s %s %s", ActionMap{ac}, type, name);
                if (table && !c)
                    str += sprintf(" %s %s", ac == AC_Drop ? "from" : "on", table);
                if (new_name)
                    str += sprintf(" to %s", new_name);
                if (info)
                    str += sprintf(" (%s)", info);
                opt.info_callback(str, ac, type, name, table, new_name, info);
            }
            if (opt.sql_callback)
                opt.sql_callback(sql);
            return sql;
        }

        static list doCallback(*hash opt, list sql, int ac, string type, string name, *string table, *string new_name, *string info) {
            if (!sql)
                return sql;
            if (opt.info_callback) {
                bool c = (type == "column");
                if (c)
                    name = sprintf("%s.%s", table, name);
                string str = sprintf("%s %s %s", ActionMap{ac}, type, name);
                if (table && !c)
                    str += sprintf(" %s %s", ac == AC_Drop ? "from" : "on", table);
                if (new_name)
                    str += sprintf(" to %s", new_name);
                if (info)
                    str += sprintf(" (%s)", info);
                opt.info_callback(str, ac, type, name, table, new_name, info);
            }
            if (opt.sql_callback)
                map opt.sql_callback($1), sql;
            return sql;
        }

/*
        static *string doCallback(*hash opt, *string sql, string fmt) {
            if (!sql)
                return;
            if (opt.info_callback)
                opt.info_callback(vsprintf(fmt, argv));
            if (opt.sql_callback)
                opt.sql_callback(sql);
            return sql;
        }

        static list doCallback(*hash opt, list sql, string fmt) {
            if (sql) {
                if (opt.info_callback)
                    opt.info_callback(vsprintf(fmt, argv));
                if (opt.sql_callback)
                    map opt.sql_callback($1), sql;
            }
            return sql;
        }
*/

        #! executes some SQL with optional arguments so that if an error occurs the current transaction state is not lost
        /** @par Example: 
            @code
$t.tryExec("drop table tmp_table");
            @endcode

            Include any arguments in the parameter list after the \a sql argument

            @param sql the SQL to execute

            @return any return value from the SQL command executed
         */
        any tryExec(string sql) {
            return tryExecArgsImpl(sql, argv);
        }

        #! executes some SQL with optional arguments so that if an error occurs the current transaction state is not lost
        /** @par Example: 
            @code
$t.tryExec("delete from tmp_table where id = %v and name = %v", $arglist);
            @endcode

            @param sql the SQL to execute
            @param args the bind / placeholder or other arguments corresponding to the SQL string

            @return any return value from the SQL command executed
         */
        any tryExecArgs(string sql, *softlist args) {
            return tryExecArgsImpl(sql, args);
        }

        #! executes some SQL so that if an error occurs the current transaction state is not lost
        /** @par Example: 
            @code
$t.tryExecRaw("drop table tmp_table");
            @endcode

            Include any arguments in the parameter list after the \a sql argument

            @param sql the SQL to execute

            @return any return value from the SQL command executed
         */
        any tryExecRaw(string sql) {
            return tryExecRawImpl(sql);
        }

        #! accepts a hash argument describing a database schema and returns a list of SQL strings that can be used to align the structure and configuration of the current schema with that of the argument; if the objects described are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $db.getAlignSql($schema_hash);
            @endcode

            @param schema_hash the schema template hash that decribes the target state of the schema
            @param opt a hash of options for the SQL creation strings; see @ref AbstractDatabase::AlignSchemaOptions for common options; each driver can support additional driver-specific options
            @param table_cache an optional object of class Tables to return the cache of AbstractTable objects keyed by table name for the schema template (ie target table definitions)

            @return a list of SQL strings that can be used to align the structure and configuration of the current schema with that of the argument; if the objects described are identical then an empty list is returned

            @throw SCHEMA-DESCRIPTION-ERROR the schema description hash has an error or a required object does not exist
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        list getAlignSql(hash schema_hash, *hash opt, *Tables table_cache) {
            validateOptionsIntern("SCHEMA-DESCRIPTION-ERROR", getSchemaDescriptionOptions(), \schema_hash);
            validateOptionsIntern("OPTION-ERROR", getAlignSchemaOptions(), \opt);

            if (!table_cache)
                table_cache = new Tables();

            # setup db table cache
            opt.db_table_cache = new Tables();

            list l = ();

            string drv = getDriverName();
            AbstractDatabase::checkDriverOptions(\schema_hash, drv);
            AbstractDatabase::checkDriverOptions(\schema_hash.sequence_map, drv);
            AbstractDatabase::checkDriverOptions(\schema_hash.sequences, drv);

            # call driver-specific align schema sql function (start)
            list tl = getAlignSqlImpl(schema_hash, opt + ("start": True));
            if (tl) l += tl;

            # rename any sequences
            foreach hash sh in (schema_hash.sequence_map.pairIterator()) {
                if (sh.value.typeCode() != NT_STRING)
                    throw "SCHEMA-DESCRIPTION-ERROR", sprintf("sequence_map %y value is not a string in the schema description hash; got type %y instead (%y)", sh.key, sh.value.type(), sh.value);

                *AbstractSequence seq = getSequence(sh.key);
                if (seq) {
                    l += AbstractDatabase::doCallback(opt, seq.getRenameSql(sh.value), AC_Rename, "sequence", sh.key, NOTHING, sh.value);
                    # remove sequence from list since we know it exists
                    remove schema_hash.sequences{sh.value};
                }
            }

            # create any missing sequences
            foreach string name in (schema_hash.sequences.keyIterator()) {
                hash sh = schema_hash.sequences{name};

                validateOptionsIntern("SEQUENCE-DESCRIPTION-ERROR", getSequenceDescriptionOptions(), \sh);

                # see if sequence exists
                if (getSequence(name))
                    continue;

                AbstractSequence seq = makeSequence(name, sh.start, sh.increment, sh.end);
                l += AbstractDatabase::doCallback(opt, seq.getCreateSql(), AC_Create, "sequence", name);
            }

            # create template tables
            table_cache.populate(ds, schema_hash.tables, opt - "db_table_cache");

            # rename any tables
            AbstractDatabase::checkDriverOptions(\schema_hash.table_map, drv);
            foreach hash th in (schema_hash.table_map) {                
                if (th.value.typeCode() != NT_STRING)
                    throw "SCHEMA-DESCRIPTION-ERROR", sprintf("table_map %y value is not a string in the schema description hash; got type %y instead (%y)", th.key, th.value.type(), th.value);

                Table t(ds, th.key);
                if (t.checkExistence()) {
                    l += AbstractDatabase::doCallback(opt, t.getRenameSql(th.value), AC_Rename, "table", th.key, NOTHING, th.value);
                    opt.db_table_cache.add(th.value, t);
                }
            }

            # now process DB tables
            AbstractDatabase::checkDriverOptions(\schema_hash.tables, drv);
            foreach string name in (schema_hash.tables.keyIterator()) {
                #printf("processing table %y\n", name);
                Table t;
                if (opt.db_table_cache.hasKey(name))
                    t = opt.db_table_cache{name};
                else {
                    t = new Table(ds, name);
                    # store in db_table_cache
                    opt.db_table_cache.add(name, t);
                }

                tl = t.getAlignSql(table_cache{name}, opt + schema_hash.tables{name}.rename + ("table_cache": table_cache));
                if (tl)
                    l += tl;
            }


            tl = alignCodeUnlocked("function", schema_hash, \getFunction(), \makeFunction(), opt, Type::String);
            if (tl) l += tl;

            tl = alignCodeUnlocked("procedure", schema_hash, \getProcedure(), \makeProcedure(), opt, Type::String);
            if (tl) l += tl;

            # call driver-specific align schema sql function (end)
            tl = getAlignSqlImpl(schema_hash, opt);
            if (tl) l += tl;

            return l;
        }

        #! accepts a hash argument describing a database schema and returns a list of SQL strings that can be used to drop any existing objects described in the schema; if none of the described objects exist, then an empty list is returned
        /** @par Example:
            @code
my list $l = $db.getDropSchemaSql($schema_hash);
            @endcode

            @param schema_hash the schema template hash that decribes the state of the schema
            @param opt a hash of options for the SQL creation strings; see @ref AbstractDatabase::DropSchemaOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to drop any existing objects in the database; if none of the described objects exist, then an empty list is returned

            @throw SCHEMA-DESCRIPTION-ERROR the schema description hash has an error
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        list getDropSchemaSql(hash schema_hash, *hash opt) {
            validateOptionsIntern("SCHEMA-DESCRIPTION-ERROR", getSchemaDescriptionOptions(), \schema_hash);
            validateOptionsIntern("OPTION-ERROR", getDropSchemaOptions(), \opt);

            list l = ();

            string drv = getDriverName();
            AbstractDatabase::checkDriverOptions(\schema_hash, drv);

            # call driver-specific align schema sql function (start)
            list tl = getDropSchemaSqlImpl(schema_hash, opt + ("start": True));
            if (tl) l += tl;

            # drop procedures
            tl = dropSqlUnlocked("procedure", schema_hash, \getProcedure(), \makeProcedure(), opt, Type::String);
            if (tl) l += tl;

            # drop functions
            tl = dropSqlUnlocked("function", schema_hash, \getFunction(), \makeFunction(), opt, Type::String);
            if (tl) l += tl;

            # setup tables with names from description but contents from DB
            Tables tables();
            map tables.getIfExists(ds, $1), schema_hash.tables.keyIterator();
            foreach AbstractTable t in (tables.dropIterator()) {
                l += AbstractDatabase::doCallback(opt, t.getDropSql(), AC_Drop, "table", t.getName());
            }

            # drop sequences
            tl = dropSqlUnlocked("sequence", schema_hash, \getSequence(), \makeSequenceFromDescription(), opt, Type::Hash);
            if (tl) l += tl;            

            # call driver-specific align schema sql function (end)
            tl = getDropSchemaSqlImpl(schema_hash, opt);
            if (tl) l += tl;

            return l;
        }

        private list dropSqlUnlocked(string type, hash schema_hash, code get, code make, *hash opt, string make_arg_type) {
            list l = ();
            hash copt = getCreationOptions();
            string drv = getDriverName();

            # drop objects
            reference fmap = \schema_hash{type + "s"};
            AbstractDatabase::checkDriverOptions(\fmap, drv);
            foreach string name in (fmap.keyIterator()) {
                AbstractSqlUtilBase::validateOptionIntern("SCHEMA-DESCRIPTION-ERROR", make_arg_type, \fmap{name}, name, type + "s");

                # make template object
                object tmpl = make(name, fmap{name}, opt.(copt.keys()));

                # see if object exists
                *object f = get(name);
                if (f) {
                    l += AbstractDatabase::doCallback(opt, tmpl.getDropSql(), AC_Drop, type, name);
                }
                else
                    AbstractDatabase::doOkCallback(opt, AC_NotFound, type, name);
            }

            return l;
        }

        private list alignCodeUnlocked(string type, hash schema_hash, code get, code make, *hash opt, string make_arg_type) {
            list l = ();
            hash copt = getCreationOptions();
            string drv = getDriverName();

            hash code_cache;

            # rename objects
            reference fmap = \schema_hash{type + "_map"};
            AbstractDatabase::checkDriverOptions(\fmap, drv);
            foreach hash fh in (fmap.pairIterator()) {                
                if (fh.value.typeCode() != NT_STRING)
                    throw "SCHEMA-DESCRIPTION-ERROR", sprintf("%s %y value is not a string in the schema description hash; got type %y instead (%y)", type + "_map", fh.key, fh.value.type(), fh.value);

                *AbstractFunction f = get(fh.key);
                if (f) {
                    list tl = AbstractDatabase::doCallback(opt, f.getRenameSql(fh.value), AC_Rename, type, fh.key, NOTHING, fh.value);
                    if (tl)
                        l += tl;

                    # add to function cache
                    f.setName(fh.value);
                    code_cache{fh.value} = f;
                }
            }

            # create any missing functions; replace updated functions
            reference fh = \schema_hash{type + "s"};
            AbstractDatabase::checkDriverOptions(\fh, drv);
            foreach string name in (fh.keyIterator()) {
                AbstractSqlUtilBase::validateOptionIntern("SCHEMA-DESCRIPTION-ERROR", make_arg_type, \fh{name}, name, type + "s");

                # make template function
                AbstractFunction templateFunc = make(name, fh{name}, opt.(copt.keys()));

                # see if function exists
                *AbstractFunction f;
                if (code_cache{name})
                    f = code_cache{name};
                else {
                    f = get(name);
                    if (!f) {
                        l += AbstractDatabase::doCallback(opt, templateFunc.getCreateSql(opt), AC_Create, type, name);
                        continue;
                    }
                }

                if (!templateFunc.equal(f)) {
                    l += AbstractDatabase::doCallback(opt, f.getDropSql(), AC_Drop, type, name);
                    l += AbstractDatabase::doCallback(opt, templateFunc.getCreateSql(opt), AC_Create, type, name);
                }
                else
                    AbstractDatabase::doOkCallback(opt, AC_Unchanged, type, name);
            }

            return l;
        }

        #! creates a database-specific AbstractSequence object corresponding to the arguments
        /** @par Example:
            @code
my AbstractSequence $seq = $db.makeSequence("seq_queues");
            @endcode

            @param name the name of the sequence
            @param start the starting value of the sequence
            @param increment the increment value of the sequence
            @param end the endinf value of the sequence, omit for no ending value
            @param opts an optional hash of options for the creation of the sequence; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw SEQUENCE-ERROR end not compatible with start and increment, increment is zero
        */
        AbstractSequence makeSequence(string name, number start = 1, number increment = 1, *softnumber end, *hash opts) {
            validateOptionsIntern("OPTION-ERROR", getCreationOptions(), \opts);

            return makeSequenceImpl(name, start, increment, end, opts);
        }

        AbstractSequence makeSequenceFromDescription(string name, *hash sh, *hash opts) {
            validateOptionsIntern("SEQUENCE-DESCRIPTION-ERROR", getSequenceDescriptionOptions(), \sh);

            return makeSequence(name, sh.start, sh.increment, sh.end);
        }

        #! creates a database-specific AbstractTable object corresponding to the arguments
        /** @par Example:
            @code
my AbstractTable $table = $db.makeTable("table", $th);
            @endcode

            @param name the name of the table
            @param desc a @ref table_desc_hash "table description hash" describing the table
            @param opts an optional hash of options for the table creation string; see @ref SqlUtil::AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed

            @see SqlUtil::Table::constructor()
        */
        AbstractTable makeTable(string name, hash desc, *hash opts) {
            AbstractTable t = AbstractTable::getTable(ds, name, opts);
            t.setupTable(desc, opts);
            return t;
        }

        #! creates a database-specific AbstractFunction object corresponding to the arguments
        /** @par Example:
            @code
my AbstractFunction $f = $db.makeFunction("update_queue", $src);
            @endcode

            @param name the name of the function
            @param src the database-specific source code of the function (see the database-specific documentation for information about the format of this parameter; generally it's simply the normal source code for the function required by the database)
            @param opts an optional hash of options for the creation of the function; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        AbstractFunction makeFunction(string name, string src, *hash opts) {
            validateOptionsIntern("OPTION-ERROR", getCreationOptions(), \opts);

            return makeFunctionImpl(name, src, opts);
        }

        #! creates a database-specific AbstractFunction object for a stored procedure corresponding to the arguments
        /** @par Example:
            @code
my AbstractFunction $f = $db.makeProcedure("get_queue_info", $src);
            @endcode

            @param name the name of the stored procedure
            @param src the database-specific source code of the stored procedure (see the database-specific documentation for information about the format of this parameter; generally it's simply the normal source code for the stored procedure required by the database)
            @param opt an optional hash of options for the creation of the stored procedure; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        AbstractFunction makeProcedure(string name, string src, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCreationOptions(), \opt);

            return makeProcedureImpl(name, src, opt);
        }

        #! drops the given function if it exists; returns @ref Qore::True "True" if the function was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropFunctionIfExists($name);
            @endcode

            @param name the name of the function
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info
            
            @return @ref Qore::True "True" if the function was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropFunctionIfExists(string name, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractFunction f = getFunction(name);
            if (!f)
                return False;
            return AbstractDatabase::doDrop(f.getDropSql(), "function", name, opt);
        }

        #! drops the given procedure if it exists; returns @ref Qore::True "True" if the procedure was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropProcedureIfExists($name);
            @endcode

            @param name the name of the procedure
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return @ref Qore::True "True" if the procedure was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropProcedureIfExists(string name, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractFunction f = getProcedure(name);
            if (!f)
                return False;
            return AbstractDatabase::doDrop(f.getDropSql(), "procedure", name, opt);
        }

        #! drops the given sequence if it exists; returns @ref Qore::True "True" if the sequence was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropSequenceIfExists($name);
            @endcode

            @param name the name of the sequence
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return @ref Qore::True "True" if the sequence was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropSequenceIfExists(string name, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractSequence seq = getSequence(name);
            if (!seq)
                return False;
            return AbstractDatabase::doDrop(seq.getDropSql(), "sequence", name, opt);
        }

        #! drops the given table if it exists; returns @ref Qore::True "True" if the table was dropped, @ref Qore::False "False" if not
        /** @par Example:
            @code
$db.dropTableIfExists($name);
            @endcode

            @param name the name of the table
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return @ref Qore::True "True" if the table was dropped, @ref Qore::False "False" if not

            @throw OPTION-ERROR invalid or unknown callback option
        */
        bool dropTableIfExists(string name, *hash opt) {            
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractTable obj = getTable(name);
            if (!obj)
                return False;
            obj.drop(opt);
            return True;
        }

        #! returns the SQL require to drop the given function if it exists or @ref nothing if the named function does not exist
        /** @par Example:
            @code
my string $sql = $db.getDropFunctionSqlIfExists($name);
            @endcode

            @param name the name of the function
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info
            
            @return the SQL require to drop the given function if it exists or @ref nothing if the named function does not exist

            @throw OPTION-ERROR invalid or unknown callback option
        */
        *string getDropFunctionSqlIfExists(string name, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractFunction f = getFunction(name);
            if (!f)
                return;
            return AbstractDatabase::doDropSql(f.getDropSql(), "function", name, opt);
        }

        #! returns the SQL require to drop the given procedure if it exists or @ref nothing if the named procedure does not exist
        /** @par Example:
            @code
my string $sql = $db.getDropProcedureSqlIfExists($name);
            @endcode

            @param name the name of the procedure
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info
            
            @return the SQL require to drop the given procedure if it exists or @ref nothing if the named procedure does not exist

            @throw OPTION-ERROR invalid or unknown callback option
        */
        *string getDropProcedureSqlIfExists(string name, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractFunction f = getProcedure(name);
            if (!f)
                return;
            return AbstractDatabase::doDropSql(f.getDropSql(), "procedure", name, opt);
        }

        #! returns the SQL require to drop the given sequence if it exists or @ref nothing if the named sequence does not exist
        /** @par Example:
            @code
my string $sql = $db.getDropSequenceSqlIfExists($name);
            @endcode

            @param name the name of the sequence
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info
            
            @return the SQL require to drop the given sequence if it exists or @ref nothing if the named sequence does not exist

            @throw OPTION-ERROR invalid or unknown callback option
        */
        *string getDropSequenceSqlIfExists(string name, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractSequence obj = getSequence(name);
            if (!obj)
                return;
            return AbstractDatabase::doDropSql(obj.getDropSql(), "sequence", name, opt);
        }

        #! returns the SQL require to drop the given table if it exists or @ref nothing if the named table does not exist
        /** @par Example:
            @code
my string $sql = $db.getDropTableSqlIfExists($name);
            @endcode

            @param name the name of the table
            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info
            
            @return the SQL require to drop the given table if it exists or @ref nothing if the named table does not exist

            @throw OPTION-ERROR invalid or unknown callback option
        */
        *list getDropTableSqlIfExists(string name, *hash opt) {            
            validateOptionsIntern("OPTION-ERROR", getCallbackOptions(), \opt);
            *AbstractTable t = getTable(name);
            if (!t)
                return;
            return t.getDropSql(opt);
        }

        doDropSql(*softlist l, string type, string name, *hash opt) {
            if (l)
                AbstractDatabase::doCallback(opt, l, AC_Drop, type, name);
        }

        bool doDrop(*softlist l, string type, string name, *hash opt) {
            if (l) {
                AbstractDatabase::doCallback(opt, l, AC_Drop, type, name);
                on_success ds.commit();
                on_error ds.rollback();
                map ds.execRaw($1), l;
                return True;
            }
            return False;
        }

        #! returns a list of SQL strings that can be used to update a function in the database to the function definition passed as an argument
        /** @par Example:
            @code
my list $l = $db.getAlignFunctionSql($f);
            @endcode

            @param f the template or target version of the function to compare to the database version
            @param opt an optional hash of options for the generation of the SQL strings; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to update a function in the database to the function definition passed as an argument

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        list getAlignFunctionSql(AbstractFunction f, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getCreationOptions(), \opt);

            *AbstractFunction of = getFunctionImpl(f.name);

            list l = ();

            if (!of) {
                l += AbstractDatabase::doCallback(opt, f.getCreateSql(opt), AC_Create, "function", f.name);
            }
            else if (!of.equal(f)) {
                l += AbstractDatabase::doCallback(opt, of.getDropSql(), AC_Drop, "function", f.name);
                l += AbstractDatabase::doCallback(opt, of.getCreateSql(opt), AC_Create, "function", f.name);
            }
            else
                AbstractDatabase::doOkCallback(opt, AC_Unchanged, "function", f.name);

            return l;
        }

        #! returns a list of SQL strings that can be used to update a stored procedure in the database to the stored procedure definition passed as an argument
        /** @par Example:
            @code
my list $l = $db.getAlignProcedureSql($f);
            @endcode

            @param f the template or target version of the stored procedure to compare to the database version
            @param opt an optional hash of options for the generation of the SQL strings; see @ref AbstractDatabase::CreationOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to update a stored procedure in the database to the stored procedure definition passed as an argument

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        list getAlignProcedureSql(AbstractFunction f, *hash opt) {
            *AbstractFunction of = getProcedureImpl(f.name);

            list l = ();

            if (!of)
                l += f.getCreateSql(opt);
            else if (!of.equal(f)) {
                l += of.getDropSql();
                l += f.getCreateSql(opt);
            }
                
            return l;
        }

        #! returns an AbstractTable argument for the given table name or @ref nothing if the table cannot be found
        /** @par Example:
            @code
my *AbstractTable $table = $db.getTable("queues");
            @endcode

            @param name the uniquely-identifying name of the table to retrieve

            @return an AbstractTable argument for the given table name or @ref nothing if the table cannot be found
         */
        *AbstractTable getTable(string name) {
            AbstractTable t = AbstractTable::getTable(ds, name);
            return t.checkExistence() ? t : NOTHING;
        }

        #! returns an AbstractSequence argument for the given sequence name or @ref nothing if the sequence cannot be found
        /** @par Example:
            @code
my *AbstractSequence $seq = $db.getSequence("seq_queues");
            @endcode

            @param name the uniquely-identifying name of the sequence to retrieve

            @return an AbstractSequence argument for the given sequence name or @ref nothing if the sequence cannot be found
         */
        *AbstractSequence getSequence(string name) {
            return getSequenceImpl(name);
        }

        #! returns an AbstractFunction argument for the given function name or @ref nothing if the function cannot be found
        /** @par Example:
            @code
my *AbstractFunction $f = $db.getFunction("update_queue");
            @endcode

            @param name the uniquely-identifying name of the function to retrieve

            @return an AbstractFunction argument for the given function name or @ref nothing if the function cannot be found

            @note for databases that support overloaded functions, the arguments must be passed in parentheses after the name to match overloaded functions properly
         */
        *AbstractFunction getFunction(string name) {
            return getFunctionImpl(name);
        }

        #! returns an AbstractFunction argument for the given stored procedure name or @ref nothing if the stored procedur  cannot be found
        /** @par Example:
            @code
my *AbstractFunction $f = $db.getProcedure("update_queue");
            @endcode

            @param name the uniquely-identifying name of the stored procedure to retrieve

            @return an AbstractFunction argument for the given stored procedure name or @ref nothing if the stored procedure cannot be found

            @note for databases that support overloaded stored procedures, the arguments must be passed in parentheses after the name to match overloaded stored procedures properly
         */
        *AbstractFunction getProcedure(string name) {
            return getProcedureImpl(name);
        }

        #! returns the next value in the given sequence
        /** @par Example:
            @code
my number $n = $db.getNextSequenceValue("seq_customers");
            @endcode

            @param name the name of the sequence

            @return the next value in the given sequence
        */
        int getNextSequenceValue(string name) {
            return getNextSequenceValueImpl(name);
        }

        #! returns an SQL string corresponding to the list of commands in the argument
        /** @par Example:
            @code
my string $sql = $t.getSqlFromList($list);
            @endcode

            @param l a list of SQL commands
            
            @return an SQL string corresponding to the list of commands in the argument
        */
        string getSqlFromList(list l) {
            return getCreateSqlImpl(l);
        }

        #! returns @ref Qore::True "True" if the database supports sequences
        bool supportsSequences() {
            return supportsSequencesImpl();
        }

        #! returns a list of string table names in the database
        list listTables() {
            return listTablesImpl();
        }
        
        #! returns an iterator listing the string table names in the database
        Qore::ListIterator tableIterator() {
            return listTablesImpl().iterator();            
        }
 
        #! returns a list of string function names in the database
        list listFunctions() {
            return listFunctionsImpl();
        }
        
        #! returns an iterator listing the string function names in the database
        Qore::ListIterator functionIterator() {
            return listFunctionsImpl().iterator();            
        }

        #! returns a list of string procedure names in the database
        list listProcedures() {
            return listProceduresImpl();
        }
        
        #! returns an iterator listing the string procedure names in the database
        Qore::ListIterator procedureIterator() {
            return listProceduresImpl().iterator();            
        }

        #! returns a list of string sequence names in the database
        list listSequences() {
            return listSequencesImpl();
        }
        
        #! returns an iterator listing the string sequence names in the database
        Qore::ListIterator sequenceIterator() {
            return listSequencesImpl().iterator();            
        }

        #! returns a list of string view names in the database
        list listViews() {
            return listViewsImpl();
        }
        
        #! returns an iterator listing the string view names in the database
        Qore::ListIterator viewIterator() {
            return listViewsImpl().iterator();            
        }

        private validateOptionsIntern(string err, hash ropt, reference opt) {
            AbstractSqlUtilBase::validateOptionsIntern(err, ropt, \opt, ds.getDBName());
        }

        private validateOptionsIntern(string err, hash ropt, reference opt, string tag) {
            AbstractSqlUtilBase::validateOptionsIntern(err, ropt, \opt, tag);
        }

        static AbstractDatabase getDatabase(AbstractDatasource nds, *hash opts) {
            string drv = nds.getDriverName();

            # generate module and module namespace name
            string mn = drv[0].upr() + drv.substr(1) + "SqlUtil";

            # try to load module
            try {
                load_module(mn);                
            }
            catch (hash ex) {
                throw "DATABASE-DRIVER-ERROR", sprintf("%s: no support for driver %y yet: %s: %s", get_ex_pos(ex), drv, ex.err, ex.desc);
            }

            # try to get AbstractDatabase object
            try {
                return call_function(mn + "::" + "get_database", nds, opts);
            }
            catch (hash ex) {
                throw "DATABASE-DRIVER-ERROR", sprintf("%s: error retrieving AbstractDatabase object for driver %y: %s: %s", get_ex_pos(ex), drv, ex.err, ex.desc);
            }
        }

        static AbstractDatabase getDatabase(string dsstr, *hash opts) {
            Datasource nds(dsstr);
            return AbstractDatabase::getDatabase(nds, opts);
        }

        static AbstractDatabase getDatabase(hash dsh, *hash opts) {
            Datasource nds(dsh);
            return AbstractDatabase::getDatabase(nds, opts);
        }

        static checkDriverOptions(reference h, string drv) {
            if (h.driver) {
                if (h.driver{drv})
                    h += h.driver{drv};
                delete h.driver;
            }
        }

        #! override in subclasses to return driver-specific options
        private hash getDatabaseOptions() {
            return DatabaseOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getCallbackOptions() {
            return CallbackOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getCreationOptions() {
            return CreationOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getCacheOptions() {
            return CacheOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getAlignSchemaOptions() {
            return AlignSchemaOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getDropSchemaOptions() {
            return DropSchemaOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getSchemaDescriptionOptions() {
            return SchemaDescriptionOptions;
        }

        #! override in subclasses to return driver-specific options
        private hash getSequenceDescriptionOptions() {
            return SequenceDescriptionOptions;
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        private any tryExecArgsImpl(string sql, *softlist args) {
            return ds.vexec(sql, args);
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        private any tryExecRawImpl(string sql) {
            return ds.execRaw(sql);
        }

        private abstract string getCreateSqlImpl(list l);
        private abstract list getAlignSqlImpl(hash schema_hash, *hash opt);
        private abstract list getDropSchemaSqlImpl(hash schema_hash, *hash opt);

        private abstract *AbstractSequence getSequenceImpl(string name);
        private abstract *AbstractFunction getFunctionImpl(string name);
        private abstract *AbstractFunction getProcedureImpl(string name);

        private abstract AbstractSequence makeSequenceImpl(string name, number start = 1, number increment = 1, *softnumber end, *hash opts);
        private abstract AbstractFunction makeFunctionImpl(string name, string src, *hash opts);
        private abstract AbstractFunction makeProcedureImpl(string name, string src, *hash opts);

        private abstract list listTablesImpl();
        private abstract list listFunctionsImpl();
        private abstract list listProceduresImpl();
        private abstract list listSequencesImpl();
        private abstract list listViewsImpl();

        #! returns the next value in the given sequence
        private abstract int getNextSequenceValueImpl(string name);

        #! returns @ref Qore::True "True" if the database supports sequences
        private abstract bool supportsSequencesImpl();
    }

    #! represents a database table; this class embeds an AbstractTable object that is created automatically in the constructor based on the database driver for the AbstractDatasource object providing the database connection
    /** Driver-specific modules that provide the AbstractTable implementation embedded in this class are loaded on demand based on the driver's name.
        The driver-specific module's name is generated based on the db-driver's name with the first letter capitalized then with \c "SqlUtil" appended.

        For example:
        - \c "oracle": <a href="../../OracleSqlUtil/html/index.html">OracleSqlUtil</a>
        - \c "pgsql": <a href="../../PgsqlSqlUtil/html/index.html">PgsqlSqlUtil</a>
        - \c "mysql": <a href="../../MysqlSqlUtil/html/index.html">MysqlSqlUtil</a>

        etc.
    */
    public class Table {
        private {
            #! the embedded AbstractTable object that actually provides the functionality for this class
            AbstractTable t;
        }

        #! creates the Table object
        /** @par Example:
            @code
my Table $table($ds, "table");
            @endcode

            @param ds the AbstractDatasource object used to provide the DB connection
            @param name the name of the table
            @param opts a hash of options for the table creation string; see @ref SqlUtil::AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw TABLE-DRIVER-ERROR no database-specific module can be loaded
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        constructor(AbstractDatasource ds, string name, *hash opts) {
            t = AbstractTable::getTable(ds, name, opts);
        }

        #! creates the Table object
        /** @par Example:
            @code
my Table $table("pgsql:user/pass@db%host", "table");
            @endcode

            @param ds a datasource description string in the format that can be parsed by parse_datasource()
            @param name the name of the table
            @param opts a hash of options for the table creation string; see @ref SqlUtil::AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw TABLE-DRIVER-ERROR no database-specific module can be loaded
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        constructor(string ds, string name, *hash opts) {
            t = AbstractTable::getTable(ds, name, opts);
        }
        
        #! creates the Table object
        /** @par Example:
            @code
my Table $table("pgsql:user/pass@db%host", "table");
            @endcode

            @param ds a hash giving parameters for the new datasource with the following possible keys (the \c "type" key is mandatory, also usable with the output of the parse_datasource() function):
            - \c type: (@ref string_or_nothing_type "*string") The name of the database driver to use; this key is mandatory; if not present, an exception will be raised. See @ref sql_constants for builtin constants for DBI drivers shipped with Qore, or see the DBI driver documentation to use an add-on driver (this string should be the name of the driver to be loaded)
            - \c user: (@ref string_or_nothing_type "*string") The user name for the new connection
            - \c pass: (@ref string_or_nothing_type "*string") The password for the new connection
            - \c db: (@ref string_or_nothing_type "*string") The database name for the new connection
            - \c charset: (@ref string_or_nothing_type "*string") The database-specific name of the character encoding to use for the new connection. Also see Qore::SQL::Datasource::setDBCharset() for a method that allows this parameter to be set after the constructor. If no value is passed for this parameter, then the database character encoding corresponding to the default character encoding for the %Qore process will be used instead.
            - \c host: (@ref string_or_nothing_type "*string") The host name for the new connection
            - \c port: (@ref softint_type "softint") The port number for the new connection
            - \c options: (@ref hash_or_nothing_type "*hash") Any options for the new connection
            @param name the name of the table
            @param opts a hash of options for the table creation string; see @ref SqlUtil::AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw TABLE-DRIVER-ERROR no database-specific module can be loaded
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        constructor(hash ds, string name, *hash opts) {
            t = AbstractTable::getTable(ds, name, opts);
        }

        #! creates the object from a table description hash
        /** @param ds the AbstractDatasource for the connection to the database
            @param desc a @ref table_desc_hash "table description hash" describing the table
            @param name the name of the table
            @param opts an optional hash of options for the table creation string; see @ref SqlUtil::AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw DESCRIPTION-ERROR invalid or unsupported description hash value passed
        */
        constructor(AbstractDatasource ds, hash desc, string name, *hash opts) {
            t = AbstractTable::getTable(ds, name);
            t.setupTable(desc, opts);
        }

        #! changes the datasource for the table; if the \c inDb flag is @ref Qore::True "True", then it is set to @ref Qore::False "False" by calling this method
        /** @par Example:
            @code
my Table $table($ds1, "table_name");
$table.setDatasource($ds2);
$table.create();
            @endcode

            @param nds the new datasource for the table

            @note it's generally not safe to call this method while SQL operations are in progress in other threads on the same table
        */
        setDatasource(AbstractDatasource nds) {
            t.setDatasource(nds);
        }

        #! commits the current transaction on the underlying @ref Qore::SQL::AbstractDatasource
        commit() {
            t.commit();
        }

        #! rolls back the current transaction on the underlying @ref Qore::SQL::AbstractDatasource
        rollback() {
            t.rollback();
        }

        #! returns the name of the table
        string getName() {
            return t.getName();
        }

        #! gets the underlying AbstractDatasource
        Qore::SQL::AbstractDatasource getDatasource() {
            return t.getDatasource();
        }

        #! returns the AbstractTable object contained by this object
        AbstractTable getTable() {
            return t;
        }

        #! executes a method on the contained AbstractTable object
        any methodGate(string meth) {
            return callObjectMethodArgs(t, meth, argv);
        }

        #! returns @ref Qore::True "True" if the table has been read from or created in the database, @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $table.inDb();
            @endcode

            @return @ref Qore::True "True" if the table has been read from or created in the database, @ref Qore::False "False" if not
         */
        bool inDb() {
            return t.inDb();
        }

        #! creates the object from a table description hash
        /** @param desc a @ref table_desc_hash "table description hash" describing the table
            @param opt an optional hash of options for the table creation string; see @ref SqlUtil::AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw DESCRIPTION-ERROR invalid or unsupported description hash value passed
        */
        setupTable(hash desc, *hash opt) {
            t.setupTable(desc, opt);
        }

        #! returns an iterator for all unique constraints on the table (including the primary key if any)
        /** @par Example:
            @code
map printf("unique constraint %s\n", $1.getName()), $table.getUniqueConstraintIterator();
            @endcode

            @return an iterator for all unique constraints on the table (including the primary key if any)
        */
        Qore::AbstractIterator getUniqueConstraintIterator() {
            return t.getUniqueConstraintIterator();
        }

        #! drops the table from the database; releases the transaction lock after dropping the table
        /** @par Example:
            @code
$table.drop();
            @endcode

            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @throw OPTION-ERROR invalid or unknown callback option

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref dropNoCommit() to execute without any transaction management
         */
        drop(*hash opt) {
            t.drop(opt);
        }

        #! drops the table from the database without any transaction management
        /** @par Example:
            @code
$table.dropNoCommit();
            @endcode

            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @throw OPTION-ERROR invalid or unknown callback option

            @note Transaction management is normally not performed when dropping tables, however this method uses the Qore::SQL::AbstractDatasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        dropNoCommit(*hash opt) {
            t.dropNoCommit(opt);
        }
        
        #! executes some SQL with optional arguments so that if an error occurs the current transaction state is not lost
        /** @par Example: 
            @code
$t.tryExec("drop table tmp_table");
            @endcode

            Include any arguments in the parameter list after the \a sql argument

            @param sql the SQL to execute

            @return any return value from the SQL command executed
         */
        any tryExec(string sql) {
            return t.tryExecArgs(sql, argv);
        }

        #! executes some SQL with optional arguments so that if an error occurs the current transaction state is not lost
        /** @par Example: 
            @code
$t.tryExec("delete from tmp_table where id = %v and name = %v", $arglist);
            @endcode

            @param sql the SQL to execute
            @param args the bind / placeholder or other arguments corresponding to the SQL string

            @return any return value from the SQL command executed
         */
        any tryExecArgs(string sql, *softlist args) {
            return t.tryExecArgs(sql, args);
        }

        #! executes some SQL so that if an error occurs the current transaction state is not lost
        /** @par Example: 
            @code
$t.tryExecRaw("drop table tmp_table");
            @endcode

            Include any arguments in the parameter list after the \a sql argument

            @param sql the SQL to execute

            @return any return value from the SQL command executed
         */
        any tryExecRaw(string sql) {
            return t.tryExecRaw(sql);
        }

        #! truncates all the table data; releases the transaction lock after executing
        /** @par Example:
            @code
$table.truncate();
            @endcode

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref truncateNoCommit() to execute without any transaction management
         */
        truncate() {
            t.truncate();
        }

        #! truncates all the table data without any transaction management
        /** @par Example:
            @code
$table.truncateNoCommit();
            @endcode

            @note Transaction management may not be applied when truncating tables depending on the database driver (for example truncating tables in Oracle does not participate in transaction management), however this method uses the Qore::SQL::AbstractDatasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        truncateNoCommit() {
            t.truncateNoCommit();
        }
        
        #! gets the SQL that can be used to truncate the table
        /** @par Example:
            @code
my string $sql = $table.getTruncateSql();
            @endcode

            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return the SQL that can be used to truncate the table

            @throw OPTION-ERROR invalid or unsupported option passed

            @see inDb() for a method that tells if the table is already in the database or not

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
         */
        string getTruncateSql(*hash opt) {
            return t.getTruncateSql(opt);
        }

        #! creates the table in the database; releases the transaction lock after creating the table
        /** @par Example:
            @code
$table.create();
            @endcode

            @param opt a hash of options for the SQL creation string; see @ref SqlUtil::AbstractTable::TableCreationOptions for common options; each driver can support additional driver-specific options

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref createNoCommit() to execute without any transaction management

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        create(*hash opt) {
            t.create(opt);
        }

        #! creates the table with all associated properties (indexes, constraints, etc) without any transaction management
        /** @par Example:
            @code
$table.createNoCommit();
            @endcode

            @param opt a hash of options for the SQL creation string; see @ref SqlUtil::AbstractTable::TableCreationOptions for common options; each driver can support additional driver-specific options

            @note Transaction management is normally not performed when creating tables, however this method uses the Qore::SQL::AbstractDatasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        createNoCommit(*hash opt) {
            t.createNoCommit(opt);
        }

        #! renames the table; if the table already exists in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
$table.rename("new_name");
            @endcode

            @param new_name the new name for the table
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)
            @param table_cache an optional @ref SqlUtil::Tables "Tables" argument to update the table name in any table cache

            @see getRenameSql()
        */
        rename(string new_name, *reference sql, *Tables table_cache) {
            return t.rename(new_name, \sql, table_cache);
        }

        #! returns @ref Qore::True "True" if the table has no data rows, @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $table.emptyData();
            @endcode

            @return @ref Qore::True "True" if the table has no data rows, @ref Qore::False "False" if not

            @see 
            - empty()
            - rowCount()
        */
        bool emptyData() {
            return t.emptyData();
        }

        #! returns @ref Qore::True "True" if the table has no definitions, @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $table.empty();
            @endcode

            @return @ref Qore::True "True" if the table has no definitions, @ref Qore::False "False" if not

            @see emptyData()
        */
        bool empty() {
            return t.empty();
        }

        #! adds a column to the table; if the table already exists, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
$table.addColumn("name", ("qore_type": Type::String, "size": 50), False);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column
            @param opt a hash describing the column; the following keys are permitted (other column options may be supported depending on the underlying AbstractTable implementation):
            - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion;
            - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
            - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
            - \c scale: for numeric data types, this value gives the scale
            - \c default_value: the default value for the column
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @param nullable if @ref Qore::True "True" then the column can hold NULL values; note that primary key columns cannot be nullable

            @throw COLUMN-ERROR no \c native_type or \c qore_type keys in column option hash, column already exists, invalid column data

            @note make sure and add a \c default_value value when adding a column with a \c "not null" constraint with existing data

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractColumn addColumn(string cname, hash opt, bool nullable = True, *reference lsql) {
            return t.addColumn(cname, opt, nullable, \lsql);
        }

        #! returns a list of SQL strings that can be use to add a column to the table
        /** @par Example:
            @code
my list $l = $table.getAddColumnSql("name", ("qore_type": Type::String, "size": 50), False);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column
            @param copt a hash describing the column; the following keys are permitted (other column options may be supported depending on the underlying AbstractTable implementation):
            - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion;
            - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
            - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
            - \c scale: for numeric data types, this value gives the scale
            - \c default_value: the default value for the column
            @param nullable if @ref Qore::True "True" then the column can hold NULL values; note that primary key columns cannot be nullable
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be use to add a column to the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw COLUMN-ERROR no \c native_type or \c qore_type keys in column option hash, column already exists, invalid column data

            @note
            - make sure and add a \c default_value value when adding a column with a \c "not null" constraint with existing data
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
         */
        list getAddColumnSql(string cname, hash copt, bool nullable = True, *hash opt) {
            return t.getAddColumnSql(cname, copt, nullable, opt);
        }

        #! modifies an existing column in the table; if the table already exists, then the changes are effected in the database also immediately; otherwise it is only updated internally and the new column definition will be created when create() is called for example
        /** @par Example:
            @code
$table.modifyColumn("name", ("qore_type": Type::String, "size": 240), False);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column
            @param opt a hash describing the column; the following keys are permitted (other column options may be supported depending on the underlying AbstractTable implementation):
            - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion;
            - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
            - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
            - \c scale: for numeric data types, this value gives the scale
            - \c default_value: the default value for the column
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @param nullable if @ref Qore::True "True" then the column can hold NULL values; note that primary key columns cannot be nullable

            @throw COLUMN-ERROR no \c native_type or \c qore_type keys in column option hash, column does not exist, invalid column data

            @note make sure and add a \c default_value value when modifying a column to have a \c "not null" constraint with existing data

            @see
            - inDb() for a method that tells if the table is already in the database or not
            - renameColumn() for a method that allows the column name to be changed
         */
        AbstractColumn modifyColumn(string cname, hash opt, bool nullable = True, *reference lsql) {
            return t.modifyColumn(cname, opt, nullable, \lsql);
        }

        #! gets a list of SQL strings that can be used to modify an existing column in the table
        /** @par Example:
            @code
my list $l = $table.getModifyColumnSql("name", ("qore_type": Type::String, "size": 240), False);
            @endcode

            @param cname the name of the column
            @param copt a hash describing the column; the following keys are permitted (other column options may be supported depending on the underlying AbstractTable implementation):
            - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion;
            - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
            - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
            - \c scale: for numeric data types, this value gives the scale
            - \c default_value: the default value for the column
            @param nullable if @ref Qore::True "True" then the column can hold NULL values; note that primary key columns cannot be nullable
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options
                
            @return a list of SQL strings that can be used to modify an existing column in the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw COLUMN-ERROR no \c native_type or \c qore_type keys in column option hash, column does not exist, invalid column data

            @note make sure and add a \c default_value value when modifying a column to have a \c "not null" constraint with existing data

            @note
            - make sure and add a \c default_value value when modifying a column to have a \c "not null" constraint with existing data
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
         */
        list getModifyColumnSql(string cname, hash copt, bool nullable = True, *hash opt) {
            return t.getModifyColumnSql(cname, copt, nullable, opt);
        }

        #! renames an existing column; if the table already exists, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
my AbstractColumn $col = $table.renameColumn("name", "family_name");
            @endcode

            @param old_name the current name of the column
            @param new_name the new name for the column
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)
            @return the column object that was updated

            @throw COLUMN-ERROR if the given column does not exist in the table

            @see modifyColumn() for a method that allows the column definition to be updated

            @note if any primary key or foreign table constraints refer to the column, the internal reprepsentations are also renamed, however check constraints are not updated and will be invalid if they refer to the renamed column
        */
        AbstractColumn renameColumn(string old_name, string new_name, reference sql) {
            return t.renameColumn(old_name, new_name, \sql);
        }

        #! gets an SQL string that can be used to rename an existing column in the table
        /** @par Example:
            @code
my string $sql = $table.getRenameColumnSql("name", "family_name");
            @endcode

            @param old_name the current name of the column
            @param new_name the new name of the column
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options
                
            @return an SQL string that can be used to rename an existing column in the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw COLUMN-ERROR if the given column does not exist in the table

            @see getModifyColumnSql() for a method that allows the column definition to be updated

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
        */
        string getRenameColumnSql(string old_name, string new_name, *hash opt) {
            return t.getRenameColumnSql(old_name, new_name, opt);
        }

        #! adds a primary key to the table; if the table already exists, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractPrimaryKey $pk = $table.addPrimaryKey("pk_mytable", "id", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new primary key constraint
            @param cols a single column name or a list of columns that make up the primary key
            @param opt a hash of options for the new primary key; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractPrimaryKey object corresponding to the primary key created

            @throw PRIMARY-KEY-ERROR the table already has a primary key or invalid columns passed
            @throw OPTION-ERROR invalid or unsupported option passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractPrimaryKey addPrimaryKey(string cname, softlist cols, *hash opt, *reference sql) {
            return t.addPrimaryKey(cname, cols, opt, \sql);
        }

        #! returns the SQL that can be used to add a primary key to the table
        /** @par Example:
            @code
my string $sql = $table.getAddPrimaryKeySql("pk_mytable", "id", ("index_tablespace": "index1"), opt);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param pkname the name of the new primary key constraint
            @param cols a single column name or a list of columns that make up the primary key
            @param pkopt a hash of options for the new primary key; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ConstraintOptions
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return the SQL that can be used to add a primary key to the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw PRIMARY-KEY-ERROR the table already has a primary key or invalid columns or options passed

            @see inDb() for a method that tells if the table is already in the database or not

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
         */
        string getAddPrimaryKeySql(string pkname, softlist cols, *hash pkopt, *hash opt) {
            return t.getAddPrimaryKeySql(pkname, cols, pkopt, opt);
        }

        #! drops the primary key from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropPrimaryKey();
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the database (only executed if the table is already in the database)

            @return the primary key dropped from the table

            @throw PRIMARY-KEY-ERROR no primary key exists

            @note
            - this method retrieves the primary key definition from the database if none has already been defined
            - if there are known foreign contraints on the primary key, SQL for dropping those constraints is also included

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractPrimaryKey dropPrimaryKey(*reference lsql) {
            return t.dropPrimaryKey(\lsql);
        }

        #! gets a list of SQL strings that can be used to drop the primary key from the table
        /** @par Example:
            @code
my list $l = $table.getDropPrimaryKeySql();
            @endcode

            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to drop the primary key from the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw PRIMARY-KEY-ERROR the table has no primary key

            @note
            - this method retrieves current primary key definition from the database if not already loaded or defined
            - if there are known foreign contraints on the primary key, SQL for dropping those constraints is also returned
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
         */
        list getDropPrimaryKeySql(*hash opt) {
            return t.getDropPrimaryKeySql(opt);
        }

        #! adds a unique constraint to the table; if the table is known to be in the database already, then the constraint is added to the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractUniqueConstraint $c = $table.addUniqueConstraint("uk_mytable", "name", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new unique constraint
            @param cols a single column name or a list of columns that make up the unique constraint
            @param opt a hash of options for the new unique constraint; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractUniqueConstraint object corresponding to the unique constraint created

            @throw UNIQUE-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns passed
            @throw OPTION-ERROR invalid or unsupported option passed

            @see 
            - inDb() for a method that tells if the table is already in the database or not
            - dropUniqueConstraint() for a method that allows unique constraints to be dropped from the table
         */
        AbstractUniqueConstraint addUniqueConstraint(string cname, softlist cols, *hash opt, *reference sql) {
            return t.addUniqueConstraint(cname, cols, opt, \sql);
        }

        #! returns an SQL string that can be used to add a unique constraint to the table
        /** @par Example:
            @code
my string $sql = $table.getAddUniqueConstraintSql("uk_mytable", "name", ("index_tablespace": "index1"));
printf("%s;\n", $sql);
            @endcode

            @param cname the name of the new unique constraint
            @param cols a single column name or a list of columns that make up the unique constraint
            @param ukopt a hash of options for the new unique constraint; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ConstraintOptions
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that can be used to add a unique constraint to the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw UNIQUE-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns passed

            @see inDb() for a method that tells if the table is already in the database or not

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
         */
        string getAddUniqueConstraintSql(string cname, softlist cols, *hash ukopt, *hash opt) {
            return t.getAddUniqueConstraintSql(cname, cols, ukopt, opt);
        }

        #! adds an index to the table; if the table already exists, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractIndex $ix = $table.addIndex("uk_mytable_name", True, "name", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param iname the name of the new index
            @param unique a flag to tell if the new index should be unique or not
            @param cols a single column name or a list of columns that make up the index
            @param opt a hash of options for the new index; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::IndexOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractIndex object corresponding to the index created

            @throw INDEX-ERROR the table already has an index with the given name or invalid columns were passed
            @throw OPTION-ERROR invalid or unsupported option passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractIndex addIndex(string iname, bool unique, softlist cols, *hash opt, *reference sql) {
            return t.addIndex(iname, unique, cols, opt, \sql);
        }

        #! returns an SQL string that can be used to add an index to the table
        /** @par Example:
            @code
my string $sql = $table.getAddIndexSql("uk_mytable_name", True, "name", ("index_tablespace": "index1"));
printf("%s;\n", $sql);
            @endcode

            @param iname the name of the new index
            @param unique a flag to tell if the new index should be unique or not
            @param cols a single column name or a list of columns that make up the index
            @param ixopt a hash of options for the new index; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::IndexOptions
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that can be used to add an index to the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw INDEX-ERROR the table already has an index with the given name or invalid columns or options were passed

            @see inDb() for a method that tells if the table is already in the database or not

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
         */
        string getAddIndexSql(string iname, bool unique, softlist cols, *hash ixopt, *hash opt) {
            return t.getAddIndexSql(iname, unique, cols, ixopt, opt);
        }

        #! renames an existing index; if the table is already known to be in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
my AbstractIndex $ix = $table.renameIndex("uk_table_name", "unique_table_name");
            @endcode

            @param old_name the current name of the index
            @param new_name the new name for the index
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)
            @return the index object that was updated

            @throw INDEX-ERROR if the old index does not exist in the table or if the new index name already exists
        */
        AbstractIndex renameIndex(string old_name, string new_name, reference sql) {
            return t.renameIndex(old_name, new_name, \sql);
        }

        #! gets the SQL that can be used to drop an index from the table
        /** @par Example:
            @code
my string $sql = $table.getDropIndexSql("uk_mytable_name");
            @endcode

            @param iname the name of the index to drop
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return the SQL that can be used to drop an index from the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw INDEX-ERROR the given index does not exist in the table

            @note
            - this method retrieves current index definitions from the database if not already loaded or defined
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
         */
        string getDropIndexSql(string iname, *hash opt) {
            return t.getDropIndexSql(iname, opt);
        }

        #! gets the SQL that can be used to drop a constraint from the table; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint
        /** @par Example:
            @code
my string $sql = $table.getDropConstraintSql("uk_mytable_name");
            @endcode

            @param cname the name of the constraint to drop
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return the SQL that can be used to drop a constraint from the table; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw CONSTRAINT-ERROR the given constraint does not exist in the table

            @note
            - this method retrieves current constraint definitions from the database if not already loaded or defined
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
         */
        string getDropConstraintSql(string cname, *hash opt) {
            return t.getDropConstraintSql(cname, opt);
        }

        #! gets the SQL that can be used to drop a constraint from the table if it exists, otherwise returns @ref nothing; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint
        /** @par Example:
            @code
my *string $sql = $table.getDropConstraintIfExistsSql("uk_mytable_name");
            @endcode

            @param cname the name of the constraint to drop
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options
            @param cref an optional reference to an AbstractConstraint object that will return the constraint dropped

            @return the SQL that can be used to drop a constraint from the table if it exists, otherwise returns @ref nothing; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint

            @throw OPTION-ERROR invalid or unsupported option passed

            @note
            - this method retrieves current constraint definitions from the database if not already loaded or defined
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
         */
        *string getDropConstraintIfExistsSql(string cname, *hash opt, *reference cref) {
            return t.getDropConstraintIfExistsSql(cname, opt, \cref);
        }

        #! drops the index from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropIndex("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param iname the name of the index to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the index dropped from the table

            @throw INDEX-ERROR the given index does not exist

            @note this method retrieves all current index definitions from the database if none have already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractIndex dropIndex(string iname, *reference sql) {
            return t.dropIndex(iname, \sql);
        }

        #! adds an foreign constraint to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractForeignConstraint $fc = $table.addForeignConstraint("fk_mytable_other_table", ("name", "version"), "other_table", NOTHING, \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new foreign constraint
            @param cols a single column name or a list of columns in the local table that make up the foreign constraint
            @param table the name of the other table that the constraint targets
            @param tcols a single column name or a list of columns in the foreign table or @ref nothing meaning that the column names are the same as in the local table; if column names are given the same number of columns must be given in the local and foreign tables
            @param opt a hash of options for the new foreign constraint; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ForeignConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractForeignConstraint object corresponding to the foreign constraint created

            @throw FOREIGN-CONSTRAINT-ERROR the table already has an foreign constraint with the given name or invalid columns were passed
            @throw OPTION-ERROR invalid or unsupported option passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractForeignConstraint addForeignConstraint(string cname, softlist cols, string table, *softlist tcols, *hash opt, *reference sql) {
            return t.addForeignConstraint(cname, cols, table, tcols, opt, \sql);
        }

        #! returns an SQL string that can be used to add a foreign constraint to the table
        /** @par Example:
            @code
my string $sql = $table.getAddForeignConstraintSql("fk_mytable_other_table", ("name", "version"), "other_table");
printf("%s;\n", $sql);
            @endcode

            @param cname the name of the new foreign constraint
            @param cols a single column name or a list of columns in the local table that make up the foreign constraint
            @param table the name of the other table that the constraint targets
            @param tcols a single column name or a list of columns in the foreign table or @ref nothing meaning that the column names are the same as in the local table; if column names are given the same number of columns must be given in the local and foreign tables
            @param fkopt a hash of options for the new foreign constraint; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ForeignConstraintOptions
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that can be used to add a foreign constraint to the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw FOREIGN-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns or options were passed

            @see inDb() for a method that tells if the table is already in the database or not

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
         */
        string getAddForeignConstraintSql(string cname, softlist cols, string table, *softlist tcols, *hash fkopt, *hash opt) {
            return t.getAddForeignConstraintSql(cname, cols, table, tcols, fkopt, opt);
        }

        #! drops the foreign constraint from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropForeignConstraint("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the foreign constraint to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the foreign constraint dropped from the table

            @throw FOREIGN-CONSTRAINT-ERROR the given constraint does not exist

            @note this method retrieves all current foreign constraint definitions from the database if none have already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractForeignConstraint dropForeignConstraint(string cname, *reference sql) {
            return t.dropForeignConstraint(cname, \sql);
        }

        #! removes the named foreign constraint from the table; no SQL is executed in any case, only the named foreign constraint is removed from the table definition
        /** @par Example:
            @code
$table.removeForeignConstraint("uk_mytable_name");
            @endcode

            @param cname the name of the foreign constraint to remove

            @return the foreign constraint removed from the table

            @throw FOREIGN-CONSTRAINT-ERROR the given constraint does not exist

            @note this method retrieves all current foreign constraint definitions from the database if none have already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractForeignConstraint removeForeignConstraint(string cname) {
            return t.removeForeignConstraint(cname);
        }

        #! adds a check constraint to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractCheckConstraint $cc = $table.addCheckConstraint("check_mytable_id", "id > 10", NOTHING, \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new constraint
            @param src the source of the constraint clause
            @param opt a hash of options for the new foreign constraint; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractCheckConstraint object corresponding to the check constraint created

            @throw CHECK-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns or options were passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractCheckConstraint addCheckConstraint(string cname, string src, *hash opt, *reference sql) {
            return t.addCheckConstraint(cname, src, opt, \sql);
        }

        #! returns an SQL string that can be used to add a check constraint to the table
        /** @par Example:
            @code
my string $sql = $table.getAddCheckConstraintSql("check_mytable_id", "id > 10");
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new constraint
            @param src the source of the constraint clause
            @param copt a hash of options for the new constraint; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ConstraintOptions
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that can be used to add a check constraint to the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw CHECK-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns or options were passed

            @see inDb() for a method that tells if the table is already in the database or not

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
         */
        string getAddCheckConstraintSql(string cname, string src, *hash copt, *hash opt) {
            return t.getAddCheckConstraintSql(cname, src, copt, opt);
        }

        #! renames an existing constraint; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint; if the table is already known to be in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
my AbstractConstraint $con = $table.renameConstraint("pk_table_name", "pkey_table_name");
            @endcode

            @param old_name the current name of the constraint
            @param new_name the new name for the constraint
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the constraint (only executed if the table is already in the database)
            @return the constraint object that was updated

            @throw CONSTRAINT-ERROR if the old constraint does not exist in the table or if the new constraint name already exists
        */
        AbstractConstraint renameConstraint(string old_name, string new_name, reference lsql) {
            return t.renameConstraint(old_name, new_name, \lsql);
        }

        #! drops a constraint from the table; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropConstraint("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the constraint to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the constraint dropped from the table

            @throw CONSTRAINT-ERROR the given constraint does not exist in the table

            @note this method retrieves current constraint definitions from the database if not already loaded or defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractConstraint dropConstraint(string cname, *reference sql) {
            return t.dropConstraint(cname, \sql); 
        }

        #! adds a trigger to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractTrigger $trig = $table.addTrigger("trig_mytable",x $trigger_source, NOTHING, \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param tname the name of the new trigger
            @param src the database-specific source of the trigger
            @param opt a hash of options for the new trigger; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::TriggerOptions
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractTrigger object corresponding to the trigger created

            @throw TRIGGER-ERROR the table already has a trigger with the given name or invalid options were passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractTrigger addTrigger(string tname, string src, *hash opt, *reference lsql) {
            return t.addTrigger(tname, src, opt, \lsql);
        }

        #! returns a list of SQL strings that can be used to add a trigger to the table
        /** @par Example:
            @code
my string $sql = $table.getAddTriggerSql("trig_mytable", $trigger_src);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param tname the name of the new trigger
            @param src the source of the trigger
            @param topt a hash of options for the new trigger; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::TriggerOptions
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to add a trigger to the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw TRIGGER-ERROR the table already has a trigger with the given name or invalid options were passed

            @see inDb() for a method that tells if the table is already in the database or not

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
         */
        list getAddTriggerSql(string tname, string src, *hash topt, *hash opt) {
            return t.getAddTriggerSql(tname, src, topt, opt);
        }

        #! drops the given trigger from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropTrigger("trig_mytable");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param tname the name of the trigger to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the database (only executed if the table is already in the database)

            @return the trigger dropped from the table

            @throw TRIGGER-ERROR the given trigger does not exist

            @note this method retrieves all current trigger definitions from the database if none have already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractTrigger dropTrigger(string tname, *reference sql) {
            return t.dropTrigger(tname, \sql);
        }

        #! returns SQL that can be used to drop the given trigger from the table
        /** @par Example:
            @code
my list $l = $table.getDropTriggerSql("trig_mytable");
            @endcode

            @param tname the name of the trigger to drop
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return the SQL that can be used to drop the given trigger from the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw TRIGGER-ERROR the given trigger does not exist

            @note
            - this method retrieves all current trigger definitions from the database if none have already been defined
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
         */
        list getDropTriggerSql(string tname, *hash opt) {
            return t.getDropTriggerSql(tname, opt);
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument
        /** @par Example:
            @code
my string $str = $table.getSqlValue($date);
            @endcode

            @param v the value to convert to an SQL value

            @return a string representing the value usable in SQL strings for the given database driver

            @throw VALUE-ERROR the given value cannot be converted to an SQL string (missing rules for value)
         */
        string getSqlValue(any v) {
            return t.getSqlValue(v);
        }
        
        #! drops a column from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropColumn("notes_2");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column to drop
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @throw COLUMN-ERROR the named column is not present in the table

            @note this method retrieves the table definition from the database if none has already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractColumn dropColumn(string cname, *reference lsql) {
            return t.dropColumn(cname, \lsql);
        }

        #! returns the SQL that can be used to drop a column from the table
        /** @par Example:
            @code
my list $l = $table.getDropColumnSql("notes_2");
            @endcode

            @param cname the name of the column to drop
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return the SQL that can be used to drop a column from the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw COLUMN-ERROR the named column is not present in the table

            @note
            - this method retrieves the column definitions from the database if none have already been defined
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
         */
        list getDropColumnSql(string cname, *hash opt) {
            return t.getDropColumnSql(cname, opt);
        }

        #! inserts a row into the table; the transaction is committed if successful, if an error occurs, it is rolled back
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert
            @param sql an optional reference to a string to return the SQL generated for the insert statement

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
         */
        insert(hash row, *reference sql) {
            t.insert(row, \sql);
        }

        #! inserts a row into the table without any transaction management; a transaction will be in progress after this method is successfully executed
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert
            @param sql an optional reference to a string to return the SQL generated for the insert statement

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
         */
        insertNoCommit(hash row, *reference sql) {
            t.insertNoCommit(row, \sql);
        }

        #! inserts a row into the table; the transaction is committed if successful, if an error occurs, it is rolled back
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
         */
        insert(hash row, *hash opt) {
            t.insert(row, opt);
        }

        #! inserts a row into the table without any transaction management; a transaction will be in progress after this method is successfully executed
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
         */
        insertNoCommit(hash row, *hash opt) {
            t.insertNoCommit(row, opt);
        }

        #! inserts rows into a table based on a select statement from another table (which must be using the same datasource as the current table); the transaction is committed if successful, if an error occurs, it is rolled back
        /** @par Example:
            @code
my int $rows = $table.insertFromSelect(("id", "name", "created"), $source_table, (("columns": ("id", "name", "created"), "where": ("type": "CUSTOMER")))); 
            @endcode

            @param cols the list of column names to use to insert in the current table
            @param source the source table for the select statement
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return the number of rows inserted

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR unknown or invalid column in insert list
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note this method does not take insert options because it is executed entirely in the database server; use insertFromIterator() or insertFromIteratorNoCommit() to insert arbitrary data with insert options
        */
        int insertFromSelect(list cols, AbstractTable source, *hash sh, *reference sql) {
            return t.insertFromSelect(cols, source, sh, \sql);
        }

        #! inserts rows into a table based on a select statement from another table (which must be using the same datasource as the current table); a transaction will be in progress after this method is successfully executed
        /** @par Example:
            @code
my int $rows = $table.insertFromSelectNoCommit(("id", "name", "created"), $source_table, (("columns": ("id", "name", "created"), "where": ("type": "CUSTOMER")))); 
            @endcode

            @param cols the list of column names to use to insert in the current table
            @param source the source table for the select statement
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return the number of rows inserted

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR unknown or invalid column in insert list
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note this method does not take insert options because it is executed entirely in the database server; use insertFromIterator() or insertFromIteratorNoCommit() to insert arbitrary data with insert options
        */
        int insertFromSelectNoCommit(list cols, AbstractTable source, *hash sh, *reference sql) {
            return t.insertFromSelectNoCommit(cols, source, sh, \sql);
        }

        #! inserts rows into a table based on a select statement from another table (which must be using the same datasource as the current table); the transaction is committed if successful, if an error occurs, it is rolled back
        /** @par Example:
            @code
my int $rows = $table.insertFromSelect(("id", "name", "created"), $source_table, (("columns": ("id", "name", "created"), "where": ("type": "CUSTOMER")))); 
            @endcode

            @param cols the list of column names to use to insert in the current table
            @param source the source table for the select statement
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return the number of rows inserted

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR unknown or invalid column in insert list
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note this method does not take insert options because it is executed entirely in the database server; use insertFromIterator() or insertFromIteratorNoCommit() to insert arbitrary data with insert options
        */
        int insertFromSelect(list cols, AbstractTable source, *hash sh, *hash opt) {
            return t.insertFromSelect(cols, source, sh, opt);
        }

        #! inserts rows into a table based on a select statement from another table (which must be using the same datasource as the current table); a transaction will be in progress after this method is successfully executed
        /** @par Example:
            @code
my int $rows = $table.insertFromSelectNoCommit(("id", "name", "created"), $source_table, (("columns": ("id", "name", "created"), "where": ("type": "CUSTOMER")))); 
            @endcode

            @param cols the list of column names to use to insert in the current table
            @param source the source table for the select statement
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return the number of rows inserted

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR unknown or invalid column in insert list
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note this method does not take insert options because it is executed entirely in the database server; use insertFromIterator() or insertFromIteratorNoCommit() to insert arbitrary data with insert options
        */
        int insertFromSelectNoCommit(list cols, AbstractTable source, *hash sh, *hash opt) {
            return t.insertFromSelectNoCommit(cols, source, sh, opt);
        }

        #! this method inserts data from the given iterator argument (whose @ref Qore::AbstractIterator::getValue() "getValue()" method must return a hash giving row values) into the current table; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my int $rows = $table.insertFromIterator($i);
            @endcode

            @param i the @ref Qore::AbstractIterator argument that will provide the data to insert into the current table; the @ref Qore::AbstractIterator::getValue() "getValue()" method of this object must return a hash giving row values (for example, the @ref Qore::SQL::SQLStatement class is well-suited to be used here); note that the iterator is assumed to return the same columns in the same order in every element
            @param opt a hash of options for the insert operation; see @ref SqlUtil::AbstractTable::InsertOptions for common options; each driver can support additional driver-specific options

            @return the number of rows inserted

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted

            @see
            - insertFromIteratorNoCommit()
            - upsertFromIterator()
            - upsertFromIteratorNoCommit()
        */
        int insertFromIterator(Qore::AbstractIterator i, *hash opt) {
            return t.insertFromIterator(i, opt);
        }

        #! this method inserts data from the given iterator argument (whose @ref Qore::AbstractIterator::getValue() "getValue()" method must return a hash giving row values) into the current table; no transaction management is performed with this method
        /** @par Example:
            @code
my int $rows = $table.insertFromIteratorNoCommit($i);
            @endcode

            @param i the @ref Qore::AbstractIterator argument that will provide the data to insert into the current table; the @ref Qore::AbstractIterator::getValue() "getValue()" method of this object must return a hash giving row values (for example, the @ref Qore::SQL::SQLStatement class is well-suited to be used here); note that the iterator is assumed to return the same columns in the same order in every element
            @param opt a hash of options for the insert operation; see @ref SqlUtil::AbstractTable::InsertOptions for common options; each driver can support additional driver-specific options

            @return the number of rows inserted

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted

            @see
            - insertFromIterator()
            - upsertFromIterator()
            - upsertFromIteratorNoCommit()
        */
        int insertFromIteratorNoCommit(Qore::AbstractIterator i, *hash opt) {
            return t.insertFromIteratorNoCommit(i, opt);
        }

        #! update or insert the data in the table according to the hash argument; the table must have a unique key to do this; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
$table.upsert($row);
            @endcode

            @param row a hash representing the row to insert or update
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy

            @return an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note if upserting multiple rows; it's better to use getUpsertClosure() or getUpsertClosureWithValidation() and execute the closure on each row; when using this method, the overhead for setting up the upsert is made for each row which is very inefficient

            @see
            - upsertNoCommit()
            - getUpsertClosure()
            - getUpsertClosureWithValidation()
         */
        int upsert(hash row, int upsert_strategy = AbstractTable::UpsertAuto) {
            return t.upsert(row, upsert_strategy);
        }

        #! update or insert the data in the table according to the hash argument; the table must have a unique key to do this; no transaction management is performed with this method
        /** @par Example:
            @code
$table.upsertNoCommit($row);
            @endcode

            @param row a hash representing the row to insert or update
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy

            @return an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note if upserting multiple rows; it's better to use getUpsertClosure() or getUpsertClosureWithValidation() and execute the closure on each row; when using this method, the overhead for setting up the upsert is made for each row which is very inefficient

            @see
            - upsert()
            - getUpsertClosure()
            - getUpsertClosureWithValidation()
         */
        int upsertNoCommit(hash row, int upsert_strategy = AbstractTable::UpsertAuto) {
            return t.upsertNoCommit(row, upsert_strategy);
        }

        #! returns a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the table must have a unique key to do this; the closure returned does not check the input hash for validity
        /** @par Example:
            @code
my Datasource $ds("pgsql:user/pass@db%localhost");
my Table $table($ds, "table_name");
my code $upsert = $table.getUpsertClosure($row, AbstractTable::UpsertSelectFirst);
on_success $ds.commit();
on_error $ds.rollback();
map $upsert($1), $row_list;
            @endcode

            @param example_row a hash representing an example row to insert or update; every row passed to the upsert closure returned must have the same keys in the same order
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy

            @return a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the closure returned does not check the input hash for validity; the closure has the following signature: @code int sub upsert(hash $row) {} @endcode The return value of the closuse is an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note the row values passed to the closure for upserting are not checked if they match the example row passed to the getUpsertClosure() method; passing non-conforming data will cause errors; see @ref SqlUtil::AbstractTable::getUpsertClosureWithValidation() for a similar method that returns a validating closure; the closure returned by this method is faster than the one returned by @ref SqlUtil::AbstractTable::getUpsertClosure() since there is no validation

            @see
            - upsert()
            - upsertNoCommit()
            - getUpsertClosureWithValidation()
         */
        code getUpsertClosure(hash example_row, int upsert_strategy = AbstractTable::UpsertAuto) {
            return t.getUpsertClosure(example_row, upsert_strategy);
        }

        #! returns a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the table must have a unique key to do this; the closure returned validates the input hash for validity
        /** @par Example:
            @code
my Datasource $ds("pgsql:user/pass@db%localhost");
my Table $table($ds, "table_name");
my code $upsert = $table.getUpsertClosureWithValidation($row, AbstractTable::UpsertSelectFirst);
on_success $ds.commit();
on_error $ds.rollback();
map $upsert($1), $row_list;
            @endcode

            @param example_row a hash representing an example row to insert or update; every row passed to the upsert closure returned must have the same keys in the same order or the closure returned will throw an \c UPSERT-ERROR exception
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy

            @return a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the closure has the following signature: @code int sub upsert(hash $row) {} @endcode The return value of the closuse is an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note the row values passed to the closure for upserting are checked if they match the example row passed to the getUpsertClosure() method; passing non-conforming data to the closure will cause the closure to throw an \c UPSERT-ERROR exception; see @ref SqlUtil::AbstractTable::getUpsertClosure() for a similar method that returns a non-validating closure; the closure returned by this method is a little slower than the one returned by @ref SqlUtil::AbstractTable::getUpsertClosure() since each row is validated

            @see
            - upsert()
            - upsertNoCommit()
            - getUpsertClosure()
         */
        code getUpsertClosureWithValidation(hash example_row, int upsert_strategy = AbstractTable::UpsertAuto) {
            return t.getUpsertClosureWithValidation(example_row, upsert_strategy);
        }

        #! this method upserts or merges data from the given iterator argument (whose @ref Qore::AbstractIterator::getValue() "getValue()" method must return a hash giving row values) into the current table; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my hash $h = $table.upsertFromIterator($i, AbstractTable::UpsertUpdateFirst);
            @endcode

            @param i the @ref Qore::AbstractIterator argument that will provide the data to upsert or merge into the current table; the @ref Qore::AbstractIterator::getValue() "getValue()" method of this object must return a hash giving row values (for example, the @ref Qore::SQL::SQLStatement class is well-suited to be used here)
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy
            @param opt a hash of options for the upsert operation; see @ref SqlUtil::AbstractTable::UpsertOptions for common options; each driver can support additional driver-specific options

            @return @ref nothing if no actions were taken or a hash with the following keys assigned to numeric values indicating the number of rows processed (keys correspond to @ref SqlUtil::AbstractTable::UpsertResultDescriptionMap keys):
            - \c "inserted": the number of rows inserted
            - \c "verified": the number of rows updated unconditionally; note that this key is returned with all upsert strategy codes other than @ref SqlUtil::AbstractTable::UpsertSelectFirst instead of \c "updated"
            - \c "updated": the number of rows updated; note that this key is only returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, otherwise updated rows are reported as \c "verified" since rows are updated unconditionally with other the upsert strategy codes
            - \c "unchanged": the number of rows unchanged; this key can only be returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, since this is the only upsert strategy that compares row data
            - \c "deleted": the number of rows deleted; this can only be returned if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True"

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True", then a hash of primary key values in the input data is built as the input data is iterated.  After iterating, if the row count of the table and the input data matches, then nothing more is done, otherwise, every row of the table is iterated and compared to the primary key hash; if a row does not match a primary key value, then it is deleted.  This operation is only executed if \c delete_others is @ref Qore::True "True" and is expensive for large data sets.

            @see
            - upsertFromIteratorNoCommit()
            - upsertFromSelect()
            - upsertFromSelectNoCommit()
            - upsert()
            - upsertNoCommit()
            - getUpsertClosure()
        */
        *hash upsertFromIterator(Qore::AbstractIterator i, int upsert_strategy = AbstractTable::UpsertAuto, *hash opt) {
            return t.upsertFromIterator(i, upsert_strategy, opt);
        }

        #! this method upserts or merges data from the given iterator argument (whose @ref Qore::AbstractIterator::getValue() "getValue()" method must return a hash giving row values) into the current table; no transaction management is performed with this method
        /** @par Example:
            @code
my hash $h = $table.upsertFromIteratorNoCommit($i, AbstractTable::UpsertUpdateFirst);
            @endcode

            @param i the @ref Qore::AbstractIterator argument that will provide the data to upsert or merge into the current table; the @ref Qore::AbstractIterator::getValue() "getValue()" method of this object must return a hash giving row values (for example, the @ref Qore::SQL::SQLStatement class is well-suited to be used here)
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy
            @param opt a hash of options for the upsert operation; see @ref SqlUtil::AbstractTable::UpsertOptions for common options; each driver can support additional driver-specific options

            @return @ref nothing if no actions were taken or a hash with the following keys assigned to numeric values indicating the number of rows processed (keys correspond to @ref SqlUtil::AbstractTable::UpsertResultDescriptionMap keys):
            - \c "inserted": the number of rows inserted
            - \c "verified": the number of rows updated unconditionally; note that this key is returned with all upsert strategy codes other than @ref SqlUtil::AbstractTable::UpsertSelectFirst instead of \c "updated"
            - \c "updated": the number of rows updated; note that this key is only returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, otherwise updated rows are reported as \c "verified" since rows are updated unconditionally with other the upsert strategy codes
            - \c "unchanged": the number of rows unchanged; this key can only be returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, since this is the only upsert strategy that compares row data
            - \c "deleted": the number of rows deleted; this can only be returned if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True"

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True", then a hash of primary key values in the input data is built as the input data is iterated.  After iterating, if the row count of the table and the input data matches, then nothing more is done, otherwise, every row of the table is iterated and compared to the primary key hash; if a row does not match a primary key value, then it is deleted.  This operation is only executed if \c delete_others is @ref Qore::True "True" and is expensive for large data sets.

            @see
            - upsertFromIteratorNoCommit()
            - upsertFromSelect()
            - upsertFromSelectNoCommit()
            - upsert()
            - upsertNoCommit()
            - getUpsertClosure()
        */
        *hash upsertFromIteratorNoCommit(Qore::AbstractIterator i, int upsert_strategy = AbstractTable::UpsertAuto, *hash opt) {
            return t.upsertFromIteratorNoCommit(i, upsert_strategy, opt);
        }

        #! this method upserts or merges data from the given foreign table and @ref select_option_hash "select option hash" into the current table; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my hash $h = $table.upsertFromSelect($table2, ("where": ("account_type": "CUSTOMER")), AbstractTable::UpsertUpdateFirst);
            @endcode

            The table argument does not need to be in the same database as the current table; it can also
            be in a different database server or a database server of a different type (you can use this method to upsert or
            merge data to or from any database supported by SqlUtil).

            @param src the table for the source data; this does not need to be in the same database as the target (the current table), nor does it need to be the same database type
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy
            @param opt a hash of options for the upsert operation; see @ref SqlUtil::AbstractTable::UpsertOptions for common options; each driver can support additional driver-specific options

            @return @ref nothing if no actions were taken or a hash with the following keys assigned to numeric values indicating the number of rows processed (keys correspond to @ref SqlUtil::AbstractTable::UpsertResultDescriptionMap keys):
            - \c "inserted": the number of rows inserted
            - \c "verified": the number of rows updated unconditionally; note that this key is returned with all upsert strategy codes other than @ref SqlUtil::AbstractTable::UpsertSelectFirst instead of \c "updated"
            - \c "updated": the number of rows updated; note that this key is only returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, otherwise updated rows are reported as \c "verified" since rows are updated unconditionally with other the upsert strategy codes
            - \c "unchanged": the number of rows unchanged; this key can only be returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, since this is the only upsert strategy that compares row data
            - \c "deleted": the number of rows deleted; this can only be returned if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True"

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note
            - if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True", then a hash of primary key values in the input data is built as the input data is iterated.  After iterating, if the row count of the table and the input data matches, then nothing more is done, otherwise, every row of the table is iterated and compared to the primary key hash; if a row does not match a primary key value, then it is deleted.  This operation is only executed if \c delete_others is @ref Qore::True "True" and is expensive for large data sets.
            - this method also calls commit() or rollback() on the source table to release the transaction lock on the underlying source table datasource as an @ref Qore::SQL::SQLStatement "SQLStatement" object is used to pipeline the data to the upsert code; use upsertFromSelectNoCommit() to do manual transaction management instead
            - unlike insertFromSelect() and insertFromSelectNoCommit(), this method processes arbitrary input data and accepts @ref SqlUtil::AbstractTable::UpsertOptions "upsert options"

            @see
            - upsertFromSelectNoCommit()
            - upsertFromIterator()
            - upsertFromIteratorNoCommit()
            - upsert()
            - upsertNoCommit()
            - getUpsertClosure()
        */
        *hash upsertFromSelect(AbstractTable src, *hash sh, int upsert_strategy = AbstractTable::UpsertAuto, *hash opt) {
            return t.upsertFromSelect(src, sh, upsert_strategy, opt);
        }

        #! this method upserts or merges data from the given foreign table and @ref select_option_hash "select option hash" into the current table; no transaction management is performed with this method
        /** @par Example:
            @code
on_success { $table.commit(); $table2.commit(); }
on_error { $table.rollback(); $table2.rollback(); }
my hash $h = $table.upsertFromSelectNoCommit($table2, ("where": ("account_type": "CUSTOMER")), AbstractTable::UpsertUpdateFirst);
            @endcode

            The table argument does not need to be in the same database as the current table; it can also
            be in a different database server or a database server of a different type (you can use this method to upsert or
            merge data to or from any database supported by SqlUtil).

            @param src the table for the source data; this does not need to be in the same database as the target (the current table), nor does it need to be the same database type
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy
            @param opt a hash of options for the upsert operation; see @ref SqlUtil::AbstractTable::UpsertOptions for common options; each driver can support additional driver-specific options

            @return @ref nothing if no actions were taken or a hash with the following keys assigned to numeric values indicating the number of rows processed (keys correspond to @ref SqlUtil::AbstractTable::UpsertResultDescriptionMap keys):
            - \c "inserted": the number of rows inserted
            - \c "verified": the number of rows updated unconditionally; note that this key is returned with all upsert strategy codes other than @ref SqlUtil::AbstractTable::UpsertSelectFirst instead of \c "updated"
            - \c "updated": the number of rows updated; note that this key is only returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, otherwise updated rows are reported as \c "verified" since rows are updated unconditionally with other the upsert strategy codes
            - \c "unchanged": the number of rows unchanged; this key can only be returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, since this is the only upsert strategy that compares row data
            - \c "deleted": the number of rows deleted; this can only be returned if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True"

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note
            - if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True", then a hash of primary key values in the input data is built as the input data is iterated.  After iterating, if the row count of the table and the input data matches, then nothing more is done, otherwise, every row of the table is iterated and compared to the primary key hash; if a row does not match a primary key value, then it is deleted.  This operation is only executed if \c delete_others is @ref Qore::True "True" and is expensive for large data sets.
           - this method uses an @ref Qore::SQL::SQLStatement "SQLStatement" object to pipeline the select data to the upsert code; to release the transaction lock acquired by the @ref Qore::SQL::SQLStatement "SQLStatement" object, a commit() or rollback() action must be executed on the underlying datasource object as in the example above
            - unlike insertFromSelect() and insertFromSelectNoCommit(), this method processes arbitrary input data and accepts @ref SqlUtil::AbstractTable::UpsertOptions "upsert options"

            @see
            - upsertFromSelect()
            - upsertFromIterator()
            - upsertFromIteratorNoCommit()
            - upsert()
            - upsertNoCommit()
            - getUpsertClosure()
        */
        *hash upsertFromSelectNoCommit(AbstractTable src, *hash sh, int upsert_strategy = AbstractTable::UpsertAuto, *hash opt) {
            return t.upsertFromSelectNoCommit(src, sh, upsert_strategy, opt);
        }

        #! this method upserts or merges data from the given foreign table and @ref select_option_hash "select option hash" into the current table; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my hash $h = $table.upsertFromSelect($table2, ("where": ("account_type": "CUSTOMER")), AbstractTable::UpsertUpdateFirst);
            @endcode

            The table argument does not need to be in the same database as the current table; it can also
            be in a different database server or a database server of a different type (you can use this method to upsert or
            merge data to or from any database supported by SqlUtil).

            @param src the table for the source data; this does not need to be in the same database as the target (the current table), nor does it need to be the same database type
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy
            @param opt a hash of options for the upsert operation; see @ref SqlUtil::AbstractTable::UpsertOptions for common options; each driver can support additional driver-specific options

            @return @ref nothing if no actions were taken or a hash with the following keys assigned to numeric values indicating the number of rows processed (keys correspond to @ref SqlUtil::AbstractTable::UpsertResultDescriptionMap keys):
            - \c "inserted": the number of rows inserted
            - \c "verified": the number of rows updated unconditionally; note that this key is returned with all upsert strategy codes other than @ref SqlUtil::AbstractTable::UpsertSelectFirst instead of \c "updated"
            - \c "updated": the number of rows updated; note that this key is only returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, otherwise updated rows are reported as \c "verified" since rows are updated unconditionally with other the upsert strategy codes
            - \c "unchanged": the number of rows unchanged; this key can only be returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, since this is the only upsert strategy that compares row data
            - \c "deleted": the number of rows deleted; this can only be returned if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True"

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note
            - if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True", then a hash of primary key values in the input data is built as the input data is iterated.  After iterating, if the row count of the table and the input data matches, then nothing more is done, otherwise, every row of the table is iterated and compared to the primary key hash; if a row does not match a primary key value, then it is deleted.  This operation is only executed if \c delete_others is @ref Qore::True "True" and is expensive for large data sets.
            - this method also calls commit() or rollback() on the source table to release the transaction lock on the underlying source table datasource as an @ref Qore::SQL::SQLStatement "SQLStatement" object is used to pipeline the data to the upsert code; use upsertFromSelectNoCommit() to do manual transaction management instead
            - unlike insertFromSelect() and insertFromSelectNoCommit(), this method processes arbitrary input data and accepts @ref SqlUtil::AbstractTable::UpsertOptions "upsert options"

            @see
            - upsertFromSelectNoCommit()
            - upsertFromIterator()
            - upsertFromIteratorNoCommit()
            - upsert()
            - upsertNoCommit()
            - getUpsertClosure()
        */
        *hash upsertFromSelect(Table src, *hash sh, int upsert_strategy = AbstractTable::UpsertAuto, *hash opt) {
            return t.upsertFromSelect(src.getTable(), sh, upsert_strategy, opt);
        }

        #! this method upserts or merges data from the given foreign table and @ref select_option_hash "select option hash" into the current table; no transaction management is performed with this method
        /** @par Example:
            @code
on_success { $table.commit(); $table2.commit(); }
on_error { $table.rollback(); $table2.rollback(); }
my hash $h = $table.upsertFromSelectNoCommit($table2, ("where": ("account_type": "CUSTOMER")), AbstractTable::UpsertUpdateFirst);
            @endcode

            The table argument does not need to be in the same database as the current table; it can also
            be in a different database server or a database server of a different type (you can use this method to upsert or
            merge data to or from any database supported by SqlUtil).

            @param src the table for the source data; this does not need to be in the same database as the target (the current table), nor does it need to be the same database type
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy
            @param opt a hash of options for the upsert operation; see @ref SqlUtil::AbstractTable::UpsertOptions for common options; each driver can support additional driver-specific options

            @return @ref nothing if no actions were taken or a hash with the following keys assigned to numeric values indicating the number of rows processed (keys correspond to @ref SqlUtil::AbstractTable::UpsertResultDescriptionMap keys):
            - \c "inserted": the number of rows inserted
            - \c "verified": the number of rows updated unconditionally; note that this key is returned with all upsert strategy codes other than @ref SqlUtil::AbstractTable::UpsertSelectFirst instead of \c "updated"
            - \c "updated": the number of rows updated; note that this key is only returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, otherwise updated rows are reported as \c "verified" since rows are updated unconditionally with other the upsert strategy codes
            - \c "unchanged": the number of rows unchanged; this key can only be returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, since this is the only upsert strategy that compares row data
            - \c "deleted": the number of rows deleted; this can only be returned if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True"

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note
            - if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True", then a hash of primary key values in the input data is built as the input data is iterated.  After iterating, if the row count of the table and the input data matches, then nothing more is done, otherwise, every row of the table is iterated and compared to the primary key hash; if a row does not match a primary key value, then it is deleted.  This operation is only executed if \c delete_others is @ref Qore::True "True" and is expensive for large data sets.
           - this method uses an @ref Qore::SQL::SQLStatement "SQLStatement" object to pipeline the select data to the upsert code; to release the transaction lock acquired by the @ref Qore::SQL::SQLStatement "SQLStatement" object, a commit() or rollback() action must be executed on the underlying datasource object as in the example above
            - unlike insertFromSelect() and insertFromSelectNoCommit(), this method processes arbitrary input data and accepts @ref SqlUtil::AbstractTable::UpsertOptions "upsert options"

            @see
            - upsertFromSelect()
            - upsertFromIterator()
            - upsertFromIteratorNoCommit()
            - upsert()
            - upsertNoCommit()
            - getUpsertClosure()
        */
        *hash upsertFromSelectNoCommit(Table src, *hash sh, int upsert_strategy = AbstractTable::UpsertAuto, *hash opt) {
            return t.upsertFromSelectNoCommit(src.getTable(), sh, upsert_strategy, opt);
        }

        #! returns the number of rows in the table
        /** @par Example:
            @code
my int $cnt = $table.rowCount();
            @endcode

            @return the number of rows in the table

            @note to see if the table is empty or not, use emptyData() as this is much faster than rowCount()

            @see emptyData()
         */
        softint rowCount() {
            return t.rowCount();
        }

        #! returns an @ref Qore::SQL::SQLStatement "SQLStatement" object that will iterate the results of a select statement matching the arguments
        /** @par Example:
            @code
my SQLStatement $i = $table.getRowIterator();
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return an @ref Qore::SQL::SQLStatement "SQLStatement" object that will iterate the results of a select statement matching the arguments

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note
            - if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
            - the @ref Qore::SQL::SQLStatement "SQLStatement" object created by a successful call to this method acquires a thread resource for the underlying @ref Qore::SQL::AbstractDatasource "AbstractDatasource" object that must be released by calling @ref Qore::SQL::AbstractDatasource::commit() "commit()" or @ref Qore::SQL::AbstractDatasource::rollback() "rollback()", even if the statement does not acquire any database locks
         */
        Qore::SQL::SQLStatement getRowIterator(*hash sh, *reference sql) {
            return t.getRowIterator(sh, \sql);
        }

        #! returns an @ref Qore::SQL::SQLStatement "SQLStatement" object that will iterate the results of a select statement matching the arguments
        /** @par Example:
            @code
my SQLStatement $i = $table.getRowIterator();
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return an @ref Qore::SQL::SQLStatement "SQLStatement" object that will iterate the results of a select statement matching the arguments

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note
            - if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
            - the @ref Qore::SQL::SQLStatement "SQLStatement" object created by a successful call to this method acquires a thread resource for the underlying @ref Qore::SQL::AbstractDatasource "AbstractDatasource" object that must be released by calling @ref Qore::SQL::AbstractDatasource::commit() "commit()" or @ref Qore::SQL::AbstractDatasource::rollback() "rollback()", even if the statement does not acquire any database locks
         */
        Qore::SQL::SQLStatement getRowIterator(*hash sh, *hash opt) {
            return t.getRowIterator(sh, opt);
        }

        #! returns a hash representing the row in the table that matches the argument hash; if more than one row would be returned an exception is raised
        /** @par Example:
            @code
my *hash $h = $table.selectRow($sh);
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return a hash representing the row in the table that matches the argument hash; if more than one row would be returned an exception is raised

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint
            @throw DBI-SELECT-ROW-ERROR more than 1 row retrieved from the server

            @note if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
         */
        *hash selectRow(*hash sh, *reference sql) {
            return t.selectRow(sh, \sql);
        }

        #! returns a list of hashes representing the rows in the table that match the argument hash
        /** @par Example:
            @code
my *list $l = $table.selectRows($sh);
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return a list of hashes representing the rows in the table that match the argument hash

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
         */
        *list selectRows(*hash sh, *reference sql) {
            return t.selectRows(sh, \sql);
        }

        #! returns a hash of lists representing the columns and rows in the table that match the argument hahs
        /** @par Example:
            @code
my *hash $h = $table.select($sh);
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return a hash of lists representing the columns and rows in the table that match the argument hash

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
         */
        *hash select(*hash sh, *reference sql) {
            return t.select(sh, \sql);
        }

        #! returns a hash representing the row in the table that matches the argument hash; if more than one row would be returned an exception is raised
        /** @par Example:
            @code
my *hash $h = $table.selectRow($sh);
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return a hash representing the row in the table that matches the argument hash; if more than one row would be returned an exception is raised

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint
            @throw DBI-SELECT-ROW-ERROR more than 1 row retrieved from the server

            @note if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
         */
        *hash selectRow(*hash sh, *hash opt) {
            return t.selectRow(sh, opt);
        }

        #! returns a list of hashes representing the rows in the table that match the argument hash
        /** @par Example:
            @code
my *list $l = $table.selectRows($sh);
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return a list of hashes representing the rows in the table that match the argument hash

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
         */
        *list selectRows(*hash sh, *hash opt) {
            return t.selectRows(sh, opt);
        }

        #! returns a hash of lists representing the columns and rows in the table that match the argument hahs
        /** @par Example:
            @code
my *hash $h = $table.select($sh);
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return a hash of lists representing the columns and rows in the table that match the argument hash

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
         */
        *hash select(*hash sh, *hash opt) {
            return t.select(sh, opt);
        }

        #! returns the SQL string to be executed corresponding to the argument hash with an output parameter for the select bind arguments
        /** @par Example:
            @code
my list $args;
my string $sql = $table.getSelectSql($sh, \$args);
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param args an optional reference to a list for any bind arguments

            @return the SQL that can be used to execute a select on the database corresponding to the arguments; the select bind arguments are returned in an output parameter

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note
            - the select string is specific to the arguments passed (for example @ref null arguments will have clauses like 'is null')
            - if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
         */
        string getSelectSql(*hash sh, *reference args) {
            return t.getSelectSql(sh, \args);
        }

        #! deletes rows in the table matching the condition and returns the count of rows deleted; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my int $dcnt = $table.del(("name": $name));
            @endcode

            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param sql an optional reference to a string to return the SQL generated for the delete statement

            @return the count of rows deleted

            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see delNoCommit(*hash)
         */
        int del(*hash cond, *reference sql) {
            return del(cond, \sql);
        }

        #! deletes rows in the table matching the condition and returns the count of rows deleted; no transaction management is performed with this method
        /** @par Example:
            @code
my int $dcnt = $table.delNoCommit(("name": $name));
            @endcode

            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param sql an optional reference to a string to return the SQL generated for the delete statement

            @return the count of rows deleted

            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see del(*hash)
         */
        int delNoCommit(*hash cond, *reference sql) {
            return t.delNoCommit(cond, \sql);
        }

        #! updates rows in the table matching an optional condition and returns the count of rows updated; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my int $ucnt = $table.update(("id": $id), ("name": $name));
            @endcode

            @param set the hash of values to set, key values are column names, hash values are the values to assign to those columns or update operators (see @ref sql_uop_funcs)
            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param sql an optional reference to a string to return the SQL generated for the update statement

            @return the count of rows updated

            @throw UPDATE-ERROR the set hash is empty
            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see updateNoCommit()
         */
        int update(hash set, *hash cond, *reference sql) {
            return t.update(set, cond, \sql);
        }

        #! updates rows in the table matching an optional condition and returns the count of rows updated; no transaction management is performed with this method
        /** @par Example:
            @code
my int $ucnt = $table.updateNoCommit(("id": $id), ("name": $name));
            @endcode

            @param set the hash of values to set, key values are column names, hash values are the values to assign to those columns or update operators (see @ref sql_uop_funcs)
            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param sql an optional reference to a string to return the SQL generated for the update statement

            @return the count of rows updated

            @throw UPDATE-ERROR the set hash is empty
            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see update()
         */
        int updateNoCommit(hash set, *hash cond, *reference sql) {
            return t.updateNoCommit(set, cond, \sql);
        }

        #! deletes rows in the table matching the condition and returns the count of rows deleted; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my int $dcnt = $table.del(("name": $name));
            @endcode

            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return the count of rows deleted

            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see delNoCommit(*hash)
         */
        int del(*hash cond, *hash opt) {
            return del(cond, opt);
        }

        #! deletes rows in the table matching the condition and returns the count of rows deleted; no transaction management is performed with this method
        /** @par Example:
            @code
my int $dcnt = $table.delNoCommit(("name": $name));
            @endcode

            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return the count of rows deleted

            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see del(*hash)
         */
        int delNoCommit(*hash cond, *hash opt) {
            return t.delNoCommit(cond, opt);
        }

        #! updates rows in the table matching an optional condition and returns the count of rows updated; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my int $ucnt = $table.update(("id": $id), ("name": $name));
            @endcode

            @param set the hash of values to set, key values are column names, hash values are the values to assign to those columns or update operators (see @ref sql_uop_funcs)
            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return the count of rows updated

            @throw UPDATE-ERROR the set hash is empty
            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see updateNoCommit()
         */
        int update(hash set, *hash cond, *hash opt) {
            return t.update(set, cond, opt);
        }

        #! updates rows in the table matching an optional condition and returns the count of rows updated; no transaction management is performed with this method
        /** @par Example:
            @code
my int $ucnt = $table.updateNoCommit(("id": $id), ("name": $name));
            @endcode

            @param set the hash of values to set, key values are column names, hash values are the values to assign to those columns or update operators (see @ref sql_uop_funcs)
            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return the count of rows updated

            @throw UPDATE-ERROR the set hash is empty
            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see update()
         */
        int updateNoCommit(hash set, *hash cond, *hash opt) {
            return t.updateNoCommit(set, cond, opt);
        }

        #! returns an SQL string corresponding to the list of commands in the argument
        /** @par Example:
            @code
my string $sql = $t.getSqlFromList($list);
            @endcode

            @param l a list of SQL commands
            
            @return an SQL string corresponding to the list of commands in the argument
        */
        string getSqlFromList(list l) {
            return t.getSqlFromList(l);
        }

        #! returns an SQL string that could be used to rename the table in the database
        /** @par Example:
            @code
my string $sql = $table.getRenameSql("new_name");
            @endcode

            @param new_name the new name for the table
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that could be used to rename the table in the database

            @throw OPTION-ERROR invalid or unsupported option passed

            @note If the @ref sql_callback_executed "sql_callback_executed option key" is @ref Qore::True "True", this method also renames the object internally (see @ref sql_callback_executed for more information), additionally if the \c "db_table_cache" option key is assigned to a @ref SqlUtil::Tables "Tables" argument, then the table cache is also updated with the name change in this case

            @see 
            - rename()
            - inDb() for a method that tells if the table is already in the database or not
        */
        string getRenameSql(string new_name, *hash opt) {
            return t.getRenameSql(new_name, opt);
        }

        #! returns an SQL string that could be used to create the table and all known properties of the table
        /** @par Example:
            @code
printf("%s\n", $table.getCreateSqlString());
            @endcode

            @param opt a hash of options for the SQL creation string; see @ref SqlUtil::AbstractTable::TableCreationOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that could be used to create the table and all known properties of the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        string getCreateSqlString(*hash opt) {
            return t.getCreateSqlString(opt);
        }

        #! returns a list of SQL strings that could be used to create the table and all known properties of the table
        /** @par Example:
            @code
map printf("$1;\n", $1), $table.getCreateSql();
            @endcode

            @param opt a hash of options for the SQL creation string; see @ref SqlUtil::AbstractTable::TableCreationOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that could be used to create the table and all known properties of the table
        */
        list getCreateSql(*hash opt) {
            return t.getCreateSql(opt);
        }

        #! returns an SQL string that could be used to create the basic table structure without indexes and constraints 
        /** @par Example:
            @code
my string $sql = $table.getCreateTableSql();
            @endcode

            @param opt a hash of options for the SQL creation string; see @ref SqlUtil::AbstractTable::TableCreationOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that could be used to create the basic table structure without indexes and constraints 

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        string getCreateTableSql(*hash opt) {
            return t.getCreateTableSql(opt);
        }

        #! returns a list of SQL strings that could be used to create indexes on the table or @ref nothing if there are no indexes on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateIndexesSql();
            @endcode

            @param opt a hash of options for the new index; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::IndexOptions

            @return a list of SQL strings that could be used to create indexes on the table or @ref nothing if there are no indexes on the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateIndexesSql(*hash opt) {
            return t.getCreateIndexesSql(opt);
        }

        #! returns an SQL string that could be used to create the primary key on the table
        /** @par Example:
            @code
my *string $sql = $table.getCreatePrimaryKeySql();
            @endcode

            @param opt a hash of options for the new primary key; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ConstraintOptions

            @return an SQL string that could be used to create the primary key on the table or @ref nothing if there is no primary key on the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *string getCreatePrimaryKeySql(*hash opt) {
            return t.getCreatePrimaryKeySql(opt);
        }

        #! returns a list of SQL strings that could be used to create foreign constraints on the table or @ref nothing if there are no foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateForeignConstraintsSql();
            @endcode

            @param opt a hash of options for the new foreign constraint; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ForeignConstraintOptions

            @return a list of SQL strings that could be used to create foreign constraints on the table or @ref nothing if there are no foreign constraints on the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateForeignConstraintsSql(*hash opt) {
            return t.getCreateForeignConstraintsSql(opt);
        }

        #! returns a list of SQL strings that could be used to create non-foreign constraints on the table or @ref nothing if there are no non-foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateConstraintsSql();
            @endcode

            @param opt a hash of options for the non-foreign constraint creation string; see @ref SqlUtil::AbstractTable::ConstraintOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that could be used to create non-foreign constraints on the table or @ref nothing if there are no non-foreign constraints on the table

            @throw OPTION-ERROR invalid or unsupported option passed

            @see getCreateForeignConstraintsSql()
        */
        *list getCreateConstraintsSql(*hash opt) {
            return t.getCreateConstraintsSql(opt);
        }

        #! returns a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or @ref nothing if there are none
        /** @par Example:
            @code
my *list $l = $table.getCreateMiscSql();
            @endcode

            @param opt a hash of options for the SQL creation string(s); see @ref SqlUtil::AbstractTable::TableCreationOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or @ref nothing if there are none

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateMiscSql(*hash opt) {
            return t.getCreateMiscSql(opt);
        }

        #! returns a list of SQL strings that could be used to create triggers on the table or @ref nothing if there are no triggers on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateTriggersSql();
            @endcode

            @param opt a hash of options for the trigger creation strings; see @ref SqlUtil::AbstractTable::TableCreationOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that could be used to create triggers on the table or @ref nothing if there are no triggers on the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateTriggersSql(*hash opt) {
            return t.getCreateTriggersSql(opt);
        }

        #! accepts an AbstractTable argument and returns a list of SQL strings required to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $table.getAlignSql($table2);
            @endcode

            @param table the template table that the current table will be compared to
            @param opt a hash of options for the SQL creation string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings required to align the structure and configuration of the current table with that of the AbstractTable argument; if the tables are identical then an empty list is returned

            @throw TABLE-COMPATIBILITY-ERROR the argument must be of the same class as the current object
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        list getAlignSql(AbstractTable table, *hash opt) {
            return t.getAlignSql(table, opt);
        }

        #! accepts an AbstractTable argument and returns a list of SQL strings required to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $table.getAlignSql($table2);
            @endcode

            @param table the template table that the current table will be compared to
            @param opt a hash of options for the SQL creation string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings required to align the structure and configuration of the current table with that of the AbstractTable argument; if the tables are identical then an empty list is returned

            @throw TABLE-COMPATIBILITY-ERROR the argument must be of the same class as the current object
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        list getAlignSql(Table table, *hash opt) {
            return t.getAlignSql(table.t, opt);
        }

        #! accepts an AbstractTable argument and returns an SQL string that could be executed to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty string is returned
        /** @par Example:
            @code
my string $sql = $table.getAlignSqlString($table2);
            @endcode

            @param table the template table that the current table will be compared to
            @param opt a hash of options for the SQL creation string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that could be executed to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty string is returned

            @throw ALIGN-TABLE-ERROR the argument must be of the same class as the current object; template table has no columns
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        string getAlignSqlString(AbstractTable table, *hash opt) {
            return t.getAlignSqlString(table, opt);
        }

        #! accepts an AbstractTable argument and returns an SQL string that could be executed to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty string is returned
        /** @par Example:
            @code
my string $sql = $table.getAlignSqlString($table2);
            @endcode

            @param table the template table that the current table will be compared to
            @param opt a hash of options for the SQL creation string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that could be executed to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty string is returned

            @throw ALIGN-TABLE-ERROR the argument must be of the same class as the current object; template table has no columns
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        string getAlignSqlString(Table table, *hash opt) {
            return t.getAlignSqlString(table.t, opt);
        }

        #! finds a row in the table with the given primary key value; if no row matches the primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *hash $row = $table.find($id);
            @endcode

            @param id the primary key ID to find

            @return a hash of the row value matching the primary key ID or @ref nothing if no row matches the primary key value passed

            @throw PRIMARY-KEY-ERROR the table has no primary key or the primary key has more than one column
         */
        *hash find(any id) {
            return t.find(id);
        }

        #! finds rows in the table with the given primary key values; if no row matches any primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *list $rows = $table.find($list);
            @endcode

            @param ids the list of primary key IDs to find

            @return a list of hashes of rows matching the primary key IDs passed or @ref nothing if no row matches any primary key value passed

            @throw PRIMARY-KEY-ERROR the table has no primary key or the primary key has more than one column
         */
        *list find(list ids) {
            return t.find(ids);
        }

        #! finds a row in the table with the given primary key value given as a hash; if no row matches the primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *hash $row = $table.find(("account_type": $type, "name": $name));
            @endcode

            @param row a hash giving the primary key value to find; other columns may also appear in the hash, however at least all columns of the primary key must be present

            @return a hash of the row value matching the primary key value passed or @ref nothing if no row matches the primary key value passed

            @throw PRIMARY-KEY-ERROR the table has no primary key or the the hash passed does not contain all columns of the primary key
         */
        *hash find(hash row) {
            return t.find(row);
        }

        #! finds a single row in the table that match the row condition passed; multiple rows may match, but only one row will be returned from the database; if no row matches the condition hash passed then @ref nothing is returned
        /** @par Example:
            @code
my *hash $row = $table.findSingle($h);
            @endcode

            @param cond a hash giving the column values to find; see @ref where_clauses for the format of this argument

            @return a hash representing a single row in the table with the given column values; multiple rows may match, but only one row will be returned from the database; if no row matches the condition hash passed then @ref nothing is returned

            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @note this is equivalent to calling selectRows() with \c where = \c cond and \c limit = 1

            @see selectRow()
         */
        *hash findSingle(*hash cond) {
            return t.findSingle(cond);
        }

        #! finds all rows in the table with the given column values; a list of hashes is returned representing the rows returned
        /** @par Example:
            @code
my *list $rows = $table.findAll($h);
            @endcode

            @param cond a hash giving the column values to find; see @ref where_clauses for the format of this argument

            @return a list of hashes is returned representing the rows returned

            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @note this is equivalent to calling selectRows() with \c where = \c cond
         */
        *list findAll(*hash cond) {
            return t.findAll(cond);
        }

        #! reads in all attributes of the table from the database
        /** @par Example:
            @code
$table.cache();
            @endcode

            @param opts cache options; see @ref SqlUtil::AbstractTable::CacheOptions for common options; each driver can support additional driver-specific options
        */
        cache(*hash opts) {
            t.cache(opts);
        }

        #! purges the current table definition
        /** @par Example:
            @code
$table.clear();
            @endcode

        */
        clear() {
            t.clear();
        }

        #! returns an object of class Columns describing the Table
        /** @par Example:
            @code
my Columns $cols = $table.describe();
            @endcode

            @return an object of class Columns describing the Table
        */
        Columns describe() {
            return t.describe();
        }

        #! returns an object of class AbstractPrimaryKey describing the primary key of the table
        /** If there is no primary key then the object returned will be empty (see @ref SqlUtil::AbstractPrimaryKey::empty())

            @par Example:
            @code
my AbstractPrimaryKey $cols = $table.getPrimaryKey();
            @endcode

            @return an object of class AbstractPrimaryKey describing the primary key of the table
        */
        *AbstractPrimaryKey getPrimaryKey() {
            return t.getPrimaryKey();
        }

        #! returns the given AbstractUniqueConstraint object if defined for the table (also includes the primary key)
        /** @par Example:
            @code
my *AbstractUniqueConstraint uk = $table.findUniqueConstraint("uk_table2");
            @endcode

            @param name the name of the unique constraint to find

            @return the given AbstractUniqueConstraint object if defined for the table (also includes the primary key)
        */
        *AbstractUniqueConstraint findUniqueConstraint(string name) {
            return t.findUniqueConstraint(name);
        }

        #! returns an object of class Indexes describing the indexes on the table
        /** If there are no indexes on the table then the object returned will be empty (see @ref SqlUtil::Indexes::empty())

            @par Example:
            @code
my Indexes $ix = $table.getIndexes();
            @endcode

            @return an object of class Indexes describing the indexes on the table
        */
        Indexes getIndexes() {
            return t.getIndexes();
        }

        #! returns an object of class Triggers describing the triggers on the table
        /** If there are no triggers on the table then the object returned will be empty (see @ref SqlUtil::Triggers::empty())

            @par Example:
            @code
my Triggers $trig = $table.getTriggers();
            @endcode

            @return an object of class Triggers describing the triggers on the table
        */
        Triggers getTriggers() {
            return t.getTriggers();
        }

        #! returns a ForeignConstraints object describing the foreign constraints that the table has on other tables
        ForeignConstraints getForeignConstraints(*hash opt) {
            return t.getForeignConstraints(opt);
        }

        #! returns a Constraints object describing non-foreign constraints on the table
        Constraints getConstraints() {
            return t.getConstraints();
        }

        #! returns the database driver name 
        string getDriverName() {
            return t.getDriverName();
        }
    }

    #! the base abstract class for the table implementation
    public class AbstractTable inherits AbstractSqlUtilBase {
        public {
            #! table options
            /** The following keys can be set for this option:
                - \c native_case: (@ref bool_type) if @ref Qore::True "True" then objects will be returned in the case the database server returns them in even if the database server uses case-insensitive names; normally in this case %SqlUtil will convert the names to lower-case
                - \c table_cache: (@ref SqlUtil::Tables "Tables") an optional table cache for maintaining cached tables and foreign key relationships between tables                
            */
            const TableOptions = (
                "native_case": Type::Boolean,
                "table_cache": "Tables",
                );

            #! default index options
            /**
                - \c index_tablespace: (@ref string_type) a string giving the index tablespace to use for indexes
                - \c replace: (@ref bool_type) if @ref Qore::True "True" and supported by the underlying db driver "create or replace" text is used when creating objects
            */
            const IndexOptions = (
                "index_tablespace": Type::String,
                "replace": Type::Boolean,
                );

            #! default constraint options
            /** currently this option is identical to @ref SqlUtil::AbstractTable::IndexOptions
            */
            const ConstraintOptions = IndexOptions;

            #! default cache options
            const CacheOptions = (
                "table_cache": "Tables",
                );

            #! default foreign constraint options
            /** The following keys can be set for this option:
                - \c table_cache: (@ref SqlUtil::Tables "Tables") an optional table cache for maintaining cached tables and foreign key relationships between tables                
            */
            const ForeignConstraintOptions = ConstraintOptions + (
                "table_cache": "Tables",
                );

            #! default trigger options
            /** currently this option is identical to @ref AbstractDatabase::CreationOptions
            */
            const TriggerOptions = AbstractDatabase::CreationOptions;

            #! default select options
            /** the possible keys for select options are as follows (all keys are optional):
                - @ref select_option_columns "columns": describes the output columns and any output column operations
                - @ref select_option_where "where": describes how any \c "where" clause will be built
                - @ref select_option_orderby "orderby": describes the ordering of the results
                - @ref select_option_desc "desc": specifies descending order for results
                - @ref select_option_limit "limit": specifies the maximum number of results to be returned
                - @ref select_option_offset "offset": specifies the starting offset of the first record to be returned (starting with 0)
                - @ref select_option_join "join": specifies any SQL join operations to return results from multiple tables
                - @ref select_option_groupby "groupby": specifies grouping for aggregate column functions
                - @ref select_option_having "having": specifies filtering for results with aggregate column functions
             */
            const SelectOptions = (
                "columns": Type::NothingType,
                "where": "hash/list",
                "orderby": "softstringlist",
                "desc": Type::Boolean,
                "limit": Type::Int,
                "offset": Type::Int,
                "join": Type::Hash,
                "groupby": "softstringlist",
                "having": Type::Hash,
                );

            #! table creation options
            /** currently this option is a combination of @ref SqlUtil::AbstractTable::IndexOptions and @ref AbstractDatabase::CreationOptions
            */
            const TableCreationOptions = IndexOptions + AbstractDatabase::CreationOptions;

            #! table alignment options
            /** currently this option is a combination of @ref SqlUtil::AbstractTable::TableCreationOptions and the following options:
                - \c column_map: a hash for automatically renaming columns; if the source name (key) exists and the target name (value) does not exist, then the source column is automatically renamed
                - \c index_map: a hash for automatically renaming indexes; if the source name (key) exists and the target name (value) does not exist, then the source index is automatically renamed
                - \c constraint_map: a hash for automatically renaming constraints; if the source name (key) exists and the target name (value) does not exist, then the source constraint is automatically renamed
                - \c trigger_map: a hash for automatically renaming triggers; if the source name (key) exists and the target name (value) does not exist, then the source trigger is automatically renamed
                - \c db_table_cache: (@ref SqlUtil::Tables "Tables") an optional table cache for maintaining tables in the database and foreign key relationships between tables
            */
            const AlignTableOptions = TableCreationOptions + (
                "column_map": Type::Hash,
                "index_map": Type::Hash,
                "constraint_map": Type::Hash,
                "trigger_map": Type::Hash,
                "db_table_cache": "Tables",
                );

            #! Table description options
            /** this option is made up of the following keys:
                - \c columns: (@ref column_desc_hash "column description hash") a hash describing the column
                - \c primary_key : (@ref pk_desc_hash "primary key description hash") a hash describing the primary key for the table
                - \c indexes: (@ref index_desc_hash "index description hashes") a hash describing the indexes on the table
                - \c triggers: a hash of trigger information keyed by trigger name; the values are the trigger source code; since triggers are driver-dependent, a driver-independent table description would include trigger hashes under the \c drivers key and the driver key name under that
                - \c foreign_constraints: (@ref fk_desc_hash "foreign constraint hashes") a hash describing the foreign constraints on the table 
                - \c unique_constraints: (@ref uk_desc_hash "unique constraint hashes") a hash describing the unique constraints on the table 
                - \c table_cache: (@ref SqlUtil::Tables "Tables") an optional table cache for maintaining cached tables and foreign key relationships between tables                

                @see @ref table_desc_hash
            */
            const TableDescriptionHashOptions = (
                "columns": Type::Hash,
                "primary_key": Type::Hash,
                "indexes": Type::Hash,
                "triggers": Type::Hash,
                "foreign_constraints": Type::Hash,
                "unique_constraints": Type::Hash,
                #"check_constraints": Type::Hash,
                "table_cache": "Tables",
                );

            #! Column description options
            /** this option is made up of the following keys:
                - \c qore_type: (@ref string_type) a qore type string that will be converted to a native DB type with some default conversion
                - \c native_type: (@ref string_type) the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
                - \c size: (@ref int_type) for data types requiring a size component, the size; for numeric columns this represents the precision for example
                - \c scale: (@ref int_type) for numeric data types, this value gives the scale
                - \c default_value: the default value for the column
                - \c comment: (@ref string_type) an optional comment for the column
                - \c notnull: if the column should have a "not null" constraint on it; if missing the default value is @ref Qore::False "False"
                - \c driver: this key can optionally contain a hash keyed by driver name which contains a hash of values that will be added to the column description hash before processing; this way a column description hash can contain all the information required for the column including driver-specific options; any driver-specific options will overwrite values in the top level of the hash if there are duplicate hash keys, see below for an example
                @see @ref column_desc_hash
            */
            const ColumnDescOptions = (
                "qore_type": Type::String,
                "native_type": Type::String,
                "size": Type::Int,
                "scale": Type::Int,
                "default_value": Type::NothingType,
                "comment": Type::String,
                );

            #! additional column description keys valid when describing columns in a @ref table_desc_hash "table description hash"
            /** the following keys are valid in a @ref table_desc_hash "table description hash" in addition to any @ref SqlUtil::AbstractTable::ColumnDescOptions "AbstractTable::ColumnDescOptions":
                - \c notnull: (@ref bool_type) if @ref Qore::True "True" then the column will have a not null constraint
            */
            const AdditionalColumnDescOptions = (
                "notnull": Type::Boolean,
                );

            #! Column options; this is currently empty and can be extended in database-specific modules
            const ColumnOptions = hash();

            #! generic SQL data operation callbacks
            /** The following keys can be set for this option:
                - \c sqlarg_callback: see @ref sqlarg_callback
            */
            const SqlDataCallbackOptions = (
                "sqlarg_callback": "code",
                );

            #! default upsert option keys
            /** The following keys can be set for this option:
                - \c info_callback: see @ref upsert_info_callback
                - \c commit_block: the number of changes made before an automatic commit is made for upsert methods that perform commits
                - \c delete_others: if this option is @ref Qore::True "True", then a hash of primary key values in the input data is built as the input data is iterated.  After iterating, if the row count of the table and the input data matches, then nothing more is done, otherwise, every row of the table is iterated and compared to the primary key hash; if a row does not match a primary key value, then it is deleted.  This operation allows tables to be completely synchronized by removing rows in the target table not present in the source table.  This operation is expensive for large data sets.
            */
            const UpsertOptions = (
                "info_callback": "code",
                "commit_block": Type::Int,
                "delete_others": Type::Boolean,
                );

            #! default insert option keys
            /** In addition to any @ref SqlDataCallbackOptions, the following keys can be set for this option:
                - \c info_callback: see @ref insert_info_callback
                - \c commit_block: the number of changes made before an automatic commit is made for insert methods that perform commits
            */
            const InsertOptions = SqlDataCallbackOptions + (
                "info_callback": "code",
                "commit_block": Type::Int,
                );

            /** @defgroup upsert_options Upsert Strategy Codes
                These options are used with:
                - @ref SqlUtil::AbstractTable::getUpsertClosure()
                - @ref SqlUtil::AbstractTable::getUpsertClosureWithValidation()
                - @ref SqlUtil::AbstractTable::upsert()
                - @ref SqlUtil::AbstractTable::upsertNoCommit()
                - @ref SqlUtil::AbstractTable::upsertFromIterator()
                - @ref SqlUtil::AbstractTable::upsertFromIteratorNoCommit()
                - @ref SqlUtil::AbstractTable::upsertFromSelect()
                - @ref SqlUtil::AbstractTable::upsertFromSelectNoCommit()

                to specify the upsert strategy when synchronizing table data
             */
            #@{
            #! Upsert option: insert first, if the insert fails, then update
            /** with this option an insert is attempted, and if it fails due to a duplicate row, then an update is made unconditionally; with
                this upsert strategy, the following row result codes are possible:
                - @ref UR_Inserted
                - @ref UR_Verified
             */
            const UpsertInsertFirst = 1;

            #! Upsert option: update first, if the update fails, then insert
            /** with this option an update is attempted, and if it fails due to a missing row, then an insert is performed; with
                this upsert strategy, the following row result codes are possible:
                - @ref UR_Inserted
                - @ref UR_Verified
             */
            const UpsertUpdateFirst = 2;

            #! Upsert option: select first, if the row is unchanged, do nothing, if it doesn't exist, insert, otherwise update
            /** with this option the row is selected, if it doesn't exist, an insert is made, and an update is made only if the
                values are different; with this upsert strategy, the following row result codes are possible:
                - @ref UR_Inserted
                - @ref UR_Updated
                - @ref UR_Unchanged
             */
            const UpsertSelectFirst = 3;

            #! Upsert option: if the target table is empty, use @ref UpsertInsertFirst, otherwise use @ref UpsertUpdateFirst
            /** With this upsert strategy, the following row result codes are possible:
                - @ref UR_Inserted
                - @ref UR_Verified
             */
            const UpsertAuto = 4;
            #@}

            /** @defgroup upsert_results Upsert Result Codes
                @see @ref UpsertResultMap and @ref UpsertResultDescriptionMap
             */
            #@{
            #! row was inserted
            const UR_Inserted = 1;
            
            #! row was updated unconditionally (not returned with @ref UpsertSelectFirst)
            const UR_Verified = 2;

            #! row was updated because it was different (only possible with @ref UpsertSelectFirst)
            const UR_Updated = 3;

            #! row was unchanged (only possible with @ref UpsertSelectFirst)
            const UR_Unchanged = 4;

            #! row was deleted (only possible with batch upsert methods such as @ref Table::upsertFromIterator() where @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True")
            const UR_Deleted = 5;
            #@}

            #! hash mapping upsert results to a description
            /** @see @ref UpsertResultDescriptionMap for a reverse mapping
            */
            const UpsertResultMap = (
                UR_Inserted: "inserted",
                UR_Verified: "verified",
                UR_Updated: "updated",
                UR_Unchanged: "unchanged",
                UR_Deleted: "deleted",
                );

            #! hash mapping upsert descriptions to codes
            /** @see @ref UpsertResultMap for a reverse mapping
            */
            const UpsertResultDescriptionMap = (
                "inserted": UR_Inserted,
                "verified": UR_Verified,
                "updated": UR_Updated,
                "unchanged": UR_Unchanged,
                "deleted": UR_Deleted,
                );

            #! maps upsert result codes to single letter symbols
            const UpsertResultLetterMap = (
                UR_Inserted: "I",
                UR_Verified: "V",
                UR_Updated: "U",
                UR_Unchanged: ".",
                UR_Deleted: "X",
                );
        }

        private {
            #! the table's name
            string name;
            #! column description object
            Columns columns;
            #! primary key description
            *AbstractPrimaryKey primaryKey;
            #! index descriptions
            Indexes indexes;
            #! foreign constraints description
            ForeignConstraints foreignConstraints;
            #! constraint descriptions
            Constraints constraints;
            #! trigger descriptions
            Triggers triggers;
            #! native case option
            bool native_case = False;
            #! in database
            bool inDb = False;
            #! manual edits
            bool manual = False;
        }

        #! creates the object; private constructor
        /** @param nds the AbstractDatasource for the connection to the database
            @param nname the name of the table
            @param nopts an optional hash of options for the table creation string; see @ref SqlUtil::AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
         */
        private constructor(AbstractDatasource nds, string nname, *hash nopts) : AbstractSqlUtilBase(nds, nopts) {
            name = nname;
            doTableOptions(nopts);
        }

        #! copies the object
        copy(AbstractTable old) {
            # copy container objects
            if (columns)
                columns = columns.copy();
            if (primaryKey)
                primaryKey = primaryKey.copy();
            if (indexes)
                indexes = indexes.copy();
            if (foreignConstraints)
                foreignConstraints = foreignConstraints.copy();
            if (constraints)
                constraints = constraints.copy();
            if (triggers)
                triggers = triggers.copy();

            copyImpl(old);
        }

        #! changes the datasource for the table; if the \c inDb flag is @ref Qore::True "True", then it is set to @ref Qore::False "False" by calling this method
        /** @par Example:
            @code
my Table $table($ds1, "table_name");
$table.setDatasource($ds2);
$table.create();
            @endcode

            @param nds the new datasource for the table

            @note it's generally not safe to call this method while SQL operations are in progress in other threads on the same table
        */
        setDatasource(AbstractDatasource nds) {
            l.lock();
            on_exit l.unlock();

            ds = nds;
            inDb = False;
        }

        private doTableOptions(*hash nopts) {
            validateOptionsIntern("OPTION-ERROR", getTableOptions(), \nopts);
            if (nopts.native_case)
                native_case = True;
        }

        #! commits the current transaction on the underlying @ref Qore::SQL::AbstractDatasource
        commit() {
            ds.commit();
        }

        #! rolls back the current transaction on the underlying @ref Qore::SQL::AbstractDatasource
        rollback() {
            ds.rollback();
        }

        #! returns @ref Qore::True "True" if the table has been read from or created in the database, @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $table.inDb();
            @endcode

            @return @ref Qore::True "True" if the table has been read from or created in the database, @ref Qore::False "False" if not
         */
        bool inDb() {
            return inDb;
        }

        #! returns an iterator for all unique constraints on the table (including the primary key if any)
        /** @par Example:
            @code
map printf("unique constraint %s\n", $1.getName()), $table.getUniqueConstraintIterator();
            @endcode

            @return an iterator for all unique constraints on the table (including the primary key if any)
        */
        Qore::AbstractIterator getUniqueConstraintIterator() {
            l.lock();
            on_exit l.unlock();

            if (!manual) {
                getPrimaryKeyUnlocked();
                getConstraintsUnlocked();
            }

            list l = ();
            if (primaryKey)
                l += primaryKey;

            foreach AbstractConstraint c in (constraints.iterator()) {
                if (c instanceof AbstractUniqueConstraint)
                    l += c;
            }

            return l.iterator();
        }

        #! drops the table from the database; releases the transaction lock after dropping the table
        /** @par Example:
            @code
$table.drop();
            @endcode

            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @throw OPTION-ERROR invalid or unknown callback option

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref dropNoCommit() to execute without any transaction management
         */
        drop(*hash opt) {
            on_exit ds.commit();
            on_error ds.rollback();
            dropNoCommit(opt);
        }

        #! executes some SQL with optional arguments so that if an error occurs the current transaction state is not lost
        /** @par Example: 
            @code
$t.tryExec("drop table tmp_table");
            @endcode

            Include any arguments in the parameter list after the \a sql argument

            @param sql the SQL to execute

            @return any return value from the SQL command executed
         */
        any tryExec(string sql) {
            return tryExecArgsImpl(sql, argv);
        }

        #! executes some SQL with optional arguments so that if an error occurs the current transaction state is not lost
        /** @par Example: 
            @code
$t.tryExec("delete from tmp_table where id = %v and name = %v", $arglist);
            @endcode

            @param sql the SQL to execute
            @param args the bind / placeholder or other arguments corresponding to the SQL string

            @return any return value from the SQL command executed
         */
        any tryExecArgs(string sql, *softlist args) {
            return tryExecArgsImpl(sql, args);
        }

        #! executes some SQL so that if an error occurs the current transaction state is not lost
        /** @par Example: 
            @code
$t.tryExecRaw("drop table tmp_table");
            @endcode

            Include any arguments in the parameter list after the \a sql argument

            @param sql the SQL to execute

            @return any return value from the SQL command executed
         */
        any tryExecRaw(string sql) {
            return tryExecRawImpl(sql);
        }

        #! drops the table from the database without any transaction management
        /** @par Example:
            @code
$table.dropNoCommit();
            @endcode

            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @throw OPTION-ERROR invalid or unknown callback option

            @note Transaction management is normally not performed when dropping tables, however this method uses the Qore::SQL::AbstractDatasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        dropNoCommit(*hash opt) {
            map ds.execRaw($1), getDropSql(opt);
            inDb = False;
        }

        #! returns the sql required to drop the table; reimplement in subclasses if necessary
        /** @par Example:
            @code
            @endcode

            @param opt optional callback options; see @ref AbstractDatabase::CallbackOptions for more info

            @return a list of strings that can be used to drop the table and any other objects assocatied with the table (for example: PostgreSQL table trigger function(s))

            @throw OPTION-ERROR invalid or unknown callback option
        */
        softlist getDropSql(*hash opt) {
            cache();
            return AbstractDatabase::doCallback(opt, getDropSqlImpl(), AbstractDatabase::AC_Drop, "table", getSqlName());
        }

        #! truncates all the table data; releases the transaction lock after executing
        /** @par Example:
            @code
$table.truncate();
            @endcode

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref truncateNoCommit() to execute without any transaction management
         */
        truncate() {
            on_exit ds.commit();
            on_error ds.rollback();
            truncateNoCommit();
        }

        #! truncates all the table data without any transaction management
        /** @par Example:
            @code
$table.truncateNoCommit();
            @endcode

            @note Transaction management may not be applied when truncating tables depending on the database driver (for example truncating tables in Oracle does not participate in transaction management), however this method uses the Qore::SQL::AbstractDatasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.
         */
        truncateNoCommit() {
            ds.exec(getTruncateSqlImpl());
            inDb = False;
        }

        #! gets the SQL that can be used to truncate the table
        /** @par Example:
            @code
my string $sql = $table.getTruncateSql();
            @endcode

            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return the SQL that can be used to truncate the table

            @throw OPTION-ERROR invalid or unsupported option passed

            @see inDb() for a method that tells if the table is already in the database or not

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
         */
        string getTruncateSql(*hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);        
            return AbstractDatabase::doCallback(opt, getTruncateSqlImpl(), AbstractDatabase::AC_Truncate, "table", name);
        }

        #! creates the table in the database; releases the transaction lock after creating the table
        /** @par Example:
            @code
$table.create();
            @endcode

            @param opt a hash of options for the SQL creation strings

            @note The transaction is committed if successful or rolled back if an exception occurs; use @ref createNoCommit() to execute without any transaction management
         */
        create(*hash opt) {
            on_exit ds.commit();
            on_error ds.rollback();
            createNoCommit(opt);
        }

        #! creates the table with all associated properties (indexes, constraints, etc) without any transaction management
        /** @par Example:
            @code
$table.createNoCommit();
            @endcode

            @param opt a hash of options for the SQL creation strings

            @note Transaction management is normally not performed when creating tables, however this method uses the Qore::SQL::AbstractDatasource::exec() method, which normally participates in acquiring a transaction lock for the underlying datasource object; therefore after this method executes normally the transaction lock will be dedicated to the calling thread.

            @throw CREATE-TABLE-ERROR table has already been read from or created in the database
         */
        createNoCommit(*hash opt) {
            if (inDb) 
                throw "CREATE-TABLE-ERROR", sprintf("table %s has already been read from or created in the database", getSqlName());

            # get and execute all the creation strings
            map ds.execRaw($1), getCreateSql(opt, False);
            inDb = True;
            manual = False;
        }

        #! renames the table; if the table is already known to be in the database in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
$table.rename("new_name");
            @endcode

            @param new_name the new name for the table
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)
            @param table_cache an optional @ref SqlUtil::Tables "Tables" argument to update the table name in any table cache

            @see getRenameSql()
        */
        rename(string new_name, *reference sql, *Tables table_cache) {
            l.lock();
            on_exit l.unlock();

            execSql(sql = getRenameSqlImpl(name, new_name));
            doRenameIntern(new_name, table_cache);
        }

        private doRenameIntern(string new_name, *Tables table_cache) {
            if (table_cache)
                table_cache.tableRenamed(name, new_name, getSqlName());
            name = new_name;
        }

        #! returns @ref Qore::True "True" if the table has no data rows, @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $table.emptyData();
            @endcode

            @return @ref Qore::True "True" if the table has no data rows, @ref Qore::False "False" if not

            @see 
            - empty()
            - rowCount()
        */
        bool emptyData() {
            return findSingle() ? False : True;
        }

        #! returns @ref Qore::True "True" if the table has no definitions, @ref Qore::False "False" if not
        /** @par Example:
            @code
my bool $b = $table.empty();
            @endcode

            @return @ref Qore::True "True" if the table has no definitions, @ref Qore::False "False" if not

            @see emptyData()
        */
        bool empty() {
            l.lock();
            on_exit l.unlock();
            return emptyUnlocked();
        }

        private bool emptyUnlocked() {
            if (!columns.empty()
                || !primaryKey.empty()
                || !indexes.empty()
                || !foreignConstraints.empty()
                || !constraints.empty()
                || !triggers.empty())
                return False;

            return emptyImpl();
        }

        #! creates the object from a table description hash
        /** @param desc a @ref table_desc_hash "table description hash" describing the table
            @param opt an optional hash of options for the table creation string; see @ref SqlUtil::AbstractTable::TableOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw DESCRIPTION-ERROR invalid or unsupported description hash value passed
        */
        setupTable(hash desc, *hash opt) {
            # check description
            validateOptionsIntern("DESCRIPTION-ERROR", getTableDescriptionHashOptions(), \desc);

            # check options
            hash copt = getColumnOptions();
            validateOptionsIntern("OPTION-ERROR", getTableCreationOptions() + copt, \opt);

            # setup table cache
            if (!opt.table_cache)
                opt.table_cache = new Tables();

            l.lock();
            on_exit l.unlock();

            if (!emptyUnlocked())
                throw "DESCRIPTION-ERROR", sprintf("%s: cannot set up a non-empty table from a hash description", name);

            # add current table to cache
            opt.table_cache.add(name, self);

            string drv = ds.getDriverName();

            # extract column options
            *hash oc = opt.(copt.keys());

            # process descriptions
            AbstractDatabase::checkDriverOptions(\desc.columns, drv);
            AbstractDatabase::checkDriverOptions(\desc.indexes, drv);
            AbstractDatabase::checkDriverOptions(\desc.primary_key, drv);
            AbstractDatabase::checkDriverOptions(\desc.unique_constraints, drv);
            AbstractDatabase::checkDriverOptions(\desc.foreign_constraints, drv);
            AbstractDatabase::checkDriverOptions(\desc.triggers, drv);

            # process column definitions
            foreach string cn in (desc.columns.keyIterator()) {
                if (desc.columns{cn}.typeCode() != NT_HASH)
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to column key %y is not a hash, got type %y instead (%y)", name, cn, desc.columns{cn}.type(), desc.columns{cn});
                if (desc.columns{cn}.driver) {
                    desc.columns{cn} += desc.columns{cn}.driver{drv};
                    delete desc.columns{cn}.driver;
                }
            }

            preSetupTableImpl(\desc, opt);

            # add columns to table
            foreach string cn in (desc.columns.keyIterator()) {
                hash ch = desc.columns{cn};
                softbool nullable = !exists ch.notnull ? True : !(remove ch.notnull);
                addColumnUnlocked(cn, ch + oc, nullable ? True : False);
            }

            # add indexes to table
            foreach string ixn in (desc.indexes.keyIterator()) {
                if (desc.indexes{ixn}.typeCode() != NT_HASH)
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to index key %y is not a hash, got type %y instead (%y)", name, ixn, desc.indexes{ixn}.type(), desc.indexes{ixn});

                hash ih = desc.indexes{ixn};

                if (!ih.columns || !inlist(ih.columns.typeCode(), (NT_LIST, NT_STRING)))
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to \"columns\" key for index %y is not a list or a string, got type %y instead (%y)", name, ixn, ih.columns.type(), ih.columns);
                
                addIndexUnlocked(ixn, ih.unique ? True : False, ih.columns, opt.(getIndexOptions().keys()));
            }

            # add primary key to table
            if (desc.primary_key) {
                if (desc.primary_key.typeCode() != NT_HASH)
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to primary_key is not a hash, got type %y instead (%y)", name, desc.primary_key.type(), desc.primary_key);
                if (!desc.primary_key.name || desc.primary_key.name.typeCode() != NT_STRING)
                    throw "DESCRIPTION-ERROR", sprintf("%s: missing string value for 'name' key in primary_key hash: %y", name, desc.primary_key);
                
                addPrimaryKeyUnlocked(desc.primary_key.name, desc.primary_key.columns, opt.(getConstraintOptions().keys()));
            }

            # add unique constraints to table
            foreach string un in (desc.unique_constraints.keyIterator()) {
                if (desc.unique_constraints{un}.typeCode() != NT_HASH)
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to index key %y is not a hash, got type %y instead (%y)", name, un, desc.unique_constraints{un}.type(), desc.unique_constraints{un});

                hash ch = desc.unique_constraints{un};

                if (!ch.columns || !inlist(ch.columns.typeCode(), (NT_LIST, NT_STRING)))
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to \"columns\" key for unique constraint %y is not a list or a string, got type %y instead (%y)", name, un, ch.columns.type(), ch.columns);

                if (constraints.hasKey(un))                    
                    continue;
                addUniqueConstraintUnlocked(un, ch.columns, opt.(getConstraintOptions().keys()));
            }

            # add foreign constraints to table
            foreach string cn in (desc.foreign_constraints.keyIterator()) {
                if (desc.foreign_constraints{cn}.typeCode() != NT_HASH)
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to foreign constraint key %y is not a hash, got type %y instead (%y)", name, cn, desc.foreign_constraints{cn}.type(), desc.foreign_constraints{cn});

                hash ch = desc.foreign_constraints{cn};

                if (!ch.columns || !inlist(ch.columns.typeCode(), (NT_LIST, NT_STRING)))
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to \"columns\" key for foreign constraint %y is not a list or a string, got type %y instead (%y)", name, cn, ch.columns.type(), ch.columns);

                if (!ch.table || ch.table.typeCode() != NT_STRING)
                    throw "DESCRIPTION-ERROR", sprintf("%s: missing string value for \"table\" key in foreign constraint %y description: %y", name, cn, ch);

                if (exists ch.target_columns && !inlist(ch.target_columns.typeCode(), (NT_LIST, NT_STRING)))
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to \"target_columns\" key for foreign constraint %y is not a list or a string, got type %y instead (%y)", name, cn, ch.target_columns.type(), ch.target_columns);
                
                if (!ch.target_columns)
                    ch.target_columns = ch.columns;

                addForeignConstraintUnlocked(cn, ch.columns, ch.table, ch.target_columns, opt.(getForeignConstraintOptions().keys()));
            }

            # add triggers to table
            foreach string tn in (desc.triggers.keyIterator()) {
                if (desc.triggers{tn}.typeCode() != NT_STRING)
                    throw "DESCRIPTION-ERROR", sprintf("%s: value assigned to trigger key %y is not a string giving the trigger source code, got type %y instead (%y)", name, tn, desc.triggers{tn}.type(), desc.triggers{tn});
                string src = desc.triggers{tn};
                
                addTriggerUnlocked(tn, src, opt.(getTriggerOptions().keys()));
            }
            
            setupTableImpl(desc, opt);
        }

        #! adds a column to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
$table.addColumn("name", ("qore_type": Type::String, "size": 50), False);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column
            @param opt a hash describing the column; the following keys are permitted (other column options may be supported depending on the underlying AbstractTable implementation):
            - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion;
            - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
            - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
            - \c scale: for numeric data types, this value gives the scale
            - \c default_value: the default value for the column
            @param nullable if @ref Qore::True "True" then the column can hold NULL values; note that primary key columns cannot be nullable
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @throw COLUMN-ERROR no \c native_type or \c qore_type keys in column option hash, column already exists, invalid column data

            @note make sure and add a \c default_value value when adding a column with a \c "not null" constraint with existing data

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractColumn addColumn(string cname, hash opt, bool nullable = True, *reference lsql) {
            l.lock();
            on_exit l.unlock();

            return addColumnUnlocked(cname, opt, nullable, \lsql);
        }

        #! returns a list of SQL strings that can be use to add a column to the table
        /** @par Example:
            @code
my list $l = $table.getAddColumnSql("name", ("qore_type": Type::String, "size": 50), False);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column
            @param copt a hash describing the column; the following keys are permitted (other column options may be supported depending on the underlying AbstractTable implementation):
            - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion;
            - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
            - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
            - \c scale: for numeric data types, this value gives the scale
            - \c default_value: the default value for the column
            @param nullable if @ref Qore::True "True" then the column can hold NULL values; note that primary key columns cannot be nullable
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be use to add a column to the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw COLUMN-ERROR no \c native_type or \c qore_type keys in column option hash, column already exists, invalid column data

            @note
            - make sure and add a \c default_value value when adding a column with a \c "not null" constraint with existing data
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
         */
        list getAddColumnSql(string cname, hash copt, bool nullable = True, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            list lsql;

            {
                l.lock();
                on_exit l.unlock();
                addColumnUnlocked(cname, copt, nullable, \lsql, False, opt.sql_callback_executed);
            }
            
            return AbstractDatabase::doCallback(opt, lsql, AbstractDatabase::AC_Add, "column", name, cname);
        }

        private AbstractColumn addColumnUnlocked(string cname, hash opt, bool nullable = True, *reference lsql, bool do_exec = True, bool modify_table = True) {
            if (!columns)
                columns = new Columns();
            else if (columns.hasKey(cname))
                throw "COLUMN-ERROR", sprintf("%s.%s: this column already exists", name, cname);    

            if (!opt.native_type && !opt.qore_type)
                throw "COLUMN-ERROR", sprintf("%s.%s: no native_type or qore_type keys in column option hash: %y", name, cname, opt);

            validateColumnOptions(cname, \opt, nullable);

            # get the new column object
            AbstractColumn c = addColumnImpl(cname, opt, nullable);

            # add column in table if the table is already known to be in the database
            lsql = c.getCreateSql(self);
            if (do_exec)
                execSql(lsql);

            # add the column to the internal column representation
            if (modify_table)
                addColumnToTableUnlocked(c);

            return c;
        }

        private addColumnToTableUnlocked(AbstractColumn c) {
            columns.add(c.name, c);
        }

        #! modifies an existing column in the table; if the table is already known to be in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally and the new column definition will be created when create() is called for example
        /** @par Example:
            @code
$table.modifyColumn("name", ("qore_type": Type::String, "size": 240), False);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column
            @param opt a hash describing the column; the following keys are permitted (other column options may be supported depending on the underlying AbstractTable implementation):
            - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion;
            - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
            - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
            - \c scale: for numeric data types, this value gives the scale
            - \c default_value: the default value for the column
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @param nullable if @ref Qore::True "True" then the column can hold NULL values; note that primary key columns cannot be nullable

            @throw COLUMN-ERROR no \c native_type or \c qore_type keys in column option hash, column does not exist, invalid column data

            @note make sure and add a \c default_value value when modifying a column to have a \c "not null" constraint with existing data

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractColumn modifyColumn(string cname, hash opt, bool nullable = True, *reference lsql) {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            if (!columns.hasKey(cname))
                throw "COLUMN-ERROR", sprintf("%s.%s: the given column does not exist", name, cname);    

            if (!opt.native_type && !opt.qore_type)
                throw "COLUMN-ERROR", sprintf("%s.%s: no native_type or qore_type keys in column option hash: %y", name, cname, opt);

            validateColumnOptions(cname, \opt, nullable);

            # get the new column object
            AbstractColumn c = addColumnImpl(cname, opt, nullable);
            
            # add column in table if the table already exists in the DB
            execSql(lsql = columns{cname}.getModifySql(self, c));

            # replaces the column in the internal column representation with the new definition
            addColumnToTableUnlocked(c);
            return c;
        }

        #! gets a list of SQL strings that can be used to modify an existing column in the table
        /** @par Example:
            @code
my list $l = $table.getModifyColumnSql("name", ("qore_type": Type::String, "size": 240), False);
            @endcode

            @param cname the name of the column
            @param copt a hash describing the column; the following keys are permitted (other column options may be supported depending on the underlying AbstractTable implementation):
            - \c qore_type: a qore type string that will be converted to a native DB type with some default conversion;
            - \c native_type: the native database column type; if both \c native_type and \c qore_type are given then \c native_type is used
            - \c size: for data types requiring a size component, the size; for numeric columns this represents the precision for example
            - \c scale: for numeric data types, this value gives the scale
            - \c default_value: the default value for the column
            @param nullable if @ref Qore::True "True" then the column can hold NULL values; note that primary key columns cannot be nullable
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options
                
            @return a list of SQL strings that can be used to modify an existing column in the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw COLUMN-ERROR no \c native_type or \c qore_type keys in column option hash, column does not exist, invalid column data

            @note
            - make sure and add a \c default_value value when modifying a column to have a \c "not null" constraint with existing data
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
         */
        list getModifyColumnSql(string cname, hash copt, bool nullable = True, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            if (!columns.hasKey(cname))
                throw "COLUMN-ERROR", sprintf("%s.%s: the given column does not exist", name, cname);    

            if (!copt.native_type && !copt.qore_type)
                throw "COLUMN-ERROR", sprintf("%s.%s: no native_type or qore_type keys in column option hash: %y", name, cname, copt);

            validateColumnOptions(cname, \copt, nullable);

            # get the new column object
            AbstractColumn c = addColumnImpl(cname, copt, nullable);
            # replaces the column in the internal column representation with the new definition
            on_success if (opt.sql_callback_executed)
                addColumnToTableUnlocked(c);
            
            return AbstractDatabase::doCallback(opt, columns{cname}.getModifySql(self, c), AbstractDatabase::AC_Modify, "column", cname, name, NOTHING, c.getNativeTypeString());
        }

        #! renames an existing column; if the table is already known to be in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
my AbstractColumn $col = $table.renameColumn("name", "family_name");
            @endcode

            @param old_name the current name of the column
            @param new_name the new name of the column
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)
                
            @return the column object that was updated

            @throw COLUMN-ERROR if the given column does not exist in the table

            @see modifyColumn() for a method that allows the column definition to be updated

            @note if any primary key or foreign table constraints refer to the column, the internal representations are also renamed, however check constraints are not updated and will be invalid if they refer to the renamed column
        */
        AbstractColumn renameColumn(string old_name, string new_name, reference sql) {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            if (!columns.hasKey(old_name))
                throw "COLUMN-ERROR", sprintf("%s.%s: the given column does not exist", name, old_name);

            AbstractColumn c = columns{old_name};
            
            # add column in table if the table already exists in the DB
            execSql(sql = c.getRenameSql(self, new_name));

            renameColumnIntern(c, new_name);

            return c;
        }

        #! gets an SQL string that can be used to rename an existing column in the table
        /** @par Example:
            @code
my string $sql = $table.getRenameColumnSql("name", "family_name");
            @endcode

            @param old_name the current name of the column
            @param new_name the new name of the column
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options
                
            @return an SQL string that can be used to rename an existing column in the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw COLUMN-ERROR if the old column does not exist in the table or the new column already does

            @see getModifyColumnSql() for a method that allows the column definition to be updated

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
        */
        string getRenameColumnSql(string old_name, string new_name, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();

            if (!columns.hasKey(old_name))
                throw "COLUMN-ERROR", sprintf("rename %s.%s to %s: old column %y column does not exist", name, old_name, new_name, old_name);

            if (columns.hasKey(new_name))
                throw "COLUMN-ERROR", sprintf("rename %s.%s to %s: new column %y already exists in the table", name, old_name, new_name, new_name);

            on_success if (opt.sql_callback_executed)
                renameColumnIntern(columns{old_name}, new_name);

            return AbstractDatabase::doCallback(opt, columns{old_name}.getRenameSql(self, new_name), AbstractDatabase::AC_Rename, "column", old_name, name, new_name);
        }

        private AbstractColumn renameColumnIntern(AbstractColumn c, string new_name) {            
            string old_name = c.name;

            # rename column after database is updated
            c.name = new_name;

            # replaces the column in the internal column representation with the new definition
	    columns.renameKey(old_name, new_name);

            # now rename column in any constraints
            # check primary key
            if (primaryKey && primaryKey.hasKey(old_name))
                primaryKey.renameKey(old_name, new_name);

            # check foreign constraints
            foreach AbstractForeignConstraint fk in (foreignConstraints.iterator()) {
                if (fk.columns.hasKey(old_name))
                    fk.columns.renameKey(old_name, new_name);
            }

            # check unique constraints
            foreach AbstractConstraint ac in (constraints.iterator()) {
                if (!(ac instanceof AbstractUniqueConstraint))
                    continue;
                AbstractUniqueConstraint uc = cast<AbstractUniqueConstraint>(ac);
                if (uc.hasKey(old_name))
                    uc.renameKey(old_name, new_name);
            }

            # FIXME: check constraints are not updated

            return c;
        }

        private validateOptionsIntern(string err, hash ropt, reference opt) {
            AbstractSqlUtilBase::validateOptionsIntern(err, ropt, \opt, name);
        }

        private validateOptionsIntern(string err, hash ropt, reference opt, string tag) {
            AbstractSqlUtilBase::validateOptionsIntern(err, ropt, \opt, tag);
        }

        private execSql(softlist lsql) {
            #map printf("%s;\n", $1), lsql;
            if (inDb) {
                on_success ds.commit();
                on_error ds.rollback();
                map ds.execRaw($1), lsql;
            }
            else 
                manual = True;
        }

        #! adds a primary key to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractPrimaryKey $pk = $table.addPrimaryKey("pk_mytable", "id", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param pkname the name of the new primary key constraint
            @param cols a single column name or a list of columns that make up the primary key
            @param opt a hash of options for the new primary key; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractPrimaryKey object corresponding to the primary key created

            @throw PRIMARY-KEY-ERROR the table already has a primary key or invalid columns or options passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractPrimaryKey addPrimaryKey(string pkname, softlist cols, *hash opt, *reference sql) {
            l.lock();
            on_exit l.unlock();

            return addPrimaryKeyUnlocked(pkname, cols, opt, \sql);
        }

        #! returns the SQL that can be used to add a primary key to the table
        /** @par Example:
            @code
my string $sql = $table.getAddPrimaryKeySql("pk_mytable", "id", ("index_tablespace": "index1"), opt);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param pkname the name of the new primary key constraint
            @param cols a single column name or a list of columns that make up the primary key
            @param pkopt a hash of options for the new primary key; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ConstraintOptions
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return the SQL that can be used to add a primary key to the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw PRIMARY-KEY-ERROR the table already has a primary key or invalid columns or options passed

            @see inDb() for a method that tells if the table is already in the database or not

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
         */
        string getAddPrimaryKeySql(string pkname, softlist cols, *hash pkopt, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);
            l.lock();
            on_exit l.unlock();

            string sql;
            AbstractPrimaryKey pk = addPrimaryKeyUnlockedIntern(pkname, cols, pkopt, \sql);
            on_success if (opt.sql_callback_executed) {
                setPrimaryKeyUnlocked(pk);
                manual = True;
            }
            return AbstractDatabase::doCallback(opt, sql, AbstractDatabase::AC_Add, "primary key", pkname, getSqlName());
        }

        private setPrimaryKeyUnlocked(AbstractPrimaryKey pk) {
            primaryKey = pk;
        }

        private AbstractPrimaryKey addPrimaryKeyUnlocked(string pkname, softlist cols, *hash opt, *reference sql) {
            AbstractPrimaryKey pk = addPrimaryKeyUnlockedIntern(pkname, cols, opt, \sql);
            execSql(sql);
            setPrimaryKeyUnlocked(pk);
            return pk;
        }

        private AbstractPrimaryKey addPrimaryKeyUnlockedIntern(string pkname, softlist cols, *hash opt, *reference sql) {
            getColumnsUnlocked();
            if (!manual)
                getIndexesUnlocked();

            # load constraints if needed, verify unique constraint name, validate/process options
            checkUniqueConstraintNameValidateOptions("PRIMARY-KEY-ERROR", pkname, getConstraintOptions(), \opt);

            if (!primaryKey.empty())
                throw "PRIMARY-KEY-ERROR", sprintf("%s add primary key %y: already has primary key %y with columns: %y", name, pkname, primaryKey.getName(), primaryKey.keys());

            if (!cols)
                throw "PRIMARY-KEY-ERROR", sprintf("%s add primary key %y: no column names passed to %s::addPrimaryKey()", name, pkname, self.className());

            hash ch;
            while (cols) {
                any v = shift cols;
                if (v.typeCode() != NT_STRING)
                    throw "PRIMARY-KEY-ERROR", sprintf("%s add primary key %y: %y argument passed as column name to %s::addPrimaryKey(); expecting \"string\" (value: %y)", name, pkname, v.type(), self.className(), v);
                if (!columns.hasKey(v))
                    throw "PRIMARY-KEY-ERROR", sprintf("%s add primary key %y: table has no column named %y", name, pkname, v);
                ch{v} = columns{v};
            }

            # get the new primary key object
            AbstractPrimaryKey pk = addPrimaryKeyImpl(pkname, ch, opt);
            
            # find matching index for unique constraint
            pk.findMatchingIndex(indexes);

            # add pk to table if the table already exists in the DB
            sql = pk.getCreateSql(getSqlName());

            return pk;
        }

        #! gets a list of SQL strings to drop all constraints and indexes with the given column name; if the column does not exist then an empty list is returned
        /** @par Example:
            @code
my list $l = $table.getDropAllConstraintsAndIndexesOnColumnSql("status");
            @endcode

            @param cname the name of the column
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @throw OPTION-ERROR invalid or unsupported option passed

            @note
            - this method retrieves current primary key definition from the database if not already loaded or defined
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
        */
        list getDropAllConstraintsAndIndexesOnColumnSql(string cname, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            l.lock();
            on_exit l.unlock();

            return getDropAllConstraintsAndIndexesOnColumnSqlUnlocked(cname, opt);
        }

        private list getDropAllConstraintsAndIndexesOnColumnSqlUnlocked(string cname, *hash opt) {
            getAllConstraintsUnlocked();
            getIndexesUnlocked();

            list lst = ();

            if (primaryKey && primaryKey.hasColumn(cname)) {
                on_success if (opt.sql_callback_executed)
                    remove primaryKey;

                lst += AbstractDatabase::doCallback(opt, primaryKey.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "primary key", primaryKey.getName(), getSqlName());
            }

            foreach AbstractConstraint c in (constraints.iterator()) {
                if (c.hasColumn(cname)) {
                    on_success if (opt.sql_callback_executed) {
                        constraints.take(c.getName()); 
                        # if it's a unique constraint, remove any index with the same name
                        if (c instanceof AbstractUniqueConstraint && constraintsLinkedToIndexesImpl())
                            indexes.take(c.getName());
                    }

                    lst += AbstractDatabase::doCallback(opt, c.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "constraint", c.getName(), getSqlName());
                }
            }
            
            foreach AbstractForeignConstraint fk in (foreignConstraints.iterator()) {
                if (fk.hasColumn(cname)) {
                    on_success if (opt.sql_callback_executed)
                        foreignConstraints.take(fk.getName()); 

                    lst += AbstractDatabase::doCallback(opt, fk.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "foreign constraint", fk.getName(), getSqlName());
                }
            }
            
            foreach AbstractIndex ix in (indexes.iterator()) {
                if (ix.hasColumn(cname)) {
                    on_success if (opt.sql_callback_executed)
                        indexes.take(ix.name); 

                    lst += AbstractDatabase::doCallback(opt, ix.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "index", ix.name, getSqlName());
                }
            }
            
            return lst;
        }

        #! gets a list of SQL strings that can be used to drop the primary key from the table
        /** @par Example:
            @code
my list $l = $table.getDropPrimaryKeySql();
            @endcode

            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to drop the primary key from the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw PRIMARY-KEY-ERROR the table has no primary key

            @note
            - this method retrieves current primary key definition from the database if not already loaded or defined
            - if there are known foreign contraints on the primary key, SQL for dropping those constraints is also returned
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
         */
        list getDropPrimaryKeySql(*hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            l.lock();
            on_exit l.unlock();

            getPrimaryKeyUnlocked();
            if (primaryKey.empty())
                throw "PRIMARY-KEY-ERROR", sprintf("%s: has no primary key", name);

            on_success if (opt.sql_callback_executed)
                remove primaryKey;

            list l = ();
            map l += AbstractDatabase::doCallback(opt, $1.fk.getDropSql($1.table), AbstractDatabase::AC_Drop, "foreign constraint", $1.fk.getName(), $1.table), primaryKey.getSourceConstraintIterator();

            l += AbstractDatabase::doCallback(opt, primaryKey.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "primary key", primaryKey.getName(), name);
            return l;
        }

        #! drops the primary key from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropPrimaryKey();
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.
            @param lsql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the primary key dropped from the table

            @throw PRIMARY-KEY-ERROR no primary key exists

            @note
            - this method retrieves the primary key definition from the database if none has already been defined
            - if there are known foreign contraints on the primary key, SQL for dropping those constraints is also included

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractPrimaryKey dropPrimaryKey(*reference lsql) {
            l.lock();
            on_exit l.unlock();
            getPrimaryKeyUnlocked();
            if (primaryKey.empty())
                throw "PRIMARY-KEY-ERROR", sprintf("%s: has no primary key", name);

            lsql = ();
            map execSql(lsql += $1.fk.getDropSql($1.table)), primaryKey.getSourceConstraintIterator();

            # drop pk from table if the table already exists in the DB
            execSql(lsql += primaryKey.getDropSql(getSqlName()));

            return remove primaryKey;
        }
        
        #! adds a unique constraint to the table; if the table is known to be in the database already, then the constraint is added to the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractUniqueConstraint $c = $table.addUniqueConstraint("uk_mytable", "name", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new unique constraint
            @param cols a single column name or a list of columns that make up the unique constraint
            @param opt a hash of options for the new unique constraint; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractUniqueConstraint object corresponding to the unique constraint created

            @throw UNIQUE-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns passed
            @throw OPTION-ERROR invalid or unsupported option passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractUniqueConstraint addUniqueConstraint(string cname, softlist cols, *hash opt, *reference sql) {
            l.lock();
            on_exit l.unlock();
            return addUniqueConstraintUnlocked(cname, cols, opt, \sql);
        }

        #! returns an SQL string that can be used to add a unique constraint to the table
        /** @par Example:
            @code
my string $sql = $table.getAddUniqueConstraintSql("uk_mytable", "name", ("index_tablespace": "index1"));
printf("%s;\n", $sql);
            @endcode

            @param cname the name of the new unique constraint
            @param cols a single column name or a list of columns that make up the unique constraint
            @param ukopt a hash of options for the new unique constraint; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ConstraintOptions
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that can be used to add a unique constraint to the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw UNIQUE-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns passed

            @see inDb() for a method that tells if the table is already in the database or not

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
         */
        string getAddUniqueConstraintSql(string cname, softlist cols, *hash ukopt, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            l.lock();
            on_exit l.unlock();

            string sql;
            AbstractUniqueConstraint uk = addUniqueConstraintUnlockedIntern(cname, cols, ukopt, \sql);
            on_success if (opt.sql_callback_executed) {
                # set as constraint for the table
                if (!constraints)
                    constraints = new Constraints();
                constraints.add(cname, uk);
                manual = True;
            }
            return AbstractDatabase::doCallback(opt, sql, AbstractDatabase::AC_Add, "unique constraint", cname, getSqlName());
        }

        private AbstractUniqueConstraint addUniqueConstraintUnlocked(string cname, softlist cols, *hash opt, *reference sql) {
            AbstractUniqueConstraint uk = addUniqueConstraintUnlockedIntern(cname, cols, opt, \sql);
            # add foreign constraint to table in the DB if the table already exists in the DB
            execSql(sql);
            # set as constraint for the table
            if (!constraints)
                constraints = new Constraints();
            constraints.add(cname, uk);
            return uk;
        }

        private AbstractUniqueConstraint addUniqueConstraintUnlockedIntern(string cname, softlist cols, *hash opt, *reference sql) {
            getColumnsUnlocked();
            if (!manual)
                getIndexesUnlocked();

            # load constraints if needed, verify unique constraint name, validate/process options
            checkUniqueConstraintNameValidateOptions("UNIQUE-CONSTRAINT-ERROR", cname, getConstraintOptions(), \opt);

            if (!cols)
                throw "UNIQUE-CONSTRAINT-ERROR", sprintf("%s add unique constraint %y: no column names passed to %s::addUniqueConstraint()", name, cname, self.className());

            hash ch;
            while (cols) {
                any v = shift cols;
                if (v.typeCode() != NT_STRING)
                    throw "PRIMARY-KEY-ERROR", sprintf("%s add unique constraint %y: %y argument passed as column name to %s::addUniqueConstraint(); expecting \"string\" (value: %y)", name, cname, v.type(), self.className(), v);
                if (!columns.hasKey(v))
                    throw "PRIMARY-KEY-ERROR", sprintf("%s add unique constraint %y: table has no column named %y", name, cname, v);
                ch{v} = columns{v};
            }

            # get the new constraint object
            AbstractUniqueConstraint c = addUniqueConstraintImpl(cname, ch, opt);
            
            # find matching index for unique constraint
            c.findMatchingIndex(indexes);

            # add foreign constraint to table in the DB if the table already exists in the DB
            sql = c.getCreateSql(getSqlName());

            # return the new constraint
            return c;
        }

        #! adds an index to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractIndex $ix = $table.addIndex("uk_mytable_name", True, "name", ("index_tablespace": "index1"), \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param iname the name of the new index
            @param unique a flag to tell if the new index should be unique or not
            @param cols a single column name or a list of columns that make up the index
            @param opt a hash of options for the new index; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::IndexOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractIndex object corresponding to the index created

            @throw INDEX-ERROR the table already has an index with the given name or invalid columns or options were passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractIndex addIndex(string iname, bool unique, softlist cols, *hash opt, *reference sql) {
            l.lock();
            on_exit l.unlock();

            return addIndexUnlocked(iname, unique, cols, opt, \sql);
        }

        #! returns an SQL string that can be used to add an index to the table
        /** @par Example:
            @code
my string $sql = $table.getAddIndexSql("uk_mytable_name", True, "name", ("index_tablespace": "index1"));
printf("%s;\n", $sql);
            @endcode

            @param iname the name of the new index
            @param unique a flag to tell if the new index should be unique or not
            @param cols a single column name or a list of columns that make up the index
            @param ixopt a hash of options for the new index; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::IndexOptions
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that can be used to add an index to the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw INDEX-ERROR the table already has an index with the given name or invalid columns or options were passed

            @see inDb() for a method that tells if the table is already in the database or not

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
         */
        string getAddIndexSql(string iname, bool unique, softlist cols, *hash ixopt, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            l.lock();
            on_exit l.unlock();

            string sql;
            AbstractIndex ix = addIndexUnlockedIntern(iname, unique, cols, ixopt, \sql);
            on_success if (opt.sql_callback_executed) {
                # set as index for the table
                indexes.add(iname, ix);
                manual = True;
            }
            return AbstractDatabase::doCallback(opt, sql, AbstractDatabase::AC_Add, "index", iname, getSqlName());
        }

        private AbstractIndex addIndexUnlocked(string iname, bool unique, softlist cols, *hash opt, *reference sql) {
            AbstractIndex ix = addIndexUnlockedIntern(iname, unique, cols, opt, \sql);
            execSql(sql);
            # set as index for the table
            indexes.add(iname, ix);
            if (ix.unique && uniqueIndexCreatesConstraintImpl()) {
                getConstraintsUnlocked();
                if (!constraints.hasKey(ix.name)) {
                    string csql;
                    AbstractUniqueConstraint uk = addUniqueConstraintUnlockedIntern(iname, cols, opt, \csql);
                    uk.setIndexBase(ix.name);
                    if (!constraints)
                        constraints = new Constraints();
                    constraints.add(iname, uk);
                    ix.setSupportingConstraint(uk);
                }
            }
            return ix;
        }

        private AbstractIndex addIndexUnlockedIntern(string iname, bool unique, softlist cols, *hash opt, *reference sql) {
            getColumnsUnlocked();
            if (inDb)
                getIndexesUnlocked();

            if (!indexes)
                indexes = new Indexes();
            else if (indexes.hasKey(iname))
                throw "INDEX-ERROR", sprintf("%s: already has an index named %y with columns: %y", name, iname, indexes{iname}.columns.keys());

            if (!cols)
                throw "INDEX-ERROR", sprintf("%s: no column names passed to %s::addIndex()", name, self.className());

            hash ch;
            while (cols) {
                any v = shift cols;
                if (v.typeCode() != NT_STRING)
                    throw "INDEX-ERROR", sprintf("%s: %y argument passed as column name to %s::addIndex(); expecting \"string\" (value: %y)", name, v.type(), self.className(), v);
                # only check for column if the index is not a function index
                if (!columns.hasKey(v)) {
                    if (v !~ /\(.*\)/)
                        throw "INDEX-ERROR", sprintf("%s: has no column named %y", name, v);
                    ch{v} = hash();
                }
                else
                    ch{v} = columns{v};
            }

            # validate options
            hash ixopt = getIndexOptions();
            validateOptionsIntern("INDEX-ERROR", ixopt, \opt);

            # get the new index object
            AbstractIndex ix = addIndexImpl(iname, unique, ch, opt);
            
            # add index to table in the DB if the table already exists in the DB
            sql = ix.getCreateSql(getSqlName(), opt);

            # return the new index
            return ix;
        }

        #! renames an existing index; if the table is already known to be in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
my AbstractIndex $ix = $table.renameIndex("uk_table_name", "unique_table_name");
            @endcode

            @param old_name the current name of the index
            @param new_name the new name for the index
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)
            @return the index object that was updated

            @throw INDEX-ERROR if the old index does not exist in the table or if the new index name already exists
        */
        AbstractIndex renameIndex(string old_name, string new_name, reference sql) {
            l.lock();
            on_exit l.unlock();
            getIndexesUnlocked();
            
            AbstractIndex ix;

            code rename;

            if (!indexes || !indexes.hasKey(old_name))
                throw "INDEX-ERROR", sprintf("%s: has no index %y; valid index: %y", name, old_name, indexes.keys());

            ix = indexes{old_name};
            rename = sub () { indexes.renameKey(old_name, new_name); };

            # rename index in table if the table already exists in the DB
            execSql(sql = ix.getRenameSql(getSqlName(), new_name));

            ix.name = new_name;

            # rename index in container structure
            rename();
            
            # return the updated index
            return ix;
        }

        #! drops the given index from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropIndex("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param iname the name of the index to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the index dropped from the table

            @throw INDEX-ERROR the given index does not exist

            @note this method retrieves all current index definitions from the database if none have already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractIndex dropIndex(string iname, *reference sql) {
            l.lock();
            on_exit l.unlock();
            getIndexesUnlocked();
            if (!indexes.hasKey(iname))
                throw "INDEX-ERROR", sprintf("%s: has no index %y; valid indexes: %y", name, iname, indexes.keys());

            # drop index from table if the table already exists in the DB
            execSql(sql = indexes{iname}.getDropSql(getSqlName()));

            # remove from index structure and return removed index
            return indexes.take(iname);
        }

        #! gets the SQL that can be used to drop an index from the table
        /** @par Example:
            @code
my string $sql = $table.getDropIndexSql("uk_mytable_name");
            @endcode

            @param iname the name of the index to drop
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return the SQL that can be used to drop an index from the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw INDEX-ERROR the given index does not exist in the table

            @note
            - this method retrieves current index definitions from the database if not already loaded or defined
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
         */
        string getDropIndexSql(string iname, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            l.lock();
            on_exit l.unlock();

            getIndexesUnlocked();
            if (!indexes.hasKey(iname))
                throw "INDEX-ERROR", sprintf("%s: has no index %y; valid indexes: %y", name, iname, indexes.keys());

            on_success if (opt.sql_callback_executed)
                indexes.take(iname);

            return AbstractDatabase::doCallback(opt, indexes{iname}.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "index", iname, name);
        }

        #! adds a foreign constraint to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractForeignConstraint $fc = $table.addForeignConstraint("fk_mytable_other_table", ("name", "version"), "other_table", NOTHING, \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new foreign constraint
            @param cols a single column name or a list of columns in the local table that make up the foreign constraint
            @param table the name of the other table that the constraint targets
            @param tcols a single column name or a list of columns in the foreign table or @ref nothing meaning that the column names are the same as in the local table; if column names are given the same number of columns must be given in the local and foreign tables
            @param opt a hash of options for the new foreign constraint; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ForeignConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractForeignConstraint object corresponding to the foreign constraint created

            @throw FOREIGN-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns or options were passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractForeignConstraint addForeignConstraint(string cname, softlist cols, string table, *softlist tcols, *hash opt, *reference sql) {
            l.lock();
            on_exit l.unlock();

            return addForeignConstraintUnlocked(cname, cols, table, tcols, opt, \sql);
        }

        #! returns an SQL string that can be used to add a foreign constraint to the table
        /** @par Example:
            @code
my string $sql = $table.getAddForeignConstraintSql("fk_mytable_other_table", ("name", "version"), "other_table");
printf("%s;\n", $sql);
            @endcode

            @param cname the name of the new foreign constraint
            @param cols a single column name or a list of columns in the local table that make up the foreign constraint
            @param table the name of the other table that the constraint targets
            @param tcols a single column name or a list of columns in the foreign table or @ref nothing meaning that the column names are the same as in the local table; if column names are given the same number of columns must be given in the local and foreign tables
            @param fkopt a hash of options for the new foreign constraint; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ForeignConstraintOptions
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that can be used to add a foreign constraint to the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw FOREIGN-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns or options were passed

            @see inDb() for a method that tells if the table is already in the database or not

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
         */
        string getAddForeignConstraintSql(string cname, softlist cols, string table, *softlist tcols, *hash fkopt, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            l.lock();
            on_exit l.unlock();

            string sql;
            AbstractForeignConstraint fk = addForeignConstraintUnlockedIntern(cname, cols, table, tcols, fkopt, \sql);
            on_success if (opt.sql_callback_executed) {
                # update cached tables with foreign constraint source info
                if (opt.table_cache.hasKey(fk.target.table))
                    opt.table_cache{fk.target.table}.addSourceConstraint(getSqlName(), fk);
                
                # set as foreign constraint for the table
                if (!foreignConstraints)
                    foreignConstraints = new ForeignConstraints();
                foreignConstraints.add(cname, fk);
                manual = True;
            }
            return AbstractDatabase::doCallback(opt, sql, AbstractDatabase::AC_Add, "foreign constraint", cname, getSqlName());
        }

        private Columns getReferencedTableColumnsUnlocked(string table, *Tables cache, string err = "FOREIGN-CONSTRAINT-ERROR") {
            if (table == name) {
                getColumnsUnlocked();
                return columns;
            }
            if (cache.hasKey(table))
                return cache{table}.describe();
            Table t(ds, table);
            if (cache) {
                #printf("*** adding %s to cache\n", name);
                cache.add(table, t.getTable());
            }
            return t.describe();
        }

        private AbstractForeignConstraint addForeignConstraintUnlocked(string cname, softlist cols, string table, *softlist tcols, *hash opt, *reference sql) {
            AbstractForeignConstraint fk = addForeignConstraintUnlockedIntern(cname, cols, table, tcols, opt, \sql);
            execSql(sql);

            # update cached tables with foreign constraint source info
            if (opt.table_cache.hasKey(fk.target.table))
                opt.table_cache{fk.target.table}.addSourceConstraint(getSqlName(), fk);

            # set as foreign constraint for the table
            if (!foreignConstraints)
                foreignConstraints = new ForeignConstraints();
            foreignConstraints.add(cname, fk);
            return fk;
        }

        private AbstractForeignConstraint addForeignConstraintUnlockedIntern(string cname, softlist cols, string table, *softlist tcols, *hash opt, *reference sql) {
            getColumnsUnlocked();
            # load constraints if needed, verify unique constraint name, validate/process options
            checkUniqueConstraintNameValidateOptions("FOREIGN-CONSTRAINT-ERROR", cname, getForeignConstraintOptions(), \opt);

            if (!cols)
                throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y: no column names passed to %s::addForeignConstraint()", name, self.className());

            hash ch;
            while (cols) {
                any v = shift cols;
                if (v.typeCode() != NT_STRING)
                    throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y: %y argument passed as column name to %s::addForeignConstraint(); expecting \"string\" (value: %y)", name, v.type(), self.className(), v);
                if (!columns.hasKey(v))
                    throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y: has no column named %y", name, v);
                ch{v} = columns{v};
            }

            if (!tcols)
                tcols = ch.keys();

            # get target table description
            Columns targ_cols = getReferencedTableColumnsUnlocked(table, opt.table_cache);
            hash tch;
            while (tcols) {
                any v = shift tcols;
                if (v.typeCode() != NT_STRING)
                    throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y target %y: %y argument passed as target column name to %s::addForeignConstraint(); expecting \"string\" (value: %y)", name, table, v.type(), self.className(), v);
                if (!targ_cols.hasKey(v))
                    throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%y target %y: target table has no column named %y", name, table, v);
                tch{v} = targ_cols{v};
            }

            # get the new foreign constraint object
            AbstractForeignConstraint fk = addForeignConstraintImpl(cname, ch, table, tch, opt);
            
            sql = fk.getCreateSql(getSqlName());

            # return the new foreign constraint
            return fk;
        }

        #! drops a foreign constraint from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropForeignConstraint("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the foreign constraint to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the foreign constraint dropped from the table

            @throw FOREIGN-CONSTRAINT-ERROR the given constraint does not exist

            @note this method retrieves all current foreign constraint definitions from the database if none have already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractForeignConstraint dropForeignConstraint(string cname, *reference sql) {
            l.lock();
            on_exit l.unlock();
            getForeignConstraintsUnlocked();
            if (!foreignConstraints.hasKey(cname))
                throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%s: has no foreign constraint %y; valid foreign constraints: %y", name, cname, foreignConstraints.keys());

            # drop foreign constraint from table if the table already exists in the DB
            execSql(sql = foreignConstraints{cname}.getDropSql(getSqlName()));

            # remove from foreign constraint structure and return removed foreign constraint
            return foreignConstraints.take(cname);
        }

        #! removes the named foreign constraint from the table; no SQL is executed in any case, only the named foreign constraint is removed from the table definition
        /** @par Example:
            @code
$table.removeForeignConstraint("uk_mytable_name");
            @endcode

            @param cname the name of the foreign constraint to remove

            @return the foreign constraint removed from the table

            @throw FOREIGN-CONSTRAINT-ERROR the given constraint does not exist

            @note this method retrieves all current foreign constraint definitions from the database if none have already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractForeignConstraint removeForeignConstraint(string cname) {
            l.lock();
            on_exit l.unlock();
            getForeignConstraintsUnlocked();
            if (!foreignConstraints.hasKey(cname))
                throw "FOREIGN-CONSTRAINT-ERROR", sprintf("%s: has no foreign constraint %y; valid foreign constraints: %y", name, cname, foreignConstraints.keys());

            # remove from foreign constraint structure and return removed foreign constraint
            return foreignConstraints.take(cname);
        }

        #! adds a check constraint to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractCheckConstraint $cc = $table.addCheckConstraint("check_mytable_id", "id > 10", NOTHING, \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new constraint
            @param src the source of the constraint clause
            @param opt a hash of options for the new constraint; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ConstraintOptions
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractCheckConstraint object corresponding to the check constraint created

            @throw CHECK-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns or options were passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractCheckConstraint addCheckConstraint(string cname, string src, *hash opt, *reference sql) {
            l.lock();
            on_exit l.unlock();
            return addCheckConstraintUnlocked(cname, src, opt, \sql);
        }

        #! returns an SQL string that can be used to add a check constraint to the table
        /** @par Example:
            @code
my string $sql = $table.getAddCheckConstraintSql("check_mytable_id", "id > 10");
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the new constraint
            @param src the source of the constraint clause
            @param copt a hash of options for the new constraint; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::ConstraintOptions
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that can be used to add a check constraint to the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw CHECK-CONSTRAINT-ERROR the table already has a constraint with the given name or invalid columns or options were passed

            @see inDb() for a method that tells if the table is already in the database or not
 
            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
         */
        string getAddCheckConstraintSql(string cname, string src, *hash copt, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            l.lock();
            on_exit l.unlock();

            string sql;
            AbstractCheckConstraint cc = addCheckConstraintUnlocked(cname, src, copt, \sql);
            on_success if (opt.sql_callback_executed) {
                # set as constraint for the table
                if (!constraints)
                    constraints = new Constraints();
                constraints.add(cname, cc);
                manual = True;
            }
            return AbstractDatabase::doCallback(opt, sql, AbstractDatabase::AC_Add, "check constraint", cname, getSqlName());
        }

        private AbstractCheckConstraint addCheckConstraintUnlocked(string cname, string src, *hash opt, *reference sql) {
            AbstractCheckConstraint cc = addCheckConstraintUnlockedIntern(cname, src, opt, \sql);
            execSql(sql);
            
            # set as constraint for the table
            if (!constraints)
                constraints = new Constraints();
            constraints.add(cname, cc);

            # return the new constraint
            return cc;
        }

        private AbstractCheckConstraint addCheckConstraintUnlockedIntern(string cname, string src, *hash opt, *reference sql) {
            # load constraints if needed, verify unique constraint name, validate/process options
            checkUniqueConstraintNameValidateOptions("CHECK-CONSTRAINT-ERROR", cname, getConstraintOptions(), \opt);

            # get the new constraint object
            AbstractCheckConstraint cc = addCheckConstraintImpl(cname, src, opt);
            
            # get the sql creation string
            sql = cc.getCreateSql(getSqlName());

            # return the new constraint
            return cc;
        }

        #! renames an existing constraint; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint; if the table is already known to be in the database, then the changes are effected in the database also immediately; otherwise it is only updated internally
        /** @par Example:
            @code
my AbstractConstraint $con = $table.renameConstraint("pk_table_name", "pkey_table_name");
            @endcode

            @param old_name the current name of the constraint
            @param new_name the new name for the constraint
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the constraint (only executed if the table is already in the database)
            @return the constraint object that was updated

            @throw CONSTRAINT-ERROR if the old constraint does not exist in the table or if the new constraint name already exists
        */
        AbstractConstraint renameConstraint(string old_name, string new_name, reference lsql) {
            l.lock();
            on_exit l.unlock();
            getAllConstraintsUnlocked();
            
            AbstractConstraint c;

            code rename;

            if (constraints && constraints.hasKey(old_name)) {
                c = constraints{old_name};
                rename = sub () { constraints.renameKey(old_name, new_name); };
            }
            else {
                if (inDb) {
                    getPrimaryKeyUnlocked();
                    if (primaryKey && primaryKey.getName() == old_name) {
                        c = primaryKey;
                        # no need to update any container if the primary key is being updated
                        rename = sub () { };
                    }
                    else {
                        getForeignConstraintsUnlocked();
                        if (foreignConstraints && foreignConstraints.hasKey(old_name)) {
                            c = foreignConstraints{old_name};
                            rename = sub () { foreignConstraints.take(old_name); };
                        }
                    }
                }
            }
            
            if (!c) {
                list cl = ();
                # get a list of all constraint names
                cl += constraints.keys();
                if (primaryKey)
                    cl += primaryKey.getName();
                if (foreignConstraints)
                    cl += foreignConstraints.keys();
                throw "CONSTRAINT-ERROR", sprintf("%s: has no constraint %y; valid constraints: %y", name, old_name, cl);
            }

            # rename foreign constraint in table if the table already exists in the DB
            execSql(lsql = c.getRenameSql(getSqlName(), new_name));

            c.rename(new_name);

            # rename constraint in container structure
            rename();
            
            # return the updated constraint
            return c;
        }

        #! gets the SQL that can be used to drop a constraint from the table; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint
        /** @par Example:
            @code
my string $sql = $table.getDropConstraintSql("uk_mytable_name");
            @endcode

            @param cname the name of the constraint to drop
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return the SQL that can be used to drop a constraint from the table; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw CONSTRAINT-ERROR the given constraint does not exist in the table

            @note
            - this method retrieves current constraint definitions from the database if not already loaded or defined
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
         */
        string getDropConstraintSql(string cname, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            l.lock();
            on_exit l.unlock();

            code rmv;
            AbstractConstraint c = findDropConstraintUnlocked(cname, \rmv);

            on_success if (opt.sql_callback_executed)
                rmv();
 
            return AbstractDatabase::doCallback(opt, c.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "constraint", c.getName(), name);
        }

        #! gets the SQL that can be used to drop a constraint from the table if it exists, otherwise returns @ref nothing; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint
        /** @par Example:
            @code
my *string $sql = $table.getDropConstraintIfExistsSql("uk_mytable_name");
            @endcode

            @param cname the name of the constraint to drop
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options
            @param cref an optional reference to an AbstractConstraint object that will return the constraint dropped

            @return the SQL that can be used to drop a constraint from the table if it exists, otherwise returns @ref nothing; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint

            @throw OPTION-ERROR invalid or unsupported option passed

            @note
            - this method retrieves current constraint definitions from the database if not already loaded or defined
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
         */
        *string getDropConstraintIfExistsSql(string cname, *hash opt, *reference cref) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            l.lock();
            on_exit l.unlock();

            code rmv;
            AbstractConstraint c;
            try {
                c = findDropConstraintUnlocked(cname, \rmv);
                cref = c;
            }
            catch (hash ex) {
                if (ex.err == "CONSTRAINT-ERROR")
                    return;
                rethrow;
            }

            on_success if (opt.sql_callback_executed)
                rmv();
 
            return AbstractDatabase::doCallback(opt, c.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "constraint", c.getName(), name);
        }

        private AbstractConstraint findDropConstraintUnlocked(string cname, reference rmv) {
            getAllConstraintsUnlocked();
            
            AbstractConstraint c;

            if (constraints && constraints.hasKey(cname)) {
                c = constraints{cname};
                rmv = sub () {
                    constraints.take(cname); 
                    # if it's a unique constraint, remove any index with the same name
                    if (c instanceof AbstractUniqueConstraint && constraintsLinkedToIndexesImpl())
                        indexes.take(cname);
                };
            }
            else if (primaryKey && primaryKey.getName() == cname) {
                c = primaryKey;
                rmv = sub () { 
                    remove self.primaryKey; 
                    # remove any index with the same name
                    if (constraintsLinkedToIndexesImpl())
                        indexes.take(cname);
                };
            }
            else if (foreignConstraints && foreignConstraints.hasKey(cname)) {
                c = foreignConstraints{cname};
                rmv = sub () {
                    foreignConstraints.take(cname); 
                };
            }
            
            if (!c) {
                list cl = ();
                # get a list of all constraint names
                cl += constraints.keys();
                if (primaryKey)
                    cl += primaryKey.getName();
                if (foreignConstraints)
                    cl += foreignConstraints.keys();
                throw "CONSTRAINT-ERROR", sprintf("%s: has no constraint %y; valid constraints: %y", name, cname, cl);
            }

            return c;
        }

        #! drops a constraint from the table; this can be any constraint on the table, a primary key, a foreign key constraint, or a generic constraint; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropConstraint("uk_mytable_name");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the constraint to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the constraint dropped from the table

            @throw CONSTRAINT-ERROR the given constraint does not exist in the table

            @note this method retrieves current constraint definitions from the database if not already loaded or defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractConstraint dropConstraint(string cname, *reference sql) {
            l.lock();
            on_exit l.unlock();

            code rmv;
            AbstractConstraint c = findDropConstraintUnlocked(cname, \rmv);
            
            # drop foreign constraint from table if the table already exists in the DB
            execSql(sql = c.getDropSql(getSqlName()));

            # remove from foreign constraint structure and return removed foreign constraint
            rmv();
            return c;
        }

        #! adds a trigger to the table; if the table is already known to be in the database, then it is added in the database also immediately; otherwise it is only added internally and can be created when create() is called for example
        /** @par Example:
            @code
my string $sql;
my AbstractTrigger $trig = $table.addTrigger("trig_mytable", "", NOTHING, \$sql);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param tname the name of the new trigger
            @param src the source of the trigger
            @param opt a hash of options for the new trigger; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::TriggerOptions
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return an AbstractTrigger object corresponding to the trigger created

            @throw TRIGGER-ERROR the table already has a trigger with the given name or invalid options were passed

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractTrigger addTrigger(string tname, string src, *hash opt, *reference lsql) {
            l.lock();
            on_exit l.unlock();

            return addTriggerUnlocked(tname, src, opt, \lsql);
        }

        #! returns a list of SQL strings that can be used to add a trigger to the table
        /** @par Example:
            @code
my string $sql = $table.getAddTriggerSql("trig_mytable", $trigger_src);
printf("%s;\n", $sql);
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param tname the name of the new trigger
            @param src the source of the trigger
            @param topt a hash of options for the new trigger; each driver may implement its own options; for common options, see @ref SqlUtil::AbstractTable::TriggerOptions
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that can be used to add a trigger to the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw TRIGGER-ERROR the table already has a trigger with the given name or invalid options were passed

            @see inDb() for a method that tells if the table is already in the database or not

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
         */
        list getAddTriggerSql(string tname, string src, *hash topt, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            l.lock();
            on_exit l.unlock();

            list lsql;
            AbstractTrigger trig = addTriggerUnlockedIntern(tname, src, topt, \lsql);
            on_success if (opt.sql_callback_executed) {
                # store trigger in trigger container
                if (!triggers)
                    triggers = new Triggers();
                
                triggers.add(tname, trig);
                manual = True;
            }
            return AbstractDatabase::doCallback(opt, lsql, AbstractDatabase::AC_Add, "trigger", tname, getSqlName());
        }

        private AbstractTrigger addTriggerUnlocked(string tname, string src, *hash opt, *reference lsql) {
            AbstractTrigger trig = addTriggerUnlockedIntern(tname, src, opt, \lsql);
            execSql(lsql);

            # store trigger in trigger container
            if (!triggers)
                triggers = new Triggers();

            triggers.add(tname, trig);

            # return the new trigger
            return trig;
       }

        private AbstractTrigger addTriggerUnlockedIntern(string tname, string src, *hash opt, *reference lsql) {
            # load triggers if needed
            if (!manual)
                getTriggersUnlocked();

            # verify unique trigger name
            if (triggers && triggers.hasKey(tname))
                throw "TRIGGER-ERROR", sprintf("%y: already has a trigger named %y, drop the trigger before adding it", name, tname);

            # validate/process options
            validateOptionsIntern("TRIGGER-ERROR", getTriggerOptions(), \opt);

            # get the new constraint object
            AbstractTrigger trig = addTriggerImpl(tname, src, opt);
            
            lsql = trig.getCreateSql(getSqlName());

            # return the new trigger
            return trig;
        }

        #! drops the given trigger from the table; if the table is known to be in the database already, then it is also dropped from the database immediately; otherwise it is only removed internally
        /** @par Example:
            @code
$table.dropTrigger("trig_mytable");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param tname the name of the trigger to drop
            @param sql an optional reference to a string to retrieve the SQL used to modify the database (only executed if the table is already in the database)

            @return the trigger dropped from the table

            @throw TRIGGER-ERROR the given trigger does not exist

            @note this method retrieves all current trigger definitions from the database if none have already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractTrigger dropTrigger(string tname, *reference sql) {
            l.lock();
            on_exit l.unlock();
            getTriggersUnlocked();
            if (!triggers.hasKey(tname))
                throw "TRIGGER-ERROR", sprintf("%s: has no trigger %y; valid triggers: %y", name, tname, triggers.keys());

            # drop trigger from table if the table already exists in the DB
            execSql(sql = triggers{tname}.getDropSql(getSqlName()));

            # remove from trigger structure and return removed trigger
            return triggers.take(tname);
        }

        #! returns SQL that can be used to drop the given trigger from the table
        /** @par Example:
            @code
my string $sql = $table.getDropTriggerSql("trig_mytable");
            @endcode

            @param tname the name of the trigger to drop
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return the SQL that can be used to drop the given trigger from the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw TRIGGER-ERROR the given trigger does not exist

            @note
            - this method retrieves all current trigger definitions from the database if none have already been defined
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
         */
        list getDropTriggerSql(string tname, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            l.lock();
            on_exit l.unlock();

            getTriggersUnlocked();
            if (!triggers.hasKey(tname))
                throw "TRIGGER-ERROR", sprintf("%s: has no trigger %y; valid triggers: %y", name, tname, triggers.keys());

            # remove from trigger structure if sql is executed
            on_success if (opt.sql_callback_executed)
                triggers.take(tname);

            # drop trigger from table if the table already exists in the DB
            return AbstractDatabase::doCallback(opt, triggers{tname}.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "trigger", tname, getSqlName());
        }

        private getAllConstraintsUnlocked(*hash opt) {
            if (manual)
                return;

            getPrimaryKeyUnlocked();
            getForeignConstraintsUnlocked(opt);
            getConstraintsUnlocked();
        }

        private checkUniqueConstraintName(string err, string cname) {
            getAllConstraintsUnlocked();
            if (foreignConstraints.hasKey(cname))
                throw err, printf("%y: already has a foreign constraint named %y with columns: %y", name, cname, foreignConstraints{cname}.columns.keys());

            if (constraints.hasKey(cname))
                throw err, printf("%y: already has a constraint named %y", name, cname);

            if (primaryKey && primaryKey.getName() == cname)
                throw err, printf("%y: already has a primary key constraint named %y with columns: %y", name, cname, primaryKey.columns.keys());
        }

        private checkUniqueConstraintNameValidateOptions(string err, string cname, hash ropt, reference opt) {
            checkUniqueConstraintName(err, cname);
            # validate options
            validateOptionsIntern(err, ropt, \opt);
        }

        #! validates column options
        private validateColumnOptions(string cname, reference opt, bool nullable) {
            hash copt = getColumnDescOptions();

            # check valid options and option value types
            validateOptionsIntern("COLUMN-ERROR", copt, \opt, sprintf("%s.%s", name, cname));
            
            hash otm = getTypeMapImpl();

            if (!opt.native_type) {
                hash qtm = getQoreTypeMapImpl();
                opt.native_type = qtm{opt.qore_type};
                if (!opt.native_type)
                    throw "COLUMN-ERROR", sprintf("%s.%s: qore type %y cannot be mapped to a column type (valid values: %y)", name, cname, opt.qore_type, qtm.keys());
            }
            else if (!otm{opt.native_type})
                throw "COLUMN-ERROR", sprintf("%s.%s: unknown native_type %y (valid values: %y)", name, cname, opt.native_type, otm.keys());

            # get native type description
            hash th = otm{opt.native_type};

            # reset qore type from native type
            opt.qore_type = th.qore;
            opt.local_def = th;

            if (exists opt.size) {
                if (!th.size)
                    throw "COLUMN-ERROR", sprintf("%s.%s: size %y given but type %y does not take a size attribute", name, cname, opt.size, opt.native_type);
                if (th.size_range && (opt.size < th.size_range[0] || opt.size > th.size_range[1]))
                    throw "COLUMN-ERROR", sprintf("%s.%s: size %y is not valid for type %y; must be between %d and %d inclusive", name, cname, opt.size, opt.native_type, th.size_range[0], th.size_range[1]);
            }
            else {
                if (th.size == SZ_MAND)
                    throw "COLUMN-ERROR", sprintf("%s.%s: type %y requires a size argument but none was supplied (options: %y)", name, cname, opt.native_type, opt);
                opt.size = 0;
            }

            if (th.size == SZ_NUM) {
                opt.precision = opt.size;
                opt.size = 0;
                if (opt.scale) {
                    if (th.scale_range && (opt.scale < th.scale_range[0] || opt.scale > th.scale_range[1]))
                        throw "COLUMN-ERROR", sprintf("%s.%s: scale %y is not valid for type %y; must be between %d and %d inclusive", name, cname, opt.scale, opt.native_type, th.scale_range[0], th.scale_range[1]);
                }
                else
                    opt.scale = 0;
            }
            else if (opt.scale) 
                throw "COLUMN-ERROR", sprintf("%s.%s: scale %y is not valid for type %y; it is not a numeric type", name, cname, opt.scale, opt.native_type);
            else
                opt.precision = opt.scale = 0;

            if (!opt.size && th.default_size)
                opt.size = th.default_size;
            
            # check type of default value (must match column type)
            if (exists opt.default_value) {
                checkValue(cname, "default_value", \opt.default_value, th.qore);
                opt.default_value = getSqlValue(opt.default_value);
            }
        }

        #! drops a column from the table
        /** @par Example:
            @code
$table.dropColumn("notes_2");
            @endcode

            In case the table is already in the database, this method commits the transaction on success and rolls back the transaction if there's an error.

            @param cname the name of the column to drop
            @param lsql an optional reference to a list of strings to retrieve the SQL used to modify the table (only executed if the table is already in the database)

            @return the AbstractColumn object representing the column dropped from the table

            @throw COLUMN-ERROR the named column is not present in the table

            @note this method retrieves the table definition from the database if none has already been defined

            @see inDb() for a method that tells if the table is already in the database or not
         */
        AbstractColumn dropColumn(string cname, *reference lsql) {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            if (!columns.hasKey(cname))
                throw "COLUMN-ERROR", sprintf("%s.%s: no such column (valid columns: %y)", name, cname, columns.keys());

            code sc;
            if (inDb) {
                sc = sub (string str) {
                    ds.execRaw(str);
                }; 
            }

            # if there are any indexes or constraints on this column, remove them from the table first
            lsql = getDropAllConstraintsAndIndexesOnColumnSql(cname, ("sql_callback": sc, "sql_callback_executed": True));

            # drop column from table if the table already exists in the DB
            execSql(lsql += columns{cname}.getDropSql(getSqlName()));
            return columns.take(cname);
        }

        #! returns the SQL that can be used to drop a column from the table
        /** @par Example:
            @code
my string $sql = $table.getDropColumnSql("notes_2");
            @endcode

            @param cname the name of the column to drop
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return the SQL that can be used to drop a column from the table

            @throw OPTION-ERROR invalid or unsupported option passed
            @throw COLUMN-ERROR the named column is not present in the table

            @note
            - this method retrieves the column definitions from the database if none have already been defined
            - if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)

            @see inDb() for a method that tells if the table is already in the database or not
         */
        list getDropColumnSql(string cname, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            if (!columns.hasKey(cname))
                throw "COLUMN-ERROR", sprintf("%s.%s: no such column (valid columns: %y)", name, cname, columns.keys());

            on_success if (opt.sql_callback_executed)
                columns.take(cname);

            list lst = ();
            lst += getDropAllConstraintsAndIndexesOnColumnSqlUnlocked(cname, opt);
            lst += AbstractDatabase::doCallback(opt, columns{cname}.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "column", cname, name);
            return lst;
        }

        #! inserts a row into the table; the transaction is committed if successful, if an error occurs, it is rolled back
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert
            @param sql an optional reference to a string to return the SQL generated for the insert statement

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
         */
        insert(hash row, *reference sql) {
            on_success ds.commit();
            on_error ds.rollback();

            insertNoCommit(row, \sql);
        }

        #! inserts a row into the table without any transaction management; a transaction will be in progress after this method is successfully executed
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert
            @param sql an optional reference to a string to return the SQL generated for the insert statement

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
         */
        insertNoCommit(hash row, *reference sql) {
            return insertNoCommitIntern(row, \sql);
        }

        private insertNoCommitIntern(hash row, *reference sql, *hash opt) { 
            # check data callback options if any
            validateOptionsIntern("OPTION-ERROR", getSqlDataCallbackOptions(), \opt);

            l.lock();
            on_exit l.unlock();

            getColumnsUnlocked();
            sql = sprintf("insert into %s (", getSqlName());
            foreach string k in (row.keyIterator()) {
                if (!columns{k})
                    throw "COLUMN-ERROR", sprintf("%s.%s is not a valid column (valid columns: %y)", name, k, columns.keys());
            }
            sql += (foldl $1 + "," + $2, row.keyIterator());
            sql += ") values (";
            sql += (foldl $1 + "," + $2, (map "%v", row.keyIterator()));
            sql += ")";

            execData(opt, sql, row.values());
        }

        #! inserts a row into the table; the transaction is committed if successful, if an error occurs, it is rolled back
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
         */
        insert(hash row, *hash opt) {
            on_success ds.commit();
            on_error ds.rollback();

            insertNoCommitIntern(row, NOTHING, opt);
        }

        #! inserts a row into the table without any transaction management; a transaction will be in progress after this method is successfully executed
        /** @par Example:
            @code
$table.insert($row);
            @endcode

            @param row a hash representing the row to insert
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
         */
        insertNoCommit(hash row, *hash opt) {
            insertNoCommitIntern(row, NOTHING, opt);
        }

        #! inserts rows into a table based on a select statement from another table (which must be using the same datasource as the current table); the transaction is committed if successful, if an error occurs, it is rolled back
        /** @par Example:
            @code
my int $rows = $table.insertFromSelect(("id", "name", "created"), $source_table, (("columns": ("id", "name", "created"), "where": ("type": "CUSTOMER")))); 
            @endcode

            @param cols the list of column names to use to insert in the current table
            @param source the source table for the select statement
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return the number of rows inserted

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR unknown or invalid column in insert list
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note this method does not take insert options because it is executed entirely in the database server; use insertFromIterator() or insertFromIteratorNoCommit() to insert arbitrary data with insert options
        */
        int insertFromSelect(list cols, AbstractTable source, *hash sh, *reference sql) {
            on_success ds.commit();
            on_error ds.rollback();

            return insertFromSelectNoCommitIntern(cols, source, sh, \sql);
        }

        #! inserts rows into a table based on a select statement from another table (which must be using the same datasource as the current table); a transaction will be in progress after this method is successfully executed
        /** @par Example:
            @code
my int $rows = $table.insertFromSelectNoCommit(("id", "name", "created"), $source_table, (("columns": ("id", "name", "created"), "where": ("type": "CUSTOMER"))));
            @endcode

            @param cols the list of column names to use to insert in the current table
            @param source the source table for the select statement
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return the number of rows inserted

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR unknown or invalid column in insert list
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note this method does not take insert options because it is executed entirely in the database server; use insertFromIterator() or insertFromIteratorNoCommit() to insert arbitrary data with insert options
        */
        int insertFromSelectNoCommit(list cols, AbstractTable source, *hash sh, *reference sql) {
            return insertFromSelectNoCommitIntern(cols, source, sh, \sql);
        }

        private int insertFromSelectNoCommitIntern(list cols, AbstractTable source, *hash sh, *reference sql, *hash opt) {
            list args;
            string ssql = source.getSelectSql(sh, \args);

            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();

            sql = sprintf("insert into %s (", getSqlName());

            foreach string k in (cols) {
                if (!columns{k})
                    throw "COLUMN-ERROR", sprintf("%s.%s is not a valid column (valid columns: %y)", name, k, cols);
            }

            sql += (foldl $1 + "," + $2, cols);
            sql += ") " + ssql;

            return execData(opt, sql, args);
        }

        #! inserts rows into a table based on a select statement from another table (which must be using the same datasource as the current table); the transaction is committed if successful, if an error occurs, it is rolled back
        /** @par Example:
            @code
my int $rows = $table.insertFromSelect(("id", "name", "created"), $source_table, (("columns": ("id", "name", "created"), "where": ("type": "CUSTOMER")))); 
            @endcode

            @param cols the list of column names to use to insert in the current table
            @param source the source table for the select statement
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return the number of rows inserted

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR unknown or invalid column in insert list
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note this method does not take insert options because it is executed entirely in the database server; use insertFromIterator() or insertFromIteratorNoCommit() to insert arbitrary data with insert options
        */
        int insertFromSelect(list cols, AbstractTable source, *hash sh, *hash opt) {
            on_success ds.commit();
            on_error ds.rollback();

            return insertFromSelectNoCommitIntern(cols, source, sh, NOTHING, opt);
        }

        #! inserts rows into a table based on a select statement from another table (which must be using the same datasource as the current table); a transaction will be in progress after this method is successfully executed
        /** @par Example:
            @code
my int $rows = $table.insertFromSelectNoCommit(("id", "name", "created"), $source_table, (("columns": ("id", "name", "created"), "where": ("type": "CUSTOMER")))); 
            @endcode

            @param cols the list of column names to use to insert in the current table
            @param source the source table for the select statement
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return the number of rows inserted

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR unknown or invalid column in insert list
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note this method does not take insert options because it is executed entirely in the database server; use insertFromIterator() or insertFromIteratorNoCommit() to insert arbitrary data with insert options
        */
        int insertFromSelectNoCommit(list cols, AbstractTable source, *hash sh, *hash opt) {
            return insertFromSelectNoCommitIntern(cols, source, sh, NOTHING, opt);
        }

        #! this method inserts data from the given iterator argument (whose @ref Qore::AbstractIterator::getValue() "getValue()" method must return a hash giving row values) into the current table; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my int $rows = $table.insertFromIterator($i);
            @endcode

            @param i the @ref Qore::AbstractIterator argument that will provide the data to insert into the current table; the @ref Qore::AbstractIterator::getValue() "getValue()" method of this object must return a hash giving row values (for example, the @ref Qore::SQL::SQLStatement class is well-suited to be used here); note that the iterator is assumed to return the same columns in every element
            @param opt a hash of options for the insert operation; see @ref SqlUtil::AbstractTable::InsertOptions for common options; each driver can support additional driver-specific options

            @return the number of rows inserted

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted

            @see
            - insertFromIteratorNoCommit()
            - upsertFromIterator()
            - upsertFromIteratorNoCommit()
        */
        int insertFromIterator(Qore::AbstractIterator i, *hash opt) {
            on_success ds.commit();
            on_error ds.rollback();

            return insertFromIteratorNoCommitIntern(i, opt);
        }

        #! this method inserts data from the given iterator argument (whose @ref Qore::AbstractIterator::getValue() "getValue()" method must return a hash giving row values) into the current table; no transaction management is performed with this method
        /** @par Example:
            @code
my int $rows = $table.insertFromIteratorNoCommit($i);
            @endcode

            @param i the @ref Qore::AbstractIterator argument that will provide the data to insert into the current table; the @ref Qore::AbstractIterator::getValue() "getValue()" method of this object must return a hash giving row values (for example, the @ref Qore::SQL::SQLStatement class is well-suited to be used here); note that the iterator is assumed to return the same columns in the same order in every element
            @param opt a hash of options for the insert operation; see @ref SqlUtil::AbstractTable::InsertOptions for common options; each driver can support additional driver-specific options; note that this method ignores any \c "commit_block" option

            @return the number of rows inserted

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted

            @see
            - insertFromIterator()
            - upsertFromIterator()
            - upsertFromIteratorNoCommit()
        */
        int insertFromIteratorNoCommit(Qore::AbstractIterator i, *hash opt) {
            return insertFromIteratorNoCommitIntern(i, opt - "commit_block");
        }

        private int insertFromIteratorNoCommitIntern(Qore::AbstractIterator i, *hash opt) {
            # check upsert options
            validateOptionsIntern("OPTION-ERROR", getInsertOptions(), \opt);

            if (!i.next())
                return 0;

            # get initial row
            hash row = i.getValue();

            # make insert statement template
            string sql = sprintf("insert into %s (%s) values (%s)", getSqlName(), (foldl $1 + "," + $2, row.keyIterator()),
                                 (foldl $1 + "," + $2, (map "%v", row.keyIterator())));
            SQLStatement stmt(ds);
            stmt.prepare(sql);

            opt.change_count = 0;
            int rc = 0;             
            do {
                execData(stmt, opt, row.values());
                if (opt.info_callback)
                    opt.info_callback(getSqlName(), row, UR_Inserted);
                ++rc;

                if (opt.commit_block) {
                    if (++opt.change_count >= opt.commit_block) {
                        ds.commit();
                        opt.change_count = 0;
                    }
                }
            } while (i.next() && (row = i.getValue()));

            return rc;
        }

        #! update or insert the data in the table according to the hash argument; the table must have a unique key to do this; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
$table.upsert($row);
            @endcode

            @param row a hash representing the row to insert or update
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy

            @return an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note if upserting multiple rows; it's better to use getUpsertClosure() or getUpsertClosureWithValidation() and execute the closure on each row; when using this method, the overhead for setting up the upsert is made for each row which is very inefficient
         */
        int upsert(hash row, int upsert_strategy = UpsertAuto) {
            on_success ds.commit();
            on_error ds.rollback();

            return upsertNoCommit(row, upsert_strategy);
        }

        #! update or insert the data in the table according to the hash argument; the table must have a unique key to do this
        /** @par Example:
            @code
$table.upsertNoCommit($row);
            @endcode

            @param row a hash representing the row to insert or update
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy

            @return an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note if upserting multiple rows; it's better to use getUpsertClosure() or getUpsertClosureWithValidation() and execute the closure on each row; when using this method, the overhead for setting up the upsert is made for each row which is very inefficient
         */
        int upsertNoCommit(hash row, int upsert_strategy = UpsertAuto) {
            l.lock();
            on_exit l.unlock();

            code upsert = getUpsertClosureUnlocked(row, upsert_strategy);

            return upsert(row);
        }

        #! returns a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the table must have a unique key to do this; the closure returned does not check the input hash for validity
        /** @par Example:
            @code
my Datasource $ds("pgsql:user/pass@db%localhost");
my Table $table($ds, "table_name");
my code $upsert = $table.getUpsertClosure($row, AbstractTable::UpsertSelectFirst);
on_success $ds.commit();
on_error $ds.rollback();
map $upsert($1), $row_list;
            @endcode

            @param example_row a hash representing an example row to insert or update; every row passed to the upsert closure returned must have the same keys in the same order
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy

            @return a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the closure returned does not check the input hash for validity; the closure has the following signature: @code int sub upsert(hash $row) {} @endcode The return value of the closuse is an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note the row values passed to the closure for upserting are not checked if they match the example row passed to the getUpsertClosure() method; passing non-conforming data will cause errors; see @ref SqlUtil::AbstractTable::getUpsertClosureWithValidation() for a similar method that returns a validating closure; the closure returned by this method is faster than the one returned by @ref SqlUtil::AbstractTable::getUpsertClosure() since there is no validation
         */
        code getUpsertClosure(hash example_row, int upsert_strategy = UpsertAuto) {
            l.lock();
            on_exit l.unlock();

            return getUpsertClosureUnlocked(example_row, upsert_strategy);
        }

        #! returns a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the table must have a unique key to do this; the closure returned checks the input hash for validity
        /** @par Example:
            @code
my Datasource $ds("pgsql:user/pass@db%localhost");
my Table $table($ds, "table_name");
my code $upsert = $table.getUpsertClosureWithValidation($row, AbstractTable::UpsertSelectFirst);
on_success $ds.commit();
on_error $ds.rollback();
map $upsert($1), $row_list;
            @endcode

            @param example_row a hash representing an example row to insert or update; every row passed to the upsert closure returned must have the same keys in the same order or the closure returned will throw an \c UPSERT-ERROR exception
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy

            @return a closure that can be executed given a hash argument representing a single row that will be updated or inserted in the database with the given upsert strategy; the closure has the following signature: @code int sub upsert(hash $row) {} @endcode The return value of the closuse is an integer code giving the result of the update; see @ref upsert_results for more information 

            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note the row values passed to the closure for upserting are checked if they match the example row passed to the getUpsertClosure() method; passing non-conforming data to the closure will cause the closure to throw an \c UPSERT-ERROR exception; see @ref SqlUtil::AbstractTable::getUpsertClosure() for a similar method that returns a non-validating closure; the closure returned by this method is a little slower than the one returned by @ref SqlUtil::AbstractTable::getUpsertClosure() since each row is validated
         */
        code getUpsertClosureWithValidation(hash example_row, int upsert_strategy = UpsertAuto) {
            code upsert = getUpsertClosure(example_row, upsert_strategy);

            return int sub (hash row) {
                if (!row.compareKeys(example_row))
                    throw "UPSERT-ERROR", sprintf("the keys in the row passed to the upsert closure (%y) do not match the keys passed to AbstractTable::getUpsertClosureWithValidation() (%y)", row.keys, example_row.keys());
                return upsert(row);
            };
        }        

        #! this method upserts or merges data from the given iterator argument (whose @ref Qore::AbstractIterator::getValue() "getValue()" method must return a hash giving row values) into the current table; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my hash $h = $table.upsertFromIterator($i, AbstractTable::UpsertUpdateFirst);
            @endcode

            @param i the @ref Qore::AbstractIterator argument that will provide the data to upsert or merge into the current table; the @ref Qore::AbstractIterator::getValue() "getValue()" method of this object must return a hash giving row values (for example, the @ref Qore::SQL::SQLStatement class is well-suited to be used here)
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy
            @param opt a hash of options for the upsert operation; see @ref SqlUtil::AbstractTable::UpsertOptions for common options; each driver can support additional driver-specific options

            @return @ref nothing if no actions were taken or a hash with the following keys assigned to numeric values indicating the number of rows processed (keys correspond to @ref SqlUtil::AbstractTable::UpsertResultDescriptionMap keys):
            - \c "inserted": the number of rows inserted
            - \c "verified": the number of rows updated unconditionally; note that this key is returned with all upsert strategy codes other than @ref SqlUtil::AbstractTable::UpsertSelectFirst instead of \c "updated"
            - \c "updated": the number of rows updated; note that this key is only returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, otherwise updated rows are reported as \c "verified" since rows are updated unconditionally with other the upsert strategy codes
            - \c "unchanged": the number of rows unchanged; this key can only be returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, since this is the only upsert strategy that compares row data
            - \c "deleted": the number of rows deleted; this can only be returned if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True"

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True", then a hash of primary key values in the input data is built as the input data is iterated.  After iterating, if the row count of the table and the input data matches, then nothing more is done, otherwise, every row of the table is iterated and compared to the primary key hash; if a row does not match a primary key value, then it is deleted.  This operation is only executed if \c delete_others is @ref Qore::True "True" and is expensive for large data sets.

            @see
            - upsertFromIteratorNoCommit()
            - upsertFromSelect()
            - upsertFromSelectNoCommit()
            - upsert()
            - upsertNoCommit()
            - getUpsertClosure()
            - insertFromIteratorNoCommit()
            - insertFromIterator()
        */
        *hash upsertFromIterator(Qore::AbstractIterator i, int upsert_strategy = AbstractTable::UpsertAuto, *hash opt) {
            on_success ds.commit();
            on_error ds.rollback();

            return upsertFromIteratorNoCommitIntern(i, upsert_strategy, opt);
        }

        #! this method upserts or merges data from the given iterator argument (whose @ref Qore::AbstractIterator::getValue() "getValue()" method must return a hash giving row values) into the current table; no transaction management is performed with this method
        /** @par Example:
            @code
my hash $h = $table.upsertFromIteratorNoCommit($i, AbstractTable::UpsertUpdateFirst);
            @endcode

            @param i the @ref Qore::AbstractIterator argument that will provide the data to upsert or merge into the current table; the @ref Qore::AbstractIterator::getValue() "getValue()" method of this object must return a hash giving row values (for example, the @ref Qore::SQL::SQLStatement class is well-suited to be used here)
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy
            @param opt a hash of options for the upsert operation; see @ref SqlUtil::AbstractTable::UpsertOptions for common options; each driver can support additional driver-specific options; note that this method ignores any \c "commit_block" option

            @return @ref nothing if no actions were taken or a hash with the following keys assigned to numeric values indicating the number of rows processed (keys correspond to @ref SqlUtil::AbstractTable::UpsertResultDescriptionMap keys):
            - \c "inserted": the number of rows inserted
            - \c "verified": the number of rows updated unconditionally; note that this key is returned with all upsert strategy codes other than @ref SqlUtil::AbstractTable::UpsertSelectFirst instead of \c "updated"
            - \c "updated": the number of rows updated; note that this key is only returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, otherwise updated rows are reported as \c "verified" since rows are updated unconditionally with other the upsert strategy codes
            - \c "unchanged": the number of rows unchanged; this key can only be returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, since this is the only upsert strategy that compares row data
            - \c "deleted": the number of rows deleted; this can only be returned if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True"

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True", then a hash of primary key values in the input data is built as the input data is iterated.  After iterating, if the row count of the table and the input data matches, then nothing more is done, otherwise, every row of the table is iterated and compared to the primary key hash; if a row does not match a primary key value, then it is deleted.  This operation is only executed if \c delete_others is @ref Qore::True "True" and is expensive for large data sets.

            @see
            - upsertFromIteratorNoCommit()
            - upsertFromSelect()
            - upsertFromSelectNoCommit()
            - upsert()
            - upsertNoCommit()
            - getUpsertClosure()
            - insertFromIteratorNoCommit()
            - insertFromIterator()
        */
        *hash upsertFromIteratorNoCommit(Qore::AbstractIterator i, int upsert_strategy = AbstractTable::UpsertAuto, *hash opt) {
            return upsertFromIteratorNoCommitIntern(i, upsert_strategy, opt - "commit_block");
         }

        private *hash upsertFromIteratorNoCommitIntern(Qore::AbstractIterator i, int upsert_strategy = AbstractTable::UpsertAuto, *hash opt) {
            # check upsert options
            validateOptionsIntern("OPTION-ERROR", getUpsertOptions(), \opt);

            # try to get initial row
            if (!i.next())
                return;

            # result hash
            hash rh;

            # primary key value hash for "delete_others"
            hash pkh;

            hash row = i.getValue();
            code upsert = getUpsertClosure(row, upsert_strategy);

            opt.change_count = 0;
            do {
                int code = upsert(row);
                ++rh{AbstractTable::UpsertResultMap{code}};
                if (opt.info_callback)
                    opt.info_callback(getSqlName(), row, code);

                if (code != UR_Unchanged && opt.commit_block) {
                    if (++opt.change_count >= opt.commit_block) {
                        ds.commit();
                        opt.change_count = 0;
                    }
                }

                # save primary key value in primary key hash if "delete_others" is set
                if (opt.delete_others)
                    pkh{foldl $1 + "-" + $2, (map row.$1.toString(), primaryKey.keyIterator())} = True;
            } while (i.next() && (row = i.getValue()));

            if (opt.delete_others)
                rh += doDeleteOthersIntern(pkh, opt);

            return rh;
        }

        private *hash doDeleteOthersIntern(hash pkh, *hash opt) {
            hash rh;

            # iterate through the table to find rows that do not belong and delete them
            list pkl = primaryKey.keys();
            foreach hash row in (getRowIterator()) {
                string k = foldl $1 + "-" + $2, (map row.$1.toString(), pkl);
                if (pkh{k})
                    continue;

                hash h = row{pkl};
                delNoCommit(h);

                ++rh.deleted;
                if (opt.info_callback)
                    opt.info_callback(getSqlName(), row, UR_Deleted);
                if (opt.commit_block) {
                    if (++opt.change_count >= opt.commit_block) {
                        ds.commit();
                        opt.change_count = 0;
                    }
                }
            }

            return rh;
        }

        #! this method upserts or merges data from the given foreign table and @ref select_option_hash "select option hash" into the current table; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my hash $h = $table.upsertFromSelect($table2, ("where": ("account_type": "CUSTOMER")), AbstractTable::UpsertUpdateFirst);
            @endcode

            The table argument does not need to be in the same database as the current table; it can also
            be in a different database server or a database server of a different type (you can use this method to upsert or
            merge data to or from any database supported by SqlUtil).

            @param t the table for the source data; this does not need to be in the same database as the target (the current table), nor does it need to be the same database type
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy
            @param opt a hash of options for the upsert operation; see @ref SqlUtil::AbstractTable::UpsertOptions for common options; each driver can support additional driver-specific options

            @return @ref nothing if no actions were taken or a hash with the following keys assigned to numeric values indicating the number of rows processed (keys correspond to @ref SqlUtil::AbstractTable::UpsertResultDescriptionMap keys):
            - \c "inserted": the number of rows inserted
            - \c "verified": the number of rows updated unconditionally; note that this key is returned with all upsert strategy codes other than @ref SqlUtil::AbstractTable::UpsertSelectFirst instead of \c "updated"
            - \c "updated": the number of rows updated; note that this key is only returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, otherwise updated rows are reported as \c "verified" since rows are updated unconditionally with other the upsert strategy codes
            - \c "unchanged": the number of rows unchanged; this key can only be returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, since this is the only upsert strategy that compares row data
            - \c "deleted": the number of rows deleted; this can only be returned if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True"

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note
            - if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True", then a hash of primary key values in the input data is built as the input data is iterated.  After iterating, if the row count of the table and the input data matches, then nothing more is done, otherwise, every row of the table is iterated and compared to the primary key hash; if a row does not match a primary key value, then it is deleted.  This operation is only executed if \c delete_others is @ref Qore::True "True" and is expensive for large data sets.
            - this method also calls commit() or rollback() on the source table to release the transaction lock on the underlying source table datasource as an @ref Qore::SQL::SQLStatement "SQLStatement" object is used to pipeline the data to the upsert code; use upsertFromSelectNoCommit() to do manual transaction management instead
            - unlike insertFromSelect() and insertFromSelectNoCommit(), this method processes arbitrary input data and accepts @ref SqlUtil::AbstractTable::UpsertOptions "upsert options"

            @see
            - upsertFromSelectNoCommit()
            - upsertFromIterator()
            - upsertFromIteratorNoCommit()
            - upsert()
            - upsertNoCommit()
            - getUpsertClosure()
        */
        *hash upsertFromSelect(AbstractTable t, *hash sh, int upsert_strategy = AbstractTable::UpsertAuto, *hash opt) {
            on_success { ds.commit(); t.commit(); }
            on_error { ds.rollback(); t.rollback(); }

            return upsertFromSelectNoCommit(t, sh, upsert_strategy, opt);
        }

        #! this method upserts or merges data from the given foreign table and @ref select_option_hash "select option hash" into the current table; no transaction management is performed with this method
        /** @par Example:
            @code
on_success { $table.commit(); $table2.commit(); }
on_error { $table.rollback(); $table2.rollback(); }
my hash $h = $table.upsertFromSelectNoCommit($table2, ("where": ("account_type": "CUSTOMER")), AbstractTable::UpsertUpdateFirst);
            @endcode

            The table argument does not need to be in the same database as the current table; it can also
            be in a different database server or a database server of a different type (you can use this method to upsert or
            merge data to or from any database supported by SqlUtil).

            @param t the table for the source data; this does not need to be in the same database as the target (the current table), nor does it need to be the same database type
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy
            @param opt a hash of options for the upsert operation; see @ref SqlUtil::AbstractTable::UpsertOptions for common options; each driver can support additional driver-specific options; note that this method ignores any \c "commit_block" option

            @return @ref nothing if no actions were taken or a hash with the following keys assigned to numeric values indicating the number of rows processed (keys correspond to @ref SqlUtil::AbstractTable::UpsertResultDescriptionMap keys):
            - \c "inserted": the number of rows inserted
            - \c "verified": the number of rows updated unconditionally; note that this key is returned with all upsert strategy codes other than @ref SqlUtil::AbstractTable::UpsertSelectFirst instead of \c "updated"
            - \c "updated": the number of rows updated; note that this key is only returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, otherwise updated rows are reported as \c "verified" since rows are updated unconditionally with other the upsert strategy codes
            - \c "unchanged": the number of rows unchanged; this key can only be returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, since this is the only upsert strategy that compares row data
            - \c "deleted": the number of rows deleted; this can only be returned if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True"

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note
            - if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True", then a hash of primary key values in the input data is built as the input data is iterated.  After iterating, if the row count of the table and the input data matches, then nothing more is done, otherwise, every row of the table is iterated and compared to the primary key hash; if a row does not match a primary key value, then it is deleted.  This operation is only executed if \c delete_others is @ref Qore::True "True" and is expensive for large data sets.
           - this method uses an @ref Qore::SQL::SQLStatement "SQLStatement" object to pipeline the select data to the upsert code; to release the transaction lock acquired by the @ref Qore::SQL::SQLStatement "SQLStatement" object, a commit() or rollback() action must be executed on the underlying datasource object as in the example above
            - unlike insertFromSelect() and insertFromSelectNoCommit(), this method processes arbitrary input data and accepts @ref SqlUtil::AbstractTable::UpsertOptions "upsert options"

            @see
            - upsertFromSelect()
            - upsertFromIterator()
            - upsertFromIteratorNoCommit()
            - upsert()
            - upsertNoCommit()
            - getUpsertClosure()
        */
        *hash upsertFromSelectNoCommit(AbstractTable t, *hash sh, int upsert_strategy = AbstractTable::UpsertAuto, *hash opt) {
            return upsertFromIteratorNoCommitIntern(t.getRowIterator(sh), upsert_strategy, opt - "commit_block");
        }

        #! this method upserts or merges data from the given foreign table and @ref select_option_hash "select option hash" into the current table; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my hash $h = $table.upsertFromSelect($table2, ("where": ("account_type": "CUSTOMER")), AbstractTable::UpsertUpdateFirst);
            @endcode

            The table argument does not need to be in the same database as the current table; it can also
            be in a different database server or a database server of a different type (you can use this method to upsert or
            merge data to or from any database supported by SqlUtil).

            @param t the table for the source data; this does not need to be in the same database as the target (the current table), nor does it need to be the same database type
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy
            @param opt a hash of options for the upsert operation; see @ref SqlUtil::AbstractTable::UpsertOptions for common options; each driver can support additional driver-specific options

            @return @ref nothing if no actions were taken or a hash with the following keys assigned to numeric values indicating the number of rows processed (keys correspond to @ref SqlUtil::AbstractTable::UpsertResultDescriptionMap keys):
            - \c "inserted": the number of rows inserted
            - \c "verified": the number of rows updated unconditionally; note that this key is returned with all upsert strategy codes other than @ref SqlUtil::AbstractTable::UpsertSelectFirst instead of \c "updated"
            - \c "updated": the number of rows updated; note that this key is only returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, otherwise updated rows are reported as \c "verified" since rows are updated unconditionally with other the upsert strategy codes
            - \c "unchanged": the number of rows unchanged; this key can only be returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, since this is the only upsert strategy that compares row data
            - \c "deleted": the number of rows deleted; this can only be returned if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True"

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note
            - if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True", then a hash of primary key values in the input data is built as the input data is iterated.  After iterating, if the row count of the table and the input data matches, then nothing more is done, otherwise, every row of the table is iterated and compared to the primary key hash; if a row does not match a primary key value, then it is deleted.  This operation is only executed if \c delete_others is @ref Qore::True "True" and is expensive for large data sets.
            - this method also calls commit() or rollback() on the source table to release the transaction lock on the underlying source table datasource as an @ref Qore::SQL::SQLStatement "SQLStatement" object is used to pipeline the data to the upsert code; use upsertFromSelectNoCommit() to do manual transaction management instead
            - unlike insertFromSelect() and insertFromSelectNoCommit(), this method processes arbitrary input data and accepts @ref SqlUtil::AbstractTable::UpsertOptions "upsert options"

            @see
            - upsertFromSelectNoCommit()
            - upsertFromIterator()
            - upsertFromIteratorNoCommit()
            - upsert()
            - upsertNoCommit()
            - getUpsertClosure()
        */
        *hash upsertFromSelect(Table t, *hash sh, int upsert_strategy = AbstractTable::UpsertAuto, *hash opt) {
            on_success { ds.commit(); t.commit(); }
            on_error { ds.rollback(); t.rollback(); }

            return upsertFromIteratorNoCommitIntern(t.getRowIterator(sh), upsert_strategy, opt);
        }

        #! this method upserts or merges data from the given foreign table and @ref select_option_hash "select option hash" into the current table; no transaction management is performed with this method
        /** @par Example:
            @code
on_success { $table.commit(); $table2.commit(); }
on_error { $table.rollback(); $table2.rollback(); }
my hash $h = $table.upsertFromSelectNoCommit($table2, ("where": ("account_type": "CUSTOMER")), AbstractTable::UpsertUpdateFirst);
            @endcode

            The table argument does not need to be in the same database as the current table; it can also
            be in a different database server or a database server of a different type (you can use this method to upsert or
            merge data to or from any database supported by SqlUtil).

            @param t the table for the source data; this does not need to be in the same database as the target (the current table), nor does it need to be the same database type
            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param upsert_strategy see @ref upsert_options for possible values for the upsert strategy
            @param opt a hash of options for the upsert operation; see @ref SqlUtil::AbstractTable::UpsertOptions for common options; each driver can support additional driver-specific options; note that this method ignores any \c "commit_block" option

            @return @ref nothing if no actions were taken or a hash with the following keys assigned to numeric values indicating the number of rows processed (keys correspond to @ref SqlUtil::AbstractTable::UpsertResultDescriptionMap keys):
            - \c "inserted": the number of rows inserted
            - \c "verified": the number of rows updated unconditionally; note that this key is returned with all upsert strategy codes other than @ref SqlUtil::AbstractTable::UpsertSelectFirst instead of \c "updated"
            - \c "updated": the number of rows updated; note that this key is only returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, otherwise updated rows are reported as \c "verified" since rows are updated unconditionally with other the upsert strategy codes
            - \c "unchanged": the number of rows unchanged; this key can only be returned if \a upsert_strategy is @ref SqlUtil::AbstractTable::UpsertSelectFirst, since this is the only upsert strategy that compares row data
            - \c "deleted": the number of rows deleted; this can only be returned if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True"

            @throw OPTION-ERROR invalid or unsupported option
            @throw COLUMN-ERROR an unknown column was referenced in the hash to be inserted
            @throw UPSERT-ERROR no primary key, unique constraint, or unique index for upsert; not all columns of the unique constraint/index are used in the upsert statement

            @note
            - if @ref SqlUtil::AbstractTable::UpsertOptions "upsert option" \c delete_others is @ref Qore::True "True", then a hash of primary key values in the input data is built as the input data is iterated.  After iterating, if the row count of the table and the input data matches, then nothing more is done, otherwise, every row of the table is iterated and compared to the primary key hash; if a row does not match a primary key value, then it is deleted.  This operation is only executed if \c delete_others is @ref Qore::True "True" and is expensive for large data sets.
           - this method uses an @ref Qore::SQL::SQLStatement "SQLStatement" object to pipeline the select data to the upsert code; to release the transaction lock acquired by the @ref Qore::SQL::SQLStatement "SQLStatement" object, a commit() or rollback() action must be executed on the underlying datasource object as in the example above
            - unlike insertFromSelect() and insertFromSelectNoCommit(), this method processes arbitrary input data and accepts @ref SqlUtil::AbstractTable::UpsertOptions "upsert options"

            @see
            - upsertFromSelect()
            - upsertFromIterator()
            - upsertFromIteratorNoCommit()
            - upsert()
            - upsertNoCommit()
            - getUpsertClosure()
        */
        *hash upsertFromSelectNoCommit(Table t, *hash sh, int upsert_strategy = AbstractTable::UpsertAuto, *hash opt) {
            return upsertFromIteratorNoCommitIntern(t.getRowIterator(sh), upsert_strategy, opt - "commit_block");
        }

        #! returns the number of rows in the table
        /** @par Example:
            @code
my int $cnt = $table.rowCount();
            @endcode

            @return the number of rows in the table

            @note to see if the table is empty or not, use emptyData() as this is much faster than rowCount()

            @see emptyData()
         */
        softint rowCount() {
            return ds.selectRow("select count(1) cnt from %s", getSqlName()).cnt;
        }

        #! returns an @ref Qore::SQL::SQLStatement "SQLStatement" object that will iterate the results of a select statement matching the arguments
        /** @par Example:
            @code
my SQLStatement $i = $table.getRowIterator($sh);
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return an @ref Qore::SQL::SQLStatement "SQLStatement" object that will iterate the results of a select statement matching the arguments

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note
            - if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
            - the @ref Qore::SQL::SQLStatement "SQLStatement" object created by a successful call to this method acquires a thread resource for the underlying @ref Qore::SQL::AbstractDatasource "AbstractDatasource" object that must be released by calling @ref Qore::SQL::AbstractDatasource::commit() "commit()" or @ref Qore::SQL::AbstractDatasource::rollback() "rollback()", even if the statement does not acquire any database locks
         */
        Qore::SQL::SQLStatement getRowIterator(*hash sh, *reference sql) {
            return getRowIteratorIntern(sh, \sql);
        }

        private Qore::SQL::SQLStatement getRowIteratorIntern(*hash sh, *reference sql, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getSelectOptions(), \sh);

            list args;
            sql = getSelectSqlIntern(sh, \args);

            SQLStatement stmt(ds);
            stmt.prepare(sql);
            execData(stmt, opt, args);

            return stmt;
        }

        #! returns an @ref Qore::SQL::SQLStatement "SQLStatement" object that will iterate the results of a select statement matching the arguments
        /** @par Example:
            @code
my SQLStatement $i = $table.getRowIterator();
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return an @ref Qore::SQL::SQLStatement "SQLStatement" object that will iterate the results of a select statement matching the arguments

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note
            - if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
            - the @ref Qore::SQL::SQLStatement "SQLStatement" object created by a successful call to this method acquires a thread resource for the underlying @ref Qore::SQL::AbstractDatasource "AbstractDatasource" object that must be released by calling @ref Qore::SQL::AbstractDatasource::commit() "commit()" or @ref Qore::SQL::AbstractDatasource::rollback() "rollback()", even if the statement does not acquire any database locks
         */
        Qore::SQL::SQLStatement getRowIterator(*hash sh, *hash opt) {
            return getRowIteratorIntern(sh, NOTHING, opt);
        }

        #! returns a hash representing the row in the table that matches the argument hash; if more than one row would be returned an exception is raised
        /** @par Example:
            @code
my *hash $h = $table.selectRow($sh);
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return a hash representing the row in the table that matches the argument hash; if more than one row would be returned an exception is raised

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint
            @throw DBI-SELECT-ROW-ERROR more than 1 row retrieved from the server

            @note if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
         */
        *hash selectRow(*hash sh, *reference sql) {
            validateOptionsIntern("OPTION-ERROR", getSelectOptions(), \sh);

            list args;
            sql = getSelectSqlUnlocked(sh, \args);
            
            return ds.vselectRow(sql, args);
        }

        #! returns a list of hashes representing the rows in the table that match the argument hash
        /** @par Example:
            @code
my *list $l = $table.selectRows($sh);
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return a list of hashes representing the rows in the table that match the argument hash

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
         */
        *list selectRows(*hash sh, *reference sql) {
            validateOptionsIntern("OPTION-ERROR", getSelectOptions(), \sh);

            list args;
            sql = getSelectSqlUnlocked(sh, \args);
            return ds.vselectRows(sql, args);
        }

        #! returns a hash of lists representing the columns and rows in the table that match the argument hahs
        /** @par Example:
            @code
my *hash $h = $table.select($sh);
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return a hash of lists representing the columns and rows in the table that match the argument hash

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
         */
        *hash select(*hash sh, *reference sql) {
            validateOptionsIntern("OPTION-ERROR", getSelectOptions(), \sh);

            list args;
            sql = getSelectSqlUnlocked(sh, \args);

            return ds.vselect(sql, args);
        }

        #! returns a hash representing the row in the table that matches the argument hash; if more than one row would be returned an exception is raised
        /** @par Example:
            @code
my *hash $h = $table.selectRow($sh);
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return a hash representing the row in the table that matches the argument hash; if more than one row would be returned an exception is raised

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint
            @throw DBI-SELECT-ROW-ERROR more than 1 row retrieved from the server

            @note if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
         */
        *hash selectRow(*hash sh, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getSelectOptions(), \sh);
            # check data callback options if any
            validateOptionsIntern("OPTION-ERROR", getSqlDataCallbackOptions(), \opt);

            list args;
            string sql = getSelectSqlUnlocked(sh, \args);
            
            if (opt.sqlarg_callback)
                opt.sqlarg_callback(sql, args);

            return ds.vselectRow(sql, args);
        }

        #! returns a list of hashes representing the rows in the table that match the argument hash
        /** @par Example:
            @code
my *list $l = $table.selectRows($sh);
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return a list of hashes representing the rows in the table that match the argument hash

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
         */
        *list selectRows(*hash sh, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getSelectOptions(), \sh);
            # check data callback options if any
            validateOptionsIntern("OPTION-ERROR", getSqlDataCallbackOptions(), \opt);

            list args;
            string sql = getSelectSqlUnlocked(sh, \args);

            if (opt.sqlarg_callback)
                opt.sqlarg_callback(sql, args);

            return ds.vselectRows(sql, args);
        }

        #! returns a hash of lists representing the columns and rows in the table that match the argument hahs
        /** @par Example:
            @code
my *hash $h = $table.select($sh);
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return a hash of lists representing the columns and rows in the table that match the argument hash

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
         */
        *hash select(*hash sh, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getSelectOptions(), \sh);
            # check data callback options if any
            validateOptionsIntern("OPTION-ERROR", getSqlDataCallbackOptions(), \opt);

            list args;
            string sql = getSelectSqlUnlocked(sh, \args);

            if (opt.sqlarg_callback)
                opt.sqlarg_callback(sql, args);

            return ds.vselect(sql, args);
        }

        #! returns the SQL string to be executed corresponding to the argument hash with an output parameter for the select bind arguments
        /** @par Example:
            @code
my list $args;
my string $sql = $table.getSelectSql($sh, \$args);
            @endcode

            @param sh a hash of conditions for the select statement; see @ref select_option_hash "select option hash" for information about this argument
            @param args an optional reference to a list for any bind arguments

            @return the SQL that can be used to execute a select on the database corresponding to the arguments; the select bind arguments are returned in an output parameter

            @throw OPTION-ERROR invalid or unsupported select option
            @throw SELECT-ERROR \c 'offset' supplied without \c 'orderby' or \c 'limit', \c 'orderby' with \c 'limit' and \c 'offset' does not match any unique constraint

            @note
            - the select string is specific to the arguments passed (for example @ref null arguments will have clauses like 'is null')
            - if \c "offset" is supplied and no \c "orderby" is supplied, then if any primary key exists, the primary key columns will be used for the \c "orderby" option automatically
         */
        string getSelectSql(*hash sh, *reference args) {
            validateOptionsIntern("OPTION-ERROR", getSelectOptions(), \sh);

            args = ();
            return getSelectSqlIntern(sh, \args);
        }

        *AbstractUniqueConstraint matchAnyUnique(list cols) {
            if (!manual)
                getPrimaryKeyUnlocked();
            if (!primaryKey.empty() && primaryKey.partialMatchKeys(cols))
                return primaryKey;
            if (!manual)
                getConstraintsUnlocked();
            foreach AbstractConstraint c in (constraints.iterator()) {
                if (c instanceof AbstractUniqueConstraint) {
                    AbstractUniqueConstraint uk = c;
                    if (uk.partialMatchKeys(cols))
                        return uk;
                }
            }
        }

        string getSelectSqlIntern(*hash qh, reference args) {            
            l.lock();
            l.unlock();

            return getSelectSqlUnlocked(qh, \args);
        }

        string getSelectSqlUnlocked(*hash qh, reference args) {            
            if (qh.offset) {
                if (!qh.orderby) {
                    # use primary key by default
                    getPrimaryKeyUnlocked();
                    if (!primaryKey.empty())
                        qh.orderby = primaryKey.keys();
                    else
                        throw "SELECT-ERROR", sprintf("%s: select 'offset' supplied (%d) but no 'orderby' and the table has no primary key", getName(), qh.offset);
                }
                if (!qh.limit)
                    throw "SELECT-ERROR", sprintf("%s: select 'offset' supplied (%d) without limit", getName(), qh.offset);
            }
            args = ();

            # make a hash of aliases to tables when using joins
            hash jch;
            map jch{$1.alias ? $1.alias : $1.table.getName()} = $1.table, qh.join.iterator();

            string cstr;
            # make query
            if (qh.columns) {
                getColumnsUnlocked();

                # column expressions
                list ce = ();
                foreach any cv in (qh.columns) {
                    switch (cv.typeCode()) {
                        case NT_STRING: {
                            ce += getColumnNameIntern(cv, jch, boolean(qh.join));
                            break;
                        }

                        case NT_HASH: {
                            ce += doColumnOperatorIntern(cv, jch, boolean(qh.join));
                            break;
                        }

                        default:
                            throw "SELECT-ERROR", sprintf("don't know how to parse argument type %y (value: %y) in column list, expecting \"string\" or \"hash\"", cv.type(), cv);
                    }
                }
                cstr = foldl $1 + "," + $2, ce.iterator();
            }
            else
                cstr = "*";

            string sql = sprintf("select %s from %s", cstr, getSelectSqlName(qh));

            # process join specifications
            foreach any js in (qh.join.iterator()) {
                hash jh;
                if (js.typeCode() == NT_HASH)
                    jh = js;
                else if (js instanceof AbstractTable)
                    jh.table = js;
                else if (js instanceof Table)
                    jh.table = js.getTable();
                else
                    throw "SELECT-ERROR", sprintf("don't know how to process join element of type %y; expecting a join hash, an AbstractTable object, or a Table object", js.type());

                AbstractTable t = jh.table;
                t.describe();

                string an = jh.alias ? jh.alias : t.getSqlName();

                AbstractTable jt;
                if (jh.ta) {
                    if (!jch{jh.ta})
                        throw "SELECT-ERROR", sprintf("can't join with unknown table/alias %y; known tables/aliases: %y", jh.ta, list(getName()) + jch.keys());
                    jt = jch{jh.ta};                    
                }
                else
                    jt = self;

                # set join table name
                string jtn;

                if (jt != self) {
                    jt.getPrimaryKey();
                    jt.getForeignConstraints();
                    jtn = jh.ta;
                }
                else {
                    getPrimaryKeyUnlocked();
                    getForeignConstraintsUnlocked();
                    jtn = getSqlName();
                }

                # create "join on" clause
                # the join clause expression list
                list jel = ();
                if (jh.jcols) {
                    if (jh.jcols.typeCode() != NT_HASH)
                        throw "SELECT-ERROR", sprintf("join clause error; expecting a hash assigned to the \"jcols\" key; got %y instead", jh.jcols.type());
                    foreach hash jmh in (jh.jcols.pairIterator()) {
                        if (!jt.columns.hasKey(jmh.key))
                            throw "SELECT-ERROR", sprintf("cannot join on unknown column %y.%y; known columns: %y", jt.getSqlName(), jmh.key, jt.columns.keys());
                        if (!t.describe().hasKey(jmh.value))
                            throw "SELECT-ERROR", sprintf("cannot join on unknown column %y.%y; known columns: %y", t.getSqlName(), jmh.value, t.columns.keys());
                        jel += sprintf("%s.%s = %s.%s", jtn, jmh.key, an, jmh.value);
                    }
                }
                else {
                    *hash fkh;
                    if (!jt.primaryKey.empty()) {
                        # see if there is a foreign constraint from table -> pk of self
                        fkh = t.getForeignConstraints().findConstraintOn(jt.name, jt.primaryKey.keys());
                        if (fkh) {
                            AbstractIterator pki = jt.primaryKey.keyIterator();
                            AbstractIterator fki = fkh.keyIterator();
                            while (pki.next() && fki.next())
                                jel += sprintf("%s.%s = %s.%s", jtn, pki.getValue(), an, fki.getValue());
                        } 
                    }
                    if (!fkh) {
                        # see if there is a foreign constraint in self -> pk of table
                        if (!jt.foreignConstraints.empty()) {
                            AbstractPrimaryKey pk = t.getPrimaryKey();
                            if (!pk.empty()) {
                                fkh = jt.foreignConstraints.findConstraintOn(t.getName(), pk.keys());
                                if (fkh) {
                                    AbstractIterator fki = fkh.keyIterator();
                                    AbstractIterator pki = pk.keyIterator();
                                    while (pki.next() && fki.next())
                                        jel += sprintf("%s.%s = %s.%s", jtn, fki.getValue(), an, pki.getValue());
                                }
                            }
                        }

                        if (!fkh)
                            throw "SELECT-ERROR", sprintf("cannot perform a %s join from %s on %s without a column specification since neither table has a foreign constraint on the primary key of the other table", jh.jop, jt.getSqlName(), t.getSqlName());
                    }
                }

                # process any additional join conditions
                if (jh.cond)
                    jel += jt.getWhereClauseIntern(jh.cond, \args, an);

                sql += sprintf(" %s join %s%s on (%s)", JopMap{jh.jop}, t.getSelectSqlName(jh.opt), jh.alias ? (" " + jh.alias) : "", (foldl $1 + " and " + $2, jel));
            }

            getSelectWhereSqlUnlocked(\sql, \args, qh, jch, boolean(qh.join));
            if (qh.orderby) {
                if (qh.offset || qh.limit) {
                    if (!matchAnyUnique(qh.orderby))
                        throw "SELECT-ERROR", sprintf("%s: 'orderby': %y with 'offset' = %d does not match any unique constraint", getName(), qh.orderby, qh.offset);

                    doSelectOrderByWithOffsetSqlUnlockedImpl(\sql, \args, qh);
                }
                else
                    doSelectOrderBySqlUnlocked(\sql, \args, qh);
            }
            else if (qh.limit)
                doSelectLimitOnlyUnlockedImpl(\sql, \args, qh);

            if (qh.groupby) {
                list gbe = map getColumnNameIntern($1, jch, boolean(qh.join)), qh.groupby;
                sql += " group by " + (foldl $1 + "," + $2, gbe.iterator());
            }

            if (qh.having) {
                getColumnsUnlocked();
                hash cm = getColumnOperatorMap();

                list hl = ();

                foreach hash hh in (qh.having.pairIterator()) {
                    if (hh.value.typeCode() != NT_LIST)
                        throw "SELECT-ERROR", sprintf("expecting a list argument to the \"having\" condition for column %y; got type %y instead (value: %y)", hh.key, hh.value.type(), hh.value);
                    if (hh.value[0].typeCode() != NT_STRING)
                        throw "SELECT-ERROR", sprintf("expecting a string argument to the \"having\" condition in the first position giving the column operator code for column %y; got type %y instead (value: %y)", hh.key, hh.value[0].type(), hh.value[0]);

                    string hstr = doColumnOperatorIntern(hh.value[0], NOTHING, getColumnExpressionIntern(hh.key, jch, boolean(qh.join)), cm);
                    hl += doWhereExpressionIntern(hstr, hh.value[1], \args);
                }
                if (hl)
                    sql += " having " + (foldl $1 + " and " + $2, hl);
            }
            #printf("SQL: %s\nargs: %y\n", sql, args);
            return sql;
        }

        private string getSelectSqlName(*hash qh) {
            return getSqlName();
        }

        private string getColumnExpressionIntern(any cvc, *hash jch, bool join) {
            switch (cvc.typeCode()) {
                case NT_HASH:
                    return doColumnOperatorIntern(cvc, jch, join);
                case NT_STRING:
                    return getColumnNameIntern(cvc, jch, join);
            }
            throw "SELECT-ERROR", sprintf("column operator hash %y has an invalid \"column\" key; expecting a string column specification or a column operator description hash", cvc);
        }

        private string doColumnOperatorIntern(hash cvc, *hash jch, bool join) {
            return doColumnOperatorIntern(cvc.cop, cvc.arg, (cvc.column ? getColumnExpressionIntern(cvc.column, jch, join) : NOTHING), getColumnOperatorMap());
        }

        private string doColumnOperatorIntern(any cop, any arg, *string cve, hash cm) {
            if (cop.typeCode() != NT_STRING)
                throw "SELECT-ERROR", sprintf("invalid column operator code %y", cop);

            *hash cmd = cm{cop};
            if (!cmd)
                throw "SELECT-ERROR", sprintf("unknown column operator %y: expecting one of: %y", cop, cm.keys());

            if (cmd.arg) {
                string at = arg.type();
                switch (cmd.arg) {
                    default: {
                        if (at != cmd.arg)
                            throw "SELECT-ERROR", sprintf("invalid argument to column operator %y; got type %y, expecting %y", cop, at, cmd.arg);
                    }
                }
            }

            if (cmd.sqlvalue)
                arg = getSqlValue(arg);

            if (!cve && !cmd.nocolumn)
                throw "SELECT-ERROR", sprintf("column operator %y requires a column argument name but none was provided", cop);

            return cmd.code(cve, arg);
        }

        private string getColumnNameIntern(string cv, *hash jch, bool join) {
            Columns cols;
            # see if we have a table.column spec
            *string tp = (cv =~ x/(\w+)\.\w+/)[0];
            if (tp) {
                if (!jch{tp})
                    throw "SELECT-ERROR", sprintf("query references unknown alias %y in %y; known aliases in this query: %y", tp, cv, jch.keys());
                cols = jch{tp}.describe();
                splice cv, 0, tp.size() + 1;
            }
            else {
                cols = columns;
                tp = getSqlName();
            }

            if (cv != "*" && !cols.hasKey(cv))
                throw "SELECT-ERROR", sprintf("query references unknown column %y.%y; known columns: %y", tp, cv, cols.keys());
            return join ? sprintf("%s.%s", tp, cv) : cv;
        }

        private getSelectWhereSqlUnlocked(reference sql, reference args, *hash qh, *hash jch, bool join = False) {
            if (qh."where")
                sql += getWhereClauseUnlocked(qh."where", \args, NOTHING, jch, join);
        }

        private *string getWhereClause(*hash cond, reference args, *string cprefix, *hash jch, bool join = False) {
            l.lock();
            on_exit l.unlock();
            return getWhereClauseUnlocked(cond, \args, cprefix, jch, join);
        }

        private *string getWhereClause(list cond, reference args, *string cprefix, *hash jch, bool join = False) {
            l.lock();
            on_exit l.unlock();
            return getWhereClauseUnlocked(cond, \args, cprefix, jch, join);
        }

        private *string getWhereClauseUnlocked(list cond, reference args, *string cprefix, *hash jch, bool join = False) {
            getColumnsUnlocked();
            list al = ();
            if (!exists args)
                args = ();
            foreach hash ch in (cond) {
                *list wl = getWhereClauseIntern(ch, \args, cprefix, jch, join);
                if (wl)
                    al += "(" + (foldl $1 + " and " + $2, wl) + ")";
            }
            if (al)
                return " where " + (foldl $1 + " or " + $2, al);
        }

        private *string getWhereClauseUnlocked(*hash cond, reference args, *string cprefix, *hash jch, bool join = False) {
            getColumnsUnlocked();
            if (!exists args)
                args = ();
            *list wl = getWhereClauseIntern(cond, \args, cprefix, jch, join);
            if (wl)
                return " where " + (foldl $1 + " and " + $2, wl);
        }

        private *list getWhereClauseIntern(*hash cond, reference args, *string cprefix, *hash jch, bool join = False) {
            if (!cond)
                return;

            list wl = ();
            foreach hash h in (cond.pairIterator()) {
                string cn = cprefix ? sprintf("%s.%s", cprefix, h.key) : getColumnNameIntern(h.key, jch, join);
                wl += doWhereExpressionIntern(cn, h.value, \args);
            }

            return wl;
        }

        private string doWhereExpressionIntern(string cn, any we, reference args) {
            int wt = we.typeCode();
            if (wt == NT_HASH) {
                if (!we.op)
                    throw "WHERE-ERROR", sprintf("argument to key %y is a hash without an \"op\" key: %y", cn, we);

                hash wm = getWhereOperatorMap();

                *hash cmd = wm{we.op};
                if (!cmd)
                    throw "WHERE-ERROR", sprintf("operator hash for key %y hash unknown operator %y: expecting one of: %y (operator hash: %y)", cn, we.op, wm.keys(), we);

                if (cmd.recursive) {
                    cn = doWhereExpressionIntern(cn, we.arg, \args);
                    delete we.arg;
                }

                return cmd.code(self, cn, we.arg, \args);
            }
            if (we === NULL || !exists we)
                return sprintf("%s is null", cn);
            args += we;
            return sprintf("%s = %v", cn);
        }

        private doSelectOrderBySqlUnlocked(reference sql, reference args, *hash qh) {
            sql += " order by " + (foldl $1 + "," + $2, qh.orderby);
            if (qh.desc)
                sql += " desc";
        }

        #! deletes rows in the table matching the condition and returns the count of rows deleted; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my int $dcnt = $table.del(("name": $name));
            @endcode

            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return the count of rows deleted

            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see delNoCommit(*hash)
         */
        int del(*hash cond, *reference sql) {
            on_success ds.commit();
            on_error ds.rollback();

            return delNoCommit(cond, \sql);
        }

        #! deletes rows in the table matching the condition and returns the count of rows deleted; no transaction management is performed with this method
        /** @par Example:
            @code
my int $dcnt = $table.delNoCommit(("name": $name));
            @endcode

            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return the count of rows deleted

            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see del(*hash)
         */
        int delNoCommit(*hash cond, *reference sql) {
            return delNoCommitIntern(cond, \sql);
        }

        private int delNoCommitIntern(*hash cond, *reference sql, *hash opt) {
            # make query
            sql = sprintf("delete from %s", getSqlName());
            list args;
            if (cond)
                sql += getWhereClause(cond, \args);

            return execData(opt, sql, args);
        }

        #! updates rows in the table matching an optional condition and returns the count of rows updated; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my int $ucnt = $table.update(("id": $id), ("name": $name));
            @endcode

            @param set the hash of values to set, key values are column names, hash values are the values to assign to those columns or update operators (see @ref sql_uop_funcs)
            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return the count of rows updated

            @throw UPDATE-ERROR the set hash is empty
            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see updateNoCommit()
         */
        int update(hash set, *hash cond, *reference sql) {
            on_success ds.commit();
            on_error ds.rollback();

            return updateNoCommitIntern(set, cond, \sql);
        }

        #! updates rows in the table matching an optional condition and returns the count of rows updated; no transaction management is performed with this method
        /** @par Example:
            @code
my int $ucnt = $table.updateNoCommit(("id": $id), ("name": $name));
            @endcode

            @param set the hash of values to set, key values are column names, hash values are the values to assign to those columns or update operators (see @ref sql_uop_funcs)
            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param sql an optional reference to a string to return the SQL generated for the select statement

            @return the count of rows updated

            @throw UPDATE-ERROR the set hash is empty
            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see update()
         */
        int updateNoCommit(hash set, *hash cond, *reference sql) {
            return updateNoCommitIntern(set, cond, \sql);
        }

        private int updateNoCommitIntern(hash set, *hash cond, *reference sql, *hash opt) {
            # make query
            sql = sprintf("update %s set ", getSqlName());

            if (!set)
                throw "UPDATE-ERROR", "the set hash is empty";

            list args;

            list sl = ();
            foreach hash h in (set.pairIterator()) {
                string exp = sprintf("%s = ", h.key);
                if (h.value.typeCode() == NT_HASH)
                    exp += getUpdateExpression(h.key, h.value);
                else {
                    exp += "%v";
                    args += h.value;
                }
                sl += exp;
            }

            sql += foldl $1 + "," + $2, sl;

            if (cond)
                sql += getWhereClause(cond, \args);

            #printf("sql: %y\nargs: %y\n", sql, args);
            return execData(opt, sql, args);
        }

        #! deletes rows in the table matching the condition and returns the count of rows deleted; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my int $dcnt = $table.del(("name": $name));
            @endcode

            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return the count of rows deleted

            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see delNoCommit(*hash)
         */
        int del(*hash cond, *hash opt) {
            on_success ds.commit();
            on_error ds.rollback();

            return delNoCommitIntern(cond, NOTHING, opt);
        }

        #! deletes rows in the table matching the condition and returns the count of rows deleted; no transaction management is performed with this method
        /** @par Example:
            @code
my int $dcnt = $table.delNoCommit(("name": $name));
            @endcode

            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return the count of rows deleted

            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see del(*hash)
         */
        int delNoCommit(*hash cond, *hash opt) {
            return delNoCommitIntern(cond, NOTHING, opt);
        }

        #! updates rows in the table matching an optional condition and returns the count of rows updated; the transaction is committed if successful, if an error occurs then it is rolled back
        /** @par Example:
            @code
my int $ucnt = $table.update(("id": $id), ("name": $name));
            @endcode

            @param set the hash of values to set, key values are column names, hash values are the values to assign to those columns or update operators (see @ref sql_uop_funcs)
            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return the count of rows updated

            @throw UPDATE-ERROR the set hash is empty
            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see updateNoCommit()
         */
        int update(hash set, *hash cond, *hash opt) {
            on_success ds.commit();
            on_error ds.rollback();

            return updateNoCommitIntern(set, cond, NOTHING, opt);
        }

        #! updates rows in the table matching an optional condition and returns the count of rows updated; no transaction management is performed with this method
        /** @par Example:
            @code
my int $ucnt = $table.updateNoCommit(("id": $id), ("name": $name));
            @endcode

            @param set the hash of values to set, key values are column names, hash values are the values to assign to those columns or update operators (see @ref sql_uop_funcs)
            @param cond a hash of conditions for the where clause; see @ref where_clauses for more information
            @param opt optional SQL data operation callback options; see @ref AbstractTable::SqlDataCallbackOptions for more info

            @return the count of rows updated

            @throw UPDATE-ERROR the set hash is empty
            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @see update()
         */
        int updateNoCommit(hash set, *hash cond, *hash opt) {
            return updateNoCommitIntern(set, cond, NOTHING, opt);
        }
        
        private string getUpdateExpression(string col, hash uh) {
            hash um = getUpdateOperatorMap();

            *hash cmd = um{uh.uop};
            if (!cmd)
                throw "UPDATE-ERROR", sprintf("unknown update operator %y in %y: expecting one of: %y", uh.uop, uh, um.keys());

            if (cmd.arg) {
                string at = uh.arg.type();
                switch (cmd.arg) {
                    default: {
                        if (at != cmd.arg)
                            throw "UPDATE-ERROR", sprintf("invalid argument to update operator %y; got type %y, expecting %y", uh.uop, at, cmd.arg);
                    }
                }
            }

            if (cmd.sqlvalue)
                uh.arg = getSqlValue(uh.arg);

            string arg = (uh.nest ? getUpdateExpression(col, uh.nest) : col);

            return cmd.code(arg, uh.arg);
        }

        private bool emptyDataUnlocked() {
            list args;
            string sql = getSelectSqlUnlocked(("limit": 1), \args);
            return boolean(ds.vselectRow(sql, args));
        }

        private code getUpsertClosureUnlocked(hash row, int upsert_strategy = UpsertAuto) {
            if (upsert_strategy == UpsertAuto)
                upsert_strategy = emptyDataUnlocked() ? UpsertInsertFirst : UpsertUpdateFirst;

            # unique column source
            string csrc;

            # get unique columns
            Columns cols = getUpsertColumns(\csrc);

            # column list: make sure all columns in the key are used and have a value
            list cl = ();
            foreach string k in (row.keyIterator()) {
                if (!columns{k})
                    throw "COLUMN-ERROR", sprintf("%s.%s is not a valid column (valid columns: %y)", name, k, columns.keys());
                if (cols.hasKey(k))
                    cl += k;
            }

            # if not all columns of the unique constraint are used, then throw an exception
            if (cl.size() != cols.size())
                throw "UPSERT-ERROR", sprintf("not all columns from %s are used in the upsert statement; required: %y; used: %y", csrc, columns.keys(), cl);

            # use UpsertSelectFirst if the row size == the key size (ie only key values are used)
            if (cols.size() == row.size())
                upsert_strategy = UpsertSelectFirst;

            switch (upsert_strategy) {
                case UpsertInsertFirst:
                    return getUpsertInsertFirst(cols, row);

                case UpsertUpdateFirst:
                    return getUpsertUpdateFirst(cols, row);

                case UpsertSelectFirst:
                    return getUpsertSelectFirst(cols, row);
            }

            throw "UPSERT-ERROR", sprintf("invalid upsert code: %d", upsert_strategy);
        }

        private code getUpsertInsertFirst(Columns cols, hash example_row) {
            string insert_sql = getUpsertInsertSql(example_row);
            list updc = ();
            string update_sql = getUpsertUpdateSql(example_row, cols, \updc);

            return int sub (hash row) {
                if (tryInsertImpl(insert_sql, row))
                    return UR_Inserted;

                tryUpdate(update_sql, row, cols, updc);
                return UR_Verified;            
            };
        }

        private code getUpsertUpdateFirst(Columns cols, hash example_row) {
            list updc = ();
            string update_sql = getUpsertUpdateSql(example_row, cols, \updc);
            string insert_sql = getUpsertInsertSql(example_row);

            return int sub (hash row) {
                if (tryUpdate(update_sql, row, cols, updc))
                    return UR_Verified;
                
                ds.vexec(insert_sql, row.values());
                return UR_Inserted;
            };
        }

        private code getUpsertSelectFirst(Columns cols, hash example_row) {
            #printf("getUpsertSelectFirst() %s: %y\n", name, cols.keys()); 
            list updc = ();
            string select_sql = getUpsertSelectSql(example_row, cols, \updc);
            string insert_sql = getUpsertInsertSql(example_row);
            string update_sql = getUpsertUpdateSql(example_row, cols, \updc);

            return int sub (hash row) {
                list args = row.(cols.keys()).values();
                #printf("select_sql: %s args: %y\n", select_sql, args);
                *hash dbrow = ds.vselectRow(select_sql, args);
                if (!dbrow) {
                    ds.vexec(insert_sql, row.values());
                    return UR_Inserted;
                }
                if (dbrow == row{updc})
                    return UR_Unchanged;

                #printf("dbrow: %y row{%y}: %y\n", dbrow, updc, row{updc});

                tryUpdate(update_sql, row, cols, updc);
                return UR_Updated;
            };
        }

        private Columns getUpsertColumns(reference csrc) {
            getColumnsUnlocked();
            getPrimaryKeyUnlocked();

            Columns cols;

            if (!primaryKey.empty()) {
                cols = primaryKey;
                csrc = sprintf("primary key %s", primaryKey.getName());
            }
            else {
                getConstraintsUnlocked();
                # find first unique constraint
                foreach AbstractConstraint c in (constraints.iterator()) {
                    if (c instanceof AbstractUniqueConstraint) {
                        cols = cast<AbstractUniqueConstraint>(c);
                        csrc = sprintf("unique constraint %s", c.getName());
                        break;
                    }
                }
                if (!cols) {
                    getIndexesUnlocked();
                    foreach AbstractIndex ix in (indexes.iterator()) {
                        if (ix.unique) {
                            cols = ix.columns;
                            csrc = sprintf("unique index %s", ix.name);
                            break;
                        }
                    }

                    if (!cols)
                        throw "UPSERT-ERROR", sprintf("cannot perform an upsert on %s because it has no primary key, unique constraint, or unique index", name);
                }
            }

            return cols;
        }

        private string getUpsertSelectSql(hash row, Columns cols, reference updc) {
            if (cols.size() != row.size()) {
                # make list of columns not in unique key
                map updc += $1, row.keyIterator(), !cols.hasKey($1);
            }
            else
                updc = cols.keys();

            return sprintf("select %s from %s where %s", 
                           (foldl $1 + "," + $2, updc),
                           getSqlName(),
                           (foldl $1 + " and " + $2, (map sprintf("%s = %v", $1), cols.keyIterator()))
                );            
        }

        private string getUpsertInsertSql(hash row) {
            string sql = sprintf("insert into %s (", getSqlName());
            sql += (foldl $1 + "," + $2, row.keyIterator());
            sql += ") values (";
            sql += (foldl $1 + "," + $2, (map "%v", row.keyIterator()));
            sql += ")";
            return sql;
        }

        private string getUpsertUpdateSql(hash row, Columns cols, reference updc) {
            # make list of columns not in unique key if necessary
            if (!updc)
                map updc += $1, row.keyIterator(), !cols.hasKey($1);

            # make sql
            string sql = sprintf("update %s set ", getSqlName());
            sql += foldl $1 + "," + $2, (map sprintf("%s = %v", $1), updc);
            sql += " where ";
            sql += foldl $1 + " and " + $2, (map sprintf("%s = %v", $1), cols.keyIterator());

            return sql;
        }

        private softbool tryUpdate(string sql, hash row, Columns cols, list updc) {
            list args = row{updc}.values() + row{cols.keys()}.values();
            #printf("sql: %s args: %y\n", sql, args);
            return ds.vexec(sql, args);
        }

        private checkValue(string cname, string argname, reference val, string type) {
            if (val === NULL) {
                delete val;
                return;
            }
                
            switch (type) {
                case Type::Int: {
                    if (!val.intp())
                        throw "COLUMN-ERROR", sprintf("%s.%s: %s has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                    if (val.type() != type)
                        val = val.toInt();
                    break;
                }
                case Type::Float: {
                    if (!val.intp())
                        throw "COLUMN-ERROR", sprintf("%s.%s: %s has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                    if (val.type() != type)
                        val = val.toFloat();
                    break;
                }
                case Type::Number: {
                    if (!val.intp())
                        throw "COLUMN-ERROR", sprintf("%s.%s: %s has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                    if (val.type() != type)
                        val = number(val);
                    break;
                }
                case Type::Boolean: {
                    if (!val.intp())
                        throw "COLUMN-ERROR", sprintf("%s.%s: %s has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                    if (val.type() != type)
                        val = val.toBool();
                    break;
                }
                case Type::String: {
                    if (!val.strp())
                        throw "COLUMN-ERROR", sprintf("%s.%s: %s has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                    if (val.type() != type)
                        val = val.toString();
                    break;
                }
              default: {
                  if (val.type() != type)
                      throw "COLUMN-ERROR", sprintf("%s.%s: %s value for has type %y, expecting %y (value: %y)", name, cname, argname, val.type(), type, val);
                  break;
                }
            }
        }

        #! returns an SQL string corresponding to the list of commands in the argument
        /** @par Example:
            @code
my string $sql = $t.getSqlFromList($list);
            @endcode

            @param l a list of SQL commands
            
            @return an SQL string corresponding to the list of commands in the argument
        */
        string getSqlFromList(list l) {
            return getCreateSqlImpl(l);
        }

        #! returns a string for use in SQL queries representing the DB-specific value of the argument
        /** @par Example:
            @code
my string $str = $table.getSqlValue($date);
            @endcode

            @param v the value to convert to an SQL value

            @return a string representing the value usable in SQL strings for the given database driver

            @throw VALUE-ERROR the given value cannot be converted to an SQL string (missing rules for value)
         */
        string getSqlValue(any v) {
            *string str = getSqlValueImpl(v);
            if (!exists str)
                throw "VALUE-ERROR", sprintf("class %s cannot convert type %y to an SQL string (value: %y)", self.className(), v.type(), v);

            return str;
        }
        
        #! returns the name of the table
        string getName() {
            return name;
        }

        #! reads in all attributes of the table from the database
        /** @par Example:
            @code
$table.cache();
            @endcode

            @param opts cache options; see @ref SqlUtil::AbstractTable::CacheOptions for common options; each driver can support additional driver-specific options
        */
        cache(*hash opts) {
            l.lock();
            on_exit l.unlock();
            cacheUnlocked(opts);
        }

        #! purges the current table definition
        /** @par Example:
            @code
$table.clear();
            @endcode
        */
        clear() {
            l.lock();
            on_exit l.unlock();

            delete columns;
            delete primaryKey;
            delete foreignConstraints;
            delete constraints;
            delete indexes;
            delete triggers;

            clearImpl();
        }

        #! returns an object of class Columns describing the table
        /** @par Example:
            @code
my hash $h = $table.describe();
            @endcode

            @return an object of class Columns describing the table
        */
        Columns describe() {
            l.lock();
            on_exit l.unlock();
            getColumnsUnlocked();
            return columns;
        }

        #! returns an object of class AbstractPrimaryKey describing the primary key of the table
        /** If there is no primary key then the object returned will be empty (see @ref SqlUtil::AbstractPrimaryKey::empty())

            @par Example:
            @code
            @endcode

            @return an object of class AbstractPrimaryKey describing the primary key of the table
        */
        *AbstractPrimaryKey getPrimaryKey() {
            l.lock();
            on_exit l.unlock();
            getPrimaryKeyUnlocked();
            return primaryKey;
        }

        #! returns the given AbstractUniqueConstraint object if defined for the table (also includes the primary key)
        /** @par Example:
            @code
my *AbstractUniqueConstraint uk = $table.findUniqueConstraint("uk_table2");
            @endcode

            @param name the name of the unique constraint to find

            @return the given AbstractUniqueConstraint object if defined for the table (also includes the primary key)
        */
        *AbstractUniqueConstraint findUniqueConstraint(string name) {
            l.lock();
            on_exit l.unlock();

            return findUniqueConstraintUnlocked(name);
        }

        *AbstractUniqueConstraint findUniqueConstraintUnlocked(string name) {
            getPrimaryKeyUnlocked();
            getConstraintsUnlocked();
            if (primaryKey && primaryKey.getName() == name)
                return primaryKey;

            return constraints.hasKey(name) && constraints{name} instanceof AbstractUniqueConstraint ? constraints{name} : NOTHING;
        }

        #! returns an object of class Indexes describing the indexes on the table
        /** If there are no indexes on the table then the object returned will be empty (see @ref SqlUtil::Indexes::empty())

            @par Example:
            @code
my Indexes $ix = $table.getIndexes();
            @endcode

            @return an object of class Indexes describing the indexes on the table
        */
        Indexes getIndexes() {
            l.lock();
            on_exit l.unlock();
            getIndexesUnlocked();
            return indexes;
        }

        #! returns a ForeignConstraints object describing the foreign constraints that the table has on other tables
        ForeignConstraints getForeignConstraints(*hash opt) {
            l.lock();
            on_exit l.unlock();
            getForeignConstraintsUnlocked(opt);
            return foreignConstraints;
        }

        #! returns a Constraints object describing the non-foreign constraints on the table
        Constraints getConstraints() {
            l.lock();
            on_exit l.unlock();
            getConstraintsUnlocked();
            return constraints;
        }

        #! returns an object of class Triggers describing the triggers on the table
        /** If there are no triggers on the table then the object returned will be empty (see @ref SqlUtil::Triggers::empty())

            @par Example:
            @code
my Triggers $trig = $table.getTriggers();
            @endcode

            @return an object of class Triggers describing the triggers on the table
        */
        Triggers getTriggers() {
            l.lock();
            on_exit l.unlock();
            getTriggersUnlocked();
            return triggers;
        }

        #! returns an SQL string that could be used to rename the table in the database
        /** @par Example:
            @code
my string $sql = $table.getRenameSql("new_name");
            @endcode

            @param new_name the new name for the table
            @param opt a hash of options for the SQL string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that could be used to rename the table in the database

            @throw OPTION-ERROR invalid or unsupported option passed

            @note If the @ref sql_callback_executed "sql_callback_executed option key" is @ref Qore::True "True", this method also renames the object internally (see @ref sql_callback_executed for more information), additionally if the \c "db_table_cache" option key is assigned to a @ref SqlUtil::Tables "Tables" argument, then the table cache is also updated with the name change in this case

            @see 
            - rename()
            - inDb() for a method that tells if the table is already in the database or not
         */
        string getRenameSql(string new_name, *hash opt) {
            validateOptionsIntern("OPTION-ERROR", getAlignTableOptions(), \opt);

            l.lock();
            on_exit l.unlock();

            on_success if (opt.sql_callback_executed)
                doRenameIntern(new_name, opt.db_table_cache);

            return AbstractDatabase::doCallback(opt, getRenameSqlImpl(new_name), AbstractDatabase::AC_Rename, "table", name, NOTHING, new_name);
        }

        #! returns an SQL string that could be used to create the table and all known properties of the table
        /** @par Example:
            @code
printf("%s\n", $table.getCreateSql());
            @endcode

            @param opt a hash of options for the SQL creation string

            @return an SQL string that could be used to create the table and all known properties of the table
        */
        string getCreateSqlString(*hash opt) {
            l.lock();
            on_exit l.unlock();

            if (!manual)
                cacheUnlocked(opt);

            return getCreateSqlImpl(getCreateSqlUnlocked(opt));
        }

        #! returns a list of SQL strings that could be used to create the table and all known properties of the table
        /** @par Example:
            @code
map printf("$1;\n", $1), $table.getCreateSql();
            @endcode

            @param opt a hash of options for the table, index, and constraint creation strings; see @ref TableCreationOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings that could be used to create the table and all known properties of the table
        */
        list getCreateSql(*hash opt) {
            l.lock();
            on_exit l.unlock();
            if (!manual)
                cacheUnlocked(opt);
            return getCreateSqlUnlocked(opt, False);
        }

        #! returns an SQL string that could be used to create the basic table structure without indexes and constraints 
        /** @par Example:
            @code
my string $sql = $table.getCreateTableSql();
            @endcode

            @param opt a hash of options for the table creation string; see @ref TableCreationOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that could be used to create the basic table structure without indexes and constraints 

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        string getCreateTableSql(*hash opt) {
            validateOptionsIntern("OPTION-ERROR", getTableCreationOptions(), \opt);
            l.lock();
            on_exit l.unlock();
            return getCreateTableSqlUnlocked(opt);
        }

        #! returns @ref Qore::True "True" if the table exists in the database, @ref Qore::False "False" if not
        bool checkExistence() {
            l.lock();
            on_exit l.unlock();
            if (inDb)
                return True;
            return checkExistenceImpl();
        }

        #! accepts an AbstractTable argument and returns a list of SQL strings required to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty list is returned
        /** @par Example:
            @code
my list $l = $table.getAlignSql($table2);
            @endcode

            @param t the template table that the current table will be compared to
            @param opt a hash of options for the SQL creation string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return a list of SQL strings required to align the structure and configuration of the current table with that of the AbstractTable argument; if the tables are identical then an empty list is returned

            @throw ALIGN-TABLE-ERROR the argument must be of the same class as the current object; template table has no columns
            @throw OPTION-ERROR invalid or unsupported option passed

            @note if the @ref sql_callback_executed "sql_callback_executed option" is @ref Qore::True "True" in \a opt, then the changes are also effected in the current object, if not, then they are not (see @ref sql_callback_executed for more information)
        */
        list getAlignSql(AbstractTable t, *hash opt) {
            if (self.className() != t.className())
                throw "ALIGN-TABLE-ERROR", sprintf("cannot align table %y of class %y with table %y of class %y", name, self.className(), t.name, t.className());

            hash ato = getAlignTableOptions();

            validateOptionsIntern("OPTION-ERROR", ato, \opt);

            l.lock();
            on_exit l.unlock();
            # lock "template" table
            t.l.lock();
            on_exit t.l.unlock();
            
            # cache tables if not already cached
            if (!t.manual)
                t.cacheUnlocked(opt);

            if (!manual) {
                # if the table does not exist, then just return the create table strings for the template table
                if (!checkExistenceImpl())
                    return t.getCreateSqlUnlocked(opt, False);

                # use db_table_cache for table_cache when caching DB objects
                *hash db_opt = opt;
                db_opt.table_cache = remove db_opt.db_table_cache;
                cacheUnlocked(db_opt);
            }

            if (!t.columns || t.columns.empty())
                throw "ALIGN-TABLE-ERROR", sprintf("cannot align table %y with table %y: table %y has no columns", name, t.name, t.name);

            if (!columns)
                columns = new Columns();

            AbstractTable this = opt.sql_callback_executed ? self : self.copy();

            return this.getAlignSqlUnlocked(t, opt);
        }

        private list getAlignSqlUnlocked(AbstractTable t, *hash opt) {
            list l = ();

            # check name
            if (name != t.name) {
                l += AbstractDatabase::doCallback(opt, getRenameSql(t.name), AbstractDatabase::AC_Rename, "table", name, NOTHING, t.name);
                name = t.name;
            }

            # process column_map: rename columns
            foreach hash rh in (opt.column_map.pairIterator()) {
                if (columns.hasKey(rh.key)) {
                    #printf("%s rename %s -> %s cols: %y\n", name, rh.key, rh.value, columns.keys());
                    AbstractColumn c = columns{rh.key};
                    l += AbstractDatabase::doCallback(opt, c.getRenameSql(self, rh.value), AbstractDatabase::AC_Rename, "column", c.name, name, rh.value);
                    columns.renameKey(rh.key, rh.value);
                    c.name = rh.value;

                    # rename column in indexes
                    foreach AbstractIndex ix in (indexes.iterator()) {
                        if (ix.columns.hasKey(rh.key)) {
                            #printf("%s.%s: col %y %N\n", getName(), ix.name, rh.key, ix.columns);
                            AbstractColumn rc = ix.columns{rh.key};
                            rc.name = rh.value;
                            ix.columns.renameKey(rh.key, rh.value);
                        }
                    }
                    # rename column in pk
                    if (primaryKey.hasKey(rh.key)) {
                        AbstractColumn rc = primaryKey{rh.key};
                        rc.name = rh.value;
                        primaryKey.renameKey(rh.key, rh.value);
                    }
                    # rename column in unique constraints
                    foreach AbstractConstraint ct in (constraints.iterator()) {
                        if (ct instanceof AbstractUniqueConstraint) {
                            AbstractUniqueConstraint uk = ct;
                            if (uk.hasKey(rh.key)) {
                                AbstractColumn rc = uk{rh.key};
                                rc.name = rh.value;
                                uk.renameKey(rh.key, rh.value);
                            }
                        }
                    }
                    # rename column in foreign constraints
                    foreach AbstractForeignConstraint fk in (foreignConstraints.iterator()) {
                        if (fk.columns.hasKey(rh.key)) {
                            AbstractColumn rc = fk.columns{rh.key};
                            rc.name = rh.value;
                            fk.columns.renameKey(rh.key, rh.value);
                        }
                    }
                }
            }

            # before modifying columns, rename indexes constraints and drop any excess indexes and constraints
            # process index_map: rename indexes
            foreach hash rh in (opt.index_map.pairIterator()) {
                if (indexes.hasKey(rh.key)) {
                    AbstractIndex ix = indexes{rh.key};
                    l += AbstractDatabase::doCallback(opt, ix.getRenameSql(getSqlName(), rh.value), AbstractDatabase::AC_Rename, "index", ix.name, name, rh.value);
                    renameIndexUnlocked(ix, rh.value);
                }
            }

            # check for indexes with different names than in the template and rename them automatically
            foreach AbstractIndex ix in (indexes.iterator()) {
                if (!t.indexes.hasKey(ix.name)
                    && t.indexes
                    && (*AbstractIndex other = t.indexes.findEqual(ix))
                    && !indexes.hasKey(other.name)) {
                    # rename index
                    l += AbstractDatabase::doCallback(opt, ix.getRenameSql(getSqlName(), other.name), AbstractDatabase::AC_Rename, "index", ix.name, name, other.name);
                    renameIndexUnlocked(ix, other.name);
                }
            }

            # check for indexes not in the template and drop them
            foreach AbstractIndex ix in (indexes.iterator()) {
                if (!t.indexes.hasKey(ix.name)) {
                    # make sure there is no unique constraint or primary key for the unique index if the "index" option is supported
                    # in which case update the constraint to be based on the index and do not drop the index
                    if (ix.unique) {
                        if (t.primaryKey && t.primaryKey.matchKeys(ix.columns)) {
                            if (t.primaryKey.setIndexBase(ix.name)) {
                                ix.setSupportingConstraint(primaryKey);
                                continue;
                            }
                        }
                        else {
                            # see if a unique constraint with the same name and columns exists
                            if (t.constraints.hasKey(ix.name) && t.constraints{ix.name} instanceof AbstractUniqueConstraint) {
                                AbstractUniqueConstraint uk = cast<AbstractUniqueConstraint>(t.constraints{ix.name});
                                if (uk.matchKeys(ix.columns) && uk.setIndexBase(ix.name)) {
                                    ix.setSupportingConstraint(uk);
                                    continue;
                                }
                            }
                        }
                    }
                    # see if the index is supporting a constraint that has to be dropped first
                    *AbstractUniqueConstraint uk = ix.getSupportingConstraint();
                    if (uk && !constraintsLinkedToIndexesImpl()) {
                        code rmv;
                        AbstractConstraint c = findDropConstraintUnlocked(uk.getName(), \rmv);

                        l += AbstractDatabase::doCallback(opt, c.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "constraint", c.getName(), name);
                        rmv();
                    }
                    l += AbstractDatabase::doCallback(opt, ix.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "index", ix.name, name);
                    indexes.take(ix.name);
                }
            }

            # process constraint_map: rename constraints
            foreach hash rh in (opt.constraint_map.pairIterator()) {
                *AbstractConstraint c;

                if (foreignConstraints.hasKey(rh.key)) {
                    c = foreignConstraints{rh.key};
                    foreignConstraints.renameKey(rh.key, rh.value);
                }
                else if (constraints.hasKey(rh.key)) {
                    c = constraints{rh.key};
                    constraints.renameKey(rh.key, rh.value);
                }
                else if (primaryKey && primaryKey.getName() == rh.key)
                    c = primaryKey;

                if (c) {
                    l += AbstractDatabase::doCallback(opt, c.getRenameSql(getSqlName(), rh.value), AbstractDatabase::AC_Rename, "constraint", c.getName(), name, rh.value);
                    c.rename(rh.value);
                }
            }

            # check for foreign constraints with different names than in the template and rename them automatically
            foreach AbstractForeignConstraint fk in (foreignConstraints.iterator()) {
                if (!t.foreignConstraints.hasKey(fk.getName())
                    && t.foreignConstraints
                    && (*AbstractForeignConstraint other = t.foreignConstraints.findEqual(fk))
                    && !foreignConstraints.hasKey(other.getName())) {
                    # rename constraint
                    l += AbstractDatabase::doCallback(opt, fk.getRenameSql(getSqlName(), other.getName()), AbstractDatabase::AC_Rename, "constraint", fk.getName(), name, other.getName());
                    foreignConstraints.renameKey(fk.getName(), other.getName());
                    fk.rename(other.getName());
                }
            }

            # check for unique constraints with different names than in the template and rename them automatically
            foreach AbstractConstraint c in (constraints.iterator()) {
                if (!(c instanceof AbstractUniqueConstraint))
                    continue;
                AbstractUniqueConstraint uk = c;
                if (!t.constraints.hasKey(uk.getName())
                    && t.constraints
                    && (*AbstractUniqueConstraint other = t.constraints.findEqualUniqueConstraint(uk))
                    && !constraints.hasKey(other.getName())) {
                    # rename constraint
                    l += AbstractDatabase::doCallback(opt, uk.getRenameSql(getSqlName(), other.getName()), AbstractDatabase::AC_Rename, "constraint", uk.getName(), name, other.getName());
                    constraints.renameKey(uk.getName(), other.getName());
                    uk.rename(other.getName());
                }
            }

            # check for foreign constraints not in the template and drop them
            foreach AbstractForeignConstraint c in (foreignConstraints.iterator()) {
                if (!t.foreignConstraints.hasKey(c.getName())) {
                    l += AbstractDatabase::doCallback(opt, c.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "foreign constraint", c.getName(), name);
                    foreignConstraints.take(c.getName());
                }
            }

            # check for other constraints not in the template and drop them
            foreach AbstractConstraint c in (constraints.iterator()) {
                if (!t.constraints.hasKey(c.getName())) {
                    l += AbstractDatabase::doCallback(opt, c.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "constraint", c.getName(), name);
                    constraints.take(c.getName());
                }
            }

            # see if we need to drop the primary key
            if (!t.primaryKey.empty()) {
                if (!primaryKey.empty() && !primaryKey.equal(t.primaryKey)) {
                    # see if pk has the same definition but a different name; if so, it will be renamed later
                    if (primaryKey.getName() != t.primaryKey.getName()
                        && primaryKey.matchKeys(t.primaryKey))
                        continue;

                    #printf("pk1: %N\nXXXXXXX\npk2: %N\n", primaryKey, t.primaryKey);
                    l += AbstractDatabase::doCallback(opt, primaryKey.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "primary key", t.primaryKey.getName(), name);
                    if (constraintsLinkedToIndexesImpl() && indexes.hasKey(primaryKey.getName()))
                        t.primaryKey.clearIndex();
                    delete primaryKey;
                }
            }
            else if (!primaryKey.empty()) {
                l += AbstractDatabase::doCallback(opt, primaryKey.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "primary key", primaryKey.getName(), name);
                delete primaryKey;
            }

            # check for columns in the template that are not present or different in the current table
            foreach AbstractColumn c in (t.columns.iterator()) {
                if (!columns.hasKey(c.name)) {
                    # add column to table
                    l += AbstractDatabase::doCallback(opt, c.getCreateSql(self), AbstractDatabase::AC_Add, "column", c.name, name);
                }
                else {
                    # get any delta SQL
                    list cl = columns{c.name}.getModifySql(self, c);
                    # add delta SQL to list if there is any to add
                    if (cl) {
                        l += AbstractDatabase::doCallback(opt, cl, AbstractDatabase::AC_Modify, "column", c.name, name, NOTHING, c.getNativeTypeString());
                    }
                    else
                        AbstractDatabase::doOkCallback(opt, AbstractDatabase::AC_Unchanged, "column", c.name, name);
                }
            }

            # check for columns not in the template and drop them
            foreach AbstractColumn c in (columns.iterator()) {
                if (!t.columns.hasKey(c.name)) {
                    l += getDropAllConstraintsAndIndexesOnColumnSqlUnlocked(c.name, opt);
                    l += AbstractDatabase::doCallback(opt, c.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "column", c.name, name);
                }
            }

            # check for indexes in the template that are not present or different in the current table
            foreach AbstractIndex ix in (t.indexes.iterator()) {
                if (!indexes.hasKey(ix.name)) {
                    # add index to table
                    l += AbstractDatabase::doCallback(opt, ix.getCreateSql(getSqlName(), opt), AbstractDatabase::AC_Add, "index", ix.name, name);
                }
                else if (!ix.equal(indexes{ix.name})) {
                    l += AbstractDatabase::doCallback(opt, ix.getRecreateSql(ds, getSqlName(), opt), AbstractDatabase::AC_Recreate, "index", ix.name, name);
                }
                else
                    AbstractDatabase::doOkCallback(opt, AbstractDatabase::AC_Unchanged, "index", ix.name, name);
            }

            # check for primary key differences
            if (!t.primaryKey.empty()) {
                if (!primaryKey.empty()) {
                    # we know the 2 primary key definitions have equal column definitions as it's checked above
                    # see if pk has a different name
                    if (primaryKey.getName() != t.primaryKey.getName()) {
                        l += AbstractDatabase::doCallback(opt, primaryKey.getRenameSql(getSqlName(), t.primaryKey.getName()), AbstractDatabase::AC_Rename, "constraint", primaryKey.getName(), name, t.primaryKey.getName());
                        primaryKey.rename(t.primaryKey.getName());
                    }
                }
                else {
                    l += AbstractDatabase::doCallback(opt, t.primaryKey.getCreateSql(getSqlName(), opt), AbstractDatabase::AC_Add, "primary key", t.primaryKey.getName(), name);
                }
            }

            # check for foreign constraints in the template that are not present or different in the current table
            foreach AbstractForeignConstraint c in (t.foreignConstraints.iterator()) {
                if (!foreignConstraints.hasKey(c.getName())) {
                    # add constraint to table
                    l += AbstractDatabase::doCallback(opt, c.getCreateSql(getSqlName(), opt), AbstractDatabase::AC_Add, "foreign constraint", c.getName(), name);
                }
                else if (!c.equal(foreignConstraints{c.getName()})) {
                    # drop current constraint
                    l += AbstractDatabase::doCallback(opt, foreignConstraints{c.getName()}.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "foreign constraint", c.getName(), name);
                    # add new constraint to table
                    l += AbstractDatabase::doCallback(opt, c.getCreateSql(getSqlName(), opt), AbstractDatabase::AC_Add, "foreign constraint", c.getName(), name);
                }
                else
                    AbstractDatabase::doOkCallback(opt, AbstractDatabase::AC_Unchanged, "foreign constraint", c.getName(), name);
            }

            # check for other constraints in the template that are not present or different in the current table
            foreach AbstractConstraint c in (t.constraints.iterator()) {
                if (!constraints.hasKey(c.getName())) {
                    # add constraint to table
                    l += AbstractDatabase::doCallback(opt, c.getCreateSql(getSqlName(), opt), AbstractDatabase::AC_Add, "constraint", c.getName(), name);
                }
                else if (!c.equal(constraints{c.getName()})) {
                     # drop current constraint
                    l += AbstractDatabase::doCallback(opt, constraints{c.getName()}.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "constraint", c.getName(), name);
                    if (constraints{c.getName()} instanceof AbstractUniqueConstraint && constraintsLinkedToIndexesImpl() && indexes.hasKey(c.getName()))
                        cast<AbstractUniqueConstraint>(c).clearIndex();

                    # add new constraint to table
                    l += AbstractDatabase::doCallback(opt, c.getCreateSql(getSqlName(), opt), AbstractDatabase::AC_Add, "constraint", c.getName(), name);
                }
                else
                    AbstractDatabase::doOkCallback(opt, AbstractDatabase::AC_Unchanged, "constraint", c.getName(), name);
            }

            # check for table-specific alignment actions before triggers
            {
                *list fl = getAlignSqlImpl(t, opt);
                if (fl)
                    l += fl;
            }

            # check for triggers not in the template and drop them
            # do this before adding for dbs like mysql that cannot support multiple triggers with the same action on the same table
            foreach AbstractTrigger trig in (triggers.iterator()) {
                if (!t.triggers.hasKey(trig.name)) {
                    l += AbstractDatabase::doCallback(opt, trig.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "trigger", trig.name, name);
                }
            }

            # check for triggers in the template that are not present or different in the current table
            foreach AbstractTrigger trig in (t.triggers.iterator()) {
                if (!triggers.hasKey(trig.name)) {
                    # add trigger to table
                    l += AbstractDatabase::doCallback(opt, trig.getCreateSql(getSqlName(), opt), AbstractDatabase::AC_Add, "trigger", trig.name, name);
                }
                else if (!trig.equal(triggers{trig.name})) {
                    # drop current trigger
                    l += AbstractDatabase::doCallback(opt, triggers{trig.name}.getDropSql(getSqlName()), AbstractDatabase::AC_Drop, "trigger", trig.name, name);
                    # add new trigger to table
                    l += AbstractDatabase::doCallback(opt, trig.getCreateSql(getSqlName(), opt), AbstractDatabase::AC_Add, "trigger", trig.name, name);
                }
                else
                    AbstractDatabase::doOkCallback(opt, AbstractDatabase::AC_Unchanged, "trigger", trig.name, name);
            }

            return l;
        }

        private renameIndexUnlocked(AbstractIndex ix, string new_name) {
            string old_name = ix.name;
            indexes.renameKey(old_name, new_name);
            ix.name = new_name;

            # if constraints are linked to indexes, then rename any matching constraint as well
            if (constraintsLinkedToIndexesImpl()) {
                if (primaryKey && primaryKey.getName() == old_name) {
                    primaryKey.rename(new_name);
                }
                else {
                    foreach AbstractConstraint uk in (constraints.iterator()) {
                        if (uk instanceof AbstractUniqueConstraint && uk.getName() == old_name) {
                            uk.rename(new_name);
                            constraints.renameKey(old_name, new_name);
                            break;
                        }
                    }
                }
            }
        }

        #! accepts an AbstractTable argument and returns an SQL string that could be executed to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty string is returned
        /** @par Example:
            @code
my string $sql = $table.getAlignSqlString($table2);
            @endcode

            @param t the template table that the current table will be compared to
            @param opt a hash of options for the SQL creation string; see @ref SqlUtil::AbstractTable::AlignTableOptions for common options; each driver can support additional driver-specific options

            @return an SQL string that could be executed to align the structure and configuration of the current table with that of the argument; if the tables are identical then an empty string is returned

            @throw ALIGN-TABLE-ERROR the argument must be of the same class as the current object; template table has no columns
            @throw OPTION-ERROR invalid or unsupported option passed
        */
        string getAlignSqlString(AbstractTable t, *hash opt) {
            return getCreateSqlImpl(getAlignSql(t, opt));
        }

        #! returns a list of SQL strings that could be used to create indexes on the table or @ref nothing if there are no indexes on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateIndexesSql();
            @endcode

            @param opt a hash of options for the index creation string; see @ref SqlUtil::AbstractTable::IndexOptions for common options; each driver can support additional driver-specific options
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create indexes on the table or @ref nothing if there are no indexes on the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateIndexesSql(*hash opt, bool cache = True) {
            validateOptionsIntern("OPTION-ERROR", getIndexOptions(), \opt);
            l.lock();
            on_exit l.unlock();
            return getCreateIndexesSqlUnlocked(opt, cache);
        }

        #! returns an SQL string that could be used to create the primary key on the table
        /** @par Example:
            @code
my *string $sql = $table.getCreatePrimaryKeySql();
            @endcode

            @param opt a hash of options for the primary key creation string; see @ref SqlUtil::AbstractTable::ConstraintOptions for common options; each driver can support additional driver-specific options
            @param cache read in data from the database for uncached properties of the table

            @return an SQL string that could be used to create the primary key on the table or @ref nothing if there is no primary key on the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *string getCreatePrimaryKeySql(*hash opt, bool cache = True) {
            validateOptionsIntern("OPTION-ERROR", getConstraintOptions(), \opt);
            l.lock();
            on_exit l.unlock();
            return getCreatePrimaryKeySqlUnlocked(opt, cache);
        }

        #! returns a list of SQL strings that could be used to create foreign constraints on the table or @ref nothing if there are no foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateForeignConstraintsSql();
            @endcode

            @param opt a hash of options for the foreign constraint creation string; see @ref SqlUtil::AbstractTable::ForeignConstraintOptions for common options; each driver can support additional driver-specific options
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create foreign constraints on the table or @ref nothing if there are no foreign constraints on the table

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateForeignConstraintsSql(*hash opt, bool cache = True) {
            validateOptionsIntern("OPTION-ERROR", getForeignConstraintOptions(), \opt);
            l.lock();
            on_exit l.unlock();
            return getCreateForeignConstraintsSqlUnlocked(opt, cache);
        }

        #! returns a list of SQL strings that could be used to create non-foreign constraints on the table or @ref nothing if there are no non-foreign constraints on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateConstraintsSql();
            @endcode

            @param opt a hash of options for the non-foreign constraint creation string; see @ref SqlUtil::AbstractTable::ConstraintOptions for common options; each driver can support additional driver-specific options
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create non-foreign constraints on the table or @ref nothing if there are no non-foreign constraints on the table

            @see getCreateForeignConstraintsSql()

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateConstraintsSql(*hash opt, bool cache = True) {
            validateOptionsIntern("OPTION-ERROR", getConstraintOptions(), \opt);
            l.lock();
            on_exit l.unlock();
            return getCreateConstraintsSql(opt, cache);
        }

        #! returns a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or @ref nothing if there are none
        /** @par Example:
            @code
my *list $l = $table.getCreateMiscSql();
            @endcode

            @param opt a hash of options for the SQL creation string; see @ref TableCreationOptions for common options; each driver can support additional driver-specific options
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create other table attributes (such as comments, if supported and present) or @ref nothing if there are none

            @throw OPTION-ERROR invalid or unsupported option passed
        */
        *list getCreateMiscSql(*hash opt, bool cache = True) {
            validateOptionsIntern("OPTION-ERROR", getTableCreationOptions(), \opt);
            l.lock();
            on_exit l.unlock();
            return getCreateMiscSqlUnlocked(opt, cache);
        }

        #! returns a list of SQL strings that could be used to create triggers on the table or @ref nothing if there are no triggers on the table
        /** @par Example:
            @code
my *list $l = $table.getCreateTriggersSql();
            @endcode

            @param opt a hash of options for the trigger creation strings; see @ref TableCreationOptions for common options; each driver can support additional driver-specific options
            @param cache read in data from the database for uncached properties of the table

            @return a list of SQL strings that could be used to create triggers on the table or @ref nothing if there are no triggers on the table

            @throw OPTION-ERROR invalid or unsupported option passed

            @see getCreateTriggersSql()
        */
        *list getCreateTriggersSql(*hash opt, bool cache = True) {
            validateOptionsIntern("OPTION-ERROR", getTableCreationOptions(), \opt);
            l.lock();
            on_exit l.unlock();
            return getCreateTriggersSqlUnlocked(opt, cache);
        }

        #! finds a row in the table with the given primary key value; if no row matches the primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *hash $row = $table.find($id);
            @endcode

            @throw PRIMARY-KEY-ERROR the table has no primary key or the primary key has more than one column
         */
        *hash find(any id) {
            string cname = getPrimaryKeyColumn();

            return ds.selectRow("select * from %s where %s = %v", getSqlName(), cname, id);
        }

        #! finds rows in the table with the given primary key values; if no row matches any primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *list $rows = $table.find($list);
            @endcode

            @param ids the list of primary key IDs to find; if the list is empty then @ref nothing is returned

            @return a list of hashes of rows matching the primary key IDs passed or @ref nothing if no row matches any primary key value passed

            @throw PRIMARY-KEY-ERROR the table has no primary key or the primary key has more than one column
            */
        *list find(list ids) {
            string cname = getPrimaryKeyColumn();

            if (!ids)
                return;

            list args;
            hash cond{cname} = op_in(ids);
            string sql = getSelectSqlIntern(("where": cond), \args);

            return ds.vselectRows(sql, args);
        }
                
        private string getPrimaryKeyColumn() {
            l.lock();
            on_exit l.unlock();
            getPrimaryKeyUnlocked();
            if (primaryKey.empty())
                throw "PRIMARY-KEY-ERROR", sprintf("table %s has no primary key", name);
            if (primaryKey.size() > 1)
                throw "PRIMARY-KEY-ERROR", sprintf("table %s has a primary key with %d columns (%y)", name, primaryKey.size(), primaryKey.keys());
            return primaryKey.firstKey();
        }

        #! finds a row in the table with the given primary key value given as a hash; if no row matches the primary key value passed then @ref nothing is returned
        /** @par Example:
            @code
my *hash $row = $table.find(("account_type": $type, "name": $name));
            @endcode

            @param row a hash giving the primary key value to find; other columns may also appear in the hash, however at least all columns of the primary key must be present

            @return a hash of the row value matching the primary key value passed or @ref nothing if no row matches the primary key value passed

            @throw PRIMARY-KEY-ERROR the table has no primary key or the the hash passed does not contain all columns of the primary key

            @note a table with a primary key with a single column can also be used with this method; just pass a hash with one key
         */
        *hash find(hash row) {
            Columns cols;
            {
                l.lock();
                on_exit l.unlock();
                getPrimaryKeyUnlocked();
                if (primaryKey.empty())
                    throw "PRIMARY-KEY-ERROR", sprintf("table %s has no primary key", name);
                cols = primaryKey;
            }

            # make sure all columns of the primary key are included in the row
            foreach string k in (cols.keyIterator()) {
                if (!row.hasKey(k))
                    throw "PRIMARY-KEY-ERROR", sprintf("row passed is missing column %y of primary key (%y)", k, cols.keys());
            }

            # make query
            string sql = sprintf("select * from %s where ", getSqlName());
            sql += foldl $1 + " and " + $2, (map sprintf("%s = %v", $1), row.keyIterator());
            return ds.vselectRow(sql, row.values());
        }

        #! finds a single row in the table that match the row condition passed; multiple rows may match, but only one row will be returned from the database; if no row matches the condition hash passed then @ref nothing is returned
        /** @par Example:
            @code
my *hash $row = $table.findSingle($h);
            @endcode

            @param cond a hash giving the column values to find; see @ref where_clauses for the format of this argument

            @return a hash representing a single row in the table with the given column values; multiple rows may match, but only one row will be returned from the database; if no row matches the condition hash passed then @ref nothing is returned

            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @note this is equivalent to calling selectRows() with \c where = \c cond and \c limit = 1
         */
        *hash findSingle(*hash cond) {
            return selectRows(("where": cond, "limit": 1))[0];
        }

        #! finds all rows in the table with the given column values; a list of hashes is returned representing the rows returned
        /** @par Example:
            @code
my *list $rows = $table.findAll($h);
            @endcode

            @param cond a hash giving the column values to find; see @ref where_clauses for the format of this argument

            @return a list of hashes is returned representing the rows returned

            @throw WHERE-ERROR unknown operator or invalid arguments given in the cond hash for the where clause

            @note this is equivalent to calling selectRows() with \c where = \c cond
         */
        *list findAll(*hash cond) {
            return selectRows(("where": cond));
        }

        #! returns the name of the table to be used in SQL (with a possible qualifiers for schema, etc)
        string getSqlName() {
            return name;
        }

        #! returns the table options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getTableOptions() {
            return TableOptions;
        }

        #! return the foreign constraint options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getForeignConstraintOptions() {
            return ForeignConstraintOptions;
        }

        #! returns the constraint options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getConstraintOptions() {
            return ConstraintOptions;
        }

        #! returns the cache options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getCacheOptions() {
            return CacheOptions;
        }

        #! returns the table creation options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getTableCreationOptions() {
            return TableCreationOptions;
        }

        #! returns the align table options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getAlignTableOptions() {
            return AlignTableOptions;
        }

        #! returns the table description hash options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getTableDescriptionHashOptions() {
            return TableDescriptionHashOptions;
        }

        #! returns the column options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getColumnOptions() {
            return ColumnOptions;
        }

        #! returns the column description options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getColumnDescOptions() {
            return ColumnDescOptions;
        }

        #! returns the table column description options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getTableColumnDescOptions() {
            return getColumnDescOptions() + AdditionalColumnDescOptions;
        }

        #! returns the index options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getIndexOptions() {
            return IndexOptions;
        }

        #! returns the trigger options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getTriggerOptions() {
            return TriggerOptions;
        }

        #! returns the select options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getSelectOptions() {
            return SelectOptions;
        }

        #! returns the upsert options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getUpsertOptions() {
            return UpsertOptions;
        }

        #! returns the insert options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getInsertOptions() {
            return InsertOptions;
        }

        #! returns the sql data operation callback options for this driver
        /** override in subclasses to return driver-specific options    
        */
        private hash getSqlDataCallbackOptions() {
            return SqlDataCallbackOptions;
        }

        #! returns the "where" operator map for this object
        /** override in subclasses to return driver-specific options    
        */
        private hash getWhereOperatorMap() {
            return DefaultOpMap;
        }

        #! returns the column operator map for this object
        /** override in subclasses to return driver-specific options    
        */
        private hash getColumnOperatorMap() {
            return DefaultCopMap;
        }

        #! returns the update operator map for this object
        /** override in subclasses to return driver-specific options    
        */
        private hash getUpdateOperatorMap() {
            return getColumnOperatorMap().(DefaultUopMap.keys());
        }

        private string getCreateTableSqlUnlocked(*hash opt) {
            getColumnsUnlocked();
            return AbstractDatabase::doCallback(opt, getCreateTableSqlImpl(opt), AbstractDatabase::AC_Create, "table", name);
        }

        private *list getCreateIndexesSqlUnlocked(*hash opt, bool cache = True) {
            if (cache)
                getIndexesUnlocked();
            if (!indexes)
                return;

            return map AbstractDatabase::doCallback(opt, $1.getCreateSql(name, opt), AbstractDatabase::AC_Add, "index", $1.name, name), indexes.iterator();
        }

        private *string getCreatePrimaryKeySqlUnlocked(*hash opt, bool cache = True) {
            if (cache)
                getPrimaryKeyUnlocked();
            if (primaryKey.empty())
                return;
            return AbstractDatabase::doCallback(opt, primaryKey.getCreateSql(name, opt), AbstractDatabase::AC_Add, "primary key", primaryKey.getName(), name);
        }

        private *list getCreateConstraintsSqlUnlocked(*hash opt, bool cache = True) {
            if (cache)
                getConstraintsUnlocked();
            if (constraints.empty())
                return;
            return map AbstractDatabase::doCallback(opt, $1.getCreateSql(name, opt), AbstractDatabase::AC_Add, "constraint", $1.getName(), name), constraints.iterator();
        }

        private *list getCreateForeignConstraintsSqlUnlocked(*hash opt, bool cache = True) {
            if (cache)
                getForeignConstraintsUnlocked(opt);
            if (foreignConstraints.empty())
                return;
            return map AbstractDatabase::doCallback(opt, $1.getCreateSql(name, opt), AbstractDatabase::AC_Add, "foreign constraint", $1.getName(), name), foreignConstraints.iterator();
        }

        private *list getCreateMiscSqlUnlocked(*hash opt, bool cache = True) {
            return getCreateMiscSqlImpl(opt, cache);
        }

        private *list getCreateTriggersSqlUnlocked(*hash opt, bool cache = True) {
            if (cache)
                getTriggersUnlocked();
            if (triggers.empty())
                return;

            list l = ();
            map l += AbstractDatabase::doCallback(opt, $1.getCreateSql(name, opt), AbstractDatabase::AC_Add, "trigger", $1.name, name), triggers.iterator();
            return l;
        }

        private list getCreateSqlUnlocked(*hash opt, bool cache = True) {
            # make sure driver options take precedence over generic options
            if (opt) {
                string dn = getDriverName();
                if (opt.driver{dn})
                    opt += remove opt.driver{dn};
                delete opt.driver;
            }

            # mark in options that the entire table is being created
            opt.create_table_all = True;
            list l += getCreateTableSqlUnlocked(opt);
            *list tl = getCreateIndexesSqlUnlocked(opt, cache); if (tl) l += tl;
            *string sql = getCreatePrimaryKeySqlUnlocked(opt, cache); if (sql) l += sql;
            tl = getCreateForeignConstraintsSqlUnlocked(opt, cache); if (tl) l += tl;
            tl = getCreateConstraintsSqlUnlocked(opt, cache); if (tl) l += tl;
            tl = getCreateMiscSqlUnlocked(opt, cache); if (tl) l += tl;
            tl = getCreateTriggersSqlUnlocked(opt, cache); if (tl) l += tl;

            return l;
        }

        private cacheUnlocked(*hash opt) {
            getColumnsUnlocked();
            getPrimaryKeyUnlocked();
            getIndexesUnlocked();
            getForeignConstraintsUnlocked(opt);
            getConstraintsUnlocked();
            getTriggersUnlocked();
        }

        private any execData(*hash opt, string sql, *list args) {
            if (opt.sqlarg_callback)
                opt.sqlarg_callback(sql, args);
            return ds.vexec(sql, args);
        }

        private execData(SQLStatement stmt, *hash opt, *list args) {
            if (opt.sqlarg_callback)
                opt.sqlarg_callback(stmt.getSQL(), args);
            stmt.execArgs(args);
        }

        static AbstractTable getTable(AbstractDatasource nds, string nname, *hash opts) {
            string drv = nds.getDriverName();

            # generate module and module namespace name
            string mn = drv[0].upr() + drv.substr(1) + "SqlUtil";

            # try to load module
            try {
                load_module(mn);                
            }
            catch (hash ex) {
                throw "TABLE-DRIVER-ERROR", sprintf("%s: no support for driver %y yet: %s: %s", get_ex_pos(ex), drv, ex.err, ex.desc);
            }

            # try to get AbstractTable object
            try {
                return call_function(mn + "::" + "get_table", nds, nname, opts);
            }
            catch (hash ex) {
                throw "TABLE-DRIVER-ERROR", sprintf("%s: error retrieving AbstractTable object for driver %y: %s: %s", get_ex_pos(ex), drv, ex.err, ex.desc);
            }
        }

        static AbstractTable getTable(string dsstr, string nname, *hash opts) {
            Datasource nds(dsstr);
            return AbstractTable::getTable(nds, nname, opts);
        }

        static AbstractTable getTable(hash dsh, string nname, *hash opts) {
            Datasource nds(dsh);
            return AbstractTable::getTable(nds, nname, opts);
        }

        private getColumnsUnlocked() {
            if (columns)
                return;
            if (manual) {
                columns = new Columns();
                return;
            }
            columns = describeImpl();
            inDb = True;
        }

        private getPrimaryKeyUnlocked() {
            if (primaryKey || manual)
                return;
            getColumnsUnlocked();
            primaryKey = getPrimaryKeyImpl();

            # get indexes
            if (!manual && !indexes)
                indexes = getIndexesImpl();

            if (!primaryKey.empty())
                primaryKey.findMatchingIndex(indexes);

            inDb = True;
        }

        # also loads primary key and constraints (for unique constraints)
        private getIndexesUnlocked() {
            if (indexes)
                return;
            if (manual) {
                indexes = new Indexes();
                return;
            }
            # make sure columns are loaded
            getColumnsUnlocked();
            if (!manual) {
                # make sure any primary key is loaded
                getPrimaryKeyUnlocked();
                # make sure constraints are also loaded
                getConstraintsUnlocked();
            }
            indexes = getIndexesImpl();
            inDb = True;
        }

        private getForeignConstraintsUnlocked(*hash opt) {
            if (foreignConstraints)
                return;
            if (manual) {
                foreignConstraints = new ForeignConstraints();
                return;
            }
                
            getColumnsUnlocked();
            foreignConstraints = getForeignConstraintsImpl(opt);

            # update cached tables with foreign constraint source info
            if (opt.table_cache) {
                foreach AbstractForeignConstraint fk in (foreignConstraints.iterator()) {
                    if (!opt.table_cache.hasKey(fk.target.table)) {
                        Table t(ds, fk.target.table);
                        opt.table_cache.add(fk.target.table, t.getTable());
                        #printf("ERROR: missing %y in table cache (adding fk %y to %y)\n", fk.target.table, fk.getName(), getName());
                    }
                    opt.table_cache{fk.target.table}.addSourceConstraint(getSqlName(), fk);
                }
            }
            inDb = True;
        }

        private addSourceConstraint(string table_name, AbstractForeignConstraint fk) {
            bool lock = !l.lockOwner();
            if (lock) l.lock();
            on_exit if (lock) l.unlock();

            getAllConstraintsUnlocked();

            # find unique constraint with the given columns
            if (primaryKey && primaryKey.matchKeys(fk.target.columns)) {
                primaryKey.addSourceConstraint(table_name, fk);
                return;
            }
            foreach AbstractConstraint c in (constraints.iterator()) {
                if (!(c instanceof AbstractUniqueConstraint))
                    continue;
                AbstractUniqueConstraint uk = cast<AbstractUniqueConstraint>(c);
                if (uk.matchKeys(fk.target.columns)) {
                    uk.addSourceConstraint(table_name, fk);
                    return;
                }
            }
        }

        private getConstraintsUnlocked() {
            if (constraints)
                return;
            if (manual) {
                constraints = new Constraints();
                return;
            }
            getColumnsUnlocked();
            constraints = getConstraintsImpl();
            # get indexes
            if (!manual && !indexes)
                indexes = getIndexesImpl();

            foreach AbstractConstraint c in (constraints.iterator()) {
                if (!(c instanceof AbstractUniqueConstraint))
                    continue;
                AbstractUniqueConstraint uk = cast<AbstractUniqueConstraint>(c);
                uk.findMatchingIndex(indexes);
            }

            inDb = True;
        }

        private getTriggersUnlocked() {
            if (triggers)
                return;
            if (manual) {
                triggers = new Triggers();
                return;
            }
            triggers = getTriggersImpl();
            inDb = True;
        }

        private softlist getDropSqlImpl() {
            return sprintf("drop table %s", getSqlName());
        }
        
        private string getTruncateSqlImpl() {
            return sprintf("truncate table %s", getSqlName());
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        private any tryExecArgsImpl(string sql, *softlist args) {
            return ds.vexec(sql, args);
        }

        #! tries to execute a command so that if an error occurs the current transaction status is not lost
        private any tryExecRawImpl(string sql) {
            return ds.execRaw(sql);
        }

        #! clears any driver-specific table information
        private clearImpl() {
        }

        private preSetupTableImpl(reference desc, *hash opt) {
        }

        private abstract bool emptyImpl();

        #! returns a string for use in SQL queries representing the DB-specific value of the argument; returns NOTHING if the type cannot be converted to an SQL string
        private abstract *string getSqlValueImpl(any v);

        #! returns @ref Qore::True "True" if the table exists in the DB, @ref Qore::False "False" if not
        /** this method will only be called if inDb is @ref Qore::False "False" and 
            should set inDb = True if it returns @ref Qore::True "True"
         */
        private abstract bool checkExistenceImpl();

        #! returns @ref Qore::True "True" if the database support tablespaces
        private abstract bool supportsTablespacesImpl();

        #! returns @ref Qore::True "True" if the database links constraints to indexes (ie dropping the constraint drops the index, etc)
        private abstract bool constraintsLinkedToIndexesImpl();

        #! returns @ref Qore::True "True" if the database automatically creates a unique constraint when a unique index is created (ex: mysql)
        private abstract bool uniqueIndexCreatesConstraintImpl();

        private abstract setupTableImpl(hash desc, *hash opt);

        private abstract Columns describeImpl();
        private abstract *AbstractPrimaryKey getPrimaryKeyImpl();
        private abstract Indexes getIndexesImpl();
        private abstract ForeignConstraints getForeignConstraintsImpl(*hash opt);
        private abstract Constraints getConstraintsImpl();
        private abstract Triggers getTriggersImpl();

        private abstract string getCreateTableSqlImpl(*hash opt);
        private abstract *list getCreateMiscSqlImpl(*hash opt, bool cache);
        private abstract string getCreateSqlImpl(list l);
        private abstract string getRenameSqlImpl(string new_name);
        private abstract *list getAlignSqlImpl(AbstractTable t, *hash opt);
        
        private abstract AbstractColumn addColumnImpl(string cname, hash opt, bool nullable = True);
        private abstract AbstractPrimaryKey addPrimaryKeyImpl(string cname, hash ch, *hash opt);
        private abstract AbstractIndex addIndexImpl(string iname, bool enabled, hash ch, *hash opt);
        private abstract AbstractForeignConstraint addForeignConstraintImpl(string cname, hash ch, string table, hash tch, *hash opt);
        private abstract AbstractCheckConstraint addCheckConstraintImpl(string cname, string src, *hash opt);
        private abstract AbstractUniqueConstraint addUniqueConstraintImpl(string cname, hash ch, *hash opt);

        private abstract AbstractTrigger addTriggerImpl(string tname, string src, *hash opt);

        #! tries to insert a row, if there is a duplicate key, then it returns @ref Qore::False "False", if successful, returns @ref Qore::True "True"
        private abstract bool tryInsertImpl(string sql, hash row);

        #! returns the qore type -> column type map
        private abstract hash getQoreTypeMapImpl();

        #! returns the type name -> type description hash
        private abstract hash getTypeMapImpl();

        #! processes a string for use in SQL select statements when there is an "order by" and "offset" argument
        private abstract doSelectOrderByWithOffsetSqlUnlockedImpl(reference sql, reference args, *hash qh);

        #! processes a string for use in SQL select statements when there is a "limit" argument, but no "orderby" or "offset" arguments
        private abstract doSelectLimitOnlyUnlockedImpl(reference sql, reference args, *hash qh);

        #! db-specific copy actions
        private abstract copyImpl(AbstractTable old);
    }

/*
    public class Sqlite3Table inherits AbstractTable {

        public {
            const Sqlite3TypeMap = (
                "INTEGER": ("qore": "integer",),
                "NUMERIC": ("qore": "number",),
                "TEXT": ("qore": "string",),
                "BLOB": ("qore": "binary",),
                "NONE": ("qore": "any",),
                "REAL": ("qore": "float",),
                );

            const QoreTypeMap = (
                "integer": "INTEGER",
                "float": "NUMBER",
                "number": "NUMBER",
                "string": "VARCHAR2",
                #"date": "TIMESTAMP",
                "binary": "BLOB",
                );
        }

        constructor(AbstractDatasource nds, string nname, *hash opts) : AbstractTable(nds, nname, opts) {
        }

        private hash describeImpl() {
            hash rv;
            
            # NOTE: sqlite3's pragmas cannot use %v binding
            
            # table info - PK is part of the table description
            hash tableInfo = ds.select("pragma table_info(%s)", name);
            context(tableInfo) {
                rv.columns{%name} = (
                        "native_type"   : %type,
                        "qore_type"     : Sqlite3TypeMap{%type}.qore,
                        "size"          : NOTHING,
                        "nullable"      : %notnull == 1 ? NOTHING : "YES",
                    );
                if (%pk)
                    rv.primary_key{%name} = True;
            }
            
            # get index description
            hash indexes = ds.select("pragma index_list(%s)", name);
            context(indexes) {
                rv.indexes{%name}.unique = %unique == 0 ? False : True;
                hash indexColumns = ds.select("pragma index_info(%s)", %name);
                string columnName = %name;
                context (indexColumns) {
                    rv.indexes{columnName}.columns{%name} = True;
                }
            }
            
            # TODO/FIXME: FKs
            
            return rv;
        }
    }
*/
}

