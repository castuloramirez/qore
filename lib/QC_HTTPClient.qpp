/* -*- mode: c++; indent-tabs-mode: nil -*- */
/*
  QC_HTTPClient.qpp

  Qore Programming Language

  Copyright (C) 2006 - 2013 Qore Technologies

  This library is free software; you can redistribute it and/or
  modify it under the terms of the GNU Lesser General Public
  License as published by the Free Software Foundation; either
  version 2.1 of the License, or (at your option) any later version.

  This library is distributed in the hope that it will be useful,
  but WITHOUT ANY WARRANTY; without even the implied warranty of
  MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
  Lesser General Public License for more details.

  You should have received a copy of the GNU Lesser General Public
  License along with this library; if not, write to the Free Software
  Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

#include <qore/Qore.h>
#include <qore/QoreHTTPClient.h>
#include <qore/intern/QC_HTTPClient.h>
#include <qore/intern/QC_Queue.h>
#include <qore/intern/ssl_constants.h>
#include <qore/minitest.hpp>

#ifdef DEBUG_TESTS
#  include "tests/QC_HTTPClient_tests.cpp"
#endif

//! The HTTPClient class can be used to communicate with HTTP servers with and without TLS/SSL encryption
/** The HTTPClient class can be used to communicate with HTTP servers using the HTTP or HTTPS (HTTP using an SSL/TLS encrypted connection) protocol.

    By default \c "Connection: Keep-Alive" is always sent regardless of the HTTP protocol level set for the object, however if a server response contains \c "Connection: close", the connection will be closed as soon as the full response (including any message body if present) has been read.

    HTTP redirect responses are supported and can be limited with the \c max_redirects constructor hash key or by using the HTTPClient::setMaxRedirects() method. The default maximum number of redirects allowed is 5.

    HTTP basic authentication is supported; set the username and password in the URL (ex: \c "http://username:password@host:port/path"). To change the URL from the one set by the constructor, call HTTPClient::setURL().

    HTTP proxies and basic proxy authentication are supported by setting the proxy constructor hash key to the proxy URL (with a proxy username and password if required) or by calling the HTTPClient::setProxyURL() method.

    Objects of this class are thread-safe and support serializing multiple simultaneous requests from many threads. If a request is in progress and another thread attempts to make a request at the same time, the second thread will block until the first is complete. Therefore the total amount of time a thread could wait for a response in a multi-threaded context could be greater than the timeout value (which applies to the maximum time a single internal send() or recv() action can take).

    This class understands and automatically decodes \c "deflate", \c "gzip", and \c "bzip2" content encodings as well.

    The default I/O timeout value is 300,000 milliseconds (5 minutes). Note that the timeout value applies to individual internal send() or recv() operations; for this reason for large transfers the overall I/O time could exceed the timeout value.

    When an exception is thrown (for example, a response code of < \c 200 or >= \c 400 is received from the server), any message body returned will be in the \c "arg" key of the exception hash.

    This class understands the protocols in the following table.\n\n
    <b>%HTTPClient Class Protocols</b>
    |!Protocol/Scheme|!Default Port|!SSL?|!Description
    |\c http|\c 80|No|Unencrypted HTTP protocol
    |\c https|\c 443|Yes|HTTP protocol with SSL/TLS encryption

    Whenever using an HTTPClient method where a hash of headers can be passed to the method, some headers are generated by default by the class and can be overridden, and some are cannot be overridden and are ignored if passed by the client. See the following tables for details.

    <b>%HTTPClient Mandatory Headers</b>
    |!Header|!Description
    |\c Content-Length|This header is only sent if a message body is send, and, if so, the length is calculated automatically.

    <b>%HTTPClient Default, but Overridable Headers</b>
    |!Header|!Default Value
    |\c Accept|\c "text/html"
    |\c Content-Type|\c "text/html"
    |\c User-Agent|\c "Qore-HTTP-Client/0.8.6"
    |\c Connection|\c "Keep-Alive"
    |\c Accept-Encoding|\c "deflate,gzip,bzip2"

    This class supports posting network events to a @ref Qore::Thread::Queue "Queue". See @ref event_handling for more information.

    The events raised by this object are listed in the following table:
    <b>HTTPClient Events</b>
    |!Name|!Description
    |@ref EVENT_HTTP_CONTENT_LENGTH|Raised when the HTTP \c "Content-Length" header is received.
    |@ref EVENT_HTTP_CHUNKED_START|Raised when HTTP chunked data is about to be received.
    |@ref EVENT_HTTP_CHUNKED_END|Raised when all HTTP chunked data has been received.
    |@ref EVENT_HTTP_REDIRECT|Raised when an HTTP redirect message is received.
    |@ref EVENT_HTTP_SEND_MESSAGE|Raised when an HTTP message is sent.
    |@ref EVENT_HTTP_MESSAGE_RECEIVED|Raised when an HTTP message is received.
    |@ref EVENT_HTTP_FOOTERS_RECEIVED|Raised when HTTP footers are received. 
    |@ref EVENT_HTTP_CHUNKED_DATA_RECEIVED|Raised when a block of HTTP chunked data is received.
    |@ref EVENT_HTTP_CHUNK_SIZE|Raised when the next chunk size for HTTP chunked data is known.

    @note This class is not available with the @ref PO_NO_NETWORK parse option.
 */
qclass HTTPClient [dom=NETWORK; arg=QoreHTTPClient* client];

//! Creates the HTTPClient object based on the option parameter passed
/** To connect, call any method that requires a connection and an implicit connection is established, or call HTTPClient::connect().

    @param opts sets options and changes default behaviour for the object, etc; key names are case-sensitive and therefore must all be in lower-case:
    - \c url: A string giving the URL to connect to
    - \c default_port: The default port number to connect to if none is given in the URL
    - \c protocols: A hash describing new protocols, the key is the protocol name and the value is either an integer giving the default port number or a hash with \c "port" and \c "ssl" keys giving the default port number and a boolean value to indicate that an SSL connection should be established
    - \c http_version: Either \c "1.0" or \c "1.1" for the claimed HTTP protocol version compliancy in outgoing message headers
    - \c default_path: The default path to use for new connections if a path is not otherwise specified in the connection URL
    - \c max_redirects: The maximum number of redirects before throwing an exception (the default is 5)
    - \c proxy: The proxy URL for connecting through a proxy
    - \c timeout: The timeout value in milliseconds (also can be a @ref relative_dates "relative date-time value" for clarity, ex: \c 5m)
    - \c connect_timeout: The timeout value in milliseconds for establishing a new socket connection (also can be a @ref relative_dates "relative date-time value" for clarity, ex: \c 30s)

    @par Example:
    @code
my HTTPClient $httpclient(("url":"http://hostname:8080/path"));
    @endcode

    @throw HTTP-CLIENT-OPTION-ERROR invalid or unknown option passed in option hash
    @throw HTTP-CLIENT-URL-ERROR invalid URL string
    @throw HTTP-CLIENT-UNKNOWN-PROTOCOL unknown protocol passed in URL
 */
HTTPClient::constructor(hash opts) {
   ReferenceHolder<QoreHTTPClient> client(new QoreHTTPClient, xsink);
   if (client->setOptions(opts, xsink))
      return;

   self->setPrivate(CID_HTTPCLIENT, client.release());
}

//! Creates the HTTPClient object
/** 
    @par Example:
    @code
my HTTPClient $httpclient();
    @endcode
 */
HTTPClient::constructor() {
   self->setPrivate(CID_HTTPCLIENT, new QoreHTTPClient);
}

//! Copying objects of this class is not supported, an exception will be thrown
/** 
    @throw HTTPCLIENT-COPY-ERROR copying HTTPClient objects is not yet supported
 */
HTTPClient::copy() {
   xsink->raiseException("HTTPCLIENT-COPY-ERROR", "copying HTTPClient objects is not yet supported");
}

//! Destroys the HTTPClient object and closes any open connections
/** 
    @par Example:
    @code
delete $httpclient;
    @endcode
 */
HTTPClient::destructor() {
   // have to clear callbacks before destroying
   client->cleanup(xsink);
   client->deref(xsink);
}

//! Sets the HTTP protocol version string for headers in outgoing messages, allowed values are \c "1.0" and \"1.1\".
/** @param ver \c "1.0" or \"1.1\" for the HTTP protocol compliance version

    @par Example:
    @code
$httpclient.setHTTPVersion("1.1");
    @endcode

    @throw HTTP-VERSION-ERROR invalid HTTP version passed (allowed values: \c "1.0" and \"1.1\")
 */
nothing HTTPClient::setHTTPVersion(string ver) {
   client->setHTTPVersion(ver->getBuffer(), xsink);
}

//! Returns the HTTP protocol version string used in outgoing messages
/** @return the HTTP protocol version string used in outgoing messages

    @par Example:
    @code
my string $version = $httpclient.getHTTPVersion();
    @endcode
 */
string HTTPClient::getHTTPVersion() [flags=CONSTANT] {
   return new QoreStringNode(client->getHTTPVersion());
}

//! Sets the object to make a secure SSL/TLS connection on the next connect if the passed argument is @ref True, or an unencrypted cleartext connection if it is @ref False
/** This method overrides the default behaviour for the protocol set for the object

    Note that the behavior of this method when called with no argument changed in version 0.8.0; prior to version 0.8.0 calling this method with no argument would turn off secure mode; the behavior was changed to the current functionality in order to make the usage of this method consistent with other methods of the same name and to make it more logical.

    @param secure if @ref True, a SSL/TLS connection will be attempted on the next connection. If @ref False, an unencrypted cleartext connection will be established

    @par Example:
    @code
$httpclient.setSecure(True);
    @endcode
 */
nothing HTTPClient::setSecure(softbool secure = True) {
   client->setSecure(secure);
}

//! Returns @ref True if the current connection is encrypted, @ref False if not
/** @return @ref True if the current connection is encrypted, @ref False if not

    @par Example:
    @code
if ($httpclient.isSecure())
    printf("secure connection: %s %s\n", $httpclient.getSSLCipherName(), $httpclient.getSSLCipherVersion());
    @endcode
 */
bool HTTPClient::isSecure() [flags=CONSTANT] {
   return client->isSecure();
}

//! Returns a string code giving the result of verifying the remote certificate or @ref nothing if an encrypted connection is not established
/** @return A string code giving the result of verifying the peer's certificate or @ref nothing if a secure connection has not been established. The possible values are found in the keys of the @ref X509_VerificationReasons hash constant. This hash can also be used to generate a textual description of the verification result.

    @par Example:
    @code
if ($httpclient.isSecure() && exists (my *string $str = $httpclient.verifyPeerCertificate())) {
    printf("certificate: %s: %s\n", $str, X509_VerificationReasons.$str);
    @endcode
 */
*string HTTPClient::verifyPeerCertificate() [flags=CONSTANT] {
   const char *c = getSSLCVCode(client->verifyPeerCertificate());
   return c ? new QoreStringNode(c) : 0;
}

//! Returns the name of the cipher for an encrypted connection or @ref nothing if an encrypted connection is not established
/** @return the name of the cipher for an encrypted connection or @ref nothing if an encrypted connection is not established

    @par Example:
    @code
if ($httpclient.isSecure())
    printf("secure connection: %s %s\n", $httpclient.getSSLCipherName(), $httpclient.getSSLCipherVersion());
    @endcode
 */
*string HTTPClient::getSSLCipherName() [flags=CONSTANT] {
   const char *str = client->getSSLCipherName();
   return str ? new QoreStringNode(str) : 0;
}

//! Returns the version of the cipher for an encrypted connection or @ref nothing if an encrypted connection is not established
/** @return the version of the cipher for an encrypted connection or @ref nothing if an encrypted connection is not established

    @par Example:
    @code
if ($httpclient.isSecure())
    printf("secure connection: %s %s\n", $httpclient.getSSLCipherName(), $httpclient.getSSLCipherVersion());
    @endcode
 */
*string HTTPClient::getSSLCipherVersion() [flags=CONSTANT] {
   const char *str = client->getSSLCipherVersion();
   return str ? new QoreStringNode(str) : 0;
}

//! Connects to the remote socket; SSL/TLS negotiation is performed if required
/** If the protocol indicates that a secure connection should be established (or HTTPClient::setSecure() was called previsouly), SSL/TLS negotiation will be attempted. 

    If the \c TCP_NODELAY flag has been set (see HTTPClient::setNoDelay()), then after a successful connection to the remote socket, this option will be set on the socket. If an error occurs setting the \c TCP_NODELAY option, the internal flag is set to false (use HTTPClient::getNoDelay() to check the flag's state) and the error code can be retrieved with errno().

    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED

    @par Example:
    @code
$httpclient.connect();
    @endcode

    @note For possible exceptions, see the Socket::connect() method (or Socket::connectSSL() for secure connections).
 */
nothing HTTPClient::connect() {
   client->connect(xsink);
}

//! Disconnects from the remote socket if a connection is established (otherwise does nothing)
/** 
    @par Example:
    @code
$httpclient.disconnect();
    @endcode
 */
nothing HTTPClient::disconnect() {
   client->disconnect();
}

//! Sends an HTTP request with the specified method and optional message body and returns headers and any body received as a response in a hash format
/** If a connection has not already been established, an internal call to HTTPClient::connect() will be made before sending the message

    @param body The message body to send
    @param method The name of the HTTP method (\c "GET", \c "POST", \c "HEAD", \c "OPTIONS", \c "PUT", \c "DELETE", \c "TRACE", or \c "CONNECT").
    @param path The path for the message (i.e. \c "/path/resource?method&param=value")
    @param headers An optional hash of headers to include in the message.
    @param getbody If this argument is @ref True, then the object will try to receive a message body even if no \c "Content-Length" header is present in the response. Use this only with broken servers that send message bodies without a \c "Content-Length" header.
    @param info An optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request.
    @return The headers received from the HTTP server with all key names converted to lower-case. The message body (if any) will be assigned to the value of the \c "body" key.

    @par Example:
    @code
my hash $msg = $httpclient.send($body, "POST", "/path", ("Content-Type":"application/x-yaml"));
    @endcode

    @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 200 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash with a \c "code" key (giving the status code) and a \c "body" key (giving the message body returned by the server)
    @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)
 */
hash HTTPClient::send(string body, string method, *string path, *hash headers, softbool getbody = False, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   ReferenceHolder<QoreHashNode> rv(client->send(method->getBuffer(), path && !path->empty() ? path->getBuffer() : 0, headers, body->getBuffer(), body->strlen(), getbody, *ohrh, xsink), xsink);
   return *xsink ? 0 : rv.release();
}

//! Sends an HTTP request with the specified method and optional message body and returns headers and any body received as a response in a hash format
/** If a connection has not already been established, an internal call to HTTPClient::connect() will be made before sending the message

    @param body The message body to send; pass @ref nothing (no value) to send no body
    @param method The name of the HTTP method (\c "GET", \c "POST", \c "HEAD", \c "OPTIONS", \c "PUT", \c "DELETE", \c "TRACE", or \c "CONNECT").
    @param path The path for the message (i.e. \c "/path/resource?method&param=value")
    @param headers An optional hash of headers to include in the message.
    @param getbody If this argument is @ref True, then the object will try to receive a message body even if no \c "Content-Length" header is present in the response. Use this only with broken servers that send message bodies without a \c "Content-Length" header.
    @param info An optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request.
    @return The headers received from the HTTP server with all key names converted to lower-case. The message body (if any) will be assigned to the value of the \c "body" key.

    @par Example:
    @code
my hash $msg = $httpclient.send($body, "POST", "/path", ("Content-Type":"application/x-yaml"));
    @endcode

    @throw HTTP-CLIENT-METHOD-ERROR invalid/unknown HTTP method passed
    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 200 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash with a \c "code" key (giving the status code) and a \c "body" key (giving the message body returned by the server) 
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)
 */
hash HTTPClient::send(*binary body, string method, string path, *hash headers, softbool getbody = False, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   ReferenceHolder<QoreHashNode> rv(client->send(method->getBuffer(), path && !path->empty() ? path->getBuffer() : 0, headers, body ? body->getPtr() : 0, body ? body->size() : 0, getbody, *ohrh, xsink), xsink);
   return *xsink ? 0 : rv.release();
}

//! Sends an HTTP \c GET request and returns the message body received as a string or @ref nothing if no message body is received
/** In order to get the headers and the body, use the HTTPClient::send() method instead. 

    If no connection has already been established, an internal call to HTTPClient::connect() will be made before sending the request.

    If any content encoding is used for the message body in the reply, the content is decoded and returned as a string; if the content encoding uses an unknown method, then an exception is thrown.

    @param path the path for the message (i.e. \c "/path/resource?method&param=value")
    @param headers an optional hash of headers to include in the message
    @param info an optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request

    @return the message body in the reply to this message or @ref nothing in case of an error or an erroneous reply by the server with no body

    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED, @ref EVENT_HTTP_SEND_MESSAGE, @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_MESSAGE_RECEIVED, @ref EVENT_PACKET_READ, @ref EVENT_HTTP_CONTENT_LENGTH, @ref EVENT_HTTP_CHUNKED_START, @ref EVENT_HTTP_CHUNKED_END, @ref EVENT_HTTP_CHUNKED_DATA_RECEIVED, @ref EVENT_HTTP_CHUNK_SIZE, @ref EVENT_HTTP_FOOTERS_RECEIVED, @ref EVENT_HTTP_REDIRECT

    @par Example:
    @code
my *string $html = $httpclient.get("/path/file.html");
    @endcode

    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 200 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash with a \c "code" key (giving the status code) and a \c "body" key (giving the message body returned by the server) 
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)
 */
*string HTTPClient::get(string path, *hash headers, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   ReferenceHolder<AbstractQoreNode> rv(client->get(path->getBuffer(), headers, *ohrh, xsink), xsink);
   return *xsink ? 0 : rv.release();
}

//! Sends an HTTP \c HEAD request and returns as hash of the headers received
/** If no connection is established, an internal call to HTTPClient::connect() will be made before sending the message.

    @param path the path for the message (i.e. \c "/path/resource?method&param=value")
    @param headers an optional hash of headers to include in the message
    @param info an optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request

    @return the headers received from the HTTP server with all key names converted to lower-case


    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED, @ref EVENT_HTTP_SEND_MESSAGE, @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_MESSAGE_RECEIVED, @ref EVENT_PACKET_READ, @ref EVENT_HTTP_REDIRECT

    @par Example:
    @code
my hash $msg = $httpclient.head("/path");
    @endcode

    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 200 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash with a \c "code" key (giving the status code) and a \c "body" key (giving the message body returned by the server) 
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)
 */
hash HTTPClient::head(string path, *hash headers, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   ReferenceHolder<QoreHashNode> rv(client->head(path->getBuffer(), headers, *ohrh, xsink), xsink);
   return *xsink ? 0 : rv.release();
}

//! Sends an HTTP \c POST request with a message body and returns the message body received as a string or @ref nothing if no message body is received
/** In order to get the headers and the body in the response, use the HTTPClient::send() method instead.

    If no connection is established, an internal call to HTTPClient::connect() will be made before sending the message.

    @param path the path for the message (i.e. \c "/path/resource?method&param=value")
    @param body the string to use as the message body
    @param headers an optional hash of headers to include in the message
    @param info an optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request

    @return the message body in the reply to this message or @ref nothing in case no body was present in the response

    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED, @ref EVENT_HTTP_SEND_MESSAGE, @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_MESSAGE_RECEIVED, @ref EVENT_PACKET_READ, @ref EVENT_HTTP_CONTENT_LENGTH, @ref EVENT_HTTP_CHUNKED_START, @ref EVENT_HTTP_CHUNKED_END, @ref EVENT_HTTP_CHUNKED_DATA_RECEIVED, @ref EVENT_HTTP_CHUNK_SIZE, @ref EVENT_HTTP_FOOTERS_RECEIVED, @ref EVENT_HTTP_REDIRECT

    @par Example:
    @code
$httpclient.post("/path", $body);
    @endcode

    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 200 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash with a \c "code" key (giving the status code) and a \c "body" key (giving the message body returned by the server) 
    @throw ENCODING-CONVERSION-ERROR the given string could not be converted to the socket's character encoding
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)
 */
*string HTTPClient::post(string path, string body, *hash headers, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   ReferenceHolder<AbstractQoreNode> rv(client->post(path->getBuffer(), headers, body->getBuffer(), body->size(), *ohrh, xsink), xsink);
#ifdef DEBUG
   assert(!rv || rv->getType() == NT_STRING);
#endif
   return *xsink ? 0 : rv.release();
}

//! Sends an HTTP \c POST request with a message body and returns the message body received as a string or @ref nothing if no message body is received
/** In order to get the headers and the body in the response, use the HTTPClient::send() method instead.

    If no connection is established, an internal call to HTTPClient::connect() will be made before sending the message.

    @param path the path for the message (i.e. \c "/path/resource?method&param=value")
    @param body the optional data to use as the message body
    @param headers an optional hash of headers to include in the message
    @param info an optional reference to an lvalue that will be used as an output variable giving a hash of request headers and other information about the HTTP request

    @return the message body in the reply to this message or @ref nothing in case no body was present in the response

    @par Events:
    @ref EVENT_CONNECTING, @ref EVENT_CONNECTED, @ref EVENT_HOSTNAME_LOOKUP, @ref EVENT_HOSTNAME_RESOLVED, @ref EVENT_START_SSL, @ref EVENT_SSL_ESTABLISHED, @ref EVENT_HTTP_SEND_MESSAGE, @ref EVENT_PACKET_SENT, @ref EVENT_HTTP_MESSAGE_RECEIVED, @ref EVENT_PACKET_READ, @ref EVENT_HTTP_CONTENT_LENGTH, @ref EVENT_HTTP_CHUNKED_START, @ref EVENT_HTTP_CHUNKED_END, @ref EVENT_HTTP_CHUNKED_DATA_RECEIVED, @ref EVENT_HTTP_CHUNK_SIZE, @ref EVENT_HTTP_FOOTERS_RECEIVED, @ref EVENT_HTTP_REDIRECT

    @par Example:
    @code
$httpclient.post("/path", $body);
    @endcode

    @throw HTTP-CLIENT-REDIRECT-ERROR invalid redirect location given by remote
    @throw HTTP-CLIENT-MAXIMUM-REDIRECTS-EXCEEDED maximum redirect count exceeded
    @throw HTTP-CLIENT-RECEIVE-ERROR unknown content encoding received or status error communicating with HTTP server (status code < 200 or > 299); in case of a status error the \c "arg" key of the exception hash will be set to a hash with a \c "code" key (giving the status code) and a \c "body" key (giving the message body returned by the server) 
    @throw SOCKET-SEND-ERROR There was an error sending the data
    @throw SOCKET-CLOSED The remote end closed the connection
    @throw SOCKET-RECV-ERROR There was an error receiving the data
    @throw SOCKET-TIMEOUT Data transmission or reception for a single send() or recv() action exceeded the timeout period
    @throw SOCKET-SSL-ERROR There was an SSL error while reading data from the socket
    @throw SOCKET-HTTP-ERROR Invalid HTTP data was received

    @note For possible exceptions when implicitly establishing a connection, see the Socket::connect() method (or Socket::connectSSL() for secure connections)
 */
*string HTTPClient::post(string path, *binary body, *hash headers, *reference info) {
   OptHashRefHelper ohrh(info, xsink);
   ReferenceHolder<AbstractQoreNode> rv(client->post(path->getBuffer(), headers, body ? body->getPtr() : 0, body ? body->size() : 0, *ohrh, xsink), xsink);
#ifdef DEBUG
   assert(!rv || rv->getType() == NT_STRING);
#endif
   return *xsink ? 0 : rv.release();
}

//! Sets the default I/O timeout value in milliseconds
/** @param timeout_ms 0 means immediate timeout (when reading will return data only if it is already available), and negative numbers mean never timeout. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 2m = two minutes, etc.).

    @par Example:
    @code
$httpclient.setTimeout(2m);
    @endcode
 */
nothing HTTPClient::setTimeout(timeout timeout_ms = 0) {
   client->setTimeout((int)timeout_ms);
}

//! Returns the default I/O timeout as an integer in milliseconds
/** @return the default I/O timeout as an integer in milliseconds; 0 means immediate timeout (when reading only returns data if it is already available), and negative numbers mean never timeout

    @par Example:
    @code
my int $timeout = $httpclient.getTimeout();
    @endcode
 */
int HTTPClient::getTimeout() [flags=CONSTANT] {
   return client->getTimeout();
}

//! Sets the string encoding for the object; any strings deserialized with this object will be tagged with this character encoding
/** @param encoding the string encoding for the object; any strings deserialized with this object will be tagged with this character encoding

    @par Example:
    @code
$httpclient.setEncoding("UTF-8");
    @endcode
 */
nothing HTTPClient::setEncoding(string encoding) {
   client->setEncoding(QEM.findCreate(encoding));
}

//! Returns the character encoding used for the object
/** @return the character encoding used for the object

    @par Example:
    @code
my string $encoding = $httpclient.getEncoding();
    @endcode
 */
string HTTPClient::getEncoding() [flags=CONSTANT] {
   return new QoreStringNode(client->getEncoding()->getCode());
}

//! Sets a new URL value for the next connection
/** To retrieve the current URL value, use the HTTPClient::getURL() method

    @param url the new URL for the object

    @par Example:
    @code
$httpclient.setURL("https://user:password@hostname:8080/path");
    @endcode

    @throw HTTP-CLIENT-URL-ERROR invalid URL string; invalid authorization credentials in  URL (username without password or vice-versa)
    @throw HTTP-CLIENT-UNKNOWN-PROTOCOL unknown protocol (scheme) passed in URL

    @see HTTPClient::getURL()
 */
HTTPClient::setURL(string url) {
   client->setURL(url->getBuffer(), xsink);
}

//! Returns the current URL
/** @return the current URL

    @par Example:
    @code
my string $url = $httpclient.getURL();
    @endcode
 */
string HTTPClient::getURL() [flags=CONSTANT] {
   return client->getURL();
}

//! Clears the new proxy URL value for the next connection
/** This variant of the method is equivalent to HTTPClient::clearProxyURL()

    @par Example:
    @code
$httpclient.setProxyURL();
    @endcode
 */
nothing HTTPClient::setProxyURL() {
   client->clearProxyURL();
}

//! Sets a new proxy URL value for the next connection
/** @param url the new proxy URL value for the next connection

    @par Example:
    @code
$httpclient.setProxyURL("http://user:password@proxy_host:8080/path");
    @endcode

    @throw HTTP-CLIENT-URL-ERROR invalid proxy URL string; invalid authorization credentials in proxy URL (username without password or vice-versa)
    @throw HTTP-CLIENT-PROXY-PROTOCOL-ERROR unknown protocol passed in URL
 */
nothing HTTPClient::setProxyURL(string url) {
   client->setProxyURL(url->getBuffer(), xsink);
}

//! Returns the current proxy URL as a string or @ref nothing if no proxy URL is set
/** @return the current proxy URL as a string or @ref nothing if no proxy URL is set

    @par Example:
    @code
my *string $proxy_url = $httpclient.getProxyURL();
    @endcode
 */
*string HTTPClient::getProxyURL() [flags=CONSTANT] {
   return client->getProxyURL();
}

//! Clears the new proxy URL value for the next connection
/** 
    @par Example:
    @code
$httpclient.setProxyURL();
    @endcode
 */
nothing HTTPClient::clearProxyURL() {
   client->clearProxyURL();
}

//! Sets the SSL/TLS flag for the next connection to the proxy
/** 
    @par Example:
    @code
$httpclient.setProxySecure(True);
    @endcode

    @see HTTPClient::isProxySecure() to check the flag
 */
nothing HTTPClient::setProxySecure(softbool b = True) {
   client->setProxySecure(b);
}

//! Returns the SSL/TLS flag for the next proxy connection
/** @return the SSL/TLS flag for the next proxy connection

    @par Example:
    @code
my bool $b = $httpclient.isProxySecure();
    @endcode
 */
bool HTTPClient::isProxySecure() [flags=CONSTANT] {
   return client->isProxySecure();
}

//! Updates the setting for the \c max_redirects value for the object (maximum number of HTTP redirects that will be processed before an exception is raised)
/** @param mr the setting for the maximum number of HTTP redirects that will be processed before an exception is raised

    @par Example:
    @code
$httpclient.setMaxRedirects(5);
    @endcode

    @see HTTPClient::getMaxRedirects() to retrieve this value
 */
nothing HTTPClient::setMaxRedirects(softint mr = 0) {
   client->setMaxRedirects((int)mr);
}

//! Returns the current \c max_redirects value for the object (the maximum number of HTTP redirects that will be processed before an exception is raised)
/** @return the current \c max_redirects value for the object (the maximum number of HTTP redirects that will be processed before an exception is raised)

    @par Example:
    @code
my int $mr = $httpclient.getMaxRedirects();
    @endcode
 */
int HTTPClient::getMaxRedirects() [flags=CONSTANT] {
   return client->getMaxRedirects();
}

//! Clears any Queue object that may be set on the HTTPClient object so that @ref event_handling "I/O events" are no longer captured on the object
/** 
    @par Example:
    @code
$httpclient.setEventQueue();
    @endcode
 */
nothing HTTPClient::setEventQueue() {
    client->setEventQueue(0, xsink);
}

//! Sets a Queue object to receive HTTPClient and Socket events
/** @param queue a @ref Qore::Thread::Queue "Queue" object to receive HTTPClient and Socket events; note that the Queue passed cannot have any maximum size set or a QUEUE-ERROR will be thrown

    @par Example:
    @code
$httpclient.setEventQueue($queue);
    @endcode

    @throw QUEUE-ERROR the Queue passed has a maximum size set

    @see event_handling for more information
 */
nothing HTTPClient::setEventQueue(Qore::Thread::Queue[Queue] queue) {
   ReferenceHolder<Queue> q(queue, xsink);
   if (queue->getMax() != -1) {
      xsink->raiseException("QUEUE-ERROR", "the Queue object passed as a maximum size of %d entr%s, which could cause internal I/O to freeze in the HttpClient object if used; use a Queue object with no maximum size for I/O monitoring", queue->getMax(), queue->getMax() == 1 ? "y" : "ies");
      return 0;
   }
   // pass reference from QoreObject::getReferencedPrivateData() to function
   client->setEventQueue(q.release(), xsink);
}

//! Sets the connect timeout in milliseconds
/** @param timeout_ms the connect timeout in milliseconds; negative numbers mean use the default system connect timeout. Note that like all %Qore functions and methods taking timeout values, a @ref relative_dates "relative date/time value" can be used to make the units clear (i.e. \c 30s = 30 seconds, etc.).

    @par Example:
    @code
$httpclient.setConnectTimeout(2m);
    @endcode
 */
nothing HTTPClient::setConnectTimeout(timeout timeout_ms = -1) {
   client->setConnectTimeout((int)timeout_ms);
}

//! Returns the connect timeout as an integer in milliseconds
/** @return Returns the connect timeout as an integer in milliseconds; negative numbers mean the system default timeout is used

    @par Example:
    @code
my int $to = $httpclient.getConnectTimeout();
    @endcode
 */
int HTTPClient::getConnectTimeout() [flags=CONSTANT] {
   return client->getConnectTimeout();
}

//! Sets the \c TCP_NODELAY setting for the object
/** When this setting is True, then data will be immediately sent out over the HTTPClient object's socket, when it is @ref False, then data transmission may be delayed to be packaged with other data for the same target.

    Delayed data transmissions may cause problems when the sender immediately closes the socket after sending data; in this case the receiver may not get the data even though the send succeeded.

    Note that if no value is given to the method, the argument will be assumed to be @ref True, and output buffering will be turned off for the HTTPClient object.

    If the socket is not connected when this call is made, then an internal flag is set and the \c TCP_NODELAY option is enabled when the next connection is established. If the socket is connected, then if an error occurs setting the \c TCP_NODELAY option on the socket, this method will return a non-zero error code; the actual error can be checked with the errno() function.

    @param b the \c TCP_NODELAY setting for the object

    @par Example:
    @code
$httpclient.setNoDelay(True);
    @endcode

    @see HTTPClient::getNoDelay()
 */
int HTTPClient::setNoDelay(softbool b = True) {
    return client->setNoDelay(b);
}

//! Returns the \c TCP_NODELAY setting for the HTTPClient object
/** 
    @par Example:
    @code
my bool $b = $httpclient.getNoDelay();
    @endcode

    @see also HTTPClient::setNoDelay()
 */
bool HTTPClient::getNoDelay() [flags=CONSTANT] {
    return client->getNoDelay();
}

//! Returns @ref True or @ref False giving the current connection state
/** @return @ref True or @ref False giving the current connection state

    @par Example:
    @code
my bool $b = $httpclient.isConnected();
    @endcode
 */
bool HTTPClient::isConnected() [flags=CONSTANT] {
    return client->isConnected();
}

//! Sets the username and password for the connection; call after HTTPClient::setURL()
/** Call this method after calling HTTPClient::setURL() to set authentication information when not present in the URL used in HTTPClient::setURL()

    @param user the username to use for authentication in the next HTTP connection
    @param pass the password to use for authentication in the next HTTP connection

    @par Example:
    @code
$httpclient.setUserPassword($user, $pass);
    @endcode
 */
nothing HTTPClient::setUserPassword(string user, string pass) {
   client->setUserPassword(user->getBuffer(), pass->getBuffer());
}

//! Clears the username and password for the connection
/** Call this method after calling HTTPClient::setURL() to clear any authentication information present in the URL used in HTTPClient::setURL()

    This variant of the method is equivalent to HTTPClient::clearUserPassword()

    @par Example:
    @code
$httpclient.setUserPassword();
    @endcode

    @see HTTPClient::clearUserPassword()
 */
nothing HTTPClient::setUserPassword() {
   client->clearUserPassword();
}

//! Clears the username and password for the connection
/** Call this method after calling HTTPClient::setURL() to clear any authentication information present in the URL used in HTTPClient::setURL()

    @par Example:
    @code
$httpclient.clearUserPassword();
    @endcode
 */
nothing HTTPClient::clearUserPassword() {
   client->clearUserPassword();
}

//! Sets the username and password for the connection to the proxy; call after HTTPClient::setProxyURL()
/** Call this method after calling HTTPClient::setProxyURL() to set proxy authentication information when not present in the URL used in HTTPClient::setProxyURL()

    @param user the username to use for proxy authentication in the next HTTP connection
    @param pass the password to use for proxy authentication in the next HTTP connection

    @par Example:
    @code
$httpclient.setProxyUserPassword($user, $pass);
    @endcode
 */
nothing HTTPClient::setProxyUserPassword(string user, string pass) {
   client->setProxyUserPassword(user->getBuffer(), pass->getBuffer());
}

//! Clears the username and password for the next proxy connection
/** Call this method after calling HTTPClient::setProxyURL() to clear any proxy authentication information present in the URL used in HTTPClient::setProxyURL()

    This variant of the method is equivalent to HTTPClient::clearProxyUserPassword()

    @par Example:
    @code
$httpclient.setProxyUserPassword();
    @endcode

    @see HTTPClient::clearProxyUserPassword()
 */
nothing HTTPClient::setProxyUserPassword() {
   client->clearProxyUserPassword();
}

//! Clears the username and password for the next proxy connection
/** Call this method after calling HTTPClient::setProxyURL() to clear any proxy authentication information present in the URL used in HTTPClient::setProxyURL()

    @par Example:
    @code
$httpclient.clearProxyUserPassword();
    @endcode
 */
nothing HTTPClient::clearProxyUserPassword() {
   client->clearProxyUserPassword();
}

//! Returns a @ref socket_info_hash "hash of information" about the remote end for connected sockets
/** If the socket is not connected, an exception is thrown

    @par Example:
    @code
my hash $h = $httpclient.getPeerInfo();
    @endcode

    @return a @ref socket_info_hash "hash of information" about the local socket

    @throw SOCKET-GETPEERINFO-ERROR the underlying socket is not open or error in getpeername()
 */
hash HTTPClient::getPeerInfo() {
   return client->getPeerInfo(xsink);
}

//! Returns information about the local socket as a hash
/** If the socket is not open, an exception is thrown

    @par Example:
    @code
my hash $h = $httpclient.getSocketInfo();
    @endcode

    @return a @ref socket_info_hash "hash of information" about the remote end for connected sockets

    @throw SOCKET-GETSOCKETINFO-ERROR the underlying socket is not open or error in getsockname()
 */
hash HTTPClient::getSocketInfo() {
   return client->getSocketInfo(xsink);
}

